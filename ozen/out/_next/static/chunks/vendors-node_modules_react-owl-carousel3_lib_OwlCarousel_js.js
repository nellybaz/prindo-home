/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["vendors-node_modules_react-owl-carousel3_lib_OwlCarousel_js"],{

/***/ "./node_modules/react-owl-carousel3/lib/OwlCarousel.js":
/*!*************************************************************!*\
  !*** ./node_modules/react-owl-carousel3/lib/OwlCarousel.js ***!
  \*************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("(function webpackUniversalModuleDefinition(root, factory) {\n\tif(true)\n\t\tmodule.exports = factory(__webpack_require__(/*! react */ \"./node_modules/react/index.js\"));\n\telse {}\n})(this, function(__WEBPACK_EXTERNAL_MODULE_12__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __nested_webpack_require_641__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __nested_webpack_require_641__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__nested_webpack_require_641__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__nested_webpack_require_641__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__nested_webpack_require_641__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__nested_webpack_require_641__.d = function(exports, name, getter) {\n/******/ \t\tif(!__nested_webpack_require_641__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__nested_webpack_require_641__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__nested_webpack_require_641__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__nested_webpack_require_641__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__nested_webpack_require_641__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __nested_webpack_require_641__(__nested_webpack_require_641__.s = 13);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports) {\n\neval(\"// shim for using process in browser\\nvar process = module.exports = {};\\n\\n// cached from whatever global is present so that test runners that stub it\\n// don't break things.  But we need to wrap it in a try catch in case it is\\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\\n// function because try/catches deoptimize in certain engines.\\n\\nvar cachedSetTimeout;\\nvar cachedClearTimeout;\\n\\nfunction defaultSetTimout() {\\n    throw new Error('setTimeout has not been defined');\\n}\\nfunction defaultClearTimeout () {\\n    throw new Error('clearTimeout has not been defined');\\n}\\n(function () {\\n    try {\\n        if (typeof setTimeout === 'function') {\\n            cachedSetTimeout = setTimeout;\\n        } else {\\n            cachedSetTimeout = defaultSetTimout;\\n        }\\n    } catch (e) {\\n        cachedSetTimeout = defaultSetTimout;\\n    }\\n    try {\\n        if (typeof clearTimeout === 'function') {\\n            cachedClearTimeout = clearTimeout;\\n        } else {\\n            cachedClearTimeout = defaultClearTimeout;\\n        }\\n    } catch (e) {\\n        cachedClearTimeout = defaultClearTimeout;\\n    }\\n} ())\\nfunction runTimeout(fun) {\\n    if (cachedSetTimeout === setTimeout) {\\n        //normal enviroments in sane situations\\n        return setTimeout(fun, 0);\\n    }\\n    // if setTimeout wasn't available but was latter defined\\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\\n        cachedSetTimeout = setTimeout;\\n        return setTimeout(fun, 0);\\n    }\\n    try {\\n        // when when somebody has screwed with setTimeout but no I.E. maddness\\n        return cachedSetTimeout(fun, 0);\\n    } catch(e){\\n        try {\\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\\n            return cachedSetTimeout.call(null, fun, 0);\\n        } catch(e){\\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\\n            return cachedSetTimeout.call(this, fun, 0);\\n        }\\n    }\\n\\n\\n}\\nfunction runClearTimeout(marker) {\\n    if (cachedClearTimeout === clearTimeout) {\\n        //normal enviroments in sane situations\\n        return clearTimeout(marker);\\n    }\\n    // if clearTimeout wasn't available but was latter defined\\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\\n        cachedClearTimeout = clearTimeout;\\n        return clearTimeout(marker);\\n    }\\n    try {\\n        // when when somebody has screwed with setTimeout but no I.E. maddness\\n        return cachedClearTimeout(marker);\\n    } catch (e){\\n        try {\\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\\n            return cachedClearTimeout.call(null, marker);\\n        } catch (e){\\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\\n            return cachedClearTimeout.call(this, marker);\\n        }\\n    }\\n\\n\\n\\n}\\nvar queue = [];\\nvar draining = false;\\nvar currentQueue;\\nvar queueIndex = -1;\\n\\nfunction cleanUpNextTick() {\\n    if (!draining || !currentQueue) {\\n        return;\\n    }\\n    draining = false;\\n    if (currentQueue.length) {\\n        queue = currentQueue.concat(queue);\\n    } else {\\n        queueIndex = -1;\\n    }\\n    if (queue.length) {\\n        drainQueue();\\n    }\\n}\\n\\nfunction drainQueue() {\\n    if (draining) {\\n        return;\\n    }\\n    var timeout = runTimeout(cleanUpNextTick);\\n    draining = true;\\n\\n    var len = queue.length;\\n    while(len) {\\n        currentQueue = queue;\\n        queue = [];\\n        while (++queueIndex < len) {\\n            if (currentQueue) {\\n                currentQueue[queueIndex].run();\\n            }\\n        }\\n        queueIndex = -1;\\n        len = queue.length;\\n    }\\n    currentQueue = null;\\n    draining = false;\\n    runClearTimeout(timeout);\\n}\\n\\nprocess.nextTick = function (fun) {\\n    var args = new Array(arguments.length - 1);\\n    if (arguments.length > 1) {\\n        for (var i = 1; i < arguments.length; i++) {\\n            args[i - 1] = arguments[i];\\n        }\\n    }\\n    queue.push(new Item(fun, args));\\n    if (queue.length === 1 && !draining) {\\n        runTimeout(drainQueue);\\n    }\\n};\\n\\n// v8 likes predictible objects\\nfunction Item(fun, array) {\\n    this.fun = fun;\\n    this.array = array;\\n}\\nItem.prototype.run = function () {\\n    this.fun.apply(null, this.array);\\n};\\nprocess.title = 'browser';\\nprocess.browser = true;\\nprocess.env = {};\\nprocess.argv = [];\\nprocess.version = ''; // empty string to avoid regexp issues\\nprocess.versions = {};\\n\\nfunction noop() {}\\n\\nprocess.on = noop;\\nprocess.addListener = noop;\\nprocess.once = noop;\\nprocess.off = noop;\\nprocess.removeListener = noop;\\nprocess.removeAllListeners = noop;\\nprocess.emit = noop;\\nprocess.prependListener = noop;\\nprocess.prependOnceListener = noop;\\n\\nprocess.listeners = function (name) { return [] }\\n\\nprocess.binding = function (name) {\\n    throw new Error('process.binding is not supported');\\n};\\n\\nprocess.cwd = function () { return '/' };\\nprocess.chdir = function (dir) {\\n    throw new Error('process.chdir is not supported');\\n};\\nprocess.umask = function() { return 0; };\\n\\n\\n//////////////////\\n// WEBPACK FOOTER\\n// ./~/node-libs-browser/~/process/browser.js\\n// module id = 0\\n// module chunks = 0\\n\\n//# sourceURL=webpack:///./~/node-libs-browser/~/process/browser.js?\");\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\neval(\"var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\\n * jQuery JavaScript Library v3.3.1\\n * https://jquery.com/\\n *\\n * Includes Sizzle.js\\n * https://sizzlejs.com/\\n *\\n * Copyright JS Foundation and other contributors\\n * Released under the MIT license\\n * https://jquery.org/license\\n *\\n * Date: 2018-01-20T17:24Z\\n */\\n( function( global, factory ) {\\n\\n\\t\\\"use strict\\\";\\n\\n\\tif ( typeof module === \\\"object\\\" && typeof module.exports === \\\"object\\\" ) {\\n\\n\\t\\t// For CommonJS and CommonJS-like environments where a proper `window`\\n\\t\\t// is present, execute the factory and get jQuery.\\n\\t\\t// For environments that do not have a `window` with a `document`\\n\\t\\t// (such as Node.js), expose a factory as module.exports.\\n\\t\\t// This accentuates the need for the creation of a real `window`.\\n\\t\\t// e.g. var jQuery = require(\\\"jquery\\\")(window);\\n\\t\\t// See ticket #14549 for more info.\\n\\t\\tmodule.exports = global.document ?\\n\\t\\t\\tfactory( global, true ) :\\n\\t\\t\\tfunction( w ) {\\n\\t\\t\\t\\tif ( !w.document ) {\\n\\t\\t\\t\\t\\tthrow new Error( \\\"jQuery requires a window with a document\\\" );\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn factory( w );\\n\\t\\t\\t};\\n\\t} else {\\n\\t\\tfactory( global );\\n\\t}\\n\\n// Pass this if window is not defined yet\\n} )( typeof window !== \\\"undefined\\\" ? window : this, function( window, noGlobal ) {\\n\\n// Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1\\n// throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode\\n// arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common\\n// enough that all such attempts are guarded in a try block.\\n\\\"use strict\\\";\\n\\nvar arr = [];\\n\\nvar document = window.document;\\n\\nvar getProto = Object.getPrototypeOf;\\n\\nvar slice = arr.slice;\\n\\nvar concat = arr.concat;\\n\\nvar push = arr.push;\\n\\nvar indexOf = arr.indexOf;\\n\\nvar class2type = {};\\n\\nvar toString = class2type.toString;\\n\\nvar hasOwn = class2type.hasOwnProperty;\\n\\nvar fnToString = hasOwn.toString;\\n\\nvar ObjectFunctionString = fnToString.call( Object );\\n\\nvar support = {};\\n\\nvar isFunction = function isFunction( obj ) {\\n\\n      // Support: Chrome <=57, Firefox <=52\\n      // In some browsers, typeof returns \\\"function\\\" for HTML <object> elements\\n      // (i.e., `typeof document.createElement( \\\"object\\\" ) === \\\"function\\\"`).\\n      // We don't want to classify *any* DOM node as a function.\\n      return typeof obj === \\\"function\\\" && typeof obj.nodeType !== \\\"number\\\";\\n  };\\n\\n\\nvar isWindow = function isWindow( obj ) {\\n\\t\\treturn obj != null && obj === obj.window;\\n\\t};\\n\\n\\n\\n\\n\\tvar preservedScriptAttributes = {\\n\\t\\ttype: true,\\n\\t\\tsrc: true,\\n\\t\\tnoModule: true\\n\\t};\\n\\n\\tfunction DOMEval( code, doc, node ) {\\n\\t\\tdoc = doc || document;\\n\\n\\t\\tvar i,\\n\\t\\t\\tscript = doc.createElement( \\\"script\\\" );\\n\\n\\t\\tscript.text = code;\\n\\t\\tif ( node ) {\\n\\t\\t\\tfor ( i in preservedScriptAttributes ) {\\n\\t\\t\\t\\tif ( node[ i ] ) {\\n\\t\\t\\t\\t\\tscript[ i ] = node[ i ];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tdoc.head.appendChild( script ).parentNode.removeChild( script );\\n\\t}\\n\\n\\nfunction toType( obj ) {\\n\\tif ( obj == null ) {\\n\\t\\treturn obj + \\\"\\\";\\n\\t}\\n\\n\\t// Support: Android <=2.3 only (functionish RegExp)\\n\\treturn typeof obj === \\\"object\\\" || typeof obj === \\\"function\\\" ?\\n\\t\\tclass2type[ toString.call( obj ) ] || \\\"object\\\" :\\n\\t\\ttypeof obj;\\n}\\n/* global Symbol */\\n// Defining this global in .eslintrc.json would create a danger of using the global\\n// unguarded in another place, it seems safer to define global only for this module\\n\\n\\n\\nvar\\n\\tversion = \\\"3.3.1\\\",\\n\\n\\t// Define a local copy of jQuery\\n\\tjQuery = function( selector, context ) {\\n\\n\\t\\t// The jQuery object is actually just the init constructor 'enhanced'\\n\\t\\t// Need init if jQuery is called (just allow error to be thrown if not included)\\n\\t\\treturn new jQuery.fn.init( selector, context );\\n\\t},\\n\\n\\t// Support: Android <=4.0 only\\n\\t// Make sure we trim BOM and NBSP\\n\\trtrim = /^[\\\\s\\\\uFEFF\\\\xA0]+|[\\\\s\\\\uFEFF\\\\xA0]+$/g;\\n\\njQuery.fn = jQuery.prototype = {\\n\\n\\t// The current version of jQuery being used\\n\\tjquery: version,\\n\\n\\tconstructor: jQuery,\\n\\n\\t// The default length of a jQuery object is 0\\n\\tlength: 0,\\n\\n\\ttoArray: function() {\\n\\t\\treturn slice.call( this );\\n\\t},\\n\\n\\t// Get the Nth element in the matched element set OR\\n\\t// Get the whole matched element set as a clean array\\n\\tget: function( num ) {\\n\\n\\t\\t// Return all the elements in a clean array\\n\\t\\tif ( num == null ) {\\n\\t\\t\\treturn slice.call( this );\\n\\t\\t}\\n\\n\\t\\t// Return just the one element from the set\\n\\t\\treturn num < 0 ? this[ num + this.length ] : this[ num ];\\n\\t},\\n\\n\\t// Take an array of elements and push it onto the stack\\n\\t// (returning the new matched element set)\\n\\tpushStack: function( elems ) {\\n\\n\\t\\t// Build a new jQuery matched element set\\n\\t\\tvar ret = jQuery.merge( this.constructor(), elems );\\n\\n\\t\\t// Add the old object onto the stack (as a reference)\\n\\t\\tret.prevObject = this;\\n\\n\\t\\t// Return the newly-formed element set\\n\\t\\treturn ret;\\n\\t},\\n\\n\\t// Execute a callback for every element in the matched set.\\n\\teach: function( callback ) {\\n\\t\\treturn jQuery.each( this, callback );\\n\\t},\\n\\n\\tmap: function( callback ) {\\n\\t\\treturn this.pushStack( jQuery.map( this, function( elem, i ) {\\n\\t\\t\\treturn callback.call( elem, i, elem );\\n\\t\\t} ) );\\n\\t},\\n\\n\\tslice: function() {\\n\\t\\treturn this.pushStack( slice.apply( this, arguments ) );\\n\\t},\\n\\n\\tfirst: function() {\\n\\t\\treturn this.eq( 0 );\\n\\t},\\n\\n\\tlast: function() {\\n\\t\\treturn this.eq( -1 );\\n\\t},\\n\\n\\teq: function( i ) {\\n\\t\\tvar len = this.length,\\n\\t\\t\\tj = +i + ( i < 0 ? len : 0 );\\n\\t\\treturn this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );\\n\\t},\\n\\n\\tend: function() {\\n\\t\\treturn this.prevObject || this.constructor();\\n\\t},\\n\\n\\t// For internal use only.\\n\\t// Behaves like an Array's method, not like a jQuery method.\\n\\tpush: push,\\n\\tsort: arr.sort,\\n\\tsplice: arr.splice\\n};\\n\\njQuery.extend = jQuery.fn.extend = function() {\\n\\tvar options, name, src, copy, copyIsArray, clone,\\n\\t\\ttarget = arguments[ 0 ] || {},\\n\\t\\ti = 1,\\n\\t\\tlength = arguments.length,\\n\\t\\tdeep = false;\\n\\n\\t// Handle a deep copy situation\\n\\tif ( typeof target === \\\"boolean\\\" ) {\\n\\t\\tdeep = target;\\n\\n\\t\\t// Skip the boolean and the target\\n\\t\\ttarget = arguments[ i ] || {};\\n\\t\\ti++;\\n\\t}\\n\\n\\t// Handle case when target is a string or something (possible in deep copy)\\n\\tif ( typeof target !== \\\"object\\\" && !isFunction( target ) ) {\\n\\t\\ttarget = {};\\n\\t}\\n\\n\\t// Extend jQuery itself if only one argument is passed\\n\\tif ( i === length ) {\\n\\t\\ttarget = this;\\n\\t\\ti--;\\n\\t}\\n\\n\\tfor ( ; i < length; i++ ) {\\n\\n\\t\\t// Only deal with non-null/undefined values\\n\\t\\tif ( ( options = arguments[ i ] ) != null ) {\\n\\n\\t\\t\\t// Extend the base object\\n\\t\\t\\tfor ( name in options ) {\\n\\t\\t\\t\\tsrc = target[ name ];\\n\\t\\t\\t\\tcopy = options[ name ];\\n\\n\\t\\t\\t\\t// Prevent never-ending loop\\n\\t\\t\\t\\tif ( target === copy ) {\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Recurse if we're merging plain objects or arrays\\n\\t\\t\\t\\tif ( deep && copy && ( jQuery.isPlainObject( copy ) ||\\n\\t\\t\\t\\t\\t( copyIsArray = Array.isArray( copy ) ) ) ) {\\n\\n\\t\\t\\t\\t\\tif ( copyIsArray ) {\\n\\t\\t\\t\\t\\t\\tcopyIsArray = false;\\n\\t\\t\\t\\t\\t\\tclone = src && Array.isArray( src ) ? src : [];\\n\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tclone = src && jQuery.isPlainObject( src ) ? src : {};\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t// Never move original objects, clone them\\n\\t\\t\\t\\t\\ttarget[ name ] = jQuery.extend( deep, clone, copy );\\n\\n\\t\\t\\t\\t// Don't bring in undefined values\\n\\t\\t\\t\\t} else if ( copy !== undefined ) {\\n\\t\\t\\t\\t\\ttarget[ name ] = copy;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t// Return the modified object\\n\\treturn target;\\n};\\n\\njQuery.extend( {\\n\\n\\t// Unique for each copy of jQuery on the page\\n\\texpando: \\\"jQuery\\\" + ( version + Math.random() ).replace( /\\\\D/g, \\\"\\\" ),\\n\\n\\t// Assume jQuery is ready without the ready module\\n\\tisReady: true,\\n\\n\\terror: function( msg ) {\\n\\t\\tthrow new Error( msg );\\n\\t},\\n\\n\\tnoop: function() {},\\n\\n\\tisPlainObject: function( obj ) {\\n\\t\\tvar proto, Ctor;\\n\\n\\t\\t// Detect obvious negatives\\n\\t\\t// Use toString instead of jQuery.type to catch host objects\\n\\t\\tif ( !obj || toString.call( obj ) !== \\\"[object Object]\\\" ) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\tproto = getProto( obj );\\n\\n\\t\\t// Objects with no prototype (e.g., `Object.create( null )`) are plain\\n\\t\\tif ( !proto ) {\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\n\\t\\t// Objects with prototype are plain iff they were constructed by a global Object function\\n\\t\\tCtor = hasOwn.call( proto, \\\"constructor\\\" ) && proto.constructor;\\n\\t\\treturn typeof Ctor === \\\"function\\\" && fnToString.call( Ctor ) === ObjectFunctionString;\\n\\t},\\n\\n\\tisEmptyObject: function( obj ) {\\n\\n\\t\\t/* eslint-disable no-unused-vars */\\n\\t\\t// See https://github.com/eslint/eslint/issues/6125\\n\\t\\tvar name;\\n\\n\\t\\tfor ( name in obj ) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\treturn true;\\n\\t},\\n\\n\\t// Evaluates a script in a global context\\n\\tglobalEval: function( code ) {\\n\\t\\tDOMEval( code );\\n\\t},\\n\\n\\teach: function( obj, callback ) {\\n\\t\\tvar length, i = 0;\\n\\n\\t\\tif ( isArrayLike( obj ) ) {\\n\\t\\t\\tlength = obj.length;\\n\\t\\t\\tfor ( ; i < length; i++ ) {\\n\\t\\t\\t\\tif ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\tfor ( i in obj ) {\\n\\t\\t\\t\\tif ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn obj;\\n\\t},\\n\\n\\t// Support: Android <=4.0 only\\n\\ttrim: function( text ) {\\n\\t\\treturn text == null ?\\n\\t\\t\\t\\\"\\\" :\\n\\t\\t\\t( text + \\\"\\\" ).replace( rtrim, \\\"\\\" );\\n\\t},\\n\\n\\t// results is for internal usage only\\n\\tmakeArray: function( arr, results ) {\\n\\t\\tvar ret = results || [];\\n\\n\\t\\tif ( arr != null ) {\\n\\t\\t\\tif ( isArrayLike( Object( arr ) ) ) {\\n\\t\\t\\t\\tjQuery.merge( ret,\\n\\t\\t\\t\\t\\ttypeof arr === \\\"string\\\" ?\\n\\t\\t\\t\\t\\t[ arr ] : arr\\n\\t\\t\\t\\t);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tpush.call( ret, arr );\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn ret;\\n\\t},\\n\\n\\tinArray: function( elem, arr, i ) {\\n\\t\\treturn arr == null ? -1 : indexOf.call( arr, elem, i );\\n\\t},\\n\\n\\t// Support: Android <=4.0 only, PhantomJS 1 only\\n\\t// push.apply(_, arraylike) throws on ancient WebKit\\n\\tmerge: function( first, second ) {\\n\\t\\tvar len = +second.length,\\n\\t\\t\\tj = 0,\\n\\t\\t\\ti = first.length;\\n\\n\\t\\tfor ( ; j < len; j++ ) {\\n\\t\\t\\tfirst[ i++ ] = second[ j ];\\n\\t\\t}\\n\\n\\t\\tfirst.length = i;\\n\\n\\t\\treturn first;\\n\\t},\\n\\n\\tgrep: function( elems, callback, invert ) {\\n\\t\\tvar callbackInverse,\\n\\t\\t\\tmatches = [],\\n\\t\\t\\ti = 0,\\n\\t\\t\\tlength = elems.length,\\n\\t\\t\\tcallbackExpect = !invert;\\n\\n\\t\\t// Go through the array, only saving the items\\n\\t\\t// that pass the validator function\\n\\t\\tfor ( ; i < length; i++ ) {\\n\\t\\t\\tcallbackInverse = !callback( elems[ i ], i );\\n\\t\\t\\tif ( callbackInverse !== callbackExpect ) {\\n\\t\\t\\t\\tmatches.push( elems[ i ] );\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn matches;\\n\\t},\\n\\n\\t// arg is for internal usage only\\n\\tmap: function( elems, callback, arg ) {\\n\\t\\tvar length, value,\\n\\t\\t\\ti = 0,\\n\\t\\t\\tret = [];\\n\\n\\t\\t// Go through the array, translating each of the items to their new values\\n\\t\\tif ( isArrayLike( elems ) ) {\\n\\t\\t\\tlength = elems.length;\\n\\t\\t\\tfor ( ; i < length; i++ ) {\\n\\t\\t\\t\\tvalue = callback( elems[ i ], i, arg );\\n\\n\\t\\t\\t\\tif ( value != null ) {\\n\\t\\t\\t\\t\\tret.push( value );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t// Go through every key on the object,\\n\\t\\t} else {\\n\\t\\t\\tfor ( i in elems ) {\\n\\t\\t\\t\\tvalue = callback( elems[ i ], i, arg );\\n\\n\\t\\t\\t\\tif ( value != null ) {\\n\\t\\t\\t\\t\\tret.push( value );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// Flatten any nested arrays\\n\\t\\treturn concat.apply( [], ret );\\n\\t},\\n\\n\\t// A global GUID counter for objects\\n\\tguid: 1,\\n\\n\\t// jQuery.support is not used in Core but other projects attach their\\n\\t// properties to it so it needs to exist.\\n\\tsupport: support\\n} );\\n\\nif ( typeof Symbol === \\\"function\\\" ) {\\n\\tjQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];\\n}\\n\\n// Populate the class2type map\\njQuery.each( \\\"Boolean Number String Function Array Date RegExp Object Error Symbol\\\".split( \\\" \\\" ),\\nfunction( i, name ) {\\n\\tclass2type[ \\\"[object \\\" + name + \\\"]\\\" ] = name.toLowerCase();\\n} );\\n\\nfunction isArrayLike( obj ) {\\n\\n\\t// Support: real iOS 8.2 only (not reproducible in simulator)\\n\\t// `in` check used to prevent JIT error (gh-2145)\\n\\t// hasOwn isn't used here due to false negatives\\n\\t// regarding Nodelist length in IE\\n\\tvar length = !!obj && \\\"length\\\" in obj && obj.length,\\n\\t\\ttype = toType( obj );\\n\\n\\tif ( isFunction( obj ) || isWindow( obj ) ) {\\n\\t\\treturn false;\\n\\t}\\n\\n\\treturn type === \\\"array\\\" || length === 0 ||\\n\\t\\ttypeof length === \\\"number\\\" && length > 0 && ( length - 1 ) in obj;\\n}\\nvar Sizzle =\\n/*!\\n * Sizzle CSS Selector Engine v2.3.3\\n * https://sizzlejs.com/\\n *\\n * Copyright jQuery Foundation and other contributors\\n * Released under the MIT license\\n * http://jquery.org/license\\n *\\n * Date: 2016-08-08\\n */\\n(function( window ) {\\n\\nvar i,\\n\\tsupport,\\n\\tExpr,\\n\\tgetText,\\n\\tisXML,\\n\\ttokenize,\\n\\tcompile,\\n\\tselect,\\n\\toutermostContext,\\n\\tsortInput,\\n\\thasDuplicate,\\n\\n\\t// Local document vars\\n\\tsetDocument,\\n\\tdocument,\\n\\tdocElem,\\n\\tdocumentIsHTML,\\n\\trbuggyQSA,\\n\\trbuggyMatches,\\n\\tmatches,\\n\\tcontains,\\n\\n\\t// Instance-specific data\\n\\texpando = \\\"sizzle\\\" + 1 * new Date(),\\n\\tpreferredDoc = window.document,\\n\\tdirruns = 0,\\n\\tdone = 0,\\n\\tclassCache = createCache(),\\n\\ttokenCache = createCache(),\\n\\tcompilerCache = createCache(),\\n\\tsortOrder = function( a, b ) {\\n\\t\\tif ( a === b ) {\\n\\t\\t\\thasDuplicate = true;\\n\\t\\t}\\n\\t\\treturn 0;\\n\\t},\\n\\n\\t// Instance methods\\n\\thasOwn = ({}).hasOwnProperty,\\n\\tarr = [],\\n\\tpop = arr.pop,\\n\\tpush_native = arr.push,\\n\\tpush = arr.push,\\n\\tslice = arr.slice,\\n\\t// Use a stripped-down indexOf as it's faster than native\\n\\t// https://jsperf.com/thor-indexof-vs-for/5\\n\\tindexOf = function( list, elem ) {\\n\\t\\tvar i = 0,\\n\\t\\t\\tlen = list.length;\\n\\t\\tfor ( ; i < len; i++ ) {\\n\\t\\t\\tif ( list[i] === elem ) {\\n\\t\\t\\t\\treturn i;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn -1;\\n\\t},\\n\\n\\tbooleans = \\\"checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped\\\",\\n\\n\\t// Regular expressions\\n\\n\\t// http://www.w3.org/TR/css3-selectors/#whitespace\\n\\twhitespace = \\\"[\\\\\\\\x20\\\\\\\\t\\\\\\\\r\\\\\\\\n\\\\\\\\f]\\\",\\n\\n\\t// http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier\\n\\tidentifier = \\\"(?:\\\\\\\\\\\\\\\\.|[\\\\\\\\w-]|[^\\\\0-\\\\\\\\xa0])+\\\",\\n\\n\\t// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors\\n\\tattributes = \\\"\\\\\\\\[\\\" + whitespace + \\\"*(\\\" + identifier + \\\")(?:\\\" + whitespace +\\n\\t\\t// Operator (capture 2)\\n\\t\\t\\\"*([*^$|!~]?=)\\\" + whitespace +\\n\\t\\t// \\\"Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]\\\"\\n\\t\\t\\\"*(?:'((?:\\\\\\\\\\\\\\\\.|[^\\\\\\\\\\\\\\\\'])*)'|\\\\\\\"((?:\\\\\\\\\\\\\\\\.|[^\\\\\\\\\\\\\\\\\\\\\\\"])*)\\\\\\\"|(\\\" + identifier + \\\"))|)\\\" + whitespace +\\n\\t\\t\\\"*\\\\\\\\]\\\",\\n\\n\\tpseudos = \\\":(\\\" + identifier + \\\")(?:\\\\\\\\((\\\" +\\n\\t\\t// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:\\n\\t\\t// 1. quoted (capture 3; capture 4 or capture 5)\\n\\t\\t\\\"('((?:\\\\\\\\\\\\\\\\.|[^\\\\\\\\\\\\\\\\'])*)'|\\\\\\\"((?:\\\\\\\\\\\\\\\\.|[^\\\\\\\\\\\\\\\\\\\\\\\"])*)\\\\\\\")|\\\" +\\n\\t\\t// 2. simple (capture 6)\\n\\t\\t\\\"((?:\\\\\\\\\\\\\\\\.|[^\\\\\\\\\\\\\\\\()[\\\\\\\\]]|\\\" + attributes + \\\")*)|\\\" +\\n\\t\\t// 3. anything else (capture 2)\\n\\t\\t\\\".*\\\" +\\n\\t\\t\\\")\\\\\\\\)|)\\\",\\n\\n\\t// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter\\n\\trwhitespace = new RegExp( whitespace + \\\"+\\\", \\\"g\\\" ),\\n\\trtrim = new RegExp( \\\"^\\\" + whitespace + \\\"+|((?:^|[^\\\\\\\\\\\\\\\\])(?:\\\\\\\\\\\\\\\\.)*)\\\" + whitespace + \\\"+$\\\", \\\"g\\\" ),\\n\\n\\trcomma = new RegExp( \\\"^\\\" + whitespace + \\\"*,\\\" + whitespace + \\\"*\\\" ),\\n\\trcombinators = new RegExp( \\\"^\\\" + whitespace + \\\"*([>+~]|\\\" + whitespace + \\\")\\\" + whitespace + \\\"*\\\" ),\\n\\n\\trattributeQuotes = new RegExp( \\\"=\\\" + whitespace + \\\"*([^\\\\\\\\]'\\\\\\\"]*?)\\\" + whitespace + \\\"*\\\\\\\\]\\\", \\\"g\\\" ),\\n\\n\\trpseudo = new RegExp( pseudos ),\\n\\tridentifier = new RegExp( \\\"^\\\" + identifier + \\\"$\\\" ),\\n\\n\\tmatchExpr = {\\n\\t\\t\\\"ID\\\": new RegExp( \\\"^#(\\\" + identifier + \\\")\\\" ),\\n\\t\\t\\\"CLASS\\\": new RegExp( \\\"^\\\\\\\\.(\\\" + identifier + \\\")\\\" ),\\n\\t\\t\\\"TAG\\\": new RegExp( \\\"^(\\\" + identifier + \\\"|[*])\\\" ),\\n\\t\\t\\\"ATTR\\\": new RegExp( \\\"^\\\" + attributes ),\\n\\t\\t\\\"PSEUDO\\\": new RegExp( \\\"^\\\" + pseudos ),\\n\\t\\t\\\"CHILD\\\": new RegExp( \\\"^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\\\\\\\(\\\" + whitespace +\\n\\t\\t\\t\\\"*(even|odd|(([+-]|)(\\\\\\\\d*)n|)\\\" + whitespace + \\\"*(?:([+-]|)\\\" + whitespace +\\n\\t\\t\\t\\\"*(\\\\\\\\d+)|))\\\" + whitespace + \\\"*\\\\\\\\)|)\\\", \\\"i\\\" ),\\n\\t\\t\\\"bool\\\": new RegExp( \\\"^(?:\\\" + booleans + \\\")$\\\", \\\"i\\\" ),\\n\\t\\t// For use in libraries implementing .is()\\n\\t\\t// We use this for POS matching in `select`\\n\\t\\t\\\"needsContext\\\": new RegExp( \\\"^\\\" + whitespace + \\\"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\\\\\\\(\\\" +\\n\\t\\t\\twhitespace + \\\"*((?:-\\\\\\\\d)?\\\\\\\\d*)\\\" + whitespace + \\\"*\\\\\\\\)|)(?=[^-]|$)\\\", \\\"i\\\" )\\n\\t},\\n\\n\\trinputs = /^(?:input|select|textarea|button)$/i,\\n\\trheader = /^h\\\\d$/i,\\n\\n\\trnative = /^[^{]+\\\\{\\\\s*\\\\[native \\\\w/,\\n\\n\\t// Easily-parseable/retrievable ID or TAG or CLASS selectors\\n\\trquickExpr = /^(?:#([\\\\w-]+)|(\\\\w+)|\\\\.([\\\\w-]+))$/,\\n\\n\\trsibling = /[+~]/,\\n\\n\\t// CSS escapes\\n\\t// http://www.w3.org/TR/CSS21/syndata.html#escaped-characters\\n\\trunescape = new RegExp( \\\"\\\\\\\\\\\\\\\\([\\\\\\\\da-f]{1,6}\\\" + whitespace + \\\"?|(\\\" + whitespace + \\\")|.)\\\", \\\"ig\\\" ),\\n\\tfunescape = function( _, escaped, escapedWhitespace ) {\\n\\t\\tvar high = \\\"0x\\\" + escaped - 0x10000;\\n\\t\\t// NaN means non-codepoint\\n\\t\\t// Support: Firefox<24\\n\\t\\t// Workaround erroneous numeric interpretation of +\\\"0x\\\"\\n\\t\\treturn high !== high || escapedWhitespace ?\\n\\t\\t\\tescaped :\\n\\t\\t\\thigh < 0 ?\\n\\t\\t\\t\\t// BMP codepoint\\n\\t\\t\\t\\tString.fromCharCode( high + 0x10000 ) :\\n\\t\\t\\t\\t// Supplemental Plane codepoint (surrogate pair)\\n\\t\\t\\t\\tString.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );\\n\\t},\\n\\n\\t// CSS string/identifier serialization\\n\\t// https://drafts.csswg.org/cssom/#common-serializing-idioms\\n\\trcssescape = /([\\\\0-\\\\x1f\\\\x7f]|^-?\\\\d)|^-$|[^\\\\0-\\\\x1f\\\\x7f-\\\\uFFFF\\\\w-]/g,\\n\\tfcssescape = function( ch, asCodePoint ) {\\n\\t\\tif ( asCodePoint ) {\\n\\n\\t\\t\\t// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER\\n\\t\\t\\tif ( ch === \\\"\\\\0\\\" ) {\\n\\t\\t\\t\\treturn \\\"\\\\uFFFD\\\";\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Control characters and (dependent upon position) numbers get escaped as code points\\n\\t\\t\\treturn ch.slice( 0, -1 ) + \\\"\\\\\\\\\\\" + ch.charCodeAt( ch.length - 1 ).toString( 16 ) + \\\" \\\";\\n\\t\\t}\\n\\n\\t\\t// Other potentially-special ASCII characters get backslash-escaped\\n\\t\\treturn \\\"\\\\\\\\\\\" + ch;\\n\\t},\\n\\n\\t// Used for iframes\\n\\t// See setDocument()\\n\\t// Removing the function wrapper causes a \\\"Permission Denied\\\"\\n\\t// error in IE\\n\\tunloadHandler = function() {\\n\\t\\tsetDocument();\\n\\t},\\n\\n\\tdisabledAncestor = addCombinator(\\n\\t\\tfunction( elem ) {\\n\\t\\t\\treturn elem.disabled === true && (\\\"form\\\" in elem || \\\"label\\\" in elem);\\n\\t\\t},\\n\\t\\t{ dir: \\\"parentNode\\\", next: \\\"legend\\\" }\\n\\t);\\n\\n// Optimize for push.apply( _, NodeList )\\ntry {\\n\\tpush.apply(\\n\\t\\t(arr = slice.call( preferredDoc.childNodes )),\\n\\t\\tpreferredDoc.childNodes\\n\\t);\\n\\t// Support: Android<4.0\\n\\t// Detect silently failing push.apply\\n\\tarr[ preferredDoc.childNodes.length ].nodeType;\\n} catch ( e ) {\\n\\tpush = { apply: arr.length ?\\n\\n\\t\\t// Leverage slice if possible\\n\\t\\tfunction( target, els ) {\\n\\t\\t\\tpush_native.apply( target, slice.call(els) );\\n\\t\\t} :\\n\\n\\t\\t// Support: IE<9\\n\\t\\t// Otherwise append directly\\n\\t\\tfunction( target, els ) {\\n\\t\\t\\tvar j = target.length,\\n\\t\\t\\t\\ti = 0;\\n\\t\\t\\t// Can't trust NodeList.length\\n\\t\\t\\twhile ( (target[j++] = els[i++]) ) {}\\n\\t\\t\\ttarget.length = j - 1;\\n\\t\\t}\\n\\t};\\n}\\n\\nfunction Sizzle( selector, context, results, seed ) {\\n\\tvar m, i, elem, nid, match, groups, newSelector,\\n\\t\\tnewContext = context && context.ownerDocument,\\n\\n\\t\\t// nodeType defaults to 9, since context defaults to document\\n\\t\\tnodeType = context ? context.nodeType : 9;\\n\\n\\tresults = results || [];\\n\\n\\t// Return early from calls with invalid selector or context\\n\\tif ( typeof selector !== \\\"string\\\" || !selector ||\\n\\t\\tnodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {\\n\\n\\t\\treturn results;\\n\\t}\\n\\n\\t// Try to shortcut find operations (as opposed to filters) in HTML documents\\n\\tif ( !seed ) {\\n\\n\\t\\tif ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {\\n\\t\\t\\tsetDocument( context );\\n\\t\\t}\\n\\t\\tcontext = context || document;\\n\\n\\t\\tif ( documentIsHTML ) {\\n\\n\\t\\t\\t// If the selector is sufficiently simple, try using a \\\"get*By*\\\" DOM method\\n\\t\\t\\t// (excepting DocumentFragment context, where the methods don't exist)\\n\\t\\t\\tif ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {\\n\\n\\t\\t\\t\\t// ID selector\\n\\t\\t\\t\\tif ( (m = match[1]) ) {\\n\\n\\t\\t\\t\\t\\t// Document context\\n\\t\\t\\t\\t\\tif ( nodeType === 9 ) {\\n\\t\\t\\t\\t\\t\\tif ( (elem = context.getElementById( m )) ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t// Support: IE, Opera, Webkit\\n\\t\\t\\t\\t\\t\\t\\t// TODO: identify versions\\n\\t\\t\\t\\t\\t\\t\\t// getElementById can match elements by name instead of ID\\n\\t\\t\\t\\t\\t\\t\\tif ( elem.id === m ) {\\n\\t\\t\\t\\t\\t\\t\\t\\tresults.push( elem );\\n\\t\\t\\t\\t\\t\\t\\t\\treturn results;\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\treturn results;\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t// Element context\\n\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\t// Support: IE, Opera, Webkit\\n\\t\\t\\t\\t\\t\\t// TODO: identify versions\\n\\t\\t\\t\\t\\t\\t// getElementById can match elements by name instead of ID\\n\\t\\t\\t\\t\\t\\tif ( newContext && (elem = newContext.getElementById( m )) &&\\n\\t\\t\\t\\t\\t\\t\\tcontains( context, elem ) &&\\n\\t\\t\\t\\t\\t\\t\\telem.id === m ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tresults.push( elem );\\n\\t\\t\\t\\t\\t\\t\\treturn results;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Type selector\\n\\t\\t\\t\\t} else if ( match[2] ) {\\n\\t\\t\\t\\t\\tpush.apply( results, context.getElementsByTagName( selector ) );\\n\\t\\t\\t\\t\\treturn results;\\n\\n\\t\\t\\t\\t// Class selector\\n\\t\\t\\t\\t} else if ( (m = match[3]) && support.getElementsByClassName &&\\n\\t\\t\\t\\t\\tcontext.getElementsByClassName ) {\\n\\n\\t\\t\\t\\t\\tpush.apply( results, context.getElementsByClassName( m ) );\\n\\t\\t\\t\\t\\treturn results;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Take advantage of querySelectorAll\\n\\t\\t\\tif ( support.qsa &&\\n\\t\\t\\t\\t!compilerCache[ selector + \\\" \\\" ] &&\\n\\t\\t\\t\\t(!rbuggyQSA || !rbuggyQSA.test( selector )) ) {\\n\\n\\t\\t\\t\\tif ( nodeType !== 1 ) {\\n\\t\\t\\t\\t\\tnewContext = context;\\n\\t\\t\\t\\t\\tnewSelector = selector;\\n\\n\\t\\t\\t\\t// qSA looks outside Element context, which is not what we want\\n\\t\\t\\t\\t// Thanks to Andrew Dupont for this workaround technique\\n\\t\\t\\t\\t// Support: IE <=8\\n\\t\\t\\t\\t// Exclude object elements\\n\\t\\t\\t\\t} else if ( context.nodeName.toLowerCase() !== \\\"object\\\" ) {\\n\\n\\t\\t\\t\\t\\t// Capture the context ID, setting it first if necessary\\n\\t\\t\\t\\t\\tif ( (nid = context.getAttribute( \\\"id\\\" )) ) {\\n\\t\\t\\t\\t\\t\\tnid = nid.replace( rcssescape, fcssescape );\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tcontext.setAttribute( \\\"id\\\", (nid = expando) );\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t// Prefix every selector in the list\\n\\t\\t\\t\\t\\tgroups = tokenize( selector );\\n\\t\\t\\t\\t\\ti = groups.length;\\n\\t\\t\\t\\t\\twhile ( i-- ) {\\n\\t\\t\\t\\t\\t\\tgroups[i] = \\\"#\\\" + nid + \\\" \\\" + toSelector( groups[i] );\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tnewSelector = groups.join( \\\",\\\" );\\n\\n\\t\\t\\t\\t\\t// Expand context for sibling selectors\\n\\t\\t\\t\\t\\tnewContext = rsibling.test( selector ) && testContext( context.parentNode ) ||\\n\\t\\t\\t\\t\\t\\tcontext;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( newSelector ) {\\n\\t\\t\\t\\t\\ttry {\\n\\t\\t\\t\\t\\t\\tpush.apply( results,\\n\\t\\t\\t\\t\\t\\t\\tnewContext.querySelectorAll( newSelector )\\n\\t\\t\\t\\t\\t\\t);\\n\\t\\t\\t\\t\\t\\treturn results;\\n\\t\\t\\t\\t\\t} catch ( qsaError ) {\\n\\t\\t\\t\\t\\t} finally {\\n\\t\\t\\t\\t\\t\\tif ( nid === expando ) {\\n\\t\\t\\t\\t\\t\\t\\tcontext.removeAttribute( \\\"id\\\" );\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t// All others\\n\\treturn select( selector.replace( rtrim, \\\"$1\\\" ), context, results, seed );\\n}\\n\\n/**\\n * Create key-value caches of limited size\\n * @returns {function(string, object)} Returns the Object data after storing it on itself with\\n *\\tproperty name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)\\n *\\tdeleting the oldest entry\\n */\\nfunction createCache() {\\n\\tvar keys = [];\\n\\n\\tfunction cache( key, value ) {\\n\\t\\t// Use (key + \\\" \\\") to avoid collision with native prototype properties (see Issue #157)\\n\\t\\tif ( keys.push( key + \\\" \\\" ) > Expr.cacheLength ) {\\n\\t\\t\\t// Only keep the most recent entries\\n\\t\\t\\tdelete cache[ keys.shift() ];\\n\\t\\t}\\n\\t\\treturn (cache[ key + \\\" \\\" ] = value);\\n\\t}\\n\\treturn cache;\\n}\\n\\n/**\\n * Mark a function for special use by Sizzle\\n * @param {Function} fn The function to mark\\n */\\nfunction markFunction( fn ) {\\n\\tfn[ expando ] = true;\\n\\treturn fn;\\n}\\n\\n/**\\n * Support testing using an element\\n * @param {Function} fn Passed the created element and returns a boolean result\\n */\\nfunction assert( fn ) {\\n\\tvar el = document.createElement(\\\"fieldset\\\");\\n\\n\\ttry {\\n\\t\\treturn !!fn( el );\\n\\t} catch (e) {\\n\\t\\treturn false;\\n\\t} finally {\\n\\t\\t// Remove from its parent by default\\n\\t\\tif ( el.parentNode ) {\\n\\t\\t\\tel.parentNode.removeChild( el );\\n\\t\\t}\\n\\t\\t// release memory in IE\\n\\t\\tel = null;\\n\\t}\\n}\\n\\n/**\\n * Adds the same handler for all of the specified attrs\\n * @param {String} attrs Pipe-separated list of attributes\\n * @param {Function} handler The method that will be applied\\n */\\nfunction addHandle( attrs, handler ) {\\n\\tvar arr = attrs.split(\\\"|\\\"),\\n\\t\\ti = arr.length;\\n\\n\\twhile ( i-- ) {\\n\\t\\tExpr.attrHandle[ arr[i] ] = handler;\\n\\t}\\n}\\n\\n/**\\n * Checks document order of two siblings\\n * @param {Element} a\\n * @param {Element} b\\n * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b\\n */\\nfunction siblingCheck( a, b ) {\\n\\tvar cur = b && a,\\n\\t\\tdiff = cur && a.nodeType === 1 && b.nodeType === 1 &&\\n\\t\\t\\ta.sourceIndex - b.sourceIndex;\\n\\n\\t// Use IE sourceIndex if available on both nodes\\n\\tif ( diff ) {\\n\\t\\treturn diff;\\n\\t}\\n\\n\\t// Check if b follows a\\n\\tif ( cur ) {\\n\\t\\twhile ( (cur = cur.nextSibling) ) {\\n\\t\\t\\tif ( cur === b ) {\\n\\t\\t\\t\\treturn -1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn a ? 1 : -1;\\n}\\n\\n/**\\n * Returns a function to use in pseudos for input types\\n * @param {String} type\\n */\\nfunction createInputPseudo( type ) {\\n\\treturn function( elem ) {\\n\\t\\tvar name = elem.nodeName.toLowerCase();\\n\\t\\treturn name === \\\"input\\\" && elem.type === type;\\n\\t};\\n}\\n\\n/**\\n * Returns a function to use in pseudos for buttons\\n * @param {String} type\\n */\\nfunction createButtonPseudo( type ) {\\n\\treturn function( elem ) {\\n\\t\\tvar name = elem.nodeName.toLowerCase();\\n\\t\\treturn (name === \\\"input\\\" || name === \\\"button\\\") && elem.type === type;\\n\\t};\\n}\\n\\n/**\\n * Returns a function to use in pseudos for :enabled/:disabled\\n * @param {Boolean} disabled true for :disabled; false for :enabled\\n */\\nfunction createDisabledPseudo( disabled ) {\\n\\n\\t// Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable\\n\\treturn function( elem ) {\\n\\n\\t\\t// Only certain elements can match :enabled or :disabled\\n\\t\\t// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled\\n\\t\\t// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled\\n\\t\\tif ( \\\"form\\\" in elem ) {\\n\\n\\t\\t\\t// Check for inherited disabledness on relevant non-disabled elements:\\n\\t\\t\\t// * listed form-associated elements in a disabled fieldset\\n\\t\\t\\t//   https://html.spec.whatwg.org/multipage/forms.html#category-listed\\n\\t\\t\\t//   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled\\n\\t\\t\\t// * option elements in a disabled optgroup\\n\\t\\t\\t//   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled\\n\\t\\t\\t// All such elements have a \\\"form\\\" property.\\n\\t\\t\\tif ( elem.parentNode && elem.disabled === false ) {\\n\\n\\t\\t\\t\\t// Option elements defer to a parent optgroup if present\\n\\t\\t\\t\\tif ( \\\"label\\\" in elem ) {\\n\\t\\t\\t\\t\\tif ( \\\"label\\\" in elem.parentNode ) {\\n\\t\\t\\t\\t\\t\\treturn elem.parentNode.disabled === disabled;\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\treturn elem.disabled === disabled;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Support: IE 6 - 11\\n\\t\\t\\t\\t// Use the isDisabled shortcut property to check for disabled fieldset ancestors\\n\\t\\t\\t\\treturn elem.isDisabled === disabled ||\\n\\n\\t\\t\\t\\t\\t// Where there is no isDisabled, check manually\\n\\t\\t\\t\\t\\t/* jshint -W018 */\\n\\t\\t\\t\\t\\telem.isDisabled !== !disabled &&\\n\\t\\t\\t\\t\\t\\tdisabledAncestor( elem ) === disabled;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn elem.disabled === disabled;\\n\\n\\t\\t// Try to winnow out elements that can't be disabled before trusting the disabled property.\\n\\t\\t// Some victims get caught in our net (label, legend, menu, track), but it shouldn't\\n\\t\\t// even exist on them, let alone have a boolean value.\\n\\t\\t} else if ( \\\"label\\\" in elem ) {\\n\\t\\t\\treturn elem.disabled === disabled;\\n\\t\\t}\\n\\n\\t\\t// Remaining elements are neither :enabled nor :disabled\\n\\t\\treturn false;\\n\\t};\\n}\\n\\n/**\\n * Returns a function to use in pseudos for positionals\\n * @param {Function} fn\\n */\\nfunction createPositionalPseudo( fn ) {\\n\\treturn markFunction(function( argument ) {\\n\\t\\targument = +argument;\\n\\t\\treturn markFunction(function( seed, matches ) {\\n\\t\\t\\tvar j,\\n\\t\\t\\t\\tmatchIndexes = fn( [], seed.length, argument ),\\n\\t\\t\\t\\ti = matchIndexes.length;\\n\\n\\t\\t\\t// Match elements found at the specified indexes\\n\\t\\t\\twhile ( i-- ) {\\n\\t\\t\\t\\tif ( seed[ (j = matchIndexes[i]) ] ) {\\n\\t\\t\\t\\t\\tseed[j] = !(matches[j] = seed[j]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t});\\n\\t});\\n}\\n\\n/**\\n * Checks a node for validity as a Sizzle context\\n * @param {Element|Object=} context\\n * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value\\n */\\nfunction testContext( context ) {\\n\\treturn context && typeof context.getElementsByTagName !== \\\"undefined\\\" && context;\\n}\\n\\n// Expose support vars for convenience\\nsupport = Sizzle.support = {};\\n\\n/**\\n * Detects XML nodes\\n * @param {Element|Object} elem An element or a document\\n * @returns {Boolean} True iff elem is a non-HTML XML node\\n */\\nisXML = Sizzle.isXML = function( elem ) {\\n\\t// documentElement is verified for cases where it doesn't yet exist\\n\\t// (such as loading iframes in IE - #4833)\\n\\tvar documentElement = elem && (elem.ownerDocument || elem).documentElement;\\n\\treturn documentElement ? documentElement.nodeName !== \\\"HTML\\\" : false;\\n};\\n\\n/**\\n * Sets document-related variables once based on the current document\\n * @param {Element|Object} [doc] An element or document object to use to set the document\\n * @returns {Object} Returns the current document\\n */\\nsetDocument = Sizzle.setDocument = function( node ) {\\n\\tvar hasCompare, subWindow,\\n\\t\\tdoc = node ? node.ownerDocument || node : preferredDoc;\\n\\n\\t// Return early if doc is invalid or already selected\\n\\tif ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {\\n\\t\\treturn document;\\n\\t}\\n\\n\\t// Update global variables\\n\\tdocument = doc;\\n\\tdocElem = document.documentElement;\\n\\tdocumentIsHTML = !isXML( document );\\n\\n\\t// Support: IE 9-11, Edge\\n\\t// Accessing iframe documents after unload throws \\\"permission denied\\\" errors (jQuery #13936)\\n\\tif ( preferredDoc !== document &&\\n\\t\\t(subWindow = document.defaultView) && subWindow.top !== subWindow ) {\\n\\n\\t\\t// Support: IE 11, Edge\\n\\t\\tif ( subWindow.addEventListener ) {\\n\\t\\t\\tsubWindow.addEventListener( \\\"unload\\\", unloadHandler, false );\\n\\n\\t\\t// Support: IE 9 - 10 only\\n\\t\\t} else if ( subWindow.attachEvent ) {\\n\\t\\t\\tsubWindow.attachEvent( \\\"onunload\\\", unloadHandler );\\n\\t\\t}\\n\\t}\\n\\n\\t/* Attributes\\n\\t---------------------------------------------------------------------- */\\n\\n\\t// Support: IE<8\\n\\t// Verify that getAttribute really returns attributes and not properties\\n\\t// (excepting IE8 booleans)\\n\\tsupport.attributes = assert(function( el ) {\\n\\t\\tel.className = \\\"i\\\";\\n\\t\\treturn !el.getAttribute(\\\"className\\\");\\n\\t});\\n\\n\\t/* getElement(s)By*\\n\\t---------------------------------------------------------------------- */\\n\\n\\t// Check if getElementsByTagName(\\\"*\\\") returns only elements\\n\\tsupport.getElementsByTagName = assert(function( el ) {\\n\\t\\tel.appendChild( document.createComment(\\\"\\\") );\\n\\t\\treturn !el.getElementsByTagName(\\\"*\\\").length;\\n\\t});\\n\\n\\t// Support: IE<9\\n\\tsupport.getElementsByClassName = rnative.test( document.getElementsByClassName );\\n\\n\\t// Support: IE<10\\n\\t// Check if getElementById returns elements by name\\n\\t// The broken getElementById methods don't pick up programmatically-set names,\\n\\t// so use a roundabout getElementsByName test\\n\\tsupport.getById = assert(function( el ) {\\n\\t\\tdocElem.appendChild( el ).id = expando;\\n\\t\\treturn !document.getElementsByName || !document.getElementsByName( expando ).length;\\n\\t});\\n\\n\\t// ID filter and find\\n\\tif ( support.getById ) {\\n\\t\\tExpr.filter[\\\"ID\\\"] = function( id ) {\\n\\t\\t\\tvar attrId = id.replace( runescape, funescape );\\n\\t\\t\\treturn function( elem ) {\\n\\t\\t\\t\\treturn elem.getAttribute(\\\"id\\\") === attrId;\\n\\t\\t\\t};\\n\\t\\t};\\n\\t\\tExpr.find[\\\"ID\\\"] = function( id, context ) {\\n\\t\\t\\tif ( typeof context.getElementById !== \\\"undefined\\\" && documentIsHTML ) {\\n\\t\\t\\t\\tvar elem = context.getElementById( id );\\n\\t\\t\\t\\treturn elem ? [ elem ] : [];\\n\\t\\t\\t}\\n\\t\\t};\\n\\t} else {\\n\\t\\tExpr.filter[\\\"ID\\\"] =  function( id ) {\\n\\t\\t\\tvar attrId = id.replace( runescape, funescape );\\n\\t\\t\\treturn function( elem ) {\\n\\t\\t\\t\\tvar node = typeof elem.getAttributeNode !== \\\"undefined\\\" &&\\n\\t\\t\\t\\t\\telem.getAttributeNode(\\\"id\\\");\\n\\t\\t\\t\\treturn node && node.value === attrId;\\n\\t\\t\\t};\\n\\t\\t};\\n\\n\\t\\t// Support: IE 6 - 7 only\\n\\t\\t// getElementById is not reliable as a find shortcut\\n\\t\\tExpr.find[\\\"ID\\\"] = function( id, context ) {\\n\\t\\t\\tif ( typeof context.getElementById !== \\\"undefined\\\" && documentIsHTML ) {\\n\\t\\t\\t\\tvar node, i, elems,\\n\\t\\t\\t\\t\\telem = context.getElementById( id );\\n\\n\\t\\t\\t\\tif ( elem ) {\\n\\n\\t\\t\\t\\t\\t// Verify the id attribute\\n\\t\\t\\t\\t\\tnode = elem.getAttributeNode(\\\"id\\\");\\n\\t\\t\\t\\t\\tif ( node && node.value === id ) {\\n\\t\\t\\t\\t\\t\\treturn [ elem ];\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t// Fall back on getElementsByName\\n\\t\\t\\t\\t\\telems = context.getElementsByName( id );\\n\\t\\t\\t\\t\\ti = 0;\\n\\t\\t\\t\\t\\twhile ( (elem = elems[i++]) ) {\\n\\t\\t\\t\\t\\t\\tnode = elem.getAttributeNode(\\\"id\\\");\\n\\t\\t\\t\\t\\t\\tif ( node && node.value === id ) {\\n\\t\\t\\t\\t\\t\\t\\treturn [ elem ];\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn [];\\n\\t\\t\\t}\\n\\t\\t};\\n\\t}\\n\\n\\t// Tag\\n\\tExpr.find[\\\"TAG\\\"] = support.getElementsByTagName ?\\n\\t\\tfunction( tag, context ) {\\n\\t\\t\\tif ( typeof context.getElementsByTagName !== \\\"undefined\\\" ) {\\n\\t\\t\\t\\treturn context.getElementsByTagName( tag );\\n\\n\\t\\t\\t// DocumentFragment nodes don't have gEBTN\\n\\t\\t\\t} else if ( support.qsa ) {\\n\\t\\t\\t\\treturn context.querySelectorAll( tag );\\n\\t\\t\\t}\\n\\t\\t} :\\n\\n\\t\\tfunction( tag, context ) {\\n\\t\\t\\tvar elem,\\n\\t\\t\\t\\ttmp = [],\\n\\t\\t\\t\\ti = 0,\\n\\t\\t\\t\\t// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too\\n\\t\\t\\t\\tresults = context.getElementsByTagName( tag );\\n\\n\\t\\t\\t// Filter out possible comments\\n\\t\\t\\tif ( tag === \\\"*\\\" ) {\\n\\t\\t\\t\\twhile ( (elem = results[i++]) ) {\\n\\t\\t\\t\\t\\tif ( elem.nodeType === 1 ) {\\n\\t\\t\\t\\t\\t\\ttmp.push( elem );\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn tmp;\\n\\t\\t\\t}\\n\\t\\t\\treturn results;\\n\\t\\t};\\n\\n\\t// Class\\n\\tExpr.find[\\\"CLASS\\\"] = support.getElementsByClassName && function( className, context ) {\\n\\t\\tif ( typeof context.getElementsByClassName !== \\\"undefined\\\" && documentIsHTML ) {\\n\\t\\t\\treturn context.getElementsByClassName( className );\\n\\t\\t}\\n\\t};\\n\\n\\t/* QSA/matchesSelector\\n\\t---------------------------------------------------------------------- */\\n\\n\\t// QSA and matchesSelector support\\n\\n\\t// matchesSelector(:active) reports false when true (IE9/Opera 11.5)\\n\\trbuggyMatches = [];\\n\\n\\t// qSa(:focus) reports false when true (Chrome 21)\\n\\t// We allow this because of a bug in IE8/9 that throws an error\\n\\t// whenever `document.activeElement` is accessed on an iframe\\n\\t// So, we allow :focus to pass through QSA all the time to avoid the IE error\\n\\t// See https://bugs.jquery.com/ticket/13378\\n\\trbuggyQSA = [];\\n\\n\\tif ( (support.qsa = rnative.test( document.querySelectorAll )) ) {\\n\\t\\t// Build QSA regex\\n\\t\\t// Regex strategy adopted from Diego Perini\\n\\t\\tassert(function( el ) {\\n\\t\\t\\t// Select is set to empty string on purpose\\n\\t\\t\\t// This is to test IE's treatment of not explicitly\\n\\t\\t\\t// setting a boolean content attribute,\\n\\t\\t\\t// since its presence should be enough\\n\\t\\t\\t// https://bugs.jquery.com/ticket/12359\\n\\t\\t\\tdocElem.appendChild( el ).innerHTML = \\\"<a id='\\\" + expando + \\\"'></a>\\\" +\\n\\t\\t\\t\\t\\\"<select id='\\\" + expando + \\\"-\\\\r\\\\\\\\' msallowcapture=''>\\\" +\\n\\t\\t\\t\\t\\\"<option selected=''></option></select>\\\";\\n\\n\\t\\t\\t// Support: IE8, Opera 11-12.16\\n\\t\\t\\t// Nothing should be selected when empty strings follow ^= or $= or *=\\n\\t\\t\\t// The test attribute must be unknown in Opera but \\\"safe\\\" for WinRT\\n\\t\\t\\t// https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section\\n\\t\\t\\tif ( el.querySelectorAll(\\\"[msallowcapture^='']\\\").length ) {\\n\\t\\t\\t\\trbuggyQSA.push( \\\"[*^$]=\\\" + whitespace + \\\"*(?:''|\\\\\\\"\\\\\\\")\\\" );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Support: IE8\\n\\t\\t\\t// Boolean attributes and \\\"value\\\" are not treated correctly\\n\\t\\t\\tif ( !el.querySelectorAll(\\\"[selected]\\\").length ) {\\n\\t\\t\\t\\trbuggyQSA.push( \\\"\\\\\\\\[\\\" + whitespace + \\\"*(?:value|\\\" + booleans + \\\")\\\" );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+\\n\\t\\t\\tif ( !el.querySelectorAll( \\\"[id~=\\\" + expando + \\\"-]\\\" ).length ) {\\n\\t\\t\\t\\trbuggyQSA.push(\\\"~=\\\");\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Webkit/Opera - :checked should return selected option elements\\n\\t\\t\\t// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\\n\\t\\t\\t// IE8 throws error here and will not see later tests\\n\\t\\t\\tif ( !el.querySelectorAll(\\\":checked\\\").length ) {\\n\\t\\t\\t\\trbuggyQSA.push(\\\":checked\\\");\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Support: Safari 8+, iOS 8+\\n\\t\\t\\t// https://bugs.webkit.org/show_bug.cgi?id=136851\\n\\t\\t\\t// In-page `selector#id sibling-combinator selector` fails\\n\\t\\t\\tif ( !el.querySelectorAll( \\\"a#\\\" + expando + \\\"+*\\\" ).length ) {\\n\\t\\t\\t\\trbuggyQSA.push(\\\".#.+[+~]\\\");\\n\\t\\t\\t}\\n\\t\\t});\\n\\n\\t\\tassert(function( el ) {\\n\\t\\t\\tel.innerHTML = \\\"<a href='' disabled='disabled'></a>\\\" +\\n\\t\\t\\t\\t\\\"<select disabled='disabled'><option/></select>\\\";\\n\\n\\t\\t\\t// Support: Windows 8 Native Apps\\n\\t\\t\\t// The type and name attributes are restricted during .innerHTML assignment\\n\\t\\t\\tvar input = document.createElement(\\\"input\\\");\\n\\t\\t\\tinput.setAttribute( \\\"type\\\", \\\"hidden\\\" );\\n\\t\\t\\tel.appendChild( input ).setAttribute( \\\"name\\\", \\\"D\\\" );\\n\\n\\t\\t\\t// Support: IE8\\n\\t\\t\\t// Enforce case-sensitivity of name attribute\\n\\t\\t\\tif ( el.querySelectorAll(\\\"[name=d]\\\").length ) {\\n\\t\\t\\t\\trbuggyQSA.push( \\\"name\\\" + whitespace + \\\"*[*^$|!~]?=\\\" );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)\\n\\t\\t\\t// IE8 throws error here and will not see later tests\\n\\t\\t\\tif ( el.querySelectorAll(\\\":enabled\\\").length !== 2 ) {\\n\\t\\t\\t\\trbuggyQSA.push( \\\":enabled\\\", \\\":disabled\\\" );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Support: IE9-11+\\n\\t\\t\\t// IE's :disabled selector does not pick up the children of disabled fieldsets\\n\\t\\t\\tdocElem.appendChild( el ).disabled = true;\\n\\t\\t\\tif ( el.querySelectorAll(\\\":disabled\\\").length !== 2 ) {\\n\\t\\t\\t\\trbuggyQSA.push( \\\":enabled\\\", \\\":disabled\\\" );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Opera 10-11 does not throw on post-comma invalid pseudos\\n\\t\\t\\tel.querySelectorAll(\\\"*,:x\\\");\\n\\t\\t\\trbuggyQSA.push(\\\",.*:\\\");\\n\\t\\t});\\n\\t}\\n\\n\\tif ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||\\n\\t\\tdocElem.webkitMatchesSelector ||\\n\\t\\tdocElem.mozMatchesSelector ||\\n\\t\\tdocElem.oMatchesSelector ||\\n\\t\\tdocElem.msMatchesSelector) )) ) {\\n\\n\\t\\tassert(function( el ) {\\n\\t\\t\\t// Check to see if it's possible to do matchesSelector\\n\\t\\t\\t// on a disconnected node (IE 9)\\n\\t\\t\\tsupport.disconnectedMatch = matches.call( el, \\\"*\\\" );\\n\\n\\t\\t\\t// This should fail with an exception\\n\\t\\t\\t// Gecko does not error, returns false instead\\n\\t\\t\\tmatches.call( el, \\\"[s!='']:x\\\" );\\n\\t\\t\\trbuggyMatches.push( \\\"!=\\\", pseudos );\\n\\t\\t});\\n\\t}\\n\\n\\trbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join(\\\"|\\\") );\\n\\trbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join(\\\"|\\\") );\\n\\n\\t/* Contains\\n\\t---------------------------------------------------------------------- */\\n\\thasCompare = rnative.test( docElem.compareDocumentPosition );\\n\\n\\t// Element contains another\\n\\t// Purposefully self-exclusive\\n\\t// As in, an element does not contain itself\\n\\tcontains = hasCompare || rnative.test( docElem.contains ) ?\\n\\t\\tfunction( a, b ) {\\n\\t\\t\\tvar adown = a.nodeType === 9 ? a.documentElement : a,\\n\\t\\t\\t\\tbup = b && b.parentNode;\\n\\t\\t\\treturn a === bup || !!( bup && bup.nodeType === 1 && (\\n\\t\\t\\t\\tadown.contains ?\\n\\t\\t\\t\\t\\tadown.contains( bup ) :\\n\\t\\t\\t\\t\\ta.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16\\n\\t\\t\\t));\\n\\t\\t} :\\n\\t\\tfunction( a, b ) {\\n\\t\\t\\tif ( b ) {\\n\\t\\t\\t\\twhile ( (b = b.parentNode) ) {\\n\\t\\t\\t\\t\\tif ( b === a ) {\\n\\t\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn false;\\n\\t\\t};\\n\\n\\t/* Sorting\\n\\t---------------------------------------------------------------------- */\\n\\n\\t// Document order sorting\\n\\tsortOrder = hasCompare ?\\n\\tfunction( a, b ) {\\n\\n\\t\\t// Flag for duplicate removal\\n\\t\\tif ( a === b ) {\\n\\t\\t\\thasDuplicate = true;\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\n\\t\\t// Sort on method existence if only one input has compareDocumentPosition\\n\\t\\tvar compare = !a.compareDocumentPosition - !b.compareDocumentPosition;\\n\\t\\tif ( compare ) {\\n\\t\\t\\treturn compare;\\n\\t\\t}\\n\\n\\t\\t// Calculate position if both inputs belong to the same document\\n\\t\\tcompare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?\\n\\t\\t\\ta.compareDocumentPosition( b ) :\\n\\n\\t\\t\\t// Otherwise we know they are disconnected\\n\\t\\t\\t1;\\n\\n\\t\\t// Disconnected nodes\\n\\t\\tif ( compare & 1 ||\\n\\t\\t\\t(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {\\n\\n\\t\\t\\t// Choose the first element that is related to our preferred document\\n\\t\\t\\tif ( a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {\\n\\t\\t\\t\\treturn -1;\\n\\t\\t\\t}\\n\\t\\t\\tif ( b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {\\n\\t\\t\\t\\treturn 1;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Maintain original order\\n\\t\\t\\treturn sortInput ?\\n\\t\\t\\t\\t( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :\\n\\t\\t\\t\\t0;\\n\\t\\t}\\n\\n\\t\\treturn compare & 4 ? -1 : 1;\\n\\t} :\\n\\tfunction( a, b ) {\\n\\t\\t// Exit early if the nodes are identical\\n\\t\\tif ( a === b ) {\\n\\t\\t\\thasDuplicate = true;\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\n\\t\\tvar cur,\\n\\t\\t\\ti = 0,\\n\\t\\t\\taup = a.parentNode,\\n\\t\\t\\tbup = b.parentNode,\\n\\t\\t\\tap = [ a ],\\n\\t\\t\\tbp = [ b ];\\n\\n\\t\\t// Parentless nodes are either documents or disconnected\\n\\t\\tif ( !aup || !bup ) {\\n\\t\\t\\treturn a === document ? -1 :\\n\\t\\t\\t\\tb === document ? 1 :\\n\\t\\t\\t\\taup ? -1 :\\n\\t\\t\\t\\tbup ? 1 :\\n\\t\\t\\t\\tsortInput ?\\n\\t\\t\\t\\t( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :\\n\\t\\t\\t\\t0;\\n\\n\\t\\t// If the nodes are siblings, we can do a quick check\\n\\t\\t} else if ( aup === bup ) {\\n\\t\\t\\treturn siblingCheck( a, b );\\n\\t\\t}\\n\\n\\t\\t// Otherwise we need full lists of their ancestors for comparison\\n\\t\\tcur = a;\\n\\t\\twhile ( (cur = cur.parentNode) ) {\\n\\t\\t\\tap.unshift( cur );\\n\\t\\t}\\n\\t\\tcur = b;\\n\\t\\twhile ( (cur = cur.parentNode) ) {\\n\\t\\t\\tbp.unshift( cur );\\n\\t\\t}\\n\\n\\t\\t// Walk down the tree looking for a discrepancy\\n\\t\\twhile ( ap[i] === bp[i] ) {\\n\\t\\t\\ti++;\\n\\t\\t}\\n\\n\\t\\treturn i ?\\n\\t\\t\\t// Do a sibling check if the nodes have a common ancestor\\n\\t\\t\\tsiblingCheck( ap[i], bp[i] ) :\\n\\n\\t\\t\\t// Otherwise nodes in our document sort first\\n\\t\\t\\tap[i] === preferredDoc ? -1 :\\n\\t\\t\\tbp[i] === preferredDoc ? 1 :\\n\\t\\t\\t0;\\n\\t};\\n\\n\\treturn document;\\n};\\n\\nSizzle.matches = function( expr, elements ) {\\n\\treturn Sizzle( expr, null, null, elements );\\n};\\n\\nSizzle.matchesSelector = function( elem, expr ) {\\n\\t// Set document vars if needed\\n\\tif ( ( elem.ownerDocument || elem ) !== document ) {\\n\\t\\tsetDocument( elem );\\n\\t}\\n\\n\\t// Make sure that attribute selectors are quoted\\n\\texpr = expr.replace( rattributeQuotes, \\\"='$1']\\\" );\\n\\n\\tif ( support.matchesSelector && documentIsHTML &&\\n\\t\\t!compilerCache[ expr + \\\" \\\" ] &&\\n\\t\\t( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&\\n\\t\\t( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {\\n\\n\\t\\ttry {\\n\\t\\t\\tvar ret = matches.call( elem, expr );\\n\\n\\t\\t\\t// IE 9's matchesSelector returns false on disconnected nodes\\n\\t\\t\\tif ( ret || support.disconnectedMatch ||\\n\\t\\t\\t\\t\\t// As well, disconnected nodes are said to be in a document\\n\\t\\t\\t\\t\\t// fragment in IE 9\\n\\t\\t\\t\\t\\telem.document && elem.document.nodeType !== 11 ) {\\n\\t\\t\\t\\treturn ret;\\n\\t\\t\\t}\\n\\t\\t} catch (e) {}\\n\\t}\\n\\n\\treturn Sizzle( expr, document, null, [ elem ] ).length > 0;\\n};\\n\\nSizzle.contains = function( context, elem ) {\\n\\t// Set document vars if needed\\n\\tif ( ( context.ownerDocument || context ) !== document ) {\\n\\t\\tsetDocument( context );\\n\\t}\\n\\treturn contains( context, elem );\\n};\\n\\nSizzle.attr = function( elem, name ) {\\n\\t// Set document vars if needed\\n\\tif ( ( elem.ownerDocument || elem ) !== document ) {\\n\\t\\tsetDocument( elem );\\n\\t}\\n\\n\\tvar fn = Expr.attrHandle[ name.toLowerCase() ],\\n\\t\\t// Don't get fooled by Object.prototype properties (jQuery #13807)\\n\\t\\tval = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?\\n\\t\\t\\tfn( elem, name, !documentIsHTML ) :\\n\\t\\t\\tundefined;\\n\\n\\treturn val !== undefined ?\\n\\t\\tval :\\n\\t\\tsupport.attributes || !documentIsHTML ?\\n\\t\\t\\telem.getAttribute( name ) :\\n\\t\\t\\t(val = elem.getAttributeNode(name)) && val.specified ?\\n\\t\\t\\t\\tval.value :\\n\\t\\t\\t\\tnull;\\n};\\n\\nSizzle.escape = function( sel ) {\\n\\treturn (sel + \\\"\\\").replace( rcssescape, fcssescape );\\n};\\n\\nSizzle.error = function( msg ) {\\n\\tthrow new Error( \\\"Syntax error, unrecognized expression: \\\" + msg );\\n};\\n\\n/**\\n * Document sorting and removing duplicates\\n * @param {ArrayLike} results\\n */\\nSizzle.uniqueSort = function( results ) {\\n\\tvar elem,\\n\\t\\tduplicates = [],\\n\\t\\tj = 0,\\n\\t\\ti = 0;\\n\\n\\t// Unless we *know* we can detect duplicates, assume their presence\\n\\thasDuplicate = !support.detectDuplicates;\\n\\tsortInput = !support.sortStable && results.slice( 0 );\\n\\tresults.sort( sortOrder );\\n\\n\\tif ( hasDuplicate ) {\\n\\t\\twhile ( (elem = results[i++]) ) {\\n\\t\\t\\tif ( elem === results[ i ] ) {\\n\\t\\t\\t\\tj = duplicates.push( i );\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\twhile ( j-- ) {\\n\\t\\t\\tresults.splice( duplicates[ j ], 1 );\\n\\t\\t}\\n\\t}\\n\\n\\t// Clear input after sorting to release objects\\n\\t// See https://github.com/jquery/sizzle/pull/225\\n\\tsortInput = null;\\n\\n\\treturn results;\\n};\\n\\n/**\\n * Utility function for retrieving the text value of an array of DOM nodes\\n * @param {Array|Element} elem\\n */\\ngetText = Sizzle.getText = function( elem ) {\\n\\tvar node,\\n\\t\\tret = \\\"\\\",\\n\\t\\ti = 0,\\n\\t\\tnodeType = elem.nodeType;\\n\\n\\tif ( !nodeType ) {\\n\\t\\t// If no nodeType, this is expected to be an array\\n\\t\\twhile ( (node = elem[i++]) ) {\\n\\t\\t\\t// Do not traverse comment nodes\\n\\t\\t\\tret += getText( node );\\n\\t\\t}\\n\\t} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {\\n\\t\\t// Use textContent for elements\\n\\t\\t// innerText usage removed for consistency of new lines (jQuery #11153)\\n\\t\\tif ( typeof elem.textContent === \\\"string\\\" ) {\\n\\t\\t\\treturn elem.textContent;\\n\\t\\t} else {\\n\\t\\t\\t// Traverse its children\\n\\t\\t\\tfor ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {\\n\\t\\t\\t\\tret += getText( elem );\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} else if ( nodeType === 3 || nodeType === 4 ) {\\n\\t\\treturn elem.nodeValue;\\n\\t}\\n\\t// Do not include comment or processing instruction nodes\\n\\n\\treturn ret;\\n};\\n\\nExpr = Sizzle.selectors = {\\n\\n\\t// Can be adjusted by the user\\n\\tcacheLength: 50,\\n\\n\\tcreatePseudo: markFunction,\\n\\n\\tmatch: matchExpr,\\n\\n\\tattrHandle: {},\\n\\n\\tfind: {},\\n\\n\\trelative: {\\n\\t\\t\\\">\\\": { dir: \\\"parentNode\\\", first: true },\\n\\t\\t\\\" \\\": { dir: \\\"parentNode\\\" },\\n\\t\\t\\\"+\\\": { dir: \\\"previousSibling\\\", first: true },\\n\\t\\t\\\"~\\\": { dir: \\\"previousSibling\\\" }\\n\\t},\\n\\n\\tpreFilter: {\\n\\t\\t\\\"ATTR\\\": function( match ) {\\n\\t\\t\\tmatch[1] = match[1].replace( runescape, funescape );\\n\\n\\t\\t\\t// Move the given value to match[3] whether quoted or unquoted\\n\\t\\t\\tmatch[3] = ( match[3] || match[4] || match[5] || \\\"\\\" ).replace( runescape, funescape );\\n\\n\\t\\t\\tif ( match[2] === \\\"~=\\\" ) {\\n\\t\\t\\t\\tmatch[3] = \\\" \\\" + match[3] + \\\" \\\";\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn match.slice( 0, 4 );\\n\\t\\t},\\n\\n\\t\\t\\\"CHILD\\\": function( match ) {\\n\\t\\t\\t/* matches from matchExpr[\\\"CHILD\\\"]\\n\\t\\t\\t\\t1 type (only|nth|...)\\n\\t\\t\\t\\t2 what (child|of-type)\\n\\t\\t\\t\\t3 argument (even|odd|\\\\d*|\\\\d*n([+-]\\\\d+)?|...)\\n\\t\\t\\t\\t4 xn-component of xn+y argument ([+-]?\\\\d*n|)\\n\\t\\t\\t\\t5 sign of xn-component\\n\\t\\t\\t\\t6 x of xn-component\\n\\t\\t\\t\\t7 sign of y-component\\n\\t\\t\\t\\t8 y of y-component\\n\\t\\t\\t*/\\n\\t\\t\\tmatch[1] = match[1].toLowerCase();\\n\\n\\t\\t\\tif ( match[1].slice( 0, 3 ) === \\\"nth\\\" ) {\\n\\t\\t\\t\\t// nth-* requires argument\\n\\t\\t\\t\\tif ( !match[3] ) {\\n\\t\\t\\t\\t\\tSizzle.error( match[0] );\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// numeric x and y parameters for Expr.filter.CHILD\\n\\t\\t\\t\\t// remember that false/true cast respectively to 0/1\\n\\t\\t\\t\\tmatch[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === \\\"even\\\" || match[3] === \\\"odd\\\" ) );\\n\\t\\t\\t\\tmatch[5] = +( ( match[7] + match[8] ) || match[3] === \\\"odd\\\" );\\n\\n\\t\\t\\t// other types prohibit arguments\\n\\t\\t\\t} else if ( match[3] ) {\\n\\t\\t\\t\\tSizzle.error( match[0] );\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn match;\\n\\t\\t},\\n\\n\\t\\t\\\"PSEUDO\\\": function( match ) {\\n\\t\\t\\tvar excess,\\n\\t\\t\\t\\tunquoted = !match[6] && match[2];\\n\\n\\t\\t\\tif ( matchExpr[\\\"CHILD\\\"].test( match[0] ) ) {\\n\\t\\t\\t\\treturn null;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Accept quoted arguments as-is\\n\\t\\t\\tif ( match[3] ) {\\n\\t\\t\\t\\tmatch[2] = match[4] || match[5] || \\\"\\\";\\n\\n\\t\\t\\t// Strip excess characters from unquoted arguments\\n\\t\\t\\t} else if ( unquoted && rpseudo.test( unquoted ) &&\\n\\t\\t\\t\\t// Get excess from tokenize (recursively)\\n\\t\\t\\t\\t(excess = tokenize( unquoted, true )) &&\\n\\t\\t\\t\\t// advance to the next closing parenthesis\\n\\t\\t\\t\\t(excess = unquoted.indexOf( \\\")\\\", unquoted.length - excess ) - unquoted.length) ) {\\n\\n\\t\\t\\t\\t// excess is a negative index\\n\\t\\t\\t\\tmatch[0] = match[0].slice( 0, excess );\\n\\t\\t\\t\\tmatch[2] = unquoted.slice( 0, excess );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Return only captures needed by the pseudo filter method (type and argument)\\n\\t\\t\\treturn match.slice( 0, 3 );\\n\\t\\t}\\n\\t},\\n\\n\\tfilter: {\\n\\n\\t\\t\\\"TAG\\\": function( nodeNameSelector ) {\\n\\t\\t\\tvar nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();\\n\\t\\t\\treturn nodeNameSelector === \\\"*\\\" ?\\n\\t\\t\\t\\tfunction() { return true; } :\\n\\t\\t\\t\\tfunction( elem ) {\\n\\t\\t\\t\\t\\treturn elem.nodeName && elem.nodeName.toLowerCase() === nodeName;\\n\\t\\t\\t\\t};\\n\\t\\t},\\n\\n\\t\\t\\\"CLASS\\\": function( className ) {\\n\\t\\t\\tvar pattern = classCache[ className + \\\" \\\" ];\\n\\n\\t\\t\\treturn pattern ||\\n\\t\\t\\t\\t(pattern = new RegExp( \\\"(^|\\\" + whitespace + \\\")\\\" + className + \\\"(\\\" + whitespace + \\\"|$)\\\" )) &&\\n\\t\\t\\t\\tclassCache( className, function( elem ) {\\n\\t\\t\\t\\t\\treturn pattern.test( typeof elem.className === \\\"string\\\" && elem.className || typeof elem.getAttribute !== \\\"undefined\\\" && elem.getAttribute(\\\"class\\\") || \\\"\\\" );\\n\\t\\t\\t\\t});\\n\\t\\t},\\n\\n\\t\\t\\\"ATTR\\\": function( name, operator, check ) {\\n\\t\\t\\treturn function( elem ) {\\n\\t\\t\\t\\tvar result = Sizzle.attr( elem, name );\\n\\n\\t\\t\\t\\tif ( result == null ) {\\n\\t\\t\\t\\t\\treturn operator === \\\"!=\\\";\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif ( !operator ) {\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tresult += \\\"\\\";\\n\\n\\t\\t\\t\\treturn operator === \\\"=\\\" ? result === check :\\n\\t\\t\\t\\t\\toperator === \\\"!=\\\" ? result !== check :\\n\\t\\t\\t\\t\\toperator === \\\"^=\\\" ? check && result.indexOf( check ) === 0 :\\n\\t\\t\\t\\t\\toperator === \\\"*=\\\" ? check && result.indexOf( check ) > -1 :\\n\\t\\t\\t\\t\\toperator === \\\"$=\\\" ? check && result.slice( -check.length ) === check :\\n\\t\\t\\t\\t\\toperator === \\\"~=\\\" ? ( \\\" \\\" + result.replace( rwhitespace, \\\" \\\" ) + \\\" \\\" ).indexOf( check ) > -1 :\\n\\t\\t\\t\\t\\toperator === \\\"|=\\\" ? result === check || result.slice( 0, check.length + 1 ) === check + \\\"-\\\" :\\n\\t\\t\\t\\t\\tfalse;\\n\\t\\t\\t};\\n\\t\\t},\\n\\n\\t\\t\\\"CHILD\\\": function( type, what, argument, first, last ) {\\n\\t\\t\\tvar simple = type.slice( 0, 3 ) !== \\\"nth\\\",\\n\\t\\t\\t\\tforward = type.slice( -4 ) !== \\\"last\\\",\\n\\t\\t\\t\\tofType = what === \\\"of-type\\\";\\n\\n\\t\\t\\treturn first === 1 && last === 0 ?\\n\\n\\t\\t\\t\\t// Shortcut for :nth-*(n)\\n\\t\\t\\t\\tfunction( elem ) {\\n\\t\\t\\t\\t\\treturn !!elem.parentNode;\\n\\t\\t\\t\\t} :\\n\\n\\t\\t\\t\\tfunction( elem, context, xml ) {\\n\\t\\t\\t\\t\\tvar cache, uniqueCache, outerCache, node, nodeIndex, start,\\n\\t\\t\\t\\t\\t\\tdir = simple !== forward ? \\\"nextSibling\\\" : \\\"previousSibling\\\",\\n\\t\\t\\t\\t\\t\\tparent = elem.parentNode,\\n\\t\\t\\t\\t\\t\\tname = ofType && elem.nodeName.toLowerCase(),\\n\\t\\t\\t\\t\\t\\tuseCache = !xml && !ofType,\\n\\t\\t\\t\\t\\t\\tdiff = false;\\n\\n\\t\\t\\t\\t\\tif ( parent ) {\\n\\n\\t\\t\\t\\t\\t\\t// :(first|last|only)-(child|of-type)\\n\\t\\t\\t\\t\\t\\tif ( simple ) {\\n\\t\\t\\t\\t\\t\\t\\twhile ( dir ) {\\n\\t\\t\\t\\t\\t\\t\\t\\tnode = elem;\\n\\t\\t\\t\\t\\t\\t\\t\\twhile ( (node = node[ dir ]) ) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif ( ofType ?\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tnode.nodeName.toLowerCase() === name :\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tnode.nodeType === 1 ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t\\t// Reverse direction for :only-* (if we haven't yet done so)\\n\\t\\t\\t\\t\\t\\t\\t\\tstart = dir = type === \\\"only\\\" && !start && \\\"nextSibling\\\";\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\tstart = [ forward ? parent.firstChild : parent.lastChild ];\\n\\n\\t\\t\\t\\t\\t\\t// non-xml :nth-child(...) stores cache data on `parent`\\n\\t\\t\\t\\t\\t\\tif ( forward && useCache ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t// Seek `elem` from a previously-cached index\\n\\n\\t\\t\\t\\t\\t\\t\\t// ...in a gzip-friendly way\\n\\t\\t\\t\\t\\t\\t\\tnode = parent;\\n\\t\\t\\t\\t\\t\\t\\touterCache = node[ expando ] || (node[ expando ] = {});\\n\\n\\t\\t\\t\\t\\t\\t\\t// Support: IE <9 only\\n\\t\\t\\t\\t\\t\\t\\t// Defend against cloned attroperties (jQuery gh-1709)\\n\\t\\t\\t\\t\\t\\t\\tuniqueCache = outerCache[ node.uniqueID ] ||\\n\\t\\t\\t\\t\\t\\t\\t\\t(outerCache[ node.uniqueID ] = {});\\n\\n\\t\\t\\t\\t\\t\\t\\tcache = uniqueCache[ type ] || [];\\n\\t\\t\\t\\t\\t\\t\\tnodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];\\n\\t\\t\\t\\t\\t\\t\\tdiff = nodeIndex && cache[ 2 ];\\n\\t\\t\\t\\t\\t\\t\\tnode = nodeIndex && parent.childNodes[ nodeIndex ];\\n\\n\\t\\t\\t\\t\\t\\t\\twhile ( (node = ++nodeIndex && node && node[ dir ] ||\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t// Fallback to seeking `elem` from the start\\n\\t\\t\\t\\t\\t\\t\\t\\t(diff = nodeIndex = 0) || start.pop()) ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t// When found, cache indexes on `parent` and break\\n\\t\\t\\t\\t\\t\\t\\t\\tif ( node.nodeType === 1 && ++diff && node === elem ) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tuniqueCache[ type ] = [ dirruns, nodeIndex, diff ];\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\t// Use previously-cached element index if available\\n\\t\\t\\t\\t\\t\\t\\tif ( useCache ) {\\n\\t\\t\\t\\t\\t\\t\\t\\t// ...in a gzip-friendly way\\n\\t\\t\\t\\t\\t\\t\\t\\tnode = elem;\\n\\t\\t\\t\\t\\t\\t\\t\\touterCache = node[ expando ] || (node[ expando ] = {});\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t// Support: IE <9 only\\n\\t\\t\\t\\t\\t\\t\\t\\t// Defend against cloned attroperties (jQuery gh-1709)\\n\\t\\t\\t\\t\\t\\t\\t\\tuniqueCache = outerCache[ node.uniqueID ] ||\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t(outerCache[ node.uniqueID ] = {});\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tcache = uniqueCache[ type ] || [];\\n\\t\\t\\t\\t\\t\\t\\t\\tnodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];\\n\\t\\t\\t\\t\\t\\t\\t\\tdiff = nodeIndex;\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t// xml :nth-child(...)\\n\\t\\t\\t\\t\\t\\t\\t// or :nth-last-child(...) or :nth(-last)?-of-type(...)\\n\\t\\t\\t\\t\\t\\t\\tif ( diff === false ) {\\n\\t\\t\\t\\t\\t\\t\\t\\t// Use the same loop as above to seek `elem` from the start\\n\\t\\t\\t\\t\\t\\t\\t\\twhile ( (node = ++nodeIndex && node && node[ dir ] ||\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t(diff = nodeIndex = 0) || start.pop()) ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif ( ( ofType ?\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tnode.nodeName.toLowerCase() === name :\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tnode.nodeType === 1 ) &&\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t++diff ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// Cache the index of each encountered element\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif ( useCache ) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\touterCache = node[ expando ] || (node[ expando ] = {});\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// Support: IE <9 only\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// Defend against cloned attroperties (jQuery gh-1709)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tuniqueCache = outerCache[ node.uniqueID ] ||\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t(outerCache[ node.uniqueID ] = {});\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tuniqueCache[ type ] = [ dirruns, diff ];\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif ( node === elem ) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t// Incorporate the offset, then check against cycle size\\n\\t\\t\\t\\t\\t\\tdiff -= last;\\n\\t\\t\\t\\t\\t\\treturn diff === first || ( diff % first === 0 && diff / first >= 0 );\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t};\\n\\t\\t},\\n\\n\\t\\t\\\"PSEUDO\\\": function( pseudo, argument ) {\\n\\t\\t\\t// pseudo-class names are case-insensitive\\n\\t\\t\\t// http://www.w3.org/TR/selectors/#pseudo-classes\\n\\t\\t\\t// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters\\n\\t\\t\\t// Remember that setFilters inherits from pseudos\\n\\t\\t\\tvar args,\\n\\t\\t\\t\\tfn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||\\n\\t\\t\\t\\t\\tSizzle.error( \\\"unsupported pseudo: \\\" + pseudo );\\n\\n\\t\\t\\t// The user may use createPseudo to indicate that\\n\\t\\t\\t// arguments are needed to create the filter function\\n\\t\\t\\t// just as Sizzle does\\n\\t\\t\\tif ( fn[ expando ] ) {\\n\\t\\t\\t\\treturn fn( argument );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// But maintain support for old signatures\\n\\t\\t\\tif ( fn.length > 1 ) {\\n\\t\\t\\t\\targs = [ pseudo, pseudo, \\\"\\\", argument ];\\n\\t\\t\\t\\treturn Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?\\n\\t\\t\\t\\t\\tmarkFunction(function( seed, matches ) {\\n\\t\\t\\t\\t\\t\\tvar idx,\\n\\t\\t\\t\\t\\t\\t\\tmatched = fn( seed, argument ),\\n\\t\\t\\t\\t\\t\\t\\ti = matched.length;\\n\\t\\t\\t\\t\\t\\twhile ( i-- ) {\\n\\t\\t\\t\\t\\t\\t\\tidx = indexOf( seed, matched[i] );\\n\\t\\t\\t\\t\\t\\t\\tseed[ idx ] = !( matches[ idx ] = matched[i] );\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}) :\\n\\t\\t\\t\\t\\tfunction( elem ) {\\n\\t\\t\\t\\t\\t\\treturn fn( elem, 0, args );\\n\\t\\t\\t\\t\\t};\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn fn;\\n\\t\\t}\\n\\t},\\n\\n\\tpseudos: {\\n\\t\\t// Potentially complex pseudos\\n\\t\\t\\\"not\\\": markFunction(function( selector ) {\\n\\t\\t\\t// Trim the selector passed to compile\\n\\t\\t\\t// to avoid treating leading and trailing\\n\\t\\t\\t// spaces as combinators\\n\\t\\t\\tvar input = [],\\n\\t\\t\\t\\tresults = [],\\n\\t\\t\\t\\tmatcher = compile( selector.replace( rtrim, \\\"$1\\\" ) );\\n\\n\\t\\t\\treturn matcher[ expando ] ?\\n\\t\\t\\t\\tmarkFunction(function( seed, matches, context, xml ) {\\n\\t\\t\\t\\t\\tvar elem,\\n\\t\\t\\t\\t\\t\\tunmatched = matcher( seed, null, xml, [] ),\\n\\t\\t\\t\\t\\t\\ti = seed.length;\\n\\n\\t\\t\\t\\t\\t// Match elements unmatched by `matcher`\\n\\t\\t\\t\\t\\twhile ( i-- ) {\\n\\t\\t\\t\\t\\t\\tif ( (elem = unmatched[i]) ) {\\n\\t\\t\\t\\t\\t\\t\\tseed[i] = !(matches[i] = elem);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}) :\\n\\t\\t\\t\\tfunction( elem, context, xml ) {\\n\\t\\t\\t\\t\\tinput[0] = elem;\\n\\t\\t\\t\\t\\tmatcher( input, null, xml, results );\\n\\t\\t\\t\\t\\t// Don't keep the element (issue #299)\\n\\t\\t\\t\\t\\tinput[0] = null;\\n\\t\\t\\t\\t\\treturn !results.pop();\\n\\t\\t\\t\\t};\\n\\t\\t}),\\n\\n\\t\\t\\\"has\\\": markFunction(function( selector ) {\\n\\t\\t\\treturn function( elem ) {\\n\\t\\t\\t\\treturn Sizzle( selector, elem ).length > 0;\\n\\t\\t\\t};\\n\\t\\t}),\\n\\n\\t\\t\\\"contains\\\": markFunction(function( text ) {\\n\\t\\t\\ttext = text.replace( runescape, funescape );\\n\\t\\t\\treturn function( elem ) {\\n\\t\\t\\t\\treturn ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;\\n\\t\\t\\t};\\n\\t\\t}),\\n\\n\\t\\t// \\\"Whether an element is represented by a :lang() selector\\n\\t\\t// is based solely on the element's language value\\n\\t\\t// being equal to the identifier C,\\n\\t\\t// or beginning with the identifier C immediately followed by \\\"-\\\".\\n\\t\\t// The matching of C against the element's language value is performed case-insensitively.\\n\\t\\t// The identifier C does not have to be a valid language name.\\\"\\n\\t\\t// http://www.w3.org/TR/selectors/#lang-pseudo\\n\\t\\t\\\"lang\\\": markFunction( function( lang ) {\\n\\t\\t\\t// lang value must be a valid identifier\\n\\t\\t\\tif ( !ridentifier.test(lang || \\\"\\\") ) {\\n\\t\\t\\t\\tSizzle.error( \\\"unsupported lang: \\\" + lang );\\n\\t\\t\\t}\\n\\t\\t\\tlang = lang.replace( runescape, funescape ).toLowerCase();\\n\\t\\t\\treturn function( elem ) {\\n\\t\\t\\t\\tvar elemLang;\\n\\t\\t\\t\\tdo {\\n\\t\\t\\t\\t\\tif ( (elemLang = documentIsHTML ?\\n\\t\\t\\t\\t\\t\\telem.lang :\\n\\t\\t\\t\\t\\t\\telem.getAttribute(\\\"xml:lang\\\") || elem.getAttribute(\\\"lang\\\")) ) {\\n\\n\\t\\t\\t\\t\\t\\telemLang = elemLang.toLowerCase();\\n\\t\\t\\t\\t\\t\\treturn elemLang === lang || elemLang.indexOf( lang + \\\"-\\\" ) === 0;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t} while ( (elem = elem.parentNode) && elem.nodeType === 1 );\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t};\\n\\t\\t}),\\n\\n\\t\\t// Miscellaneous\\n\\t\\t\\\"target\\\": function( elem ) {\\n\\t\\t\\tvar hash = window.location && window.location.hash;\\n\\t\\t\\treturn hash && hash.slice( 1 ) === elem.id;\\n\\t\\t},\\n\\n\\t\\t\\\"root\\\": function( elem ) {\\n\\t\\t\\treturn elem === docElem;\\n\\t\\t},\\n\\n\\t\\t\\\"focus\\\": function( elem ) {\\n\\t\\t\\treturn elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);\\n\\t\\t},\\n\\n\\t\\t// Boolean properties\\n\\t\\t\\\"enabled\\\": createDisabledPseudo( false ),\\n\\t\\t\\\"disabled\\\": createDisabledPseudo( true ),\\n\\n\\t\\t\\\"checked\\\": function( elem ) {\\n\\t\\t\\t// In CSS3, :checked should return both checked and selected elements\\n\\t\\t\\t// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\\n\\t\\t\\tvar nodeName = elem.nodeName.toLowerCase();\\n\\t\\t\\treturn (nodeName === \\\"input\\\" && !!elem.checked) || (nodeName === \\\"option\\\" && !!elem.selected);\\n\\t\\t},\\n\\n\\t\\t\\\"selected\\\": function( elem ) {\\n\\t\\t\\t// Accessing this property makes selected-by-default\\n\\t\\t\\t// options in Safari work properly\\n\\t\\t\\tif ( elem.parentNode ) {\\n\\t\\t\\t\\telem.parentNode.selectedIndex;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn elem.selected === true;\\n\\t\\t},\\n\\n\\t\\t// Contents\\n\\t\\t\\\"empty\\\": function( elem ) {\\n\\t\\t\\t// http://www.w3.org/TR/selectors/#empty-pseudo\\n\\t\\t\\t// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),\\n\\t\\t\\t//   but not by others (comment: 8; processing instruction: 7; etc.)\\n\\t\\t\\t// nodeType < 6 works because attributes (2) do not appear as children\\n\\t\\t\\tfor ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {\\n\\t\\t\\t\\tif ( elem.nodeType < 6 ) {\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn true;\\n\\t\\t},\\n\\n\\t\\t\\\"parent\\\": function( elem ) {\\n\\t\\t\\treturn !Expr.pseudos[\\\"empty\\\"]( elem );\\n\\t\\t},\\n\\n\\t\\t// Element/input types\\n\\t\\t\\\"header\\\": function( elem ) {\\n\\t\\t\\treturn rheader.test( elem.nodeName );\\n\\t\\t},\\n\\n\\t\\t\\\"input\\\": function( elem ) {\\n\\t\\t\\treturn rinputs.test( elem.nodeName );\\n\\t\\t},\\n\\n\\t\\t\\\"button\\\": function( elem ) {\\n\\t\\t\\tvar name = elem.nodeName.toLowerCase();\\n\\t\\t\\treturn name === \\\"input\\\" && elem.type === \\\"button\\\" || name === \\\"button\\\";\\n\\t\\t},\\n\\n\\t\\t\\\"text\\\": function( elem ) {\\n\\t\\t\\tvar attr;\\n\\t\\t\\treturn elem.nodeName.toLowerCase() === \\\"input\\\" &&\\n\\t\\t\\t\\telem.type === \\\"text\\\" &&\\n\\n\\t\\t\\t\\t// Support: IE<8\\n\\t\\t\\t\\t// New HTML5 attribute values (e.g., \\\"search\\\") appear with elem.type === \\\"text\\\"\\n\\t\\t\\t\\t( (attr = elem.getAttribute(\\\"type\\\")) == null || attr.toLowerCase() === \\\"text\\\" );\\n\\t\\t},\\n\\n\\t\\t// Position-in-collection\\n\\t\\t\\\"first\\\": createPositionalPseudo(function() {\\n\\t\\t\\treturn [ 0 ];\\n\\t\\t}),\\n\\n\\t\\t\\\"last\\\": createPositionalPseudo(function( matchIndexes, length ) {\\n\\t\\t\\treturn [ length - 1 ];\\n\\t\\t}),\\n\\n\\t\\t\\\"eq\\\": createPositionalPseudo(function( matchIndexes, length, argument ) {\\n\\t\\t\\treturn [ argument < 0 ? argument + length : argument ];\\n\\t\\t}),\\n\\n\\t\\t\\\"even\\\": createPositionalPseudo(function( matchIndexes, length ) {\\n\\t\\t\\tvar i = 0;\\n\\t\\t\\tfor ( ; i < length; i += 2 ) {\\n\\t\\t\\t\\tmatchIndexes.push( i );\\n\\t\\t\\t}\\n\\t\\t\\treturn matchIndexes;\\n\\t\\t}),\\n\\n\\t\\t\\\"odd\\\": createPositionalPseudo(function( matchIndexes, length ) {\\n\\t\\t\\tvar i = 1;\\n\\t\\t\\tfor ( ; i < length; i += 2 ) {\\n\\t\\t\\t\\tmatchIndexes.push( i );\\n\\t\\t\\t}\\n\\t\\t\\treturn matchIndexes;\\n\\t\\t}),\\n\\n\\t\\t\\\"lt\\\": createPositionalPseudo(function( matchIndexes, length, argument ) {\\n\\t\\t\\tvar i = argument < 0 ? argument + length : argument;\\n\\t\\t\\tfor ( ; --i >= 0; ) {\\n\\t\\t\\t\\tmatchIndexes.push( i );\\n\\t\\t\\t}\\n\\t\\t\\treturn matchIndexes;\\n\\t\\t}),\\n\\n\\t\\t\\\"gt\\\": createPositionalPseudo(function( matchIndexes, length, argument ) {\\n\\t\\t\\tvar i = argument < 0 ? argument + length : argument;\\n\\t\\t\\tfor ( ; ++i < length; ) {\\n\\t\\t\\t\\tmatchIndexes.push( i );\\n\\t\\t\\t}\\n\\t\\t\\treturn matchIndexes;\\n\\t\\t})\\n\\t}\\n};\\n\\nExpr.pseudos[\\\"nth\\\"] = Expr.pseudos[\\\"eq\\\"];\\n\\n// Add button/input type pseudos\\nfor ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {\\n\\tExpr.pseudos[ i ] = createInputPseudo( i );\\n}\\nfor ( i in { submit: true, reset: true } ) {\\n\\tExpr.pseudos[ i ] = createButtonPseudo( i );\\n}\\n\\n// Easy API for creating new setFilters\\nfunction setFilters() {}\\nsetFilters.prototype = Expr.filters = Expr.pseudos;\\nExpr.setFilters = new setFilters();\\n\\ntokenize = Sizzle.tokenize = function( selector, parseOnly ) {\\n\\tvar matched, match, tokens, type,\\n\\t\\tsoFar, groups, preFilters,\\n\\t\\tcached = tokenCache[ selector + \\\" \\\" ];\\n\\n\\tif ( cached ) {\\n\\t\\treturn parseOnly ? 0 : cached.slice( 0 );\\n\\t}\\n\\n\\tsoFar = selector;\\n\\tgroups = [];\\n\\tpreFilters = Expr.preFilter;\\n\\n\\twhile ( soFar ) {\\n\\n\\t\\t// Comma and first run\\n\\t\\tif ( !matched || (match = rcomma.exec( soFar )) ) {\\n\\t\\t\\tif ( match ) {\\n\\t\\t\\t\\t// Don't consume trailing commas as valid\\n\\t\\t\\t\\tsoFar = soFar.slice( match[0].length ) || soFar;\\n\\t\\t\\t}\\n\\t\\t\\tgroups.push( (tokens = []) );\\n\\t\\t}\\n\\n\\t\\tmatched = false;\\n\\n\\t\\t// Combinators\\n\\t\\tif ( (match = rcombinators.exec( soFar )) ) {\\n\\t\\t\\tmatched = match.shift();\\n\\t\\t\\ttokens.push({\\n\\t\\t\\t\\tvalue: matched,\\n\\t\\t\\t\\t// Cast descendant combinators to space\\n\\t\\t\\t\\ttype: match[0].replace( rtrim, \\\" \\\" )\\n\\t\\t\\t});\\n\\t\\t\\tsoFar = soFar.slice( matched.length );\\n\\t\\t}\\n\\n\\t\\t// Filters\\n\\t\\tfor ( type in Expr.filter ) {\\n\\t\\t\\tif ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||\\n\\t\\t\\t\\t(match = preFilters[ type ]( match ))) ) {\\n\\t\\t\\t\\tmatched = match.shift();\\n\\t\\t\\t\\ttokens.push({\\n\\t\\t\\t\\t\\tvalue: matched,\\n\\t\\t\\t\\t\\ttype: type,\\n\\t\\t\\t\\t\\tmatches: match\\n\\t\\t\\t\\t});\\n\\t\\t\\t\\tsoFar = soFar.slice( matched.length );\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif ( !matched ) {\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t}\\n\\n\\t// Return the length of the invalid excess\\n\\t// if we're just parsing\\n\\t// Otherwise, throw an error or return tokens\\n\\treturn parseOnly ?\\n\\t\\tsoFar.length :\\n\\t\\tsoFar ?\\n\\t\\t\\tSizzle.error( selector ) :\\n\\t\\t\\t// Cache the tokens\\n\\t\\t\\ttokenCache( selector, groups ).slice( 0 );\\n};\\n\\nfunction toSelector( tokens ) {\\n\\tvar i = 0,\\n\\t\\tlen = tokens.length,\\n\\t\\tselector = \\\"\\\";\\n\\tfor ( ; i < len; i++ ) {\\n\\t\\tselector += tokens[i].value;\\n\\t}\\n\\treturn selector;\\n}\\n\\nfunction addCombinator( matcher, combinator, base ) {\\n\\tvar dir = combinator.dir,\\n\\t\\tskip = combinator.next,\\n\\t\\tkey = skip || dir,\\n\\t\\tcheckNonElements = base && key === \\\"parentNode\\\",\\n\\t\\tdoneName = done++;\\n\\n\\treturn combinator.first ?\\n\\t\\t// Check against closest ancestor/preceding element\\n\\t\\tfunction( elem, context, xml ) {\\n\\t\\t\\twhile ( (elem = elem[ dir ]) ) {\\n\\t\\t\\t\\tif ( elem.nodeType === 1 || checkNonElements ) {\\n\\t\\t\\t\\t\\treturn matcher( elem, context, xml );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn false;\\n\\t\\t} :\\n\\n\\t\\t// Check against all ancestor/preceding elements\\n\\t\\tfunction( elem, context, xml ) {\\n\\t\\t\\tvar oldCache, uniqueCache, outerCache,\\n\\t\\t\\t\\tnewCache = [ dirruns, doneName ];\\n\\n\\t\\t\\t// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching\\n\\t\\t\\tif ( xml ) {\\n\\t\\t\\t\\twhile ( (elem = elem[ dir ]) ) {\\n\\t\\t\\t\\t\\tif ( elem.nodeType === 1 || checkNonElements ) {\\n\\t\\t\\t\\t\\t\\tif ( matcher( elem, context, xml ) ) {\\n\\t\\t\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\twhile ( (elem = elem[ dir ]) ) {\\n\\t\\t\\t\\t\\tif ( elem.nodeType === 1 || checkNonElements ) {\\n\\t\\t\\t\\t\\t\\touterCache = elem[ expando ] || (elem[ expando ] = {});\\n\\n\\t\\t\\t\\t\\t\\t// Support: IE <9 only\\n\\t\\t\\t\\t\\t\\t// Defend against cloned attroperties (jQuery gh-1709)\\n\\t\\t\\t\\t\\t\\tuniqueCache = outerCache[ elem.uniqueID ] || (outerCache[ elem.uniqueID ] = {});\\n\\n\\t\\t\\t\\t\\t\\tif ( skip && skip === elem.nodeName.toLowerCase() ) {\\n\\t\\t\\t\\t\\t\\t\\telem = elem[ dir ] || elem;\\n\\t\\t\\t\\t\\t\\t} else if ( (oldCache = uniqueCache[ key ]) &&\\n\\t\\t\\t\\t\\t\\t\\toldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t// Assign to newCache so results back-propagate to previous elements\\n\\t\\t\\t\\t\\t\\t\\treturn (newCache[ 2 ] = oldCache[ 2 ]);\\n\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\t// Reuse newcache so results back-propagate to previous elements\\n\\t\\t\\t\\t\\t\\t\\tuniqueCache[ key ] = newCache;\\n\\n\\t\\t\\t\\t\\t\\t\\t// A match means we're done; a fail means we have to keep checking\\n\\t\\t\\t\\t\\t\\t\\tif ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {\\n\\t\\t\\t\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn false;\\n\\t\\t};\\n}\\n\\nfunction elementMatcher( matchers ) {\\n\\treturn matchers.length > 1 ?\\n\\t\\tfunction( elem, context, xml ) {\\n\\t\\t\\tvar i = matchers.length;\\n\\t\\t\\twhile ( i-- ) {\\n\\t\\t\\t\\tif ( !matchers[i]( elem, context, xml ) ) {\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn true;\\n\\t\\t} :\\n\\t\\tmatchers[0];\\n}\\n\\nfunction multipleContexts( selector, contexts, results ) {\\n\\tvar i = 0,\\n\\t\\tlen = contexts.length;\\n\\tfor ( ; i < len; i++ ) {\\n\\t\\tSizzle( selector, contexts[i], results );\\n\\t}\\n\\treturn results;\\n}\\n\\nfunction condense( unmatched, map, filter, context, xml ) {\\n\\tvar elem,\\n\\t\\tnewUnmatched = [],\\n\\t\\ti = 0,\\n\\t\\tlen = unmatched.length,\\n\\t\\tmapped = map != null;\\n\\n\\tfor ( ; i < len; i++ ) {\\n\\t\\tif ( (elem = unmatched[i]) ) {\\n\\t\\t\\tif ( !filter || filter( elem, context, xml ) ) {\\n\\t\\t\\t\\tnewUnmatched.push( elem );\\n\\t\\t\\t\\tif ( mapped ) {\\n\\t\\t\\t\\t\\tmap.push( i );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn newUnmatched;\\n}\\n\\nfunction setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {\\n\\tif ( postFilter && !postFilter[ expando ] ) {\\n\\t\\tpostFilter = setMatcher( postFilter );\\n\\t}\\n\\tif ( postFinder && !postFinder[ expando ] ) {\\n\\t\\tpostFinder = setMatcher( postFinder, postSelector );\\n\\t}\\n\\treturn markFunction(function( seed, results, context, xml ) {\\n\\t\\tvar temp, i, elem,\\n\\t\\t\\tpreMap = [],\\n\\t\\t\\tpostMap = [],\\n\\t\\t\\tpreexisting = results.length,\\n\\n\\t\\t\\t// Get initial elements from seed or context\\n\\t\\t\\telems = seed || multipleContexts( selector || \\\"*\\\", context.nodeType ? [ context ] : context, [] ),\\n\\n\\t\\t\\t// Prefilter to get matcher input, preserving a map for seed-results synchronization\\n\\t\\t\\tmatcherIn = preFilter && ( seed || !selector ) ?\\n\\t\\t\\t\\tcondense( elems, preMap, preFilter, context, xml ) :\\n\\t\\t\\t\\telems,\\n\\n\\t\\t\\tmatcherOut = matcher ?\\n\\t\\t\\t\\t// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,\\n\\t\\t\\t\\tpostFinder || ( seed ? preFilter : preexisting || postFilter ) ?\\n\\n\\t\\t\\t\\t\\t// ...intermediate processing is necessary\\n\\t\\t\\t\\t\\t[] :\\n\\n\\t\\t\\t\\t\\t// ...otherwise use results directly\\n\\t\\t\\t\\t\\tresults :\\n\\t\\t\\t\\tmatcherIn;\\n\\n\\t\\t// Find primary matches\\n\\t\\tif ( matcher ) {\\n\\t\\t\\tmatcher( matcherIn, matcherOut, context, xml );\\n\\t\\t}\\n\\n\\t\\t// Apply postFilter\\n\\t\\tif ( postFilter ) {\\n\\t\\t\\ttemp = condense( matcherOut, postMap );\\n\\t\\t\\tpostFilter( temp, [], context, xml );\\n\\n\\t\\t\\t// Un-match failing elements by moving them back to matcherIn\\n\\t\\t\\ti = temp.length;\\n\\t\\t\\twhile ( i-- ) {\\n\\t\\t\\t\\tif ( (elem = temp[i]) ) {\\n\\t\\t\\t\\t\\tmatcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif ( seed ) {\\n\\t\\t\\tif ( postFinder || preFilter ) {\\n\\t\\t\\t\\tif ( postFinder ) {\\n\\t\\t\\t\\t\\t// Get the final matcherOut by condensing this intermediate into postFinder contexts\\n\\t\\t\\t\\t\\ttemp = [];\\n\\t\\t\\t\\t\\ti = matcherOut.length;\\n\\t\\t\\t\\t\\twhile ( i-- ) {\\n\\t\\t\\t\\t\\t\\tif ( (elem = matcherOut[i]) ) {\\n\\t\\t\\t\\t\\t\\t\\t// Restore matcherIn since elem is not yet a final match\\n\\t\\t\\t\\t\\t\\t\\ttemp.push( (matcherIn[i] = elem) );\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tpostFinder( null, (matcherOut = []), temp, xml );\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Move matched elements from seed to results to keep them synchronized\\n\\t\\t\\t\\ti = matcherOut.length;\\n\\t\\t\\t\\twhile ( i-- ) {\\n\\t\\t\\t\\t\\tif ( (elem = matcherOut[i]) &&\\n\\t\\t\\t\\t\\t\\t(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {\\n\\n\\t\\t\\t\\t\\t\\tseed[temp] = !(results[temp] = elem);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t// Add elements to results, through postFinder if defined\\n\\t\\t} else {\\n\\t\\t\\tmatcherOut = condense(\\n\\t\\t\\t\\tmatcherOut === results ?\\n\\t\\t\\t\\t\\tmatcherOut.splice( preexisting, matcherOut.length ) :\\n\\t\\t\\t\\t\\tmatcherOut\\n\\t\\t\\t);\\n\\t\\t\\tif ( postFinder ) {\\n\\t\\t\\t\\tpostFinder( null, results, matcherOut, xml );\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tpush.apply( results, matcherOut );\\n\\t\\t\\t}\\n\\t\\t}\\n\\t});\\n}\\n\\nfunction matcherFromTokens( tokens ) {\\n\\tvar checkContext, matcher, j,\\n\\t\\tlen = tokens.length,\\n\\t\\tleadingRelative = Expr.relative[ tokens[0].type ],\\n\\t\\timplicitRelative = leadingRelative || Expr.relative[\\\" \\\"],\\n\\t\\ti = leadingRelative ? 1 : 0,\\n\\n\\t\\t// The foundational matcher ensures that elements are reachable from top-level context(s)\\n\\t\\tmatchContext = addCombinator( function( elem ) {\\n\\t\\t\\treturn elem === checkContext;\\n\\t\\t}, implicitRelative, true ),\\n\\t\\tmatchAnyContext = addCombinator( function( elem ) {\\n\\t\\t\\treturn indexOf( checkContext, elem ) > -1;\\n\\t\\t}, implicitRelative, true ),\\n\\t\\tmatchers = [ function( elem, context, xml ) {\\n\\t\\t\\tvar ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (\\n\\t\\t\\t\\t(checkContext = context).nodeType ?\\n\\t\\t\\t\\t\\tmatchContext( elem, context, xml ) :\\n\\t\\t\\t\\t\\tmatchAnyContext( elem, context, xml ) );\\n\\t\\t\\t// Avoid hanging onto element (issue #299)\\n\\t\\t\\tcheckContext = null;\\n\\t\\t\\treturn ret;\\n\\t\\t} ];\\n\\n\\tfor ( ; i < len; i++ ) {\\n\\t\\tif ( (matcher = Expr.relative[ tokens[i].type ]) ) {\\n\\t\\t\\tmatchers = [ addCombinator(elementMatcher( matchers ), matcher) ];\\n\\t\\t} else {\\n\\t\\t\\tmatcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );\\n\\n\\t\\t\\t// Return special upon seeing a positional matcher\\n\\t\\t\\tif ( matcher[ expando ] ) {\\n\\t\\t\\t\\t// Find the next relative operator (if any) for proper handling\\n\\t\\t\\t\\tj = ++i;\\n\\t\\t\\t\\tfor ( ; j < len; j++ ) {\\n\\t\\t\\t\\t\\tif ( Expr.relative[ tokens[j].type ] ) {\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn setMatcher(\\n\\t\\t\\t\\t\\ti > 1 && elementMatcher( matchers ),\\n\\t\\t\\t\\t\\ti > 1 && toSelector(\\n\\t\\t\\t\\t\\t\\t// If the preceding token was a descendant combinator, insert an implicit any-element `*`\\n\\t\\t\\t\\t\\t\\ttokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === \\\" \\\" ? \\\"*\\\" : \\\"\\\" })\\n\\t\\t\\t\\t\\t).replace( rtrim, \\\"$1\\\" ),\\n\\t\\t\\t\\t\\tmatcher,\\n\\t\\t\\t\\t\\ti < j && matcherFromTokens( tokens.slice( i, j ) ),\\n\\t\\t\\t\\t\\tj < len && matcherFromTokens( (tokens = tokens.slice( j )) ),\\n\\t\\t\\t\\t\\tj < len && toSelector( tokens )\\n\\t\\t\\t\\t);\\n\\t\\t\\t}\\n\\t\\t\\tmatchers.push( matcher );\\n\\t\\t}\\n\\t}\\n\\n\\treturn elementMatcher( matchers );\\n}\\n\\nfunction matcherFromGroupMatchers( elementMatchers, setMatchers ) {\\n\\tvar bySet = setMatchers.length > 0,\\n\\t\\tbyElement = elementMatchers.length > 0,\\n\\t\\tsuperMatcher = function( seed, context, xml, results, outermost ) {\\n\\t\\t\\tvar elem, j, matcher,\\n\\t\\t\\t\\tmatchedCount = 0,\\n\\t\\t\\t\\ti = \\\"0\\\",\\n\\t\\t\\t\\tunmatched = seed && [],\\n\\t\\t\\t\\tsetMatched = [],\\n\\t\\t\\t\\tcontextBackup = outermostContext,\\n\\t\\t\\t\\t// We must always have either seed elements or outermost context\\n\\t\\t\\t\\telems = seed || byElement && Expr.find[\\\"TAG\\\"]( \\\"*\\\", outermost ),\\n\\t\\t\\t\\t// Use integer dirruns iff this is the outermost matcher\\n\\t\\t\\t\\tdirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),\\n\\t\\t\\t\\tlen = elems.length;\\n\\n\\t\\t\\tif ( outermost ) {\\n\\t\\t\\t\\toutermostContext = context === document || context || outermost;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Add elements passing elementMatchers directly to results\\n\\t\\t\\t// Support: IE<9, Safari\\n\\t\\t\\t// Tolerate NodeList properties (IE: \\\"length\\\"; Safari: <number>) matching elements by id\\n\\t\\t\\tfor ( ; i !== len && (elem = elems[i]) != null; i++ ) {\\n\\t\\t\\t\\tif ( byElement && elem ) {\\n\\t\\t\\t\\t\\tj = 0;\\n\\t\\t\\t\\t\\tif ( !context && elem.ownerDocument !== document ) {\\n\\t\\t\\t\\t\\t\\tsetDocument( elem );\\n\\t\\t\\t\\t\\t\\txml = !documentIsHTML;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\twhile ( (matcher = elementMatchers[j++]) ) {\\n\\t\\t\\t\\t\\t\\tif ( matcher( elem, context || document, xml) ) {\\n\\t\\t\\t\\t\\t\\t\\tresults.push( elem );\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif ( outermost ) {\\n\\t\\t\\t\\t\\t\\tdirruns = dirrunsUnique;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Track unmatched elements for set filters\\n\\t\\t\\t\\tif ( bySet ) {\\n\\t\\t\\t\\t\\t// They will have gone through all possible matchers\\n\\t\\t\\t\\t\\tif ( (elem = !matcher && elem) ) {\\n\\t\\t\\t\\t\\t\\tmatchedCount--;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t// Lengthen the array for every element, matched or not\\n\\t\\t\\t\\t\\tif ( seed ) {\\n\\t\\t\\t\\t\\t\\tunmatched.push( elem );\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\t// `i` is now the count of elements visited above, and adding it to `matchedCount`\\n\\t\\t\\t// makes the latter nonnegative.\\n\\t\\t\\tmatchedCount += i;\\n\\n\\t\\t\\t// Apply set filters to unmatched elements\\n\\t\\t\\t// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`\\n\\t\\t\\t// equals `i`), unless we didn't visit _any_ elements in the above loop because we have\\n\\t\\t\\t// no element matchers and no seed.\\n\\t\\t\\t// Incrementing an initially-string \\\"0\\\" `i` allows `i` to remain a string only in that\\n\\t\\t\\t// case, which will result in a \\\"00\\\" `matchedCount` that differs from `i` but is also\\n\\t\\t\\t// numerically zero.\\n\\t\\t\\tif ( bySet && i !== matchedCount ) {\\n\\t\\t\\t\\tj = 0;\\n\\t\\t\\t\\twhile ( (matcher = setMatchers[j++]) ) {\\n\\t\\t\\t\\t\\tmatcher( unmatched, setMatched, context, xml );\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( seed ) {\\n\\t\\t\\t\\t\\t// Reintegrate element matches to eliminate the need for sorting\\n\\t\\t\\t\\t\\tif ( matchedCount > 0 ) {\\n\\t\\t\\t\\t\\t\\twhile ( i-- ) {\\n\\t\\t\\t\\t\\t\\t\\tif ( !(unmatched[i] || setMatched[i]) ) {\\n\\t\\t\\t\\t\\t\\t\\t\\tsetMatched[i] = pop.call( results );\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t// Discard index placeholder values to get only actual matches\\n\\t\\t\\t\\t\\tsetMatched = condense( setMatched );\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Add matches to results\\n\\t\\t\\t\\tpush.apply( results, setMatched );\\n\\n\\t\\t\\t\\t// Seedless set matches succeeding multiple successful matchers stipulate sorting\\n\\t\\t\\t\\tif ( outermost && !seed && setMatched.length > 0 &&\\n\\t\\t\\t\\t\\t( matchedCount + setMatchers.length ) > 1 ) {\\n\\n\\t\\t\\t\\t\\tSizzle.uniqueSort( results );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Override manipulation of globals by nested matchers\\n\\t\\t\\tif ( outermost ) {\\n\\t\\t\\t\\tdirruns = dirrunsUnique;\\n\\t\\t\\t\\toutermostContext = contextBackup;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn unmatched;\\n\\t\\t};\\n\\n\\treturn bySet ?\\n\\t\\tmarkFunction( superMatcher ) :\\n\\t\\tsuperMatcher;\\n}\\n\\ncompile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {\\n\\tvar i,\\n\\t\\tsetMatchers = [],\\n\\t\\telementMatchers = [],\\n\\t\\tcached = compilerCache[ selector + \\\" \\\" ];\\n\\n\\tif ( !cached ) {\\n\\t\\t// Generate a function of recursive functions that can be used to check each element\\n\\t\\tif ( !match ) {\\n\\t\\t\\tmatch = tokenize( selector );\\n\\t\\t}\\n\\t\\ti = match.length;\\n\\t\\twhile ( i-- ) {\\n\\t\\t\\tcached = matcherFromTokens( match[i] );\\n\\t\\t\\tif ( cached[ expando ] ) {\\n\\t\\t\\t\\tsetMatchers.push( cached );\\n\\t\\t\\t} else {\\n\\t\\t\\t\\telementMatchers.push( cached );\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// Cache the compiled function\\n\\t\\tcached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );\\n\\n\\t\\t// Save selector and tokenization\\n\\t\\tcached.selector = selector;\\n\\t}\\n\\treturn cached;\\n};\\n\\n/**\\n * A low-level selection function that works with Sizzle's compiled\\n *  selector functions\\n * @param {String|Function} selector A selector or a pre-compiled\\n *  selector function built with Sizzle.compile\\n * @param {Element} context\\n * @param {Array} [results]\\n * @param {Array} [seed] A set of elements to match against\\n */\\nselect = Sizzle.select = function( selector, context, results, seed ) {\\n\\tvar i, tokens, token, type, find,\\n\\t\\tcompiled = typeof selector === \\\"function\\\" && selector,\\n\\t\\tmatch = !seed && tokenize( (selector = compiled.selector || selector) );\\n\\n\\tresults = results || [];\\n\\n\\t// Try to minimize operations if there is only one selector in the list and no seed\\n\\t// (the latter of which guarantees us context)\\n\\tif ( match.length === 1 ) {\\n\\n\\t\\t// Reduce context if the leading compound selector is an ID\\n\\t\\ttokens = match[0] = match[0].slice( 0 );\\n\\t\\tif ( tokens.length > 2 && (token = tokens[0]).type === \\\"ID\\\" &&\\n\\t\\t\\t\\tcontext.nodeType === 9 && documentIsHTML && Expr.relative[ tokens[1].type ] ) {\\n\\n\\t\\t\\tcontext = ( Expr.find[\\\"ID\\\"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];\\n\\t\\t\\tif ( !context ) {\\n\\t\\t\\t\\treturn results;\\n\\n\\t\\t\\t// Precompiled matchers will still verify ancestry, so step up a level\\n\\t\\t\\t} else if ( compiled ) {\\n\\t\\t\\t\\tcontext = context.parentNode;\\n\\t\\t\\t}\\n\\n\\t\\t\\tselector = selector.slice( tokens.shift().value.length );\\n\\t\\t}\\n\\n\\t\\t// Fetch a seed set for right-to-left matching\\n\\t\\ti = matchExpr[\\\"needsContext\\\"].test( selector ) ? 0 : tokens.length;\\n\\t\\twhile ( i-- ) {\\n\\t\\t\\ttoken = tokens[i];\\n\\n\\t\\t\\t// Abort if we hit a combinator\\n\\t\\t\\tif ( Expr.relative[ (type = token.type) ] ) {\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\tif ( (find = Expr.find[ type ]) ) {\\n\\t\\t\\t\\t// Search, expanding context for leading sibling combinators\\n\\t\\t\\t\\tif ( (seed = find(\\n\\t\\t\\t\\t\\ttoken.matches[0].replace( runescape, funescape ),\\n\\t\\t\\t\\t\\trsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context\\n\\t\\t\\t\\t)) ) {\\n\\n\\t\\t\\t\\t\\t// If seed is empty or no tokens remain, we can return early\\n\\t\\t\\t\\t\\ttokens.splice( i, 1 );\\n\\t\\t\\t\\t\\tselector = seed.length && toSelector( tokens );\\n\\t\\t\\t\\t\\tif ( !selector ) {\\n\\t\\t\\t\\t\\t\\tpush.apply( results, seed );\\n\\t\\t\\t\\t\\t\\treturn results;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t// Compile and execute a filtering function if one is not provided\\n\\t// Provide `match` to avoid retokenization if we modified the selector above\\n\\t( compiled || compile( selector, match ) )(\\n\\t\\tseed,\\n\\t\\tcontext,\\n\\t\\t!documentIsHTML,\\n\\t\\tresults,\\n\\t\\t!context || rsibling.test( selector ) && testContext( context.parentNode ) || context\\n\\t);\\n\\treturn results;\\n};\\n\\n// One-time assignments\\n\\n// Sort stability\\nsupport.sortStable = expando.split(\\\"\\\").sort( sortOrder ).join(\\\"\\\") === expando;\\n\\n// Support: Chrome 14-35+\\n// Always assume duplicates if they aren't passed to the comparison function\\nsupport.detectDuplicates = !!hasDuplicate;\\n\\n// Initialize against the default document\\nsetDocument();\\n\\n// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)\\n// Detached nodes confoundingly follow *each other*\\nsupport.sortDetached = assert(function( el ) {\\n\\t// Should return 1, but returns 4 (following)\\n\\treturn el.compareDocumentPosition( document.createElement(\\\"fieldset\\\") ) & 1;\\n});\\n\\n// Support: IE<8\\n// Prevent attribute/property \\\"interpolation\\\"\\n// https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx\\nif ( !assert(function( el ) {\\n\\tel.innerHTML = \\\"<a href='#'></a>\\\";\\n\\treturn el.firstChild.getAttribute(\\\"href\\\") === \\\"#\\\" ;\\n}) ) {\\n\\taddHandle( \\\"type|href|height|width\\\", function( elem, name, isXML ) {\\n\\t\\tif ( !isXML ) {\\n\\t\\t\\treturn elem.getAttribute( name, name.toLowerCase() === \\\"type\\\" ? 1 : 2 );\\n\\t\\t}\\n\\t});\\n}\\n\\n// Support: IE<9\\n// Use defaultValue in place of getAttribute(\\\"value\\\")\\nif ( !support.attributes || !assert(function( el ) {\\n\\tel.innerHTML = \\\"<input/>\\\";\\n\\tel.firstChild.setAttribute( \\\"value\\\", \\\"\\\" );\\n\\treturn el.firstChild.getAttribute( \\\"value\\\" ) === \\\"\\\";\\n}) ) {\\n\\taddHandle( \\\"value\\\", function( elem, name, isXML ) {\\n\\t\\tif ( !isXML && elem.nodeName.toLowerCase() === \\\"input\\\" ) {\\n\\t\\t\\treturn elem.defaultValue;\\n\\t\\t}\\n\\t});\\n}\\n\\n// Support: IE<9\\n// Use getAttributeNode to fetch booleans when getAttribute lies\\nif ( !assert(function( el ) {\\n\\treturn el.getAttribute(\\\"disabled\\\") == null;\\n}) ) {\\n\\taddHandle( booleans, function( elem, name, isXML ) {\\n\\t\\tvar val;\\n\\t\\tif ( !isXML ) {\\n\\t\\t\\treturn elem[ name ] === true ? name.toLowerCase() :\\n\\t\\t\\t\\t\\t(val = elem.getAttributeNode( name )) && val.specified ?\\n\\t\\t\\t\\t\\tval.value :\\n\\t\\t\\t\\tnull;\\n\\t\\t}\\n\\t});\\n}\\n\\nreturn Sizzle;\\n\\n})( window );\\n\\n\\n\\njQuery.find = Sizzle;\\njQuery.expr = Sizzle.selectors;\\n\\n// Deprecated\\njQuery.expr[ \\\":\\\" ] = jQuery.expr.pseudos;\\njQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;\\njQuery.text = Sizzle.getText;\\njQuery.isXMLDoc = Sizzle.isXML;\\njQuery.contains = Sizzle.contains;\\njQuery.escapeSelector = Sizzle.escape;\\n\\n\\n\\n\\nvar dir = function( elem, dir, until ) {\\n\\tvar matched = [],\\n\\t\\ttruncate = until !== undefined;\\n\\n\\twhile ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {\\n\\t\\tif ( elem.nodeType === 1 ) {\\n\\t\\t\\tif ( truncate && jQuery( elem ).is( until ) ) {\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\tmatched.push( elem );\\n\\t\\t}\\n\\t}\\n\\treturn matched;\\n};\\n\\n\\nvar siblings = function( n, elem ) {\\n\\tvar matched = [];\\n\\n\\tfor ( ; n; n = n.nextSibling ) {\\n\\t\\tif ( n.nodeType === 1 && n !== elem ) {\\n\\t\\t\\tmatched.push( n );\\n\\t\\t}\\n\\t}\\n\\n\\treturn matched;\\n};\\n\\n\\nvar rneedsContext = jQuery.expr.match.needsContext;\\n\\n\\n\\nfunction nodeName( elem, name ) {\\n\\n  return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();\\n\\n};\\nvar rsingleTag = ( /^<([a-z][^\\\\/\\\\0>:\\\\x20\\\\t\\\\r\\\\n\\\\f]*)[\\\\x20\\\\t\\\\r\\\\n\\\\f]*\\\\/?>(?:<\\\\/\\\\1>|)$/i );\\n\\n\\n\\n// Implement the identical functionality for filter and not\\nfunction winnow( elements, qualifier, not ) {\\n\\tif ( isFunction( qualifier ) ) {\\n\\t\\treturn jQuery.grep( elements, function( elem, i ) {\\n\\t\\t\\treturn !!qualifier.call( elem, i, elem ) !== not;\\n\\t\\t} );\\n\\t}\\n\\n\\t// Single element\\n\\tif ( qualifier.nodeType ) {\\n\\t\\treturn jQuery.grep( elements, function( elem ) {\\n\\t\\t\\treturn ( elem === qualifier ) !== not;\\n\\t\\t} );\\n\\t}\\n\\n\\t// Arraylike of elements (jQuery, arguments, Array)\\n\\tif ( typeof qualifier !== \\\"string\\\" ) {\\n\\t\\treturn jQuery.grep( elements, function( elem ) {\\n\\t\\t\\treturn ( indexOf.call( qualifier, elem ) > -1 ) !== not;\\n\\t\\t} );\\n\\t}\\n\\n\\t// Filtered directly for both simple and complex selectors\\n\\treturn jQuery.filter( qualifier, elements, not );\\n}\\n\\njQuery.filter = function( expr, elems, not ) {\\n\\tvar elem = elems[ 0 ];\\n\\n\\tif ( not ) {\\n\\t\\texpr = \\\":not(\\\" + expr + \\\")\\\";\\n\\t}\\n\\n\\tif ( elems.length === 1 && elem.nodeType === 1 ) {\\n\\t\\treturn jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [];\\n\\t}\\n\\n\\treturn jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {\\n\\t\\treturn elem.nodeType === 1;\\n\\t} ) );\\n};\\n\\njQuery.fn.extend( {\\n\\tfind: function( selector ) {\\n\\t\\tvar i, ret,\\n\\t\\t\\tlen = this.length,\\n\\t\\t\\tself = this;\\n\\n\\t\\tif ( typeof selector !== \\\"string\\\" ) {\\n\\t\\t\\treturn this.pushStack( jQuery( selector ).filter( function() {\\n\\t\\t\\t\\tfor ( i = 0; i < len; i++ ) {\\n\\t\\t\\t\\t\\tif ( jQuery.contains( self[ i ], this ) ) {\\n\\t\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t} ) );\\n\\t\\t}\\n\\n\\t\\tret = this.pushStack( [] );\\n\\n\\t\\tfor ( i = 0; i < len; i++ ) {\\n\\t\\t\\tjQuery.find( selector, self[ i ], ret );\\n\\t\\t}\\n\\n\\t\\treturn len > 1 ? jQuery.uniqueSort( ret ) : ret;\\n\\t},\\n\\tfilter: function( selector ) {\\n\\t\\treturn this.pushStack( winnow( this, selector || [], false ) );\\n\\t},\\n\\tnot: function( selector ) {\\n\\t\\treturn this.pushStack( winnow( this, selector || [], true ) );\\n\\t},\\n\\tis: function( selector ) {\\n\\t\\treturn !!winnow(\\n\\t\\t\\tthis,\\n\\n\\t\\t\\t// If this is a positional/relative selector, check membership in the returned set\\n\\t\\t\\t// so $(\\\"p:first\\\").is(\\\"p:last\\\") won't return true for a doc with two \\\"p\\\".\\n\\t\\t\\ttypeof selector === \\\"string\\\" && rneedsContext.test( selector ) ?\\n\\t\\t\\t\\tjQuery( selector ) :\\n\\t\\t\\t\\tselector || [],\\n\\t\\t\\tfalse\\n\\t\\t).length;\\n\\t}\\n} );\\n\\n\\n// Initialize a jQuery object\\n\\n\\n// A central reference to the root jQuery(document)\\nvar rootjQuery,\\n\\n\\t// A simple way to check for HTML strings\\n\\t// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)\\n\\t// Strict HTML recognition (#11290: must start with <)\\n\\t// Shortcut simple #id case for speed\\n\\trquickExpr = /^(?:\\\\s*(<[\\\\w\\\\W]+>)[^>]*|#([\\\\w-]+))$/,\\n\\n\\tinit = jQuery.fn.init = function( selector, context, root ) {\\n\\t\\tvar match, elem;\\n\\n\\t\\t// HANDLE: $(\\\"\\\"), $(null), $(undefined), $(false)\\n\\t\\tif ( !selector ) {\\n\\t\\t\\treturn this;\\n\\t\\t}\\n\\n\\t\\t// Method init() accepts an alternate rootjQuery\\n\\t\\t// so migrate can support jQuery.sub (gh-2101)\\n\\t\\troot = root || rootjQuery;\\n\\n\\t\\t// Handle HTML strings\\n\\t\\tif ( typeof selector === \\\"string\\\" ) {\\n\\t\\t\\tif ( selector[ 0 ] === \\\"<\\\" &&\\n\\t\\t\\t\\tselector[ selector.length - 1 ] === \\\">\\\" &&\\n\\t\\t\\t\\tselector.length >= 3 ) {\\n\\n\\t\\t\\t\\t// Assume that strings that start and end with <> are HTML and skip the regex check\\n\\t\\t\\t\\tmatch = [ null, selector, null ];\\n\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tmatch = rquickExpr.exec( selector );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Match html or make sure no context is specified for #id\\n\\t\\t\\tif ( match && ( match[ 1 ] || !context ) ) {\\n\\n\\t\\t\\t\\t// HANDLE: $(html) -> $(array)\\n\\t\\t\\t\\tif ( match[ 1 ] ) {\\n\\t\\t\\t\\t\\tcontext = context instanceof jQuery ? context[ 0 ] : context;\\n\\n\\t\\t\\t\\t\\t// Option to run scripts is true for back-compat\\n\\t\\t\\t\\t\\t// Intentionally let the error be thrown if parseHTML is not present\\n\\t\\t\\t\\t\\tjQuery.merge( this, jQuery.parseHTML(\\n\\t\\t\\t\\t\\t\\tmatch[ 1 ],\\n\\t\\t\\t\\t\\t\\tcontext && context.nodeType ? context.ownerDocument || context : document,\\n\\t\\t\\t\\t\\t\\ttrue\\n\\t\\t\\t\\t\\t) );\\n\\n\\t\\t\\t\\t\\t// HANDLE: $(html, props)\\n\\t\\t\\t\\t\\tif ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {\\n\\t\\t\\t\\t\\t\\tfor ( match in context ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t// Properties of context are called as methods if possible\\n\\t\\t\\t\\t\\t\\t\\tif ( isFunction( this[ match ] ) ) {\\n\\t\\t\\t\\t\\t\\t\\t\\tthis[ match ]( context[ match ] );\\n\\n\\t\\t\\t\\t\\t\\t\\t// ...and otherwise set as attributes\\n\\t\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\t\\tthis.attr( match, context[ match ] );\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\treturn this;\\n\\n\\t\\t\\t\\t// HANDLE: $(#id)\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\telem = document.getElementById( match[ 2 ] );\\n\\n\\t\\t\\t\\t\\tif ( elem ) {\\n\\n\\t\\t\\t\\t\\t\\t// Inject the element directly into the jQuery object\\n\\t\\t\\t\\t\\t\\tthis[ 0 ] = elem;\\n\\t\\t\\t\\t\\t\\tthis.length = 1;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\treturn this;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t// HANDLE: $(expr, $(...))\\n\\t\\t\\t} else if ( !context || context.jquery ) {\\n\\t\\t\\t\\treturn ( context || root ).find( selector );\\n\\n\\t\\t\\t// HANDLE: $(expr, context)\\n\\t\\t\\t// (which is just equivalent to: $(context).find(expr)\\n\\t\\t\\t} else {\\n\\t\\t\\t\\treturn this.constructor( context ).find( selector );\\n\\t\\t\\t}\\n\\n\\t\\t// HANDLE: $(DOMElement)\\n\\t\\t} else if ( selector.nodeType ) {\\n\\t\\t\\tthis[ 0 ] = selector;\\n\\t\\t\\tthis.length = 1;\\n\\t\\t\\treturn this;\\n\\n\\t\\t// HANDLE: $(function)\\n\\t\\t// Shortcut for document ready\\n\\t\\t} else if ( isFunction( selector ) ) {\\n\\t\\t\\treturn root.ready !== undefined ?\\n\\t\\t\\t\\troot.ready( selector ) :\\n\\n\\t\\t\\t\\t// Execute immediately if ready is not present\\n\\t\\t\\t\\tselector( jQuery );\\n\\t\\t}\\n\\n\\t\\treturn jQuery.makeArray( selector, this );\\n\\t};\\n\\n// Give the init function the jQuery prototype for later instantiation\\ninit.prototype = jQuery.fn;\\n\\n// Initialize central reference\\nrootjQuery = jQuery( document );\\n\\n\\nvar rparentsprev = /^(?:parents|prev(?:Until|All))/,\\n\\n\\t// Methods guaranteed to produce a unique set when starting from a unique set\\n\\tguaranteedUnique = {\\n\\t\\tchildren: true,\\n\\t\\tcontents: true,\\n\\t\\tnext: true,\\n\\t\\tprev: true\\n\\t};\\n\\njQuery.fn.extend( {\\n\\thas: function( target ) {\\n\\t\\tvar targets = jQuery( target, this ),\\n\\t\\t\\tl = targets.length;\\n\\n\\t\\treturn this.filter( function() {\\n\\t\\t\\tvar i = 0;\\n\\t\\t\\tfor ( ; i < l; i++ ) {\\n\\t\\t\\t\\tif ( jQuery.contains( this, targets[ i ] ) ) {\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t} );\\n\\t},\\n\\n\\tclosest: function( selectors, context ) {\\n\\t\\tvar cur,\\n\\t\\t\\ti = 0,\\n\\t\\t\\tl = this.length,\\n\\t\\t\\tmatched = [],\\n\\t\\t\\ttargets = typeof selectors !== \\\"string\\\" && jQuery( selectors );\\n\\n\\t\\t// Positional selectors never match, since there's no _selection_ context\\n\\t\\tif ( !rneedsContext.test( selectors ) ) {\\n\\t\\t\\tfor ( ; i < l; i++ ) {\\n\\t\\t\\t\\tfor ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {\\n\\n\\t\\t\\t\\t\\t// Always skip document fragments\\n\\t\\t\\t\\t\\tif ( cur.nodeType < 11 && ( targets ?\\n\\t\\t\\t\\t\\t\\ttargets.index( cur ) > -1 :\\n\\n\\t\\t\\t\\t\\t\\t// Don't pass non-elements to Sizzle\\n\\t\\t\\t\\t\\t\\tcur.nodeType === 1 &&\\n\\t\\t\\t\\t\\t\\t\\tjQuery.find.matchesSelector( cur, selectors ) ) ) {\\n\\n\\t\\t\\t\\t\\t\\tmatched.push( cur );\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );\\n\\t},\\n\\n\\t// Determine the position of an element within the set\\n\\tindex: function( elem ) {\\n\\n\\t\\t// No argument, return index in parent\\n\\t\\tif ( !elem ) {\\n\\t\\t\\treturn ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;\\n\\t\\t}\\n\\n\\t\\t// Index in selector\\n\\t\\tif ( typeof elem === \\\"string\\\" ) {\\n\\t\\t\\treturn indexOf.call( jQuery( elem ), this[ 0 ] );\\n\\t\\t}\\n\\n\\t\\t// Locate the position of the desired element\\n\\t\\treturn indexOf.call( this,\\n\\n\\t\\t\\t// If it receives a jQuery object, the first element is used\\n\\t\\t\\telem.jquery ? elem[ 0 ] : elem\\n\\t\\t);\\n\\t},\\n\\n\\tadd: function( selector, context ) {\\n\\t\\treturn this.pushStack(\\n\\t\\t\\tjQuery.uniqueSort(\\n\\t\\t\\t\\tjQuery.merge( this.get(), jQuery( selector, context ) )\\n\\t\\t\\t)\\n\\t\\t);\\n\\t},\\n\\n\\taddBack: function( selector ) {\\n\\t\\treturn this.add( selector == null ?\\n\\t\\t\\tthis.prevObject : this.prevObject.filter( selector )\\n\\t\\t);\\n\\t}\\n} );\\n\\nfunction sibling( cur, dir ) {\\n\\twhile ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}\\n\\treturn cur;\\n}\\n\\njQuery.each( {\\n\\tparent: function( elem ) {\\n\\t\\tvar parent = elem.parentNode;\\n\\t\\treturn parent && parent.nodeType !== 11 ? parent : null;\\n\\t},\\n\\tparents: function( elem ) {\\n\\t\\treturn dir( elem, \\\"parentNode\\\" );\\n\\t},\\n\\tparentsUntil: function( elem, i, until ) {\\n\\t\\treturn dir( elem, \\\"parentNode\\\", until );\\n\\t},\\n\\tnext: function( elem ) {\\n\\t\\treturn sibling( elem, \\\"nextSibling\\\" );\\n\\t},\\n\\tprev: function( elem ) {\\n\\t\\treturn sibling( elem, \\\"previousSibling\\\" );\\n\\t},\\n\\tnextAll: function( elem ) {\\n\\t\\treturn dir( elem, \\\"nextSibling\\\" );\\n\\t},\\n\\tprevAll: function( elem ) {\\n\\t\\treturn dir( elem, \\\"previousSibling\\\" );\\n\\t},\\n\\tnextUntil: function( elem, i, until ) {\\n\\t\\treturn dir( elem, \\\"nextSibling\\\", until );\\n\\t},\\n\\tprevUntil: function( elem, i, until ) {\\n\\t\\treturn dir( elem, \\\"previousSibling\\\", until );\\n\\t},\\n\\tsiblings: function( elem ) {\\n\\t\\treturn siblings( ( elem.parentNode || {} ).firstChild, elem );\\n\\t},\\n\\tchildren: function( elem ) {\\n\\t\\treturn siblings( elem.firstChild );\\n\\t},\\n\\tcontents: function( elem ) {\\n        if ( nodeName( elem, \\\"iframe\\\" ) ) {\\n            return elem.contentDocument;\\n        }\\n\\n        // Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only\\n        // Treat the template element as a regular one in browsers that\\n        // don't support it.\\n        if ( nodeName( elem, \\\"template\\\" ) ) {\\n            elem = elem.content || elem;\\n        }\\n\\n        return jQuery.merge( [], elem.childNodes );\\n\\t}\\n}, function( name, fn ) {\\n\\tjQuery.fn[ name ] = function( until, selector ) {\\n\\t\\tvar matched = jQuery.map( this, fn, until );\\n\\n\\t\\tif ( name.slice( -5 ) !== \\\"Until\\\" ) {\\n\\t\\t\\tselector = until;\\n\\t\\t}\\n\\n\\t\\tif ( selector && typeof selector === \\\"string\\\" ) {\\n\\t\\t\\tmatched = jQuery.filter( selector, matched );\\n\\t\\t}\\n\\n\\t\\tif ( this.length > 1 ) {\\n\\n\\t\\t\\t// Remove duplicates\\n\\t\\t\\tif ( !guaranteedUnique[ name ] ) {\\n\\t\\t\\t\\tjQuery.uniqueSort( matched );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Reverse order for parents* and prev-derivatives\\n\\t\\t\\tif ( rparentsprev.test( name ) ) {\\n\\t\\t\\t\\tmatched.reverse();\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn this.pushStack( matched );\\n\\t};\\n} );\\nvar rnothtmlwhite = ( /[^\\\\x20\\\\t\\\\r\\\\n\\\\f]+/g );\\n\\n\\n\\n// Convert String-formatted options into Object-formatted ones\\nfunction createOptions( options ) {\\n\\tvar object = {};\\n\\tjQuery.each( options.match( rnothtmlwhite ) || [], function( _, flag ) {\\n\\t\\tobject[ flag ] = true;\\n\\t} );\\n\\treturn object;\\n}\\n\\n/*\\n * Create a callback list using the following parameters:\\n *\\n *\\toptions: an optional list of space-separated options that will change how\\n *\\t\\t\\tthe callback list behaves or a more traditional option object\\n *\\n * By default a callback list will act like an event callback list and can be\\n * \\\"fired\\\" multiple times.\\n *\\n * Possible options:\\n *\\n *\\tonce:\\t\\t\\twill ensure the callback list can only be fired once (like a Deferred)\\n *\\n *\\tmemory:\\t\\t\\twill keep track of previous values and will call any callback added\\n *\\t\\t\\t\\t\\tafter the list has been fired right away with the latest \\\"memorized\\\"\\n *\\t\\t\\t\\t\\tvalues (like a Deferred)\\n *\\n *\\tunique:\\t\\t\\twill ensure a callback can only be added once (no duplicate in the list)\\n *\\n *\\tstopOnFalse:\\tinterrupt callings when a callback returns false\\n *\\n */\\njQuery.Callbacks = function( options ) {\\n\\n\\t// Convert options from String-formatted to Object-formatted if needed\\n\\t// (we check in cache first)\\n\\toptions = typeof options === \\\"string\\\" ?\\n\\t\\tcreateOptions( options ) :\\n\\t\\tjQuery.extend( {}, options );\\n\\n\\tvar // Flag to know if list is currently firing\\n\\t\\tfiring,\\n\\n\\t\\t// Last fire value for non-forgettable lists\\n\\t\\tmemory,\\n\\n\\t\\t// Flag to know if list was already fired\\n\\t\\tfired,\\n\\n\\t\\t// Flag to prevent firing\\n\\t\\tlocked,\\n\\n\\t\\t// Actual callback list\\n\\t\\tlist = [],\\n\\n\\t\\t// Queue of execution data for repeatable lists\\n\\t\\tqueue = [],\\n\\n\\t\\t// Index of currently firing callback (modified by add/remove as needed)\\n\\t\\tfiringIndex = -1,\\n\\n\\t\\t// Fire callbacks\\n\\t\\tfire = function() {\\n\\n\\t\\t\\t// Enforce single-firing\\n\\t\\t\\tlocked = locked || options.once;\\n\\n\\t\\t\\t// Execute callbacks for all pending executions,\\n\\t\\t\\t// respecting firingIndex overrides and runtime changes\\n\\t\\t\\tfired = firing = true;\\n\\t\\t\\tfor ( ; queue.length; firingIndex = -1 ) {\\n\\t\\t\\t\\tmemory = queue.shift();\\n\\t\\t\\t\\twhile ( ++firingIndex < list.length ) {\\n\\n\\t\\t\\t\\t\\t// Run callback and check for early termination\\n\\t\\t\\t\\t\\tif ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&\\n\\t\\t\\t\\t\\t\\toptions.stopOnFalse ) {\\n\\n\\t\\t\\t\\t\\t\\t// Jump to end and forget the data so .add doesn't re-fire\\n\\t\\t\\t\\t\\t\\tfiringIndex = list.length;\\n\\t\\t\\t\\t\\t\\tmemory = false;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Forget the data if we're done with it\\n\\t\\t\\tif ( !options.memory ) {\\n\\t\\t\\t\\tmemory = false;\\n\\t\\t\\t}\\n\\n\\t\\t\\tfiring = false;\\n\\n\\t\\t\\t// Clean up if we're done firing for good\\n\\t\\t\\tif ( locked ) {\\n\\n\\t\\t\\t\\t// Keep an empty list if we have data for future add calls\\n\\t\\t\\t\\tif ( memory ) {\\n\\t\\t\\t\\t\\tlist = [];\\n\\n\\t\\t\\t\\t// Otherwise, this object is spent\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tlist = \\\"\\\";\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t},\\n\\n\\t\\t// Actual Callbacks object\\n\\t\\tself = {\\n\\n\\t\\t\\t// Add a callback or a collection of callbacks to the list\\n\\t\\t\\tadd: function() {\\n\\t\\t\\t\\tif ( list ) {\\n\\n\\t\\t\\t\\t\\t// If we have memory from a past run, we should fire after adding\\n\\t\\t\\t\\t\\tif ( memory && !firing ) {\\n\\t\\t\\t\\t\\t\\tfiringIndex = list.length - 1;\\n\\t\\t\\t\\t\\t\\tqueue.push( memory );\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t( function add( args ) {\\n\\t\\t\\t\\t\\t\\tjQuery.each( args, function( _, arg ) {\\n\\t\\t\\t\\t\\t\\t\\tif ( isFunction( arg ) ) {\\n\\t\\t\\t\\t\\t\\t\\t\\tif ( !options.unique || !self.has( arg ) ) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tlist.push( arg );\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t} else if ( arg && arg.length && toType( arg ) !== \\\"string\\\" ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t// Inspect recursively\\n\\t\\t\\t\\t\\t\\t\\t\\tadd( arg );\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t} );\\n\\t\\t\\t\\t\\t} )( arguments );\\n\\n\\t\\t\\t\\t\\tif ( memory && !firing ) {\\n\\t\\t\\t\\t\\t\\tfire();\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn this;\\n\\t\\t\\t},\\n\\n\\t\\t\\t// Remove a callback from the list\\n\\t\\t\\tremove: function() {\\n\\t\\t\\t\\tjQuery.each( arguments, function( _, arg ) {\\n\\t\\t\\t\\t\\tvar index;\\n\\t\\t\\t\\t\\twhile ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {\\n\\t\\t\\t\\t\\t\\tlist.splice( index, 1 );\\n\\n\\t\\t\\t\\t\\t\\t// Handle firing indexes\\n\\t\\t\\t\\t\\t\\tif ( index <= firingIndex ) {\\n\\t\\t\\t\\t\\t\\t\\tfiringIndex--;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t} );\\n\\t\\t\\t\\treturn this;\\n\\t\\t\\t},\\n\\n\\t\\t\\t// Check if a given callback is in the list.\\n\\t\\t\\t// If no argument is given, return whether or not list has callbacks attached.\\n\\t\\t\\thas: function( fn ) {\\n\\t\\t\\t\\treturn fn ?\\n\\t\\t\\t\\t\\tjQuery.inArray( fn, list ) > -1 :\\n\\t\\t\\t\\t\\tlist.length > 0;\\n\\t\\t\\t},\\n\\n\\t\\t\\t// Remove all callbacks from the list\\n\\t\\t\\tempty: function() {\\n\\t\\t\\t\\tif ( list ) {\\n\\t\\t\\t\\t\\tlist = [];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn this;\\n\\t\\t\\t},\\n\\n\\t\\t\\t// Disable .fire and .add\\n\\t\\t\\t// Abort any current/pending executions\\n\\t\\t\\t// Clear all callbacks and values\\n\\t\\t\\tdisable: function() {\\n\\t\\t\\t\\tlocked = queue = [];\\n\\t\\t\\t\\tlist = memory = \\\"\\\";\\n\\t\\t\\t\\treturn this;\\n\\t\\t\\t},\\n\\t\\t\\tdisabled: function() {\\n\\t\\t\\t\\treturn !list;\\n\\t\\t\\t},\\n\\n\\t\\t\\t// Disable .fire\\n\\t\\t\\t// Also disable .add unless we have memory (since it would have no effect)\\n\\t\\t\\t// Abort any pending executions\\n\\t\\t\\tlock: function() {\\n\\t\\t\\t\\tlocked = queue = [];\\n\\t\\t\\t\\tif ( !memory && !firing ) {\\n\\t\\t\\t\\t\\tlist = memory = \\\"\\\";\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn this;\\n\\t\\t\\t},\\n\\t\\t\\tlocked: function() {\\n\\t\\t\\t\\treturn !!locked;\\n\\t\\t\\t},\\n\\n\\t\\t\\t// Call all callbacks with the given context and arguments\\n\\t\\t\\tfireWith: function( context, args ) {\\n\\t\\t\\t\\tif ( !locked ) {\\n\\t\\t\\t\\t\\targs = args || [];\\n\\t\\t\\t\\t\\targs = [ context, args.slice ? args.slice() : args ];\\n\\t\\t\\t\\t\\tqueue.push( args );\\n\\t\\t\\t\\t\\tif ( !firing ) {\\n\\t\\t\\t\\t\\t\\tfire();\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn this;\\n\\t\\t\\t},\\n\\n\\t\\t\\t// Call all the callbacks with the given arguments\\n\\t\\t\\tfire: function() {\\n\\t\\t\\t\\tself.fireWith( this, arguments );\\n\\t\\t\\t\\treturn this;\\n\\t\\t\\t},\\n\\n\\t\\t\\t// To know if the callbacks have already been called at least once\\n\\t\\t\\tfired: function() {\\n\\t\\t\\t\\treturn !!fired;\\n\\t\\t\\t}\\n\\t\\t};\\n\\n\\treturn self;\\n};\\n\\n\\nfunction Identity( v ) {\\n\\treturn v;\\n}\\nfunction Thrower( ex ) {\\n\\tthrow ex;\\n}\\n\\nfunction adoptValue( value, resolve, reject, noValue ) {\\n\\tvar method;\\n\\n\\ttry {\\n\\n\\t\\t// Check for promise aspect first to privilege synchronous behavior\\n\\t\\tif ( value && isFunction( ( method = value.promise ) ) ) {\\n\\t\\t\\tmethod.call( value ).done( resolve ).fail( reject );\\n\\n\\t\\t// Other thenables\\n\\t\\t} else if ( value && isFunction( ( method = value.then ) ) ) {\\n\\t\\t\\tmethod.call( value, resolve, reject );\\n\\n\\t\\t// Other non-thenables\\n\\t\\t} else {\\n\\n\\t\\t\\t// Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:\\n\\t\\t\\t// * false: [ value ].slice( 0 ) => resolve( value )\\n\\t\\t\\t// * true: [ value ].slice( 1 ) => resolve()\\n\\t\\t\\tresolve.apply( undefined, [ value ].slice( noValue ) );\\n\\t\\t}\\n\\n\\t// For Promises/A+, convert exceptions into rejections\\n\\t// Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in\\n\\t// Deferred#then to conditionally suppress rejection.\\n\\t} catch ( value ) {\\n\\n\\t\\t// Support: Android 4.0 only\\n\\t\\t// Strict mode functions invoked without .call/.apply get global-object context\\n\\t\\treject.apply( undefined, [ value ] );\\n\\t}\\n}\\n\\njQuery.extend( {\\n\\n\\tDeferred: function( func ) {\\n\\t\\tvar tuples = [\\n\\n\\t\\t\\t\\t// action, add listener, callbacks,\\n\\t\\t\\t\\t// ... .then handlers, argument index, [final state]\\n\\t\\t\\t\\t[ \\\"notify\\\", \\\"progress\\\", jQuery.Callbacks( \\\"memory\\\" ),\\n\\t\\t\\t\\t\\tjQuery.Callbacks( \\\"memory\\\" ), 2 ],\\n\\t\\t\\t\\t[ \\\"resolve\\\", \\\"done\\\", jQuery.Callbacks( \\\"once memory\\\" ),\\n\\t\\t\\t\\t\\tjQuery.Callbacks( \\\"once memory\\\" ), 0, \\\"resolved\\\" ],\\n\\t\\t\\t\\t[ \\\"reject\\\", \\\"fail\\\", jQuery.Callbacks( \\\"once memory\\\" ),\\n\\t\\t\\t\\t\\tjQuery.Callbacks( \\\"once memory\\\" ), 1, \\\"rejected\\\" ]\\n\\t\\t\\t],\\n\\t\\t\\tstate = \\\"pending\\\",\\n\\t\\t\\tpromise = {\\n\\t\\t\\t\\tstate: function() {\\n\\t\\t\\t\\t\\treturn state;\\n\\t\\t\\t\\t},\\n\\t\\t\\t\\talways: function() {\\n\\t\\t\\t\\t\\tdeferred.done( arguments ).fail( arguments );\\n\\t\\t\\t\\t\\treturn this;\\n\\t\\t\\t\\t},\\n\\t\\t\\t\\t\\\"catch\\\": function( fn ) {\\n\\t\\t\\t\\t\\treturn promise.then( null, fn );\\n\\t\\t\\t\\t},\\n\\n\\t\\t\\t\\t// Keep pipe for back-compat\\n\\t\\t\\t\\tpipe: function( /* fnDone, fnFail, fnProgress */ ) {\\n\\t\\t\\t\\t\\tvar fns = arguments;\\n\\n\\t\\t\\t\\t\\treturn jQuery.Deferred( function( newDefer ) {\\n\\t\\t\\t\\t\\t\\tjQuery.each( tuples, function( i, tuple ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t// Map tuples (progress, done, fail) to arguments (done, fail, progress)\\n\\t\\t\\t\\t\\t\\t\\tvar fn = isFunction( fns[ tuple[ 4 ] ] ) && fns[ tuple[ 4 ] ];\\n\\n\\t\\t\\t\\t\\t\\t\\t// deferred.progress(function() { bind to newDefer or newDefer.notify })\\n\\t\\t\\t\\t\\t\\t\\t// deferred.done(function() { bind to newDefer or newDefer.resolve })\\n\\t\\t\\t\\t\\t\\t\\t// deferred.fail(function() { bind to newDefer or newDefer.reject })\\n\\t\\t\\t\\t\\t\\t\\tdeferred[ tuple[ 1 ] ]( function() {\\n\\t\\t\\t\\t\\t\\t\\t\\tvar returned = fn && fn.apply( this, arguments );\\n\\t\\t\\t\\t\\t\\t\\t\\tif ( returned && isFunction( returned.promise ) ) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\treturned.promise()\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t.progress( newDefer.notify )\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t.done( newDefer.resolve )\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t.fail( newDefer.reject );\\n\\t\\t\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tnewDefer[ tuple[ 0 ] + \\\"With\\\" ](\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tthis,\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tfn ? [ returned ] : arguments\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t);\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t} );\\n\\t\\t\\t\\t\\t\\t} );\\n\\t\\t\\t\\t\\t\\tfns = null;\\n\\t\\t\\t\\t\\t} ).promise();\\n\\t\\t\\t\\t},\\n\\t\\t\\t\\tthen: function( onFulfilled, onRejected, onProgress ) {\\n\\t\\t\\t\\t\\tvar maxDepth = 0;\\n\\t\\t\\t\\t\\tfunction resolve( depth, deferred, handler, special ) {\\n\\t\\t\\t\\t\\t\\treturn function() {\\n\\t\\t\\t\\t\\t\\t\\tvar that = this,\\n\\t\\t\\t\\t\\t\\t\\t\\targs = arguments,\\n\\t\\t\\t\\t\\t\\t\\t\\tmightThrow = function() {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tvar returned, then;\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// Support: Promises/A+ section 2.3.3.3.3\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// https://promisesaplus.com/#point-59\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// Ignore double-resolution attempts\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif ( depth < maxDepth ) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\treturned = handler.apply( that, args );\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// Support: Promises/A+ section 2.3.1\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// https://promisesaplus.com/#point-48\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif ( returned === deferred.promise() ) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tthrow new TypeError( \\\"Thenable self-resolution\\\" );\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// Support: Promises/A+ sections 2.3.3.1, 3.5\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// https://promisesaplus.com/#point-54\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// https://promisesaplus.com/#point-75\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// Retrieve `then` only once\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tthen = returned &&\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// Support: Promises/A+ section 2.3.4\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// https://promisesaplus.com/#point-64\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// Only check objects and functions for thenability\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t( typeof returned === \\\"object\\\" ||\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\ttypeof returned === \\\"function\\\" ) &&\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\treturned.then;\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// Handle a returned thenable\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif ( isFunction( then ) ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// Special processors (notify) just wait for resolution\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif ( special ) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tthen.call(\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\treturned,\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tresolve( maxDepth, deferred, Identity, special ),\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tresolve( maxDepth, deferred, Thrower, special )\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t);\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// Normal processors (resolve) also hook into progress\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// ...and disregard older resolution values\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tmaxDepth++;\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tthen.call(\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\treturned,\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tresolve( maxDepth, deferred, Identity, special ),\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tresolve( maxDepth, deferred, Thrower, special ),\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tresolve( maxDepth, deferred, Identity,\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tdeferred.notifyWith )\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t);\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// Handle all other returned values\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// Only substitute handlers pass on context\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// and multiple values (non-spec behavior)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif ( handler !== Identity ) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tthat = undefined;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\targs = [ returned ];\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// Process the value(s)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// Default process is resolve\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t( special || deferred.resolveWith )( that, args );\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t\\t},\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t// Only normal processors (resolve) catch and reject exceptions\\n\\t\\t\\t\\t\\t\\t\\t\\tprocess = special ?\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tmightThrow :\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tfunction() {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\ttry {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tmightThrow();\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t} catch ( e ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif ( jQuery.Deferred.exceptionHook ) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tjQuery.Deferred.exceptionHook( e,\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tprocess.stackTrace );\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// Support: Promises/A+ section 2.3.3.3.4.1\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// https://promisesaplus.com/#point-61\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// Ignore post-resolution exceptions\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif ( depth + 1 >= maxDepth ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// Only substitute handlers pass on context\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// and multiple values (non-spec behavior)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif ( handler !== Thrower ) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tthat = undefined;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\targs = [ e ];\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tdeferred.rejectWith( that, args );\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t};\\n\\n\\t\\t\\t\\t\\t\\t\\t// Support: Promises/A+ section 2.3.3.3.1\\n\\t\\t\\t\\t\\t\\t\\t// https://promisesaplus.com/#point-57\\n\\t\\t\\t\\t\\t\\t\\t// Re-resolve promises immediately to dodge false rejection from\\n\\t\\t\\t\\t\\t\\t\\t// subsequent errors\\n\\t\\t\\t\\t\\t\\t\\tif ( depth ) {\\n\\t\\t\\t\\t\\t\\t\\t\\tprocess();\\n\\t\\t\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t// Call an optional hook to record the stack, in case of exception\\n\\t\\t\\t\\t\\t\\t\\t\\t// since it's otherwise lost when execution goes async\\n\\t\\t\\t\\t\\t\\t\\t\\tif ( jQuery.Deferred.getStackHook ) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tprocess.stackTrace = jQuery.Deferred.getStackHook();\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t\\twindow.setTimeout( process );\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t};\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\treturn jQuery.Deferred( function( newDefer ) {\\n\\n\\t\\t\\t\\t\\t\\t// progress_handlers.add( ... )\\n\\t\\t\\t\\t\\t\\ttuples[ 0 ][ 3 ].add(\\n\\t\\t\\t\\t\\t\\t\\tresolve(\\n\\t\\t\\t\\t\\t\\t\\t\\t0,\\n\\t\\t\\t\\t\\t\\t\\t\\tnewDefer,\\n\\t\\t\\t\\t\\t\\t\\t\\tisFunction( onProgress ) ?\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tonProgress :\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tIdentity,\\n\\t\\t\\t\\t\\t\\t\\t\\tnewDefer.notifyWith\\n\\t\\t\\t\\t\\t\\t\\t)\\n\\t\\t\\t\\t\\t\\t);\\n\\n\\t\\t\\t\\t\\t\\t// fulfilled_handlers.add( ... )\\n\\t\\t\\t\\t\\t\\ttuples[ 1 ][ 3 ].add(\\n\\t\\t\\t\\t\\t\\t\\tresolve(\\n\\t\\t\\t\\t\\t\\t\\t\\t0,\\n\\t\\t\\t\\t\\t\\t\\t\\tnewDefer,\\n\\t\\t\\t\\t\\t\\t\\t\\tisFunction( onFulfilled ) ?\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tonFulfilled :\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tIdentity\\n\\t\\t\\t\\t\\t\\t\\t)\\n\\t\\t\\t\\t\\t\\t);\\n\\n\\t\\t\\t\\t\\t\\t// rejected_handlers.add( ... )\\n\\t\\t\\t\\t\\t\\ttuples[ 2 ][ 3 ].add(\\n\\t\\t\\t\\t\\t\\t\\tresolve(\\n\\t\\t\\t\\t\\t\\t\\t\\t0,\\n\\t\\t\\t\\t\\t\\t\\t\\tnewDefer,\\n\\t\\t\\t\\t\\t\\t\\t\\tisFunction( onRejected ) ?\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tonRejected :\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tThrower\\n\\t\\t\\t\\t\\t\\t\\t)\\n\\t\\t\\t\\t\\t\\t);\\n\\t\\t\\t\\t\\t} ).promise();\\n\\t\\t\\t\\t},\\n\\n\\t\\t\\t\\t// Get a promise for this deferred\\n\\t\\t\\t\\t// If obj is provided, the promise aspect is added to the object\\n\\t\\t\\t\\tpromise: function( obj ) {\\n\\t\\t\\t\\t\\treturn obj != null ? jQuery.extend( obj, promise ) : promise;\\n\\t\\t\\t\\t}\\n\\t\\t\\t},\\n\\t\\t\\tdeferred = {};\\n\\n\\t\\t// Add list-specific methods\\n\\t\\tjQuery.each( tuples, function( i, tuple ) {\\n\\t\\t\\tvar list = tuple[ 2 ],\\n\\t\\t\\t\\tstateString = tuple[ 5 ];\\n\\n\\t\\t\\t// promise.progress = list.add\\n\\t\\t\\t// promise.done = list.add\\n\\t\\t\\t// promise.fail = list.add\\n\\t\\t\\tpromise[ tuple[ 1 ] ] = list.add;\\n\\n\\t\\t\\t// Handle state\\n\\t\\t\\tif ( stateString ) {\\n\\t\\t\\t\\tlist.add(\\n\\t\\t\\t\\t\\tfunction() {\\n\\n\\t\\t\\t\\t\\t\\t// state = \\\"resolved\\\" (i.e., fulfilled)\\n\\t\\t\\t\\t\\t\\t// state = \\\"rejected\\\"\\n\\t\\t\\t\\t\\t\\tstate = stateString;\\n\\t\\t\\t\\t\\t},\\n\\n\\t\\t\\t\\t\\t// rejected_callbacks.disable\\n\\t\\t\\t\\t\\t// fulfilled_callbacks.disable\\n\\t\\t\\t\\t\\ttuples[ 3 - i ][ 2 ].disable,\\n\\n\\t\\t\\t\\t\\t// rejected_handlers.disable\\n\\t\\t\\t\\t\\t// fulfilled_handlers.disable\\n\\t\\t\\t\\t\\ttuples[ 3 - i ][ 3 ].disable,\\n\\n\\t\\t\\t\\t\\t// progress_callbacks.lock\\n\\t\\t\\t\\t\\ttuples[ 0 ][ 2 ].lock,\\n\\n\\t\\t\\t\\t\\t// progress_handlers.lock\\n\\t\\t\\t\\t\\ttuples[ 0 ][ 3 ].lock\\n\\t\\t\\t\\t);\\n\\t\\t\\t}\\n\\n\\t\\t\\t// progress_handlers.fire\\n\\t\\t\\t// fulfilled_handlers.fire\\n\\t\\t\\t// rejected_handlers.fire\\n\\t\\t\\tlist.add( tuple[ 3 ].fire );\\n\\n\\t\\t\\t// deferred.notify = function() { deferred.notifyWith(...) }\\n\\t\\t\\t// deferred.resolve = function() { deferred.resolveWith(...) }\\n\\t\\t\\t// deferred.reject = function() { deferred.rejectWith(...) }\\n\\t\\t\\tdeferred[ tuple[ 0 ] ] = function() {\\n\\t\\t\\t\\tdeferred[ tuple[ 0 ] + \\\"With\\\" ]( this === deferred ? undefined : this, arguments );\\n\\t\\t\\t\\treturn this;\\n\\t\\t\\t};\\n\\n\\t\\t\\t// deferred.notifyWith = list.fireWith\\n\\t\\t\\t// deferred.resolveWith = list.fireWith\\n\\t\\t\\t// deferred.rejectWith = list.fireWith\\n\\t\\t\\tdeferred[ tuple[ 0 ] + \\\"With\\\" ] = list.fireWith;\\n\\t\\t} );\\n\\n\\t\\t// Make the deferred a promise\\n\\t\\tpromise.promise( deferred );\\n\\n\\t\\t// Call given func if any\\n\\t\\tif ( func ) {\\n\\t\\t\\tfunc.call( deferred, deferred );\\n\\t\\t}\\n\\n\\t\\t// All done!\\n\\t\\treturn deferred;\\n\\t},\\n\\n\\t// Deferred helper\\n\\twhen: function( singleValue ) {\\n\\t\\tvar\\n\\n\\t\\t\\t// count of uncompleted subordinates\\n\\t\\t\\tremaining = arguments.length,\\n\\n\\t\\t\\t// count of unprocessed arguments\\n\\t\\t\\ti = remaining,\\n\\n\\t\\t\\t// subordinate fulfillment data\\n\\t\\t\\tresolveContexts = Array( i ),\\n\\t\\t\\tresolveValues = slice.call( arguments ),\\n\\n\\t\\t\\t// the master Deferred\\n\\t\\t\\tmaster = jQuery.Deferred(),\\n\\n\\t\\t\\t// subordinate callback factory\\n\\t\\t\\tupdateFunc = function( i ) {\\n\\t\\t\\t\\treturn function( value ) {\\n\\t\\t\\t\\t\\tresolveContexts[ i ] = this;\\n\\t\\t\\t\\t\\tresolveValues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;\\n\\t\\t\\t\\t\\tif ( !( --remaining ) ) {\\n\\t\\t\\t\\t\\t\\tmaster.resolveWith( resolveContexts, resolveValues );\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t};\\n\\t\\t\\t};\\n\\n\\t\\t// Single- and empty arguments are adopted like Promise.resolve\\n\\t\\tif ( remaining <= 1 ) {\\n\\t\\t\\tadoptValue( singleValue, master.done( updateFunc( i ) ).resolve, master.reject,\\n\\t\\t\\t\\t!remaining );\\n\\n\\t\\t\\t// Use .then() to unwrap secondary thenables (cf. gh-3000)\\n\\t\\t\\tif ( master.state() === \\\"pending\\\" ||\\n\\t\\t\\t\\tisFunction( resolveValues[ i ] && resolveValues[ i ].then ) ) {\\n\\n\\t\\t\\t\\treturn master.then();\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// Multiple arguments are aggregated like Promise.all array elements\\n\\t\\twhile ( i-- ) {\\n\\t\\t\\tadoptValue( resolveValues[ i ], updateFunc( i ), master.reject );\\n\\t\\t}\\n\\n\\t\\treturn master.promise();\\n\\t}\\n} );\\n\\n\\n// These usually indicate a programmer mistake during development,\\n// warn about them ASAP rather than swallowing them by default.\\nvar rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;\\n\\njQuery.Deferred.exceptionHook = function( error, stack ) {\\n\\n\\t// Support: IE 8 - 9 only\\n\\t// Console exists when dev tools are open, which can happen at any time\\n\\tif ( window.console && window.console.warn && error && rerrorNames.test( error.name ) ) {\\n\\t\\twindow.console.warn( \\\"jQuery.Deferred exception: \\\" + error.message, error.stack, stack );\\n\\t}\\n};\\n\\n\\n\\n\\njQuery.readyException = function( error ) {\\n\\twindow.setTimeout( function() {\\n\\t\\tthrow error;\\n\\t} );\\n};\\n\\n\\n\\n\\n// The deferred used on DOM ready\\nvar readyList = jQuery.Deferred();\\n\\njQuery.fn.ready = function( fn ) {\\n\\n\\treadyList\\n\\t\\t.then( fn )\\n\\n\\t\\t// Wrap jQuery.readyException in a function so that the lookup\\n\\t\\t// happens at the time of error handling instead of callback\\n\\t\\t// registration.\\n\\t\\t.catch( function( error ) {\\n\\t\\t\\tjQuery.readyException( error );\\n\\t\\t} );\\n\\n\\treturn this;\\n};\\n\\njQuery.extend( {\\n\\n\\t// Is the DOM ready to be used? Set to true once it occurs.\\n\\tisReady: false,\\n\\n\\t// A counter to track how many items to wait for before\\n\\t// the ready event fires. See #6781\\n\\treadyWait: 1,\\n\\n\\t// Handle when the DOM is ready\\n\\tready: function( wait ) {\\n\\n\\t\\t// Abort if there are pending holds or we're already ready\\n\\t\\tif ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\t// Remember that the DOM is ready\\n\\t\\tjQuery.isReady = true;\\n\\n\\t\\t// If a normal DOM Ready event fired, decrement, and wait if need be\\n\\t\\tif ( wait !== true && --jQuery.readyWait > 0 ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\t// If there are functions bound, to execute\\n\\t\\treadyList.resolveWith( document, [ jQuery ] );\\n\\t}\\n} );\\n\\njQuery.ready.then = readyList.then;\\n\\n// The ready event handler and self cleanup method\\nfunction completed() {\\n\\tdocument.removeEventListener( \\\"DOMContentLoaded\\\", completed );\\n\\twindow.removeEventListener( \\\"load\\\", completed );\\n\\tjQuery.ready();\\n}\\n\\n// Catch cases where $(document).ready() is called\\n// after the browser event has already occurred.\\n// Support: IE <=9 - 10 only\\n// Older IE sometimes signals \\\"interactive\\\" too soon\\nif ( document.readyState === \\\"complete\\\" ||\\n\\t( document.readyState !== \\\"loading\\\" && !document.documentElement.doScroll ) ) {\\n\\n\\t// Handle it asynchronously to allow scripts the opportunity to delay ready\\n\\twindow.setTimeout( jQuery.ready );\\n\\n} else {\\n\\n\\t// Use the handy event callback\\n\\tdocument.addEventListener( \\\"DOMContentLoaded\\\", completed );\\n\\n\\t// A fallback to window.onload, that will always work\\n\\twindow.addEventListener( \\\"load\\\", completed );\\n}\\n\\n\\n\\n\\n// Multifunctional method to get and set values of a collection\\n// The value/s can optionally be executed if it's a function\\nvar access = function( elems, fn, key, value, chainable, emptyGet, raw ) {\\n\\tvar i = 0,\\n\\t\\tlen = elems.length,\\n\\t\\tbulk = key == null;\\n\\n\\t// Sets many values\\n\\tif ( toType( key ) === \\\"object\\\" ) {\\n\\t\\tchainable = true;\\n\\t\\tfor ( i in key ) {\\n\\t\\t\\taccess( elems, fn, i, key[ i ], true, emptyGet, raw );\\n\\t\\t}\\n\\n\\t// Sets one value\\n\\t} else if ( value !== undefined ) {\\n\\t\\tchainable = true;\\n\\n\\t\\tif ( !isFunction( value ) ) {\\n\\t\\t\\traw = true;\\n\\t\\t}\\n\\n\\t\\tif ( bulk ) {\\n\\n\\t\\t\\t// Bulk operations run against the entire set\\n\\t\\t\\tif ( raw ) {\\n\\t\\t\\t\\tfn.call( elems, value );\\n\\t\\t\\t\\tfn = null;\\n\\n\\t\\t\\t// ...except when executing function values\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tbulk = fn;\\n\\t\\t\\t\\tfn = function( elem, key, value ) {\\n\\t\\t\\t\\t\\treturn bulk.call( jQuery( elem ), value );\\n\\t\\t\\t\\t};\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif ( fn ) {\\n\\t\\t\\tfor ( ; i < len; i++ ) {\\n\\t\\t\\t\\tfn(\\n\\t\\t\\t\\t\\telems[ i ], key, raw ?\\n\\t\\t\\t\\t\\tvalue :\\n\\t\\t\\t\\t\\tvalue.call( elems[ i ], i, fn( elems[ i ], key ) )\\n\\t\\t\\t\\t);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tif ( chainable ) {\\n\\t\\treturn elems;\\n\\t}\\n\\n\\t// Gets\\n\\tif ( bulk ) {\\n\\t\\treturn fn.call( elems );\\n\\t}\\n\\n\\treturn len ? fn( elems[ 0 ], key ) : emptyGet;\\n};\\n\\n\\n// Matches dashed string for camelizing\\nvar rmsPrefix = /^-ms-/,\\n\\trdashAlpha = /-([a-z])/g;\\n\\n// Used by camelCase as callback to replace()\\nfunction fcamelCase( all, letter ) {\\n\\treturn letter.toUpperCase();\\n}\\n\\n// Convert dashed to camelCase; used by the css and data modules\\n// Support: IE <=9 - 11, Edge 12 - 15\\n// Microsoft forgot to hump their vendor prefix (#9572)\\nfunction camelCase( string ) {\\n\\treturn string.replace( rmsPrefix, \\\"ms-\\\" ).replace( rdashAlpha, fcamelCase );\\n}\\nvar acceptData = function( owner ) {\\n\\n\\t// Accepts only:\\n\\t//  - Node\\n\\t//    - Node.ELEMENT_NODE\\n\\t//    - Node.DOCUMENT_NODE\\n\\t//  - Object\\n\\t//    - Any\\n\\treturn owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );\\n};\\n\\n\\n\\n\\nfunction Data() {\\n\\tthis.expando = jQuery.expando + Data.uid++;\\n}\\n\\nData.uid = 1;\\n\\nData.prototype = {\\n\\n\\tcache: function( owner ) {\\n\\n\\t\\t// Check if the owner object already has a cache\\n\\t\\tvar value = owner[ this.expando ];\\n\\n\\t\\t// If not, create one\\n\\t\\tif ( !value ) {\\n\\t\\t\\tvalue = {};\\n\\n\\t\\t\\t// We can accept data for non-element nodes in modern browsers,\\n\\t\\t\\t// but we should not, see #8335.\\n\\t\\t\\t// Always return an empty object.\\n\\t\\t\\tif ( acceptData( owner ) ) {\\n\\n\\t\\t\\t\\t// If it is a node unlikely to be stringify-ed or looped over\\n\\t\\t\\t\\t// use plain assignment\\n\\t\\t\\t\\tif ( owner.nodeType ) {\\n\\t\\t\\t\\t\\towner[ this.expando ] = value;\\n\\n\\t\\t\\t\\t// Otherwise secure it in a non-enumerable property\\n\\t\\t\\t\\t// configurable must be true to allow the property to be\\n\\t\\t\\t\\t// deleted when data is removed\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tObject.defineProperty( owner, this.expando, {\\n\\t\\t\\t\\t\\t\\tvalue: value,\\n\\t\\t\\t\\t\\t\\tconfigurable: true\\n\\t\\t\\t\\t\\t} );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn value;\\n\\t},\\n\\tset: function( owner, data, value ) {\\n\\t\\tvar prop,\\n\\t\\t\\tcache = this.cache( owner );\\n\\n\\t\\t// Handle: [ owner, key, value ] args\\n\\t\\t// Always use camelCase key (gh-2257)\\n\\t\\tif ( typeof data === \\\"string\\\" ) {\\n\\t\\t\\tcache[ camelCase( data ) ] = value;\\n\\n\\t\\t// Handle: [ owner, { properties } ] args\\n\\t\\t} else {\\n\\n\\t\\t\\t// Copy the properties one-by-one to the cache object\\n\\t\\t\\tfor ( prop in data ) {\\n\\t\\t\\t\\tcache[ camelCase( prop ) ] = data[ prop ];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn cache;\\n\\t},\\n\\tget: function( owner, key ) {\\n\\t\\treturn key === undefined ?\\n\\t\\t\\tthis.cache( owner ) :\\n\\n\\t\\t\\t// Always use camelCase key (gh-2257)\\n\\t\\t\\towner[ this.expando ] && owner[ this.expando ][ camelCase( key ) ];\\n\\t},\\n\\taccess: function( owner, key, value ) {\\n\\n\\t\\t// In cases where either:\\n\\t\\t//\\n\\t\\t//   1. No key was specified\\n\\t\\t//   2. A string key was specified, but no value provided\\n\\t\\t//\\n\\t\\t// Take the \\\"read\\\" path and allow the get method to determine\\n\\t\\t// which value to return, respectively either:\\n\\t\\t//\\n\\t\\t//   1. The entire cache object\\n\\t\\t//   2. The data stored at the key\\n\\t\\t//\\n\\t\\tif ( key === undefined ||\\n\\t\\t\\t\\t( ( key && typeof key === \\\"string\\\" ) && value === undefined ) ) {\\n\\n\\t\\t\\treturn this.get( owner, key );\\n\\t\\t}\\n\\n\\t\\t// When the key is not a string, or both a key and value\\n\\t\\t// are specified, set or extend (existing objects) with either:\\n\\t\\t//\\n\\t\\t//   1. An object of properties\\n\\t\\t//   2. A key and value\\n\\t\\t//\\n\\t\\tthis.set( owner, key, value );\\n\\n\\t\\t// Since the \\\"set\\\" path can have two possible entry points\\n\\t\\t// return the expected data based on which path was taken[*]\\n\\t\\treturn value !== undefined ? value : key;\\n\\t},\\n\\tremove: function( owner, key ) {\\n\\t\\tvar i,\\n\\t\\t\\tcache = owner[ this.expando ];\\n\\n\\t\\tif ( cache === undefined ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tif ( key !== undefined ) {\\n\\n\\t\\t\\t// Support array or space separated string of keys\\n\\t\\t\\tif ( Array.isArray( key ) ) {\\n\\n\\t\\t\\t\\t// If key is an array of keys...\\n\\t\\t\\t\\t// We always set camelCase keys, so remove that.\\n\\t\\t\\t\\tkey = key.map( camelCase );\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tkey = camelCase( key );\\n\\n\\t\\t\\t\\t// If a key with the spaces exists, use it.\\n\\t\\t\\t\\t// Otherwise, create an array by matching non-whitespace\\n\\t\\t\\t\\tkey = key in cache ?\\n\\t\\t\\t\\t\\t[ key ] :\\n\\t\\t\\t\\t\\t( key.match( rnothtmlwhite ) || [] );\\n\\t\\t\\t}\\n\\n\\t\\t\\ti = key.length;\\n\\n\\t\\t\\twhile ( i-- ) {\\n\\t\\t\\t\\tdelete cache[ key[ i ] ];\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// Remove the expando if there's no more data\\n\\t\\tif ( key === undefined || jQuery.isEmptyObject( cache ) ) {\\n\\n\\t\\t\\t// Support: Chrome <=35 - 45\\n\\t\\t\\t// Webkit & Blink performance suffers when deleting properties\\n\\t\\t\\t// from DOM nodes, so set to undefined instead\\n\\t\\t\\t// https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)\\n\\t\\t\\tif ( owner.nodeType ) {\\n\\t\\t\\t\\towner[ this.expando ] = undefined;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tdelete owner[ this.expando ];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t},\\n\\thasData: function( owner ) {\\n\\t\\tvar cache = owner[ this.expando ];\\n\\t\\treturn cache !== undefined && !jQuery.isEmptyObject( cache );\\n\\t}\\n};\\nvar dataPriv = new Data();\\n\\nvar dataUser = new Data();\\n\\n\\n\\n//\\tImplementation Summary\\n//\\n//\\t1. Enforce API surface and semantic compatibility with 1.9.x branch\\n//\\t2. Improve the module's maintainability by reducing the storage\\n//\\t\\tpaths to a single mechanism.\\n//\\t3. Use the same single mechanism to support \\\"private\\\" and \\\"user\\\" data.\\n//\\t4. _Never_ expose \\\"private\\\" data to user code (TODO: Drop _data, _removeData)\\n//\\t5. Avoid exposing implementation details on user objects (eg. expando properties)\\n//\\t6. Provide a clear path for implementation upgrade to WeakMap in 2014\\n\\nvar rbrace = /^(?:\\\\{[\\\\w\\\\W]*\\\\}|\\\\[[\\\\w\\\\W]*\\\\])$/,\\n\\trmultiDash = /[A-Z]/g;\\n\\nfunction getData( data ) {\\n\\tif ( data === \\\"true\\\" ) {\\n\\t\\treturn true;\\n\\t}\\n\\n\\tif ( data === \\\"false\\\" ) {\\n\\t\\treturn false;\\n\\t}\\n\\n\\tif ( data === \\\"null\\\" ) {\\n\\t\\treturn null;\\n\\t}\\n\\n\\t// Only convert to a number if it doesn't change the string\\n\\tif ( data === +data + \\\"\\\" ) {\\n\\t\\treturn +data;\\n\\t}\\n\\n\\tif ( rbrace.test( data ) ) {\\n\\t\\treturn JSON.parse( data );\\n\\t}\\n\\n\\treturn data;\\n}\\n\\nfunction dataAttr( elem, key, data ) {\\n\\tvar name;\\n\\n\\t// If nothing was found internally, try to fetch any\\n\\t// data from the HTML5 data-* attribute\\n\\tif ( data === undefined && elem.nodeType === 1 ) {\\n\\t\\tname = \\\"data-\\\" + key.replace( rmultiDash, \\\"-$&\\\" ).toLowerCase();\\n\\t\\tdata = elem.getAttribute( name );\\n\\n\\t\\tif ( typeof data === \\\"string\\\" ) {\\n\\t\\t\\ttry {\\n\\t\\t\\t\\tdata = getData( data );\\n\\t\\t\\t} catch ( e ) {}\\n\\n\\t\\t\\t// Make sure we set the data so it isn't changed later\\n\\t\\t\\tdataUser.set( elem, key, data );\\n\\t\\t} else {\\n\\t\\t\\tdata = undefined;\\n\\t\\t}\\n\\t}\\n\\treturn data;\\n}\\n\\njQuery.extend( {\\n\\thasData: function( elem ) {\\n\\t\\treturn dataUser.hasData( elem ) || dataPriv.hasData( elem );\\n\\t},\\n\\n\\tdata: function( elem, name, data ) {\\n\\t\\treturn dataUser.access( elem, name, data );\\n\\t},\\n\\n\\tremoveData: function( elem, name ) {\\n\\t\\tdataUser.remove( elem, name );\\n\\t},\\n\\n\\t// TODO: Now that all calls to _data and _removeData have been replaced\\n\\t// with direct calls to dataPriv methods, these can be deprecated.\\n\\t_data: function( elem, name, data ) {\\n\\t\\treturn dataPriv.access( elem, name, data );\\n\\t},\\n\\n\\t_removeData: function( elem, name ) {\\n\\t\\tdataPriv.remove( elem, name );\\n\\t}\\n} );\\n\\njQuery.fn.extend( {\\n\\tdata: function( key, value ) {\\n\\t\\tvar i, name, data,\\n\\t\\t\\telem = this[ 0 ],\\n\\t\\t\\tattrs = elem && elem.attributes;\\n\\n\\t\\t// Gets all values\\n\\t\\tif ( key === undefined ) {\\n\\t\\t\\tif ( this.length ) {\\n\\t\\t\\t\\tdata = dataUser.get( elem );\\n\\n\\t\\t\\t\\tif ( elem.nodeType === 1 && !dataPriv.get( elem, \\\"hasDataAttrs\\\" ) ) {\\n\\t\\t\\t\\t\\ti = attrs.length;\\n\\t\\t\\t\\t\\twhile ( i-- ) {\\n\\n\\t\\t\\t\\t\\t\\t// Support: IE 11 only\\n\\t\\t\\t\\t\\t\\t// The attrs elements can be null (#14894)\\n\\t\\t\\t\\t\\t\\tif ( attrs[ i ] ) {\\n\\t\\t\\t\\t\\t\\t\\tname = attrs[ i ].name;\\n\\t\\t\\t\\t\\t\\t\\tif ( name.indexOf( \\\"data-\\\" ) === 0 ) {\\n\\t\\t\\t\\t\\t\\t\\t\\tname = camelCase( name.slice( 5 ) );\\n\\t\\t\\t\\t\\t\\t\\t\\tdataAttr( elem, name, data[ name ] );\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tdataPriv.set( elem, \\\"hasDataAttrs\\\", true );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn data;\\n\\t\\t}\\n\\n\\t\\t// Sets multiple values\\n\\t\\tif ( typeof key === \\\"object\\\" ) {\\n\\t\\t\\treturn this.each( function() {\\n\\t\\t\\t\\tdataUser.set( this, key );\\n\\t\\t\\t} );\\n\\t\\t}\\n\\n\\t\\treturn access( this, function( value ) {\\n\\t\\t\\tvar data;\\n\\n\\t\\t\\t// The calling jQuery object (element matches) is not empty\\n\\t\\t\\t// (and therefore has an element appears at this[ 0 ]) and the\\n\\t\\t\\t// `value` parameter was not undefined. An empty jQuery object\\n\\t\\t\\t// will result in `undefined` for elem = this[ 0 ] which will\\n\\t\\t\\t// throw an exception if an attempt to read a data cache is made.\\n\\t\\t\\tif ( elem && value === undefined ) {\\n\\n\\t\\t\\t\\t// Attempt to get data from the cache\\n\\t\\t\\t\\t// The key will always be camelCased in Data\\n\\t\\t\\t\\tdata = dataUser.get( elem, key );\\n\\t\\t\\t\\tif ( data !== undefined ) {\\n\\t\\t\\t\\t\\treturn data;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Attempt to \\\"discover\\\" the data in\\n\\t\\t\\t\\t// HTML5 custom data-* attrs\\n\\t\\t\\t\\tdata = dataAttr( elem, key );\\n\\t\\t\\t\\tif ( data !== undefined ) {\\n\\t\\t\\t\\t\\treturn data;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// We tried really hard, but the data doesn't exist.\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Set the data...\\n\\t\\t\\tthis.each( function() {\\n\\n\\t\\t\\t\\t// We always store the camelCased key\\n\\t\\t\\t\\tdataUser.set( this, key, value );\\n\\t\\t\\t} );\\n\\t\\t}, null, value, arguments.length > 1, null, true );\\n\\t},\\n\\n\\tremoveData: function( key ) {\\n\\t\\treturn this.each( function() {\\n\\t\\t\\tdataUser.remove( this, key );\\n\\t\\t} );\\n\\t}\\n} );\\n\\n\\njQuery.extend( {\\n\\tqueue: function( elem, type, data ) {\\n\\t\\tvar queue;\\n\\n\\t\\tif ( elem ) {\\n\\t\\t\\ttype = ( type || \\\"fx\\\" ) + \\\"queue\\\";\\n\\t\\t\\tqueue = dataPriv.get( elem, type );\\n\\n\\t\\t\\t// Speed up dequeue by getting out quickly if this is just a lookup\\n\\t\\t\\tif ( data ) {\\n\\t\\t\\t\\tif ( !queue || Array.isArray( data ) ) {\\n\\t\\t\\t\\t\\tqueue = dataPriv.access( elem, type, jQuery.makeArray( data ) );\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tqueue.push( data );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn queue || [];\\n\\t\\t}\\n\\t},\\n\\n\\tdequeue: function( elem, type ) {\\n\\t\\ttype = type || \\\"fx\\\";\\n\\n\\t\\tvar queue = jQuery.queue( elem, type ),\\n\\t\\t\\tstartLength = queue.length,\\n\\t\\t\\tfn = queue.shift(),\\n\\t\\t\\thooks = jQuery._queueHooks( elem, type ),\\n\\t\\t\\tnext = function() {\\n\\t\\t\\t\\tjQuery.dequeue( elem, type );\\n\\t\\t\\t};\\n\\n\\t\\t// If the fx queue is dequeued, always remove the progress sentinel\\n\\t\\tif ( fn === \\\"inprogress\\\" ) {\\n\\t\\t\\tfn = queue.shift();\\n\\t\\t\\tstartLength--;\\n\\t\\t}\\n\\n\\t\\tif ( fn ) {\\n\\n\\t\\t\\t// Add a progress sentinel to prevent the fx queue from being\\n\\t\\t\\t// automatically dequeued\\n\\t\\t\\tif ( type === \\\"fx\\\" ) {\\n\\t\\t\\t\\tqueue.unshift( \\\"inprogress\\\" );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Clear up the last queue stop function\\n\\t\\t\\tdelete hooks.stop;\\n\\t\\t\\tfn.call( elem, next, hooks );\\n\\t\\t}\\n\\n\\t\\tif ( !startLength && hooks ) {\\n\\t\\t\\thooks.empty.fire();\\n\\t\\t}\\n\\t},\\n\\n\\t// Not public - generate a queueHooks object, or return the current one\\n\\t_queueHooks: function( elem, type ) {\\n\\t\\tvar key = type + \\\"queueHooks\\\";\\n\\t\\treturn dataPriv.get( elem, key ) || dataPriv.access( elem, key, {\\n\\t\\t\\tempty: jQuery.Callbacks( \\\"once memory\\\" ).add( function() {\\n\\t\\t\\t\\tdataPriv.remove( elem, [ type + \\\"queue\\\", key ] );\\n\\t\\t\\t} )\\n\\t\\t} );\\n\\t}\\n} );\\n\\njQuery.fn.extend( {\\n\\tqueue: function( type, data ) {\\n\\t\\tvar setter = 2;\\n\\n\\t\\tif ( typeof type !== \\\"string\\\" ) {\\n\\t\\t\\tdata = type;\\n\\t\\t\\ttype = \\\"fx\\\";\\n\\t\\t\\tsetter--;\\n\\t\\t}\\n\\n\\t\\tif ( arguments.length < setter ) {\\n\\t\\t\\treturn jQuery.queue( this[ 0 ], type );\\n\\t\\t}\\n\\n\\t\\treturn data === undefined ?\\n\\t\\t\\tthis :\\n\\t\\t\\tthis.each( function() {\\n\\t\\t\\t\\tvar queue = jQuery.queue( this, type, data );\\n\\n\\t\\t\\t\\t// Ensure a hooks for this queue\\n\\t\\t\\t\\tjQuery._queueHooks( this, type );\\n\\n\\t\\t\\t\\tif ( type === \\\"fx\\\" && queue[ 0 ] !== \\\"inprogress\\\" ) {\\n\\t\\t\\t\\t\\tjQuery.dequeue( this, type );\\n\\t\\t\\t\\t}\\n\\t\\t\\t} );\\n\\t},\\n\\tdequeue: function( type ) {\\n\\t\\treturn this.each( function() {\\n\\t\\t\\tjQuery.dequeue( this, type );\\n\\t\\t} );\\n\\t},\\n\\tclearQueue: function( type ) {\\n\\t\\treturn this.queue( type || \\\"fx\\\", [] );\\n\\t},\\n\\n\\t// Get a promise resolved when queues of a certain type\\n\\t// are emptied (fx is the type by default)\\n\\tpromise: function( type, obj ) {\\n\\t\\tvar tmp,\\n\\t\\t\\tcount = 1,\\n\\t\\t\\tdefer = jQuery.Deferred(),\\n\\t\\t\\telements = this,\\n\\t\\t\\ti = this.length,\\n\\t\\t\\tresolve = function() {\\n\\t\\t\\t\\tif ( !( --count ) ) {\\n\\t\\t\\t\\t\\tdefer.resolveWith( elements, [ elements ] );\\n\\t\\t\\t\\t}\\n\\t\\t\\t};\\n\\n\\t\\tif ( typeof type !== \\\"string\\\" ) {\\n\\t\\t\\tobj = type;\\n\\t\\t\\ttype = undefined;\\n\\t\\t}\\n\\t\\ttype = type || \\\"fx\\\";\\n\\n\\t\\twhile ( i-- ) {\\n\\t\\t\\ttmp = dataPriv.get( elements[ i ], type + \\\"queueHooks\\\" );\\n\\t\\t\\tif ( tmp && tmp.empty ) {\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\ttmp.empty.add( resolve );\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tresolve();\\n\\t\\treturn defer.promise( obj );\\n\\t}\\n} );\\nvar pnum = ( /[+-]?(?:\\\\d*\\\\.|)\\\\d+(?:[eE][+-]?\\\\d+|)/ ).source;\\n\\nvar rcssNum = new RegExp( \\\"^(?:([+-])=|)(\\\" + pnum + \\\")([a-z%]*)$\\\", \\\"i\\\" );\\n\\n\\nvar cssExpand = [ \\\"Top\\\", \\\"Right\\\", \\\"Bottom\\\", \\\"Left\\\" ];\\n\\nvar isHiddenWithinTree = function( elem, el ) {\\n\\n\\t\\t// isHiddenWithinTree might be called from jQuery#filter function;\\n\\t\\t// in that case, element will be second argument\\n\\t\\telem = el || elem;\\n\\n\\t\\t// Inline style trumps all\\n\\t\\treturn elem.style.display === \\\"none\\\" ||\\n\\t\\t\\telem.style.display === \\\"\\\" &&\\n\\n\\t\\t\\t// Otherwise, check computed style\\n\\t\\t\\t// Support: Firefox <=43 - 45\\n\\t\\t\\t// Disconnected elements can have computed display: none, so first confirm that elem is\\n\\t\\t\\t// in the document.\\n\\t\\t\\tjQuery.contains( elem.ownerDocument, elem ) &&\\n\\n\\t\\t\\tjQuery.css( elem, \\\"display\\\" ) === \\\"none\\\";\\n\\t};\\n\\nvar swap = function( elem, options, callback, args ) {\\n\\tvar ret, name,\\n\\t\\told = {};\\n\\n\\t// Remember the old values, and insert the new ones\\n\\tfor ( name in options ) {\\n\\t\\told[ name ] = elem.style[ name ];\\n\\t\\telem.style[ name ] = options[ name ];\\n\\t}\\n\\n\\tret = callback.apply( elem, args || [] );\\n\\n\\t// Revert the old values\\n\\tfor ( name in options ) {\\n\\t\\telem.style[ name ] = old[ name ];\\n\\t}\\n\\n\\treturn ret;\\n};\\n\\n\\n\\n\\nfunction adjustCSS( elem, prop, valueParts, tween ) {\\n\\tvar adjusted, scale,\\n\\t\\tmaxIterations = 20,\\n\\t\\tcurrentValue = tween ?\\n\\t\\t\\tfunction() {\\n\\t\\t\\t\\treturn tween.cur();\\n\\t\\t\\t} :\\n\\t\\t\\tfunction() {\\n\\t\\t\\t\\treturn jQuery.css( elem, prop, \\\"\\\" );\\n\\t\\t\\t},\\n\\t\\tinitial = currentValue(),\\n\\t\\tunit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? \\\"\\\" : \\\"px\\\" ),\\n\\n\\t\\t// Starting value computation is required for potential unit mismatches\\n\\t\\tinitialInUnit = ( jQuery.cssNumber[ prop ] || unit !== \\\"px\\\" && +initial ) &&\\n\\t\\t\\trcssNum.exec( jQuery.css( elem, prop ) );\\n\\n\\tif ( initialInUnit && initialInUnit[ 3 ] !== unit ) {\\n\\n\\t\\t// Support: Firefox <=54\\n\\t\\t// Halve the iteration target value to prevent interference from CSS upper bounds (gh-2144)\\n\\t\\tinitial = initial / 2;\\n\\n\\t\\t// Trust units reported by jQuery.css\\n\\t\\tunit = unit || initialInUnit[ 3 ];\\n\\n\\t\\t// Iteratively approximate from a nonzero starting point\\n\\t\\tinitialInUnit = +initial || 1;\\n\\n\\t\\twhile ( maxIterations-- ) {\\n\\n\\t\\t\\t// Evaluate and update our best guess (doubling guesses that zero out).\\n\\t\\t\\t// Finish if the scale equals or crosses 1 (making the old*new product non-positive).\\n\\t\\t\\tjQuery.style( elem, prop, initialInUnit + unit );\\n\\t\\t\\tif ( ( 1 - scale ) * ( 1 - ( scale = currentValue() / initial || 0.5 ) ) <= 0 ) {\\n\\t\\t\\t\\tmaxIterations = 0;\\n\\t\\t\\t}\\n\\t\\t\\tinitialInUnit = initialInUnit / scale;\\n\\n\\t\\t}\\n\\n\\t\\tinitialInUnit = initialInUnit * 2;\\n\\t\\tjQuery.style( elem, prop, initialInUnit + unit );\\n\\n\\t\\t// Make sure we update the tween properties later on\\n\\t\\tvalueParts = valueParts || [];\\n\\t}\\n\\n\\tif ( valueParts ) {\\n\\t\\tinitialInUnit = +initialInUnit || +initial || 0;\\n\\n\\t\\t// Apply relative offset (+=/-=) if specified\\n\\t\\tadjusted = valueParts[ 1 ] ?\\n\\t\\t\\tinitialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :\\n\\t\\t\\t+valueParts[ 2 ];\\n\\t\\tif ( tween ) {\\n\\t\\t\\ttween.unit = unit;\\n\\t\\t\\ttween.start = initialInUnit;\\n\\t\\t\\ttween.end = adjusted;\\n\\t\\t}\\n\\t}\\n\\treturn adjusted;\\n}\\n\\n\\nvar defaultDisplayMap = {};\\n\\nfunction getDefaultDisplay( elem ) {\\n\\tvar temp,\\n\\t\\tdoc = elem.ownerDocument,\\n\\t\\tnodeName = elem.nodeName,\\n\\t\\tdisplay = defaultDisplayMap[ nodeName ];\\n\\n\\tif ( display ) {\\n\\t\\treturn display;\\n\\t}\\n\\n\\ttemp = doc.body.appendChild( doc.createElement( nodeName ) );\\n\\tdisplay = jQuery.css( temp, \\\"display\\\" );\\n\\n\\ttemp.parentNode.removeChild( temp );\\n\\n\\tif ( display === \\\"none\\\" ) {\\n\\t\\tdisplay = \\\"block\\\";\\n\\t}\\n\\tdefaultDisplayMap[ nodeName ] = display;\\n\\n\\treturn display;\\n}\\n\\nfunction showHide( elements, show ) {\\n\\tvar display, elem,\\n\\t\\tvalues = [],\\n\\t\\tindex = 0,\\n\\t\\tlength = elements.length;\\n\\n\\t// Determine new display value for elements that need to change\\n\\tfor ( ; index < length; index++ ) {\\n\\t\\telem = elements[ index ];\\n\\t\\tif ( !elem.style ) {\\n\\t\\t\\tcontinue;\\n\\t\\t}\\n\\n\\t\\tdisplay = elem.style.display;\\n\\t\\tif ( show ) {\\n\\n\\t\\t\\t// Since we force visibility upon cascade-hidden elements, an immediate (and slow)\\n\\t\\t\\t// check is required in this first loop unless we have a nonempty display value (either\\n\\t\\t\\t// inline or about-to-be-restored)\\n\\t\\t\\tif ( display === \\\"none\\\" ) {\\n\\t\\t\\t\\tvalues[ index ] = dataPriv.get( elem, \\\"display\\\" ) || null;\\n\\t\\t\\t\\tif ( !values[ index ] ) {\\n\\t\\t\\t\\t\\telem.style.display = \\\"\\\";\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif ( elem.style.display === \\\"\\\" && isHiddenWithinTree( elem ) ) {\\n\\t\\t\\t\\tvalues[ index ] = getDefaultDisplay( elem );\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\tif ( display !== \\\"none\\\" ) {\\n\\t\\t\\t\\tvalues[ index ] = \\\"none\\\";\\n\\n\\t\\t\\t\\t// Remember what we're overwriting\\n\\t\\t\\t\\tdataPriv.set( elem, \\\"display\\\", display );\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t// Set the display of the elements in a second loop to avoid constant reflow\\n\\tfor ( index = 0; index < length; index++ ) {\\n\\t\\tif ( values[ index ] != null ) {\\n\\t\\t\\telements[ index ].style.display = values[ index ];\\n\\t\\t}\\n\\t}\\n\\n\\treturn elements;\\n}\\n\\njQuery.fn.extend( {\\n\\tshow: function() {\\n\\t\\treturn showHide( this, true );\\n\\t},\\n\\thide: function() {\\n\\t\\treturn showHide( this );\\n\\t},\\n\\ttoggle: function( state ) {\\n\\t\\tif ( typeof state === \\\"boolean\\\" ) {\\n\\t\\t\\treturn state ? this.show() : this.hide();\\n\\t\\t}\\n\\n\\t\\treturn this.each( function() {\\n\\t\\t\\tif ( isHiddenWithinTree( this ) ) {\\n\\t\\t\\t\\tjQuery( this ).show();\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tjQuery( this ).hide();\\n\\t\\t\\t}\\n\\t\\t} );\\n\\t}\\n} );\\nvar rcheckableType = ( /^(?:checkbox|radio)$/i );\\n\\nvar rtagName = ( /<([a-z][^\\\\/\\\\0>\\\\x20\\\\t\\\\r\\\\n\\\\f]+)/i );\\n\\nvar rscriptType = ( /^$|^module$|\\\\/(?:java|ecma)script/i );\\n\\n\\n\\n// We have to close these tags to support XHTML (#13200)\\nvar wrapMap = {\\n\\n\\t// Support: IE <=9 only\\n\\toption: [ 1, \\\"<select multiple='multiple'>\\\", \\\"</select>\\\" ],\\n\\n\\t// XHTML parsers do not magically insert elements in the\\n\\t// same way that tag soup parsers do. So we cannot shorten\\n\\t// this by omitting <tbody> or other required elements.\\n\\tthead: [ 1, \\\"<table>\\\", \\\"</table>\\\" ],\\n\\tcol: [ 2, \\\"<table><colgroup>\\\", \\\"</colgroup></table>\\\" ],\\n\\ttr: [ 2, \\\"<table><tbody>\\\", \\\"</tbody></table>\\\" ],\\n\\ttd: [ 3, \\\"<table><tbody><tr>\\\", \\\"</tr></tbody></table>\\\" ],\\n\\n\\t_default: [ 0, \\\"\\\", \\\"\\\" ]\\n};\\n\\n// Support: IE <=9 only\\nwrapMap.optgroup = wrapMap.option;\\n\\nwrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;\\nwrapMap.th = wrapMap.td;\\n\\n\\nfunction getAll( context, tag ) {\\n\\n\\t// Support: IE <=9 - 11 only\\n\\t// Use typeof to avoid zero-argument method invocation on host objects (#15151)\\n\\tvar ret;\\n\\n\\tif ( typeof context.getElementsByTagName !== \\\"undefined\\\" ) {\\n\\t\\tret = context.getElementsByTagName( tag || \\\"*\\\" );\\n\\n\\t} else if ( typeof context.querySelectorAll !== \\\"undefined\\\" ) {\\n\\t\\tret = context.querySelectorAll( tag || \\\"*\\\" );\\n\\n\\t} else {\\n\\t\\tret = [];\\n\\t}\\n\\n\\tif ( tag === undefined || tag && nodeName( context, tag ) ) {\\n\\t\\treturn jQuery.merge( [ context ], ret );\\n\\t}\\n\\n\\treturn ret;\\n}\\n\\n\\n// Mark scripts as having already been evaluated\\nfunction setGlobalEval( elems, refElements ) {\\n\\tvar i = 0,\\n\\t\\tl = elems.length;\\n\\n\\tfor ( ; i < l; i++ ) {\\n\\t\\tdataPriv.set(\\n\\t\\t\\telems[ i ],\\n\\t\\t\\t\\\"globalEval\\\",\\n\\t\\t\\t!refElements || dataPriv.get( refElements[ i ], \\\"globalEval\\\" )\\n\\t\\t);\\n\\t}\\n}\\n\\n\\nvar rhtml = /<|&#?\\\\w+;/;\\n\\nfunction buildFragment( elems, context, scripts, selection, ignored ) {\\n\\tvar elem, tmp, tag, wrap, contains, j,\\n\\t\\tfragment = context.createDocumentFragment(),\\n\\t\\tnodes = [],\\n\\t\\ti = 0,\\n\\t\\tl = elems.length;\\n\\n\\tfor ( ; i < l; i++ ) {\\n\\t\\telem = elems[ i ];\\n\\n\\t\\tif ( elem || elem === 0 ) {\\n\\n\\t\\t\\t// Add nodes directly\\n\\t\\t\\tif ( toType( elem ) === \\\"object\\\" ) {\\n\\n\\t\\t\\t\\t// Support: Android <=4.0 only, PhantomJS 1 only\\n\\t\\t\\t\\t// push.apply(_, arraylike) throws on ancient WebKit\\n\\t\\t\\t\\tjQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );\\n\\n\\t\\t\\t// Convert non-html into a text node\\n\\t\\t\\t} else if ( !rhtml.test( elem ) ) {\\n\\t\\t\\t\\tnodes.push( context.createTextNode( elem ) );\\n\\n\\t\\t\\t// Convert html into DOM nodes\\n\\t\\t\\t} else {\\n\\t\\t\\t\\ttmp = tmp || fragment.appendChild( context.createElement( \\\"div\\\" ) );\\n\\n\\t\\t\\t\\t// Deserialize a standard representation\\n\\t\\t\\t\\ttag = ( rtagName.exec( elem ) || [ \\\"\\\", \\\"\\\" ] )[ 1 ].toLowerCase();\\n\\t\\t\\t\\twrap = wrapMap[ tag ] || wrapMap._default;\\n\\t\\t\\t\\ttmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];\\n\\n\\t\\t\\t\\t// Descend through wrappers to the right content\\n\\t\\t\\t\\tj = wrap[ 0 ];\\n\\t\\t\\t\\twhile ( j-- ) {\\n\\t\\t\\t\\t\\ttmp = tmp.lastChild;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Support: Android <=4.0 only, PhantomJS 1 only\\n\\t\\t\\t\\t// push.apply(_, arraylike) throws on ancient WebKit\\n\\t\\t\\t\\tjQuery.merge( nodes, tmp.childNodes );\\n\\n\\t\\t\\t\\t// Remember the top-level container\\n\\t\\t\\t\\ttmp = fragment.firstChild;\\n\\n\\t\\t\\t\\t// Ensure the created nodes are orphaned (#12392)\\n\\t\\t\\t\\ttmp.textContent = \\\"\\\";\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t// Remove wrapper from fragment\\n\\tfragment.textContent = \\\"\\\";\\n\\n\\ti = 0;\\n\\twhile ( ( elem = nodes[ i++ ] ) ) {\\n\\n\\t\\t// Skip elements already in the context collection (trac-4087)\\n\\t\\tif ( selection && jQuery.inArray( elem, selection ) > -1 ) {\\n\\t\\t\\tif ( ignored ) {\\n\\t\\t\\t\\tignored.push( elem );\\n\\t\\t\\t}\\n\\t\\t\\tcontinue;\\n\\t\\t}\\n\\n\\t\\tcontains = jQuery.contains( elem.ownerDocument, elem );\\n\\n\\t\\t// Append to fragment\\n\\t\\ttmp = getAll( fragment.appendChild( elem ), \\\"script\\\" );\\n\\n\\t\\t// Preserve script evaluation history\\n\\t\\tif ( contains ) {\\n\\t\\t\\tsetGlobalEval( tmp );\\n\\t\\t}\\n\\n\\t\\t// Capture executables\\n\\t\\tif ( scripts ) {\\n\\t\\t\\tj = 0;\\n\\t\\t\\twhile ( ( elem = tmp[ j++ ] ) ) {\\n\\t\\t\\t\\tif ( rscriptType.test( elem.type || \\\"\\\" ) ) {\\n\\t\\t\\t\\t\\tscripts.push( elem );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn fragment;\\n}\\n\\n\\n( function() {\\n\\tvar fragment = document.createDocumentFragment(),\\n\\t\\tdiv = fragment.appendChild( document.createElement( \\\"div\\\" ) ),\\n\\t\\tinput = document.createElement( \\\"input\\\" );\\n\\n\\t// Support: Android 4.0 - 4.3 only\\n\\t// Check state lost if the name is set (#11217)\\n\\t// Support: Windows Web Apps (WWA)\\n\\t// `name` and `type` must use .setAttribute for WWA (#14901)\\n\\tinput.setAttribute( \\\"type\\\", \\\"radio\\\" );\\n\\tinput.setAttribute( \\\"checked\\\", \\\"checked\\\" );\\n\\tinput.setAttribute( \\\"name\\\", \\\"t\\\" );\\n\\n\\tdiv.appendChild( input );\\n\\n\\t// Support: Android <=4.1 only\\n\\t// Older WebKit doesn't clone checked state correctly in fragments\\n\\tsupport.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;\\n\\n\\t// Support: IE <=11 only\\n\\t// Make sure textarea (and checkbox) defaultValue is properly cloned\\n\\tdiv.innerHTML = \\\"<textarea>x</textarea>\\\";\\n\\tsupport.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;\\n} )();\\nvar documentElement = document.documentElement;\\n\\n\\n\\nvar\\n\\trkeyEvent = /^key/,\\n\\trmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,\\n\\trtypenamespace = /^([^.]*)(?:\\\\.(.+)|)/;\\n\\nfunction returnTrue() {\\n\\treturn true;\\n}\\n\\nfunction returnFalse() {\\n\\treturn false;\\n}\\n\\n// Support: IE <=9 only\\n// See #13393 for more info\\nfunction safeActiveElement() {\\n\\ttry {\\n\\t\\treturn document.activeElement;\\n\\t} catch ( err ) { }\\n}\\n\\nfunction on( elem, types, selector, data, fn, one ) {\\n\\tvar origFn, type;\\n\\n\\t// Types can be a map of types/handlers\\n\\tif ( typeof types === \\\"object\\\" ) {\\n\\n\\t\\t// ( types-Object, selector, data )\\n\\t\\tif ( typeof selector !== \\\"string\\\" ) {\\n\\n\\t\\t\\t// ( types-Object, data )\\n\\t\\t\\tdata = data || selector;\\n\\t\\t\\tselector = undefined;\\n\\t\\t}\\n\\t\\tfor ( type in types ) {\\n\\t\\t\\ton( elem, type, selector, data, types[ type ], one );\\n\\t\\t}\\n\\t\\treturn elem;\\n\\t}\\n\\n\\tif ( data == null && fn == null ) {\\n\\n\\t\\t// ( types, fn )\\n\\t\\tfn = selector;\\n\\t\\tdata = selector = undefined;\\n\\t} else if ( fn == null ) {\\n\\t\\tif ( typeof selector === \\\"string\\\" ) {\\n\\n\\t\\t\\t// ( types, selector, fn )\\n\\t\\t\\tfn = data;\\n\\t\\t\\tdata = undefined;\\n\\t\\t} else {\\n\\n\\t\\t\\t// ( types, data, fn )\\n\\t\\t\\tfn = data;\\n\\t\\t\\tdata = selector;\\n\\t\\t\\tselector = undefined;\\n\\t\\t}\\n\\t}\\n\\tif ( fn === false ) {\\n\\t\\tfn = returnFalse;\\n\\t} else if ( !fn ) {\\n\\t\\treturn elem;\\n\\t}\\n\\n\\tif ( one === 1 ) {\\n\\t\\torigFn = fn;\\n\\t\\tfn = function( event ) {\\n\\n\\t\\t\\t// Can use an empty set, since event contains the info\\n\\t\\t\\tjQuery().off( event );\\n\\t\\t\\treturn origFn.apply( this, arguments );\\n\\t\\t};\\n\\n\\t\\t// Use same guid so caller can remove using origFn\\n\\t\\tfn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );\\n\\t}\\n\\treturn elem.each( function() {\\n\\t\\tjQuery.event.add( this, types, fn, data, selector );\\n\\t} );\\n}\\n\\n/*\\n * Helper functions for managing events -- not part of the public interface.\\n * Props to Dean Edwards' addEvent library for many of the ideas.\\n */\\njQuery.event = {\\n\\n\\tglobal: {},\\n\\n\\tadd: function( elem, types, handler, data, selector ) {\\n\\n\\t\\tvar handleObjIn, eventHandle, tmp,\\n\\t\\t\\tevents, t, handleObj,\\n\\t\\t\\tspecial, handlers, type, namespaces, origType,\\n\\t\\t\\telemData = dataPriv.get( elem );\\n\\n\\t\\t// Don't attach events to noData or text/comment nodes (but allow plain objects)\\n\\t\\tif ( !elemData ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\t// Caller can pass in an object of custom data in lieu of the handler\\n\\t\\tif ( handler.handler ) {\\n\\t\\t\\thandleObjIn = handler;\\n\\t\\t\\thandler = handleObjIn.handler;\\n\\t\\t\\tselector = handleObjIn.selector;\\n\\t\\t}\\n\\n\\t\\t// Ensure that invalid selectors throw exceptions at attach time\\n\\t\\t// Evaluate against documentElement in case elem is a non-element node (e.g., document)\\n\\t\\tif ( selector ) {\\n\\t\\t\\tjQuery.find.matchesSelector( documentElement, selector );\\n\\t\\t}\\n\\n\\t\\t// Make sure that the handler has a unique ID, used to find/remove it later\\n\\t\\tif ( !handler.guid ) {\\n\\t\\t\\thandler.guid = jQuery.guid++;\\n\\t\\t}\\n\\n\\t\\t// Init the element's event structure and main handler, if this is the first\\n\\t\\tif ( !( events = elemData.events ) ) {\\n\\t\\t\\tevents = elemData.events = {};\\n\\t\\t}\\n\\t\\tif ( !( eventHandle = elemData.handle ) ) {\\n\\t\\t\\teventHandle = elemData.handle = function( e ) {\\n\\n\\t\\t\\t\\t// Discard the second event of a jQuery.event.trigger() and\\n\\t\\t\\t\\t// when an event is called after a page has unloaded\\n\\t\\t\\t\\treturn typeof jQuery !== \\\"undefined\\\" && jQuery.event.triggered !== e.type ?\\n\\t\\t\\t\\t\\tjQuery.event.dispatch.apply( elem, arguments ) : undefined;\\n\\t\\t\\t};\\n\\t\\t}\\n\\n\\t\\t// Handle multiple events separated by a space\\n\\t\\ttypes = ( types || \\\"\\\" ).match( rnothtmlwhite ) || [ \\\"\\\" ];\\n\\t\\tt = types.length;\\n\\t\\twhile ( t-- ) {\\n\\t\\t\\ttmp = rtypenamespace.exec( types[ t ] ) || [];\\n\\t\\t\\ttype = origType = tmp[ 1 ];\\n\\t\\t\\tnamespaces = ( tmp[ 2 ] || \\\"\\\" ).split( \\\".\\\" ).sort();\\n\\n\\t\\t\\t// There *must* be a type, no attaching namespace-only handlers\\n\\t\\t\\tif ( !type ) {\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// If event changes its type, use the special event handlers for the changed type\\n\\t\\t\\tspecial = jQuery.event.special[ type ] || {};\\n\\n\\t\\t\\t// If selector defined, determine special event api type, otherwise given type\\n\\t\\t\\ttype = ( selector ? special.delegateType : special.bindType ) || type;\\n\\n\\t\\t\\t// Update special based on newly reset type\\n\\t\\t\\tspecial = jQuery.event.special[ type ] || {};\\n\\n\\t\\t\\t// handleObj is passed to all event handlers\\n\\t\\t\\thandleObj = jQuery.extend( {\\n\\t\\t\\t\\ttype: type,\\n\\t\\t\\t\\torigType: origType,\\n\\t\\t\\t\\tdata: data,\\n\\t\\t\\t\\thandler: handler,\\n\\t\\t\\t\\tguid: handler.guid,\\n\\t\\t\\t\\tselector: selector,\\n\\t\\t\\t\\tneedsContext: selector && jQuery.expr.match.needsContext.test( selector ),\\n\\t\\t\\t\\tnamespace: namespaces.join( \\\".\\\" )\\n\\t\\t\\t}, handleObjIn );\\n\\n\\t\\t\\t// Init the event handler queue if we're the first\\n\\t\\t\\tif ( !( handlers = events[ type ] ) ) {\\n\\t\\t\\t\\thandlers = events[ type ] = [];\\n\\t\\t\\t\\thandlers.delegateCount = 0;\\n\\n\\t\\t\\t\\t// Only use addEventListener if the special events handler returns false\\n\\t\\t\\t\\tif ( !special.setup ||\\n\\t\\t\\t\\t\\tspecial.setup.call( elem, data, namespaces, eventHandle ) === false ) {\\n\\n\\t\\t\\t\\t\\tif ( elem.addEventListener ) {\\n\\t\\t\\t\\t\\t\\telem.addEventListener( type, eventHandle );\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( special.add ) {\\n\\t\\t\\t\\tspecial.add.call( elem, handleObj );\\n\\n\\t\\t\\t\\tif ( !handleObj.handler.guid ) {\\n\\t\\t\\t\\t\\thandleObj.handler.guid = handler.guid;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Add to the element's handler list, delegates in front\\n\\t\\t\\tif ( selector ) {\\n\\t\\t\\t\\thandlers.splice( handlers.delegateCount++, 0, handleObj );\\n\\t\\t\\t} else {\\n\\t\\t\\t\\thandlers.push( handleObj );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Keep track of which events have ever been used, for event optimization\\n\\t\\t\\tjQuery.event.global[ type ] = true;\\n\\t\\t}\\n\\n\\t},\\n\\n\\t// Detach an event or set of events from an element\\n\\tremove: function( elem, types, handler, selector, mappedTypes ) {\\n\\n\\t\\tvar j, origCount, tmp,\\n\\t\\t\\tevents, t, handleObj,\\n\\t\\t\\tspecial, handlers, type, namespaces, origType,\\n\\t\\t\\telemData = dataPriv.hasData( elem ) && dataPriv.get( elem );\\n\\n\\t\\tif ( !elemData || !( events = elemData.events ) ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\t// Once for each type.namespace in types; type may be omitted\\n\\t\\ttypes = ( types || \\\"\\\" ).match( rnothtmlwhite ) || [ \\\"\\\" ];\\n\\t\\tt = types.length;\\n\\t\\twhile ( t-- ) {\\n\\t\\t\\ttmp = rtypenamespace.exec( types[ t ] ) || [];\\n\\t\\t\\ttype = origType = tmp[ 1 ];\\n\\t\\t\\tnamespaces = ( tmp[ 2 ] || \\\"\\\" ).split( \\\".\\\" ).sort();\\n\\n\\t\\t\\t// Unbind all events (on this namespace, if provided) for the element\\n\\t\\t\\tif ( !type ) {\\n\\t\\t\\t\\tfor ( type in events ) {\\n\\t\\t\\t\\t\\tjQuery.event.remove( elem, type + types[ t ], handler, selector, true );\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\n\\t\\t\\tspecial = jQuery.event.special[ type ] || {};\\n\\t\\t\\ttype = ( selector ? special.delegateType : special.bindType ) || type;\\n\\t\\t\\thandlers = events[ type ] || [];\\n\\t\\t\\ttmp = tmp[ 2 ] &&\\n\\t\\t\\t\\tnew RegExp( \\\"(^|\\\\\\\\.)\\\" + namespaces.join( \\\"\\\\\\\\.(?:.*\\\\\\\\.|)\\\" ) + \\\"(\\\\\\\\.|$)\\\" );\\n\\n\\t\\t\\t// Remove matching events\\n\\t\\t\\torigCount = j = handlers.length;\\n\\t\\t\\twhile ( j-- ) {\\n\\t\\t\\t\\thandleObj = handlers[ j ];\\n\\n\\t\\t\\t\\tif ( ( mappedTypes || origType === handleObj.origType ) &&\\n\\t\\t\\t\\t\\t( !handler || handler.guid === handleObj.guid ) &&\\n\\t\\t\\t\\t\\t( !tmp || tmp.test( handleObj.namespace ) ) &&\\n\\t\\t\\t\\t\\t( !selector || selector === handleObj.selector ||\\n\\t\\t\\t\\t\\t\\tselector === \\\"**\\\" && handleObj.selector ) ) {\\n\\t\\t\\t\\t\\thandlers.splice( j, 1 );\\n\\n\\t\\t\\t\\t\\tif ( handleObj.selector ) {\\n\\t\\t\\t\\t\\t\\thandlers.delegateCount--;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif ( special.remove ) {\\n\\t\\t\\t\\t\\t\\tspecial.remove.call( elem, handleObj );\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Remove generic event handler if we removed something and no more handlers exist\\n\\t\\t\\t// (avoids potential for endless recursion during removal of special event handlers)\\n\\t\\t\\tif ( origCount && !handlers.length ) {\\n\\t\\t\\t\\tif ( !special.teardown ||\\n\\t\\t\\t\\t\\tspecial.teardown.call( elem, namespaces, elemData.handle ) === false ) {\\n\\n\\t\\t\\t\\t\\tjQuery.removeEvent( elem, type, elemData.handle );\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tdelete events[ type ];\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// Remove data and the expando if it's no longer used\\n\\t\\tif ( jQuery.isEmptyObject( events ) ) {\\n\\t\\t\\tdataPriv.remove( elem, \\\"handle events\\\" );\\n\\t\\t}\\n\\t},\\n\\n\\tdispatch: function( nativeEvent ) {\\n\\n\\t\\t// Make a writable jQuery.Event from the native event object\\n\\t\\tvar event = jQuery.event.fix( nativeEvent );\\n\\n\\t\\tvar i, j, ret, matched, handleObj, handlerQueue,\\n\\t\\t\\targs = new Array( arguments.length ),\\n\\t\\t\\thandlers = ( dataPriv.get( this, \\\"events\\\" ) || {} )[ event.type ] || [],\\n\\t\\t\\tspecial = jQuery.event.special[ event.type ] || {};\\n\\n\\t\\t// Use the fix-ed jQuery.Event rather than the (read-only) native event\\n\\t\\targs[ 0 ] = event;\\n\\n\\t\\tfor ( i = 1; i < arguments.length; i++ ) {\\n\\t\\t\\targs[ i ] = arguments[ i ];\\n\\t\\t}\\n\\n\\t\\tevent.delegateTarget = this;\\n\\n\\t\\t// Call the preDispatch hook for the mapped type, and let it bail if desired\\n\\t\\tif ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\t// Determine handlers\\n\\t\\thandlerQueue = jQuery.event.handlers.call( this, event, handlers );\\n\\n\\t\\t// Run delegates first; they may want to stop propagation beneath us\\n\\t\\ti = 0;\\n\\t\\twhile ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {\\n\\t\\t\\tevent.currentTarget = matched.elem;\\n\\n\\t\\t\\tj = 0;\\n\\t\\t\\twhile ( ( handleObj = matched.handlers[ j++ ] ) &&\\n\\t\\t\\t\\t!event.isImmediatePropagationStopped() ) {\\n\\n\\t\\t\\t\\t// Triggered event must either 1) have no namespace, or 2) have namespace(s)\\n\\t\\t\\t\\t// a subset or equal to those in the bound event (both can have no namespace).\\n\\t\\t\\t\\tif ( !event.rnamespace || event.rnamespace.test( handleObj.namespace ) ) {\\n\\n\\t\\t\\t\\t\\tevent.handleObj = handleObj;\\n\\t\\t\\t\\t\\tevent.data = handleObj.data;\\n\\n\\t\\t\\t\\t\\tret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||\\n\\t\\t\\t\\t\\t\\thandleObj.handler ).apply( matched.elem, args );\\n\\n\\t\\t\\t\\t\\tif ( ret !== undefined ) {\\n\\t\\t\\t\\t\\t\\tif ( ( event.result = ret ) === false ) {\\n\\t\\t\\t\\t\\t\\t\\tevent.preventDefault();\\n\\t\\t\\t\\t\\t\\t\\tevent.stopPropagation();\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// Call the postDispatch hook for the mapped type\\n\\t\\tif ( special.postDispatch ) {\\n\\t\\t\\tspecial.postDispatch.call( this, event );\\n\\t\\t}\\n\\n\\t\\treturn event.result;\\n\\t},\\n\\n\\thandlers: function( event, handlers ) {\\n\\t\\tvar i, handleObj, sel, matchedHandlers, matchedSelectors,\\n\\t\\t\\thandlerQueue = [],\\n\\t\\t\\tdelegateCount = handlers.delegateCount,\\n\\t\\t\\tcur = event.target;\\n\\n\\t\\t// Find delegate handlers\\n\\t\\tif ( delegateCount &&\\n\\n\\t\\t\\t// Support: IE <=9\\n\\t\\t\\t// Black-hole SVG <use> instance trees (trac-13180)\\n\\t\\t\\tcur.nodeType &&\\n\\n\\t\\t\\t// Support: Firefox <=42\\n\\t\\t\\t// Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)\\n\\t\\t\\t// https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click\\n\\t\\t\\t// Support: IE 11 only\\n\\t\\t\\t// ...but not arrow key \\\"clicks\\\" of radio inputs, which can have `button` -1 (gh-2343)\\n\\t\\t\\t!( event.type === \\\"click\\\" && event.button >= 1 ) ) {\\n\\n\\t\\t\\tfor ( ; cur !== this; cur = cur.parentNode || this ) {\\n\\n\\t\\t\\t\\t// Don't check non-elements (#13208)\\n\\t\\t\\t\\t// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)\\n\\t\\t\\t\\tif ( cur.nodeType === 1 && !( event.type === \\\"click\\\" && cur.disabled === true ) ) {\\n\\t\\t\\t\\t\\tmatchedHandlers = [];\\n\\t\\t\\t\\t\\tmatchedSelectors = {};\\n\\t\\t\\t\\t\\tfor ( i = 0; i < delegateCount; i++ ) {\\n\\t\\t\\t\\t\\t\\thandleObj = handlers[ i ];\\n\\n\\t\\t\\t\\t\\t\\t// Don't conflict with Object.prototype properties (#13203)\\n\\t\\t\\t\\t\\t\\tsel = handleObj.selector + \\\" \\\";\\n\\n\\t\\t\\t\\t\\t\\tif ( matchedSelectors[ sel ] === undefined ) {\\n\\t\\t\\t\\t\\t\\t\\tmatchedSelectors[ sel ] = handleObj.needsContext ?\\n\\t\\t\\t\\t\\t\\t\\t\\tjQuery( sel, this ).index( cur ) > -1 :\\n\\t\\t\\t\\t\\t\\t\\t\\tjQuery.find( sel, this, null, [ cur ] ).length;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tif ( matchedSelectors[ sel ] ) {\\n\\t\\t\\t\\t\\t\\t\\tmatchedHandlers.push( handleObj );\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif ( matchedHandlers.length ) {\\n\\t\\t\\t\\t\\t\\thandlerQueue.push( { elem: cur, handlers: matchedHandlers } );\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// Add the remaining (directly-bound) handlers\\n\\t\\tcur = this;\\n\\t\\tif ( delegateCount < handlers.length ) {\\n\\t\\t\\thandlerQueue.push( { elem: cur, handlers: handlers.slice( delegateCount ) } );\\n\\t\\t}\\n\\n\\t\\treturn handlerQueue;\\n\\t},\\n\\n\\taddProp: function( name, hook ) {\\n\\t\\tObject.defineProperty( jQuery.Event.prototype, name, {\\n\\t\\t\\tenumerable: true,\\n\\t\\t\\tconfigurable: true,\\n\\n\\t\\t\\tget: isFunction( hook ) ?\\n\\t\\t\\t\\tfunction() {\\n\\t\\t\\t\\t\\tif ( this.originalEvent ) {\\n\\t\\t\\t\\t\\t\\t\\treturn hook( this.originalEvent );\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t} :\\n\\t\\t\\t\\tfunction() {\\n\\t\\t\\t\\t\\tif ( this.originalEvent ) {\\n\\t\\t\\t\\t\\t\\t\\treturn this.originalEvent[ name ];\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t},\\n\\n\\t\\t\\tset: function( value ) {\\n\\t\\t\\t\\tObject.defineProperty( this, name, {\\n\\t\\t\\t\\t\\tenumerable: true,\\n\\t\\t\\t\\t\\tconfigurable: true,\\n\\t\\t\\t\\t\\twritable: true,\\n\\t\\t\\t\\t\\tvalue: value\\n\\t\\t\\t\\t} );\\n\\t\\t\\t}\\n\\t\\t} );\\n\\t},\\n\\n\\tfix: function( originalEvent ) {\\n\\t\\treturn originalEvent[ jQuery.expando ] ?\\n\\t\\t\\toriginalEvent :\\n\\t\\t\\tnew jQuery.Event( originalEvent );\\n\\t},\\n\\n\\tspecial: {\\n\\t\\tload: {\\n\\n\\t\\t\\t// Prevent triggered image.load events from bubbling to window.load\\n\\t\\t\\tnoBubble: true\\n\\t\\t},\\n\\t\\tfocus: {\\n\\n\\t\\t\\t// Fire native event if possible so blur/focus sequence is correct\\n\\t\\t\\ttrigger: function() {\\n\\t\\t\\t\\tif ( this !== safeActiveElement() && this.focus ) {\\n\\t\\t\\t\\t\\tthis.focus();\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t},\\n\\t\\t\\tdelegateType: \\\"focusin\\\"\\n\\t\\t},\\n\\t\\tblur: {\\n\\t\\t\\ttrigger: function() {\\n\\t\\t\\t\\tif ( this === safeActiveElement() && this.blur ) {\\n\\t\\t\\t\\t\\tthis.blur();\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t},\\n\\t\\t\\tdelegateType: \\\"focusout\\\"\\n\\t\\t},\\n\\t\\tclick: {\\n\\n\\t\\t\\t// For checkbox, fire native event so checked state will be right\\n\\t\\t\\ttrigger: function() {\\n\\t\\t\\t\\tif ( this.type === \\\"checkbox\\\" && this.click && nodeName( this, \\\"input\\\" ) ) {\\n\\t\\t\\t\\t\\tthis.click();\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t},\\n\\n\\t\\t\\t// For cross-browser consistency, don't fire native .click() on links\\n\\t\\t\\t_default: function( event ) {\\n\\t\\t\\t\\treturn nodeName( event.target, \\\"a\\\" );\\n\\t\\t\\t}\\n\\t\\t},\\n\\n\\t\\tbeforeunload: {\\n\\t\\t\\tpostDispatch: function( event ) {\\n\\n\\t\\t\\t\\t// Support: Firefox 20+\\n\\t\\t\\t\\t// Firefox doesn't alert if the returnValue field is not set.\\n\\t\\t\\t\\tif ( event.result !== undefined && event.originalEvent ) {\\n\\t\\t\\t\\t\\tevent.originalEvent.returnValue = event.result;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n};\\n\\njQuery.removeEvent = function( elem, type, handle ) {\\n\\n\\t// This \\\"if\\\" is needed for plain objects\\n\\tif ( elem.removeEventListener ) {\\n\\t\\telem.removeEventListener( type, handle );\\n\\t}\\n};\\n\\njQuery.Event = function( src, props ) {\\n\\n\\t// Allow instantiation without the 'new' keyword\\n\\tif ( !( this instanceof jQuery.Event ) ) {\\n\\t\\treturn new jQuery.Event( src, props );\\n\\t}\\n\\n\\t// Event object\\n\\tif ( src && src.type ) {\\n\\t\\tthis.originalEvent = src;\\n\\t\\tthis.type = src.type;\\n\\n\\t\\t// Events bubbling up the document may have been marked as prevented\\n\\t\\t// by a handler lower down the tree; reflect the correct value.\\n\\t\\tthis.isDefaultPrevented = src.defaultPrevented ||\\n\\t\\t\\t\\tsrc.defaultPrevented === undefined &&\\n\\n\\t\\t\\t\\t// Support: Android <=2.3 only\\n\\t\\t\\t\\tsrc.returnValue === false ?\\n\\t\\t\\treturnTrue :\\n\\t\\t\\treturnFalse;\\n\\n\\t\\t// Create target properties\\n\\t\\t// Support: Safari <=6 - 7 only\\n\\t\\t// Target should not be a text node (#504, #13143)\\n\\t\\tthis.target = ( src.target && src.target.nodeType === 3 ) ?\\n\\t\\t\\tsrc.target.parentNode :\\n\\t\\t\\tsrc.target;\\n\\n\\t\\tthis.currentTarget = src.currentTarget;\\n\\t\\tthis.relatedTarget = src.relatedTarget;\\n\\n\\t// Event type\\n\\t} else {\\n\\t\\tthis.type = src;\\n\\t}\\n\\n\\t// Put explicitly provided properties onto the event object\\n\\tif ( props ) {\\n\\t\\tjQuery.extend( this, props );\\n\\t}\\n\\n\\t// Create a timestamp if incoming event doesn't have one\\n\\tthis.timeStamp = src && src.timeStamp || Date.now();\\n\\n\\t// Mark it as fixed\\n\\tthis[ jQuery.expando ] = true;\\n};\\n\\n// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding\\n// https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html\\njQuery.Event.prototype = {\\n\\tconstructor: jQuery.Event,\\n\\tisDefaultPrevented: returnFalse,\\n\\tisPropagationStopped: returnFalse,\\n\\tisImmediatePropagationStopped: returnFalse,\\n\\tisSimulated: false,\\n\\n\\tpreventDefault: function() {\\n\\t\\tvar e = this.originalEvent;\\n\\n\\t\\tthis.isDefaultPrevented = returnTrue;\\n\\n\\t\\tif ( e && !this.isSimulated ) {\\n\\t\\t\\te.preventDefault();\\n\\t\\t}\\n\\t},\\n\\tstopPropagation: function() {\\n\\t\\tvar e = this.originalEvent;\\n\\n\\t\\tthis.isPropagationStopped = returnTrue;\\n\\n\\t\\tif ( e && !this.isSimulated ) {\\n\\t\\t\\te.stopPropagation();\\n\\t\\t}\\n\\t},\\n\\tstopImmediatePropagation: function() {\\n\\t\\tvar e = this.originalEvent;\\n\\n\\t\\tthis.isImmediatePropagationStopped = returnTrue;\\n\\n\\t\\tif ( e && !this.isSimulated ) {\\n\\t\\t\\te.stopImmediatePropagation();\\n\\t\\t}\\n\\n\\t\\tthis.stopPropagation();\\n\\t}\\n};\\n\\n// Includes all common event props including KeyEvent and MouseEvent specific props\\njQuery.each( {\\n\\taltKey: true,\\n\\tbubbles: true,\\n\\tcancelable: true,\\n\\tchangedTouches: true,\\n\\tctrlKey: true,\\n\\tdetail: true,\\n\\teventPhase: true,\\n\\tmetaKey: true,\\n\\tpageX: true,\\n\\tpageY: true,\\n\\tshiftKey: true,\\n\\tview: true,\\n\\t\\\"char\\\": true,\\n\\tcharCode: true,\\n\\tkey: true,\\n\\tkeyCode: true,\\n\\tbutton: true,\\n\\tbuttons: true,\\n\\tclientX: true,\\n\\tclientY: true,\\n\\toffsetX: true,\\n\\toffsetY: true,\\n\\tpointerId: true,\\n\\tpointerType: true,\\n\\tscreenX: true,\\n\\tscreenY: true,\\n\\ttargetTouches: true,\\n\\ttoElement: true,\\n\\ttouches: true,\\n\\n\\twhich: function( event ) {\\n\\t\\tvar button = event.button;\\n\\n\\t\\t// Add which for key events\\n\\t\\tif ( event.which == null && rkeyEvent.test( event.type ) ) {\\n\\t\\t\\treturn event.charCode != null ? event.charCode : event.keyCode;\\n\\t\\t}\\n\\n\\t\\t// Add which for click: 1 === left; 2 === middle; 3 === right\\n\\t\\tif ( !event.which && button !== undefined && rmouseEvent.test( event.type ) ) {\\n\\t\\t\\tif ( button & 1 ) {\\n\\t\\t\\t\\treturn 1;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( button & 2 ) {\\n\\t\\t\\t\\treturn 3;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( button & 4 ) {\\n\\t\\t\\t\\treturn 2;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\n\\t\\treturn event.which;\\n\\t}\\n}, jQuery.event.addProp );\\n\\n// Create mouseenter/leave events using mouseover/out and event-time checks\\n// so that event delegation works in jQuery.\\n// Do the same for pointerenter/pointerleave and pointerover/pointerout\\n//\\n// Support: Safari 7 only\\n// Safari sends mouseenter too often; see:\\n// https://bugs.chromium.org/p/chromium/issues/detail?id=470258\\n// for the description of the bug (it existed in older Chrome versions as well).\\njQuery.each( {\\n\\tmouseenter: \\\"mouseover\\\",\\n\\tmouseleave: \\\"mouseout\\\",\\n\\tpointerenter: \\\"pointerover\\\",\\n\\tpointerleave: \\\"pointerout\\\"\\n}, function( orig, fix ) {\\n\\tjQuery.event.special[ orig ] = {\\n\\t\\tdelegateType: fix,\\n\\t\\tbindType: fix,\\n\\n\\t\\thandle: function( event ) {\\n\\t\\t\\tvar ret,\\n\\t\\t\\t\\ttarget = this,\\n\\t\\t\\t\\trelated = event.relatedTarget,\\n\\t\\t\\t\\thandleObj = event.handleObj;\\n\\n\\t\\t\\t// For mouseenter/leave call the handler if related is outside the target.\\n\\t\\t\\t// NB: No relatedTarget if the mouse left/entered the browser window\\n\\t\\t\\tif ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {\\n\\t\\t\\t\\tevent.type = handleObj.origType;\\n\\t\\t\\t\\tret = handleObj.handler.apply( this, arguments );\\n\\t\\t\\t\\tevent.type = fix;\\n\\t\\t\\t}\\n\\t\\t\\treturn ret;\\n\\t\\t}\\n\\t};\\n} );\\n\\njQuery.fn.extend( {\\n\\n\\ton: function( types, selector, data, fn ) {\\n\\t\\treturn on( this, types, selector, data, fn );\\n\\t},\\n\\tone: function( types, selector, data, fn ) {\\n\\t\\treturn on( this, types, selector, data, fn, 1 );\\n\\t},\\n\\toff: function( types, selector, fn ) {\\n\\t\\tvar handleObj, type;\\n\\t\\tif ( types && types.preventDefault && types.handleObj ) {\\n\\n\\t\\t\\t// ( event )  dispatched jQuery.Event\\n\\t\\t\\thandleObj = types.handleObj;\\n\\t\\t\\tjQuery( types.delegateTarget ).off(\\n\\t\\t\\t\\thandleObj.namespace ?\\n\\t\\t\\t\\t\\thandleObj.origType + \\\".\\\" + handleObj.namespace :\\n\\t\\t\\t\\t\\thandleObj.origType,\\n\\t\\t\\t\\thandleObj.selector,\\n\\t\\t\\t\\thandleObj.handler\\n\\t\\t\\t);\\n\\t\\t\\treturn this;\\n\\t\\t}\\n\\t\\tif ( typeof types === \\\"object\\\" ) {\\n\\n\\t\\t\\t// ( types-object [, selector] )\\n\\t\\t\\tfor ( type in types ) {\\n\\t\\t\\t\\tthis.off( type, selector, types[ type ] );\\n\\t\\t\\t}\\n\\t\\t\\treturn this;\\n\\t\\t}\\n\\t\\tif ( selector === false || typeof selector === \\\"function\\\" ) {\\n\\n\\t\\t\\t// ( types [, fn] )\\n\\t\\t\\tfn = selector;\\n\\t\\t\\tselector = undefined;\\n\\t\\t}\\n\\t\\tif ( fn === false ) {\\n\\t\\t\\tfn = returnFalse;\\n\\t\\t}\\n\\t\\treturn this.each( function() {\\n\\t\\t\\tjQuery.event.remove( this, types, fn, selector );\\n\\t\\t} );\\n\\t}\\n} );\\n\\n\\nvar\\n\\n\\t/* eslint-disable max-len */\\n\\n\\t// See https://github.com/eslint/eslint/issues/3229\\n\\trxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\\\\/\\\\0>\\\\x20\\\\t\\\\r\\\\n\\\\f]*)[^>]*)\\\\/>/gi,\\n\\n\\t/* eslint-enable */\\n\\n\\t// Support: IE <=10 - 11, Edge 12 - 13 only\\n\\t// In IE/Edge using regex groups here causes severe slowdowns.\\n\\t// See https://connect.microsoft.com/IE/feedback/details/1736512/\\n\\trnoInnerhtml = /<script|<style|<link/i,\\n\\n\\t// checked=\\\"checked\\\" or checked\\n\\trchecked = /checked\\\\s*(?:[^=]|=\\\\s*.checked.)/i,\\n\\trcleanScript = /^\\\\s*<!(?:\\\\[CDATA\\\\[|--)|(?:\\\\]\\\\]|--)>\\\\s*$/g;\\n\\n// Prefer a tbody over its parent table for containing new rows\\nfunction manipulationTarget( elem, content ) {\\n\\tif ( nodeName( elem, \\\"table\\\" ) &&\\n\\t\\tnodeName( content.nodeType !== 11 ? content : content.firstChild, \\\"tr\\\" ) ) {\\n\\n\\t\\treturn jQuery( elem ).children( \\\"tbody\\\" )[ 0 ] || elem;\\n\\t}\\n\\n\\treturn elem;\\n}\\n\\n// Replace/restore the type attribute of script elements for safe DOM manipulation\\nfunction disableScript( elem ) {\\n\\telem.type = ( elem.getAttribute( \\\"type\\\" ) !== null ) + \\\"/\\\" + elem.type;\\n\\treturn elem;\\n}\\nfunction restoreScript( elem ) {\\n\\tif ( ( elem.type || \\\"\\\" ).slice( 0, 5 ) === \\\"true/\\\" ) {\\n\\t\\telem.type = elem.type.slice( 5 );\\n\\t} else {\\n\\t\\telem.removeAttribute( \\\"type\\\" );\\n\\t}\\n\\n\\treturn elem;\\n}\\n\\nfunction cloneCopyEvent( src, dest ) {\\n\\tvar i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;\\n\\n\\tif ( dest.nodeType !== 1 ) {\\n\\t\\treturn;\\n\\t}\\n\\n\\t// 1. Copy private data: events, handlers, etc.\\n\\tif ( dataPriv.hasData( src ) ) {\\n\\t\\tpdataOld = dataPriv.access( src );\\n\\t\\tpdataCur = dataPriv.set( dest, pdataOld );\\n\\t\\tevents = pdataOld.events;\\n\\n\\t\\tif ( events ) {\\n\\t\\t\\tdelete pdataCur.handle;\\n\\t\\t\\tpdataCur.events = {};\\n\\n\\t\\t\\tfor ( type in events ) {\\n\\t\\t\\t\\tfor ( i = 0, l = events[ type ].length; i < l; i++ ) {\\n\\t\\t\\t\\t\\tjQuery.event.add( dest, type, events[ type ][ i ] );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t// 2. Copy user data\\n\\tif ( dataUser.hasData( src ) ) {\\n\\t\\tudataOld = dataUser.access( src );\\n\\t\\tudataCur = jQuery.extend( {}, udataOld );\\n\\n\\t\\tdataUser.set( dest, udataCur );\\n\\t}\\n}\\n\\n// Fix IE bugs, see support tests\\nfunction fixInput( src, dest ) {\\n\\tvar nodeName = dest.nodeName.toLowerCase();\\n\\n\\t// Fails to persist the checked state of a cloned checkbox or radio button.\\n\\tif ( nodeName === \\\"input\\\" && rcheckableType.test( src.type ) ) {\\n\\t\\tdest.checked = src.checked;\\n\\n\\t// Fails to return the selected option to the default selected state when cloning options\\n\\t} else if ( nodeName === \\\"input\\\" || nodeName === \\\"textarea\\\" ) {\\n\\t\\tdest.defaultValue = src.defaultValue;\\n\\t}\\n}\\n\\nfunction domManip( collection, args, callback, ignored ) {\\n\\n\\t// Flatten any nested arrays\\n\\targs = concat.apply( [], args );\\n\\n\\tvar fragment, first, scripts, hasScripts, node, doc,\\n\\t\\ti = 0,\\n\\t\\tl = collection.length,\\n\\t\\tiNoClone = l - 1,\\n\\t\\tvalue = args[ 0 ],\\n\\t\\tvalueIsFunction = isFunction( value );\\n\\n\\t// We can't cloneNode fragments that contain checked, in WebKit\\n\\tif ( valueIsFunction ||\\n\\t\\t\\t( l > 1 && typeof value === \\\"string\\\" &&\\n\\t\\t\\t\\t!support.checkClone && rchecked.test( value ) ) ) {\\n\\t\\treturn collection.each( function( index ) {\\n\\t\\t\\tvar self = collection.eq( index );\\n\\t\\t\\tif ( valueIsFunction ) {\\n\\t\\t\\t\\targs[ 0 ] = value.call( this, index, self.html() );\\n\\t\\t\\t}\\n\\t\\t\\tdomManip( self, args, callback, ignored );\\n\\t\\t} );\\n\\t}\\n\\n\\tif ( l ) {\\n\\t\\tfragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );\\n\\t\\tfirst = fragment.firstChild;\\n\\n\\t\\tif ( fragment.childNodes.length === 1 ) {\\n\\t\\t\\tfragment = first;\\n\\t\\t}\\n\\n\\t\\t// Require either new content or an interest in ignored elements to invoke the callback\\n\\t\\tif ( first || ignored ) {\\n\\t\\t\\tscripts = jQuery.map( getAll( fragment, \\\"script\\\" ), disableScript );\\n\\t\\t\\thasScripts = scripts.length;\\n\\n\\t\\t\\t// Use the original fragment for the last item\\n\\t\\t\\t// instead of the first because it can end up\\n\\t\\t\\t// being emptied incorrectly in certain situations (#8070).\\n\\t\\t\\tfor ( ; i < l; i++ ) {\\n\\t\\t\\t\\tnode = fragment;\\n\\n\\t\\t\\t\\tif ( i !== iNoClone ) {\\n\\t\\t\\t\\t\\tnode = jQuery.clone( node, true, true );\\n\\n\\t\\t\\t\\t\\t// Keep references to cloned scripts for later restoration\\n\\t\\t\\t\\t\\tif ( hasScripts ) {\\n\\n\\t\\t\\t\\t\\t\\t// Support: Android <=4.0 only, PhantomJS 1 only\\n\\t\\t\\t\\t\\t\\t// push.apply(_, arraylike) throws on ancient WebKit\\n\\t\\t\\t\\t\\t\\tjQuery.merge( scripts, getAll( node, \\\"script\\\" ) );\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tcallback.call( collection[ i ], node, i );\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( hasScripts ) {\\n\\t\\t\\t\\tdoc = scripts[ scripts.length - 1 ].ownerDocument;\\n\\n\\t\\t\\t\\t// Reenable scripts\\n\\t\\t\\t\\tjQuery.map( scripts, restoreScript );\\n\\n\\t\\t\\t\\t// Evaluate executable scripts on first document insertion\\n\\t\\t\\t\\tfor ( i = 0; i < hasScripts; i++ ) {\\n\\t\\t\\t\\t\\tnode = scripts[ i ];\\n\\t\\t\\t\\t\\tif ( rscriptType.test( node.type || \\\"\\\" ) &&\\n\\t\\t\\t\\t\\t\\t!dataPriv.access( node, \\\"globalEval\\\" ) &&\\n\\t\\t\\t\\t\\t\\tjQuery.contains( doc, node ) ) {\\n\\n\\t\\t\\t\\t\\t\\tif ( node.src && ( node.type || \\\"\\\" ).toLowerCase()  !== \\\"module\\\" ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t// Optional AJAX dependency, but won't run scripts if not present\\n\\t\\t\\t\\t\\t\\t\\tif ( jQuery._evalUrl ) {\\n\\t\\t\\t\\t\\t\\t\\t\\tjQuery._evalUrl( node.src );\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\tDOMEval( node.textContent.replace( rcleanScript, \\\"\\\" ), doc, node );\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn collection;\\n}\\n\\nfunction remove( elem, selector, keepData ) {\\n\\tvar node,\\n\\t\\tnodes = selector ? jQuery.filter( selector, elem ) : elem,\\n\\t\\ti = 0;\\n\\n\\tfor ( ; ( node = nodes[ i ] ) != null; i++ ) {\\n\\t\\tif ( !keepData && node.nodeType === 1 ) {\\n\\t\\t\\tjQuery.cleanData( getAll( node ) );\\n\\t\\t}\\n\\n\\t\\tif ( node.parentNode ) {\\n\\t\\t\\tif ( keepData && jQuery.contains( node.ownerDocument, node ) ) {\\n\\t\\t\\t\\tsetGlobalEval( getAll( node, \\\"script\\\" ) );\\n\\t\\t\\t}\\n\\t\\t\\tnode.parentNode.removeChild( node );\\n\\t\\t}\\n\\t}\\n\\n\\treturn elem;\\n}\\n\\njQuery.extend( {\\n\\thtmlPrefilter: function( html ) {\\n\\t\\treturn html.replace( rxhtmlTag, \\\"<$1></$2>\\\" );\\n\\t},\\n\\n\\tclone: function( elem, dataAndEvents, deepDataAndEvents ) {\\n\\t\\tvar i, l, srcElements, destElements,\\n\\t\\t\\tclone = elem.cloneNode( true ),\\n\\t\\t\\tinPage = jQuery.contains( elem.ownerDocument, elem );\\n\\n\\t\\t// Fix IE cloning issues\\n\\t\\tif ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&\\n\\t\\t\\t\\t!jQuery.isXMLDoc( elem ) ) {\\n\\n\\t\\t\\t// We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2\\n\\t\\t\\tdestElements = getAll( clone );\\n\\t\\t\\tsrcElements = getAll( elem );\\n\\n\\t\\t\\tfor ( i = 0, l = srcElements.length; i < l; i++ ) {\\n\\t\\t\\t\\tfixInput( srcElements[ i ], destElements[ i ] );\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// Copy the events from the original to the clone\\n\\t\\tif ( dataAndEvents ) {\\n\\t\\t\\tif ( deepDataAndEvents ) {\\n\\t\\t\\t\\tsrcElements = srcElements || getAll( elem );\\n\\t\\t\\t\\tdestElements = destElements || getAll( clone );\\n\\n\\t\\t\\t\\tfor ( i = 0, l = srcElements.length; i < l; i++ ) {\\n\\t\\t\\t\\t\\tcloneCopyEvent( srcElements[ i ], destElements[ i ] );\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tcloneCopyEvent( elem, clone );\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// Preserve script evaluation history\\n\\t\\tdestElements = getAll( clone, \\\"script\\\" );\\n\\t\\tif ( destElements.length > 0 ) {\\n\\t\\t\\tsetGlobalEval( destElements, !inPage && getAll( elem, \\\"script\\\" ) );\\n\\t\\t}\\n\\n\\t\\t// Return the cloned set\\n\\t\\treturn clone;\\n\\t},\\n\\n\\tcleanData: function( elems ) {\\n\\t\\tvar data, elem, type,\\n\\t\\t\\tspecial = jQuery.event.special,\\n\\t\\t\\ti = 0;\\n\\n\\t\\tfor ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {\\n\\t\\t\\tif ( acceptData( elem ) ) {\\n\\t\\t\\t\\tif ( ( data = elem[ dataPriv.expando ] ) ) {\\n\\t\\t\\t\\t\\tif ( data.events ) {\\n\\t\\t\\t\\t\\t\\tfor ( type in data.events ) {\\n\\t\\t\\t\\t\\t\\t\\tif ( special[ type ] ) {\\n\\t\\t\\t\\t\\t\\t\\t\\tjQuery.event.remove( elem, type );\\n\\n\\t\\t\\t\\t\\t\\t\\t// This is a shortcut to avoid jQuery.event.remove's overhead\\n\\t\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\t\\tjQuery.removeEvent( elem, type, data.handle );\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t// Support: Chrome <=35 - 45+\\n\\t\\t\\t\\t\\t// Assign undefined instead of using delete, see Data#remove\\n\\t\\t\\t\\t\\telem[ dataPriv.expando ] = undefined;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif ( elem[ dataUser.expando ] ) {\\n\\n\\t\\t\\t\\t\\t// Support: Chrome <=35 - 45+\\n\\t\\t\\t\\t\\t// Assign undefined instead of using delete, see Data#remove\\n\\t\\t\\t\\t\\telem[ dataUser.expando ] = undefined;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n} );\\n\\njQuery.fn.extend( {\\n\\tdetach: function( selector ) {\\n\\t\\treturn remove( this, selector, true );\\n\\t},\\n\\n\\tremove: function( selector ) {\\n\\t\\treturn remove( this, selector );\\n\\t},\\n\\n\\ttext: function( value ) {\\n\\t\\treturn access( this, function( value ) {\\n\\t\\t\\treturn value === undefined ?\\n\\t\\t\\t\\tjQuery.text( this ) :\\n\\t\\t\\t\\tthis.empty().each( function() {\\n\\t\\t\\t\\t\\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\\n\\t\\t\\t\\t\\t\\tthis.textContent = value;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t} );\\n\\t\\t}, null, value, arguments.length );\\n\\t},\\n\\n\\tappend: function() {\\n\\t\\treturn domManip( this, arguments, function( elem ) {\\n\\t\\t\\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\\n\\t\\t\\t\\tvar target = manipulationTarget( this, elem );\\n\\t\\t\\t\\ttarget.appendChild( elem );\\n\\t\\t\\t}\\n\\t\\t} );\\n\\t},\\n\\n\\tprepend: function() {\\n\\t\\treturn domManip( this, arguments, function( elem ) {\\n\\t\\t\\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\\n\\t\\t\\t\\tvar target = manipulationTarget( this, elem );\\n\\t\\t\\t\\ttarget.insertBefore( elem, target.firstChild );\\n\\t\\t\\t}\\n\\t\\t} );\\n\\t},\\n\\n\\tbefore: function() {\\n\\t\\treturn domManip( this, arguments, function( elem ) {\\n\\t\\t\\tif ( this.parentNode ) {\\n\\t\\t\\t\\tthis.parentNode.insertBefore( elem, this );\\n\\t\\t\\t}\\n\\t\\t} );\\n\\t},\\n\\n\\tafter: function() {\\n\\t\\treturn domManip( this, arguments, function( elem ) {\\n\\t\\t\\tif ( this.parentNode ) {\\n\\t\\t\\t\\tthis.parentNode.insertBefore( elem, this.nextSibling );\\n\\t\\t\\t}\\n\\t\\t} );\\n\\t},\\n\\n\\tempty: function() {\\n\\t\\tvar elem,\\n\\t\\t\\ti = 0;\\n\\n\\t\\tfor ( ; ( elem = this[ i ] ) != null; i++ ) {\\n\\t\\t\\tif ( elem.nodeType === 1 ) {\\n\\n\\t\\t\\t\\t// Prevent memory leaks\\n\\t\\t\\t\\tjQuery.cleanData( getAll( elem, false ) );\\n\\n\\t\\t\\t\\t// Remove any remaining nodes\\n\\t\\t\\t\\telem.textContent = \\\"\\\";\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn this;\\n\\t},\\n\\n\\tclone: function( dataAndEvents, deepDataAndEvents ) {\\n\\t\\tdataAndEvents = dataAndEvents == null ? false : dataAndEvents;\\n\\t\\tdeepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;\\n\\n\\t\\treturn this.map( function() {\\n\\t\\t\\treturn jQuery.clone( this, dataAndEvents, deepDataAndEvents );\\n\\t\\t} );\\n\\t},\\n\\n\\thtml: function( value ) {\\n\\t\\treturn access( this, function( value ) {\\n\\t\\t\\tvar elem = this[ 0 ] || {},\\n\\t\\t\\t\\ti = 0,\\n\\t\\t\\t\\tl = this.length;\\n\\n\\t\\t\\tif ( value === undefined && elem.nodeType === 1 ) {\\n\\t\\t\\t\\treturn elem.innerHTML;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// See if we can take a shortcut and just use innerHTML\\n\\t\\t\\tif ( typeof value === \\\"string\\\" && !rnoInnerhtml.test( value ) &&\\n\\t\\t\\t\\t!wrapMap[ ( rtagName.exec( value ) || [ \\\"\\\", \\\"\\\" ] )[ 1 ].toLowerCase() ] ) {\\n\\n\\t\\t\\t\\tvalue = jQuery.htmlPrefilter( value );\\n\\n\\t\\t\\t\\ttry {\\n\\t\\t\\t\\t\\tfor ( ; i < l; i++ ) {\\n\\t\\t\\t\\t\\t\\telem = this[ i ] || {};\\n\\n\\t\\t\\t\\t\\t\\t// Remove element nodes and prevent memory leaks\\n\\t\\t\\t\\t\\t\\tif ( elem.nodeType === 1 ) {\\n\\t\\t\\t\\t\\t\\t\\tjQuery.cleanData( getAll( elem, false ) );\\n\\t\\t\\t\\t\\t\\t\\telem.innerHTML = value;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\telem = 0;\\n\\n\\t\\t\\t\\t// If using innerHTML throws an exception, use the fallback method\\n\\t\\t\\t\\t} catch ( e ) {}\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( elem ) {\\n\\t\\t\\t\\tthis.empty().append( value );\\n\\t\\t\\t}\\n\\t\\t}, null, value, arguments.length );\\n\\t},\\n\\n\\treplaceWith: function() {\\n\\t\\tvar ignored = [];\\n\\n\\t\\t// Make the changes, replacing each non-ignored context element with the new content\\n\\t\\treturn domManip( this, arguments, function( elem ) {\\n\\t\\t\\tvar parent = this.parentNode;\\n\\n\\t\\t\\tif ( jQuery.inArray( this, ignored ) < 0 ) {\\n\\t\\t\\t\\tjQuery.cleanData( getAll( this ) );\\n\\t\\t\\t\\tif ( parent ) {\\n\\t\\t\\t\\t\\tparent.replaceChild( elem, this );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t// Force callback invocation\\n\\t\\t}, ignored );\\n\\t}\\n} );\\n\\njQuery.each( {\\n\\tappendTo: \\\"append\\\",\\n\\tprependTo: \\\"prepend\\\",\\n\\tinsertBefore: \\\"before\\\",\\n\\tinsertAfter: \\\"after\\\",\\n\\treplaceAll: \\\"replaceWith\\\"\\n}, function( name, original ) {\\n\\tjQuery.fn[ name ] = function( selector ) {\\n\\t\\tvar elems,\\n\\t\\t\\tret = [],\\n\\t\\t\\tinsert = jQuery( selector ),\\n\\t\\t\\tlast = insert.length - 1,\\n\\t\\t\\ti = 0;\\n\\n\\t\\tfor ( ; i <= last; i++ ) {\\n\\t\\t\\telems = i === last ? this : this.clone( true );\\n\\t\\t\\tjQuery( insert[ i ] )[ original ]( elems );\\n\\n\\t\\t\\t// Support: Android <=4.0 only, PhantomJS 1 only\\n\\t\\t\\t// .get() because push.apply(_, arraylike) throws on ancient WebKit\\n\\t\\t\\tpush.apply( ret, elems.get() );\\n\\t\\t}\\n\\n\\t\\treturn this.pushStack( ret );\\n\\t};\\n} );\\nvar rnumnonpx = new RegExp( \\\"^(\\\" + pnum + \\\")(?!px)[a-z%]+$\\\", \\\"i\\\" );\\n\\nvar getStyles = function( elem ) {\\n\\n\\t\\t// Support: IE <=11 only, Firefox <=30 (#15098, #14150)\\n\\t\\t// IE throws on elements created in popups\\n\\t\\t// FF meanwhile throws on frame elements through \\\"defaultView.getComputedStyle\\\"\\n\\t\\tvar view = elem.ownerDocument.defaultView;\\n\\n\\t\\tif ( !view || !view.opener ) {\\n\\t\\t\\tview = window;\\n\\t\\t}\\n\\n\\t\\treturn view.getComputedStyle( elem );\\n\\t};\\n\\nvar rboxStyle = new RegExp( cssExpand.join( \\\"|\\\" ), \\\"i\\\" );\\n\\n\\n\\n( function() {\\n\\n\\t// Executing both pixelPosition & boxSizingReliable tests require only one layout\\n\\t// so they're executed at the same time to save the second computation.\\n\\tfunction computeStyleTests() {\\n\\n\\t\\t// This is a singleton, we need to execute it only once\\n\\t\\tif ( !div ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tcontainer.style.cssText = \\\"position:absolute;left:-11111px;width:60px;\\\" +\\n\\t\\t\\t\\\"margin-top:1px;padding:0;border:0\\\";\\n\\t\\tdiv.style.cssText =\\n\\t\\t\\t\\\"position:relative;display:block;box-sizing:border-box;overflow:scroll;\\\" +\\n\\t\\t\\t\\\"margin:auto;border:1px;padding:1px;\\\" +\\n\\t\\t\\t\\\"width:60%;top:1%\\\";\\n\\t\\tdocumentElement.appendChild( container ).appendChild( div );\\n\\n\\t\\tvar divStyle = window.getComputedStyle( div );\\n\\t\\tpixelPositionVal = divStyle.top !== \\\"1%\\\";\\n\\n\\t\\t// Support: Android 4.0 - 4.3 only, Firefox <=3 - 44\\n\\t\\treliableMarginLeftVal = roundPixelMeasures( divStyle.marginLeft ) === 12;\\n\\n\\t\\t// Support: Android 4.0 - 4.3 only, Safari <=9.1 - 10.1, iOS <=7.0 - 9.3\\n\\t\\t// Some styles come back with percentage values, even though they shouldn't\\n\\t\\tdiv.style.right = \\\"60%\\\";\\n\\t\\tpixelBoxStylesVal = roundPixelMeasures( divStyle.right ) === 36;\\n\\n\\t\\t// Support: IE 9 - 11 only\\n\\t\\t// Detect misreporting of content dimensions for box-sizing:border-box elements\\n\\t\\tboxSizingReliableVal = roundPixelMeasures( divStyle.width ) === 36;\\n\\n\\t\\t// Support: IE 9 only\\n\\t\\t// Detect overflow:scroll screwiness (gh-3699)\\n\\t\\tdiv.style.position = \\\"absolute\\\";\\n\\t\\tscrollboxSizeVal = div.offsetWidth === 36 || \\\"absolute\\\";\\n\\n\\t\\tdocumentElement.removeChild( container );\\n\\n\\t\\t// Nullify the div so it wouldn't be stored in the memory and\\n\\t\\t// it will also be a sign that checks already performed\\n\\t\\tdiv = null;\\n\\t}\\n\\n\\tfunction roundPixelMeasures( measure ) {\\n\\t\\treturn Math.round( parseFloat( measure ) );\\n\\t}\\n\\n\\tvar pixelPositionVal, boxSizingReliableVal, scrollboxSizeVal, pixelBoxStylesVal,\\n\\t\\treliableMarginLeftVal,\\n\\t\\tcontainer = document.createElement( \\\"div\\\" ),\\n\\t\\tdiv = document.createElement( \\\"div\\\" );\\n\\n\\t// Finish early in limited (non-browser) environments\\n\\tif ( !div.style ) {\\n\\t\\treturn;\\n\\t}\\n\\n\\t// Support: IE <=9 - 11 only\\n\\t// Style of cloned element affects source element cloned (#8908)\\n\\tdiv.style.backgroundClip = \\\"content-box\\\";\\n\\tdiv.cloneNode( true ).style.backgroundClip = \\\"\\\";\\n\\tsupport.clearCloneStyle = div.style.backgroundClip === \\\"content-box\\\";\\n\\n\\tjQuery.extend( support, {\\n\\t\\tboxSizingReliable: function() {\\n\\t\\t\\tcomputeStyleTests();\\n\\t\\t\\treturn boxSizingReliableVal;\\n\\t\\t},\\n\\t\\tpixelBoxStyles: function() {\\n\\t\\t\\tcomputeStyleTests();\\n\\t\\t\\treturn pixelBoxStylesVal;\\n\\t\\t},\\n\\t\\tpixelPosition: function() {\\n\\t\\t\\tcomputeStyleTests();\\n\\t\\t\\treturn pixelPositionVal;\\n\\t\\t},\\n\\t\\treliableMarginLeft: function() {\\n\\t\\t\\tcomputeStyleTests();\\n\\t\\t\\treturn reliableMarginLeftVal;\\n\\t\\t},\\n\\t\\tscrollboxSize: function() {\\n\\t\\t\\tcomputeStyleTests();\\n\\t\\t\\treturn scrollboxSizeVal;\\n\\t\\t}\\n\\t} );\\n} )();\\n\\n\\nfunction curCSS( elem, name, computed ) {\\n\\tvar width, minWidth, maxWidth, ret,\\n\\n\\t\\t// Support: Firefox 51+\\n\\t\\t// Retrieving style before computed somehow\\n\\t\\t// fixes an issue with getting wrong values\\n\\t\\t// on detached elements\\n\\t\\tstyle = elem.style;\\n\\n\\tcomputed = computed || getStyles( elem );\\n\\n\\t// getPropertyValue is needed for:\\n\\t//   .css('filter') (IE 9 only, #12537)\\n\\t//   .css('--customProperty) (#3144)\\n\\tif ( computed ) {\\n\\t\\tret = computed.getPropertyValue( name ) || computed[ name ];\\n\\n\\t\\tif ( ret === \\\"\\\" && !jQuery.contains( elem.ownerDocument, elem ) ) {\\n\\t\\t\\tret = jQuery.style( elem, name );\\n\\t\\t}\\n\\n\\t\\t// A tribute to the \\\"awesome hack by Dean Edwards\\\"\\n\\t\\t// Android Browser returns percentage for some values,\\n\\t\\t// but width seems to be reliably pixels.\\n\\t\\t// This is against the CSSOM draft spec:\\n\\t\\t// https://drafts.csswg.org/cssom/#resolved-values\\n\\t\\tif ( !support.pixelBoxStyles() && rnumnonpx.test( ret ) && rboxStyle.test( name ) ) {\\n\\n\\t\\t\\t// Remember the original values\\n\\t\\t\\twidth = style.width;\\n\\t\\t\\tminWidth = style.minWidth;\\n\\t\\t\\tmaxWidth = style.maxWidth;\\n\\n\\t\\t\\t// Put in the new values to get a computed value out\\n\\t\\t\\tstyle.minWidth = style.maxWidth = style.width = ret;\\n\\t\\t\\tret = computed.width;\\n\\n\\t\\t\\t// Revert the changed values\\n\\t\\t\\tstyle.width = width;\\n\\t\\t\\tstyle.minWidth = minWidth;\\n\\t\\t\\tstyle.maxWidth = maxWidth;\\n\\t\\t}\\n\\t}\\n\\n\\treturn ret !== undefined ?\\n\\n\\t\\t// Support: IE <=9 - 11 only\\n\\t\\t// IE returns zIndex value as an integer.\\n\\t\\tret + \\\"\\\" :\\n\\t\\tret;\\n}\\n\\n\\nfunction addGetHookIf( conditionFn, hookFn ) {\\n\\n\\t// Define the hook, we'll check on the first run if it's really needed.\\n\\treturn {\\n\\t\\tget: function() {\\n\\t\\t\\tif ( conditionFn() ) {\\n\\n\\t\\t\\t\\t// Hook not needed (or it's not possible to use it due\\n\\t\\t\\t\\t// to missing dependency), remove it.\\n\\t\\t\\t\\tdelete this.get;\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Hook needed; redefine it so that the support test is not executed again.\\n\\t\\t\\treturn ( this.get = hookFn ).apply( this, arguments );\\n\\t\\t}\\n\\t};\\n}\\n\\n\\nvar\\n\\n\\t// Swappable if display is none or starts with table\\n\\t// except \\\"table\\\", \\\"table-cell\\\", or \\\"table-caption\\\"\\n\\t// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display\\n\\trdisplayswap = /^(none|table(?!-c[ea]).+)/,\\n\\trcustomProp = /^--/,\\n\\tcssShow = { position: \\\"absolute\\\", visibility: \\\"hidden\\\", display: \\\"block\\\" },\\n\\tcssNormalTransform = {\\n\\t\\tletterSpacing: \\\"0\\\",\\n\\t\\tfontWeight: \\\"400\\\"\\n\\t},\\n\\n\\tcssPrefixes = [ \\\"Webkit\\\", \\\"Moz\\\", \\\"ms\\\" ],\\n\\temptyStyle = document.createElement( \\\"div\\\" ).style;\\n\\n// Return a css property mapped to a potentially vendor prefixed property\\nfunction vendorPropName( name ) {\\n\\n\\t// Shortcut for names that are not vendor prefixed\\n\\tif ( name in emptyStyle ) {\\n\\t\\treturn name;\\n\\t}\\n\\n\\t// Check for vendor prefixed names\\n\\tvar capName = name[ 0 ].toUpperCase() + name.slice( 1 ),\\n\\t\\ti = cssPrefixes.length;\\n\\n\\twhile ( i-- ) {\\n\\t\\tname = cssPrefixes[ i ] + capName;\\n\\t\\tif ( name in emptyStyle ) {\\n\\t\\t\\treturn name;\\n\\t\\t}\\n\\t}\\n}\\n\\n// Return a property mapped along what jQuery.cssProps suggests or to\\n// a vendor prefixed property.\\nfunction finalPropName( name ) {\\n\\tvar ret = jQuery.cssProps[ name ];\\n\\tif ( !ret ) {\\n\\t\\tret = jQuery.cssProps[ name ] = vendorPropName( name ) || name;\\n\\t}\\n\\treturn ret;\\n}\\n\\nfunction setPositiveNumber( elem, value, subtract ) {\\n\\n\\t// Any relative (+/-) values have already been\\n\\t// normalized at this point\\n\\tvar matches = rcssNum.exec( value );\\n\\treturn matches ?\\n\\n\\t\\t// Guard against undefined \\\"subtract\\\", e.g., when used as in cssHooks\\n\\t\\tMath.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || \\\"px\\\" ) :\\n\\t\\tvalue;\\n}\\n\\nfunction boxModelAdjustment( elem, dimension, box, isBorderBox, styles, computedVal ) {\\n\\tvar i = dimension === \\\"width\\\" ? 1 : 0,\\n\\t\\textra = 0,\\n\\t\\tdelta = 0;\\n\\n\\t// Adjustment may not be necessary\\n\\tif ( box === ( isBorderBox ? \\\"border\\\" : \\\"content\\\" ) ) {\\n\\t\\treturn 0;\\n\\t}\\n\\n\\tfor ( ; i < 4; i += 2 ) {\\n\\n\\t\\t// Both box models exclude margin\\n\\t\\tif ( box === \\\"margin\\\" ) {\\n\\t\\t\\tdelta += jQuery.css( elem, box + cssExpand[ i ], true, styles );\\n\\t\\t}\\n\\n\\t\\t// If we get here with a content-box, we're seeking \\\"padding\\\" or \\\"border\\\" or \\\"margin\\\"\\n\\t\\tif ( !isBorderBox ) {\\n\\n\\t\\t\\t// Add padding\\n\\t\\t\\tdelta += jQuery.css( elem, \\\"padding\\\" + cssExpand[ i ], true, styles );\\n\\n\\t\\t\\t// For \\\"border\\\" or \\\"margin\\\", add border\\n\\t\\t\\tif ( box !== \\\"padding\\\" ) {\\n\\t\\t\\t\\tdelta += jQuery.css( elem, \\\"border\\\" + cssExpand[ i ] + \\\"Width\\\", true, styles );\\n\\n\\t\\t\\t// But still keep track of it otherwise\\n\\t\\t\\t} else {\\n\\t\\t\\t\\textra += jQuery.css( elem, \\\"border\\\" + cssExpand[ i ] + \\\"Width\\\", true, styles );\\n\\t\\t\\t}\\n\\n\\t\\t// If we get here with a border-box (content + padding + border), we're seeking \\\"content\\\" or\\n\\t\\t// \\\"padding\\\" or \\\"margin\\\"\\n\\t\\t} else {\\n\\n\\t\\t\\t// For \\\"content\\\", subtract padding\\n\\t\\t\\tif ( box === \\\"content\\\" ) {\\n\\t\\t\\t\\tdelta -= jQuery.css( elem, \\\"padding\\\" + cssExpand[ i ], true, styles );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// For \\\"content\\\" or \\\"padding\\\", subtract border\\n\\t\\t\\tif ( box !== \\\"margin\\\" ) {\\n\\t\\t\\t\\tdelta -= jQuery.css( elem, \\\"border\\\" + cssExpand[ i ] + \\\"Width\\\", true, styles );\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t// Account for positive content-box scroll gutter when requested by providing computedVal\\n\\tif ( !isBorderBox && computedVal >= 0 ) {\\n\\n\\t\\t// offsetWidth/offsetHeight is a rounded sum of content, padding, scroll gutter, and border\\n\\t\\t// Assuming integer scroll gutter, subtract the rest and round down\\n\\t\\tdelta += Math.max( 0, Math.ceil(\\n\\t\\t\\telem[ \\\"offset\\\" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -\\n\\t\\t\\tcomputedVal -\\n\\t\\t\\tdelta -\\n\\t\\t\\textra -\\n\\t\\t\\t0.5\\n\\t\\t) );\\n\\t}\\n\\n\\treturn delta;\\n}\\n\\nfunction getWidthOrHeight( elem, dimension, extra ) {\\n\\n\\t// Start with computed style\\n\\tvar styles = getStyles( elem ),\\n\\t\\tval = curCSS( elem, dimension, styles ),\\n\\t\\tisBorderBox = jQuery.css( elem, \\\"boxSizing\\\", false, styles ) === \\\"border-box\\\",\\n\\t\\tvalueIsBorderBox = isBorderBox;\\n\\n\\t// Support: Firefox <=54\\n\\t// Return a confounding non-pixel value or feign ignorance, as appropriate.\\n\\tif ( rnumnonpx.test( val ) ) {\\n\\t\\tif ( !extra ) {\\n\\t\\t\\treturn val;\\n\\t\\t}\\n\\t\\tval = \\\"auto\\\";\\n\\t}\\n\\n\\t// Check for style in case a browser which returns unreliable values\\n\\t// for getComputedStyle silently falls back to the reliable elem.style\\n\\tvalueIsBorderBox = valueIsBorderBox &&\\n\\t\\t( support.boxSizingReliable() || val === elem.style[ dimension ] );\\n\\n\\t// Fall back to offsetWidth/offsetHeight when value is \\\"auto\\\"\\n\\t// This happens for inline elements with no explicit setting (gh-3571)\\n\\t// Support: Android <=4.1 - 4.3 only\\n\\t// Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)\\n\\tif ( val === \\\"auto\\\" ||\\n\\t\\t!parseFloat( val ) && jQuery.css( elem, \\\"display\\\", false, styles ) === \\\"inline\\\" ) {\\n\\n\\t\\tval = elem[ \\\"offset\\\" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ];\\n\\n\\t\\t// offsetWidth/offsetHeight provide border-box values\\n\\t\\tvalueIsBorderBox = true;\\n\\t}\\n\\n\\t// Normalize \\\"\\\" and auto\\n\\tval = parseFloat( val ) || 0;\\n\\n\\t// Adjust for the element's box model\\n\\treturn ( val +\\n\\t\\tboxModelAdjustment(\\n\\t\\t\\telem,\\n\\t\\t\\tdimension,\\n\\t\\t\\textra || ( isBorderBox ? \\\"border\\\" : \\\"content\\\" ),\\n\\t\\t\\tvalueIsBorderBox,\\n\\t\\t\\tstyles,\\n\\n\\t\\t\\t// Provide the current computed size to request scroll gutter calculation (gh-3589)\\n\\t\\t\\tval\\n\\t\\t)\\n\\t) + \\\"px\\\";\\n}\\n\\njQuery.extend( {\\n\\n\\t// Add in style property hooks for overriding the default\\n\\t// behavior of getting and setting a style property\\n\\tcssHooks: {\\n\\t\\topacity: {\\n\\t\\t\\tget: function( elem, computed ) {\\n\\t\\t\\t\\tif ( computed ) {\\n\\n\\t\\t\\t\\t\\t// We should always get a number back from opacity\\n\\t\\t\\t\\t\\tvar ret = curCSS( elem, \\\"opacity\\\" );\\n\\t\\t\\t\\t\\treturn ret === \\\"\\\" ? \\\"1\\\" : ret;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t},\\n\\n\\t// Don't automatically add \\\"px\\\" to these possibly-unitless properties\\n\\tcssNumber: {\\n\\t\\t\\\"animationIterationCount\\\": true,\\n\\t\\t\\\"columnCount\\\": true,\\n\\t\\t\\\"fillOpacity\\\": true,\\n\\t\\t\\\"flexGrow\\\": true,\\n\\t\\t\\\"flexShrink\\\": true,\\n\\t\\t\\\"fontWeight\\\": true,\\n\\t\\t\\\"lineHeight\\\": true,\\n\\t\\t\\\"opacity\\\": true,\\n\\t\\t\\\"order\\\": true,\\n\\t\\t\\\"orphans\\\": true,\\n\\t\\t\\\"widows\\\": true,\\n\\t\\t\\\"zIndex\\\": true,\\n\\t\\t\\\"zoom\\\": true\\n\\t},\\n\\n\\t// Add in properties whose names you wish to fix before\\n\\t// setting or getting the value\\n\\tcssProps: {},\\n\\n\\t// Get and set the style property on a DOM Node\\n\\tstyle: function( elem, name, value, extra ) {\\n\\n\\t\\t// Don't set styles on text and comment nodes\\n\\t\\tif ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\t// Make sure that we're working with the right name\\n\\t\\tvar ret, type, hooks,\\n\\t\\t\\torigName = camelCase( name ),\\n\\t\\t\\tisCustomProp = rcustomProp.test( name ),\\n\\t\\t\\tstyle = elem.style;\\n\\n\\t\\t// Make sure that we're working with the right name. We don't\\n\\t\\t// want to query the value if it is a CSS custom property\\n\\t\\t// since they are user-defined.\\n\\t\\tif ( !isCustomProp ) {\\n\\t\\t\\tname = finalPropName( origName );\\n\\t\\t}\\n\\n\\t\\t// Gets hook for the prefixed version, then unprefixed version\\n\\t\\thooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];\\n\\n\\t\\t// Check if we're setting a value\\n\\t\\tif ( value !== undefined ) {\\n\\t\\t\\ttype = typeof value;\\n\\n\\t\\t\\t// Convert \\\"+=\\\" or \\\"-=\\\" to relative numbers (#7345)\\n\\t\\t\\tif ( type === \\\"string\\\" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {\\n\\t\\t\\t\\tvalue = adjustCSS( elem, name, ret );\\n\\n\\t\\t\\t\\t// Fixes bug #9237\\n\\t\\t\\t\\ttype = \\\"number\\\";\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Make sure that null and NaN values aren't set (#7116)\\n\\t\\t\\tif ( value == null || value !== value ) {\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// If a number was passed in, add the unit (except for certain CSS properties)\\n\\t\\t\\tif ( type === \\\"number\\\" ) {\\n\\t\\t\\t\\tvalue += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? \\\"\\\" : \\\"px\\\" );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// background-* props affect original clone's values\\n\\t\\t\\tif ( !support.clearCloneStyle && value === \\\"\\\" && name.indexOf( \\\"background\\\" ) === 0 ) {\\n\\t\\t\\t\\tstyle[ name ] = \\\"inherit\\\";\\n\\t\\t\\t}\\n\\n\\t\\t\\t// If a hook was provided, use that value, otherwise just set the specified value\\n\\t\\t\\tif ( !hooks || !( \\\"set\\\" in hooks ) ||\\n\\t\\t\\t\\t( value = hooks.set( elem, value, extra ) ) !== undefined ) {\\n\\n\\t\\t\\t\\tif ( isCustomProp ) {\\n\\t\\t\\t\\t\\tstyle.setProperty( name, value );\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tstyle[ name ] = value;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t} else {\\n\\n\\t\\t\\t// If a hook was provided get the non-computed value from there\\n\\t\\t\\tif ( hooks && \\\"get\\\" in hooks &&\\n\\t\\t\\t\\t( ret = hooks.get( elem, false, extra ) ) !== undefined ) {\\n\\n\\t\\t\\t\\treturn ret;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Otherwise just get the value from the style object\\n\\t\\t\\treturn style[ name ];\\n\\t\\t}\\n\\t},\\n\\n\\tcss: function( elem, name, extra, styles ) {\\n\\t\\tvar val, num, hooks,\\n\\t\\t\\torigName = camelCase( name ),\\n\\t\\t\\tisCustomProp = rcustomProp.test( name );\\n\\n\\t\\t// Make sure that we're working with the right name. We don't\\n\\t\\t// want to modify the value if it is a CSS custom property\\n\\t\\t// since they are user-defined.\\n\\t\\tif ( !isCustomProp ) {\\n\\t\\t\\tname = finalPropName( origName );\\n\\t\\t}\\n\\n\\t\\t// Try prefixed name followed by the unprefixed name\\n\\t\\thooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];\\n\\n\\t\\t// If a hook was provided get the computed value from there\\n\\t\\tif ( hooks && \\\"get\\\" in hooks ) {\\n\\t\\t\\tval = hooks.get( elem, true, extra );\\n\\t\\t}\\n\\n\\t\\t// Otherwise, if a way to get the computed value exists, use that\\n\\t\\tif ( val === undefined ) {\\n\\t\\t\\tval = curCSS( elem, name, styles );\\n\\t\\t}\\n\\n\\t\\t// Convert \\\"normal\\\" to computed value\\n\\t\\tif ( val === \\\"normal\\\" && name in cssNormalTransform ) {\\n\\t\\t\\tval = cssNormalTransform[ name ];\\n\\t\\t}\\n\\n\\t\\t// Make numeric if forced or a qualifier was provided and val looks numeric\\n\\t\\tif ( extra === \\\"\\\" || extra ) {\\n\\t\\t\\tnum = parseFloat( val );\\n\\t\\t\\treturn extra === true || isFinite( num ) ? num || 0 : val;\\n\\t\\t}\\n\\n\\t\\treturn val;\\n\\t}\\n} );\\n\\njQuery.each( [ \\\"height\\\", \\\"width\\\" ], function( i, dimension ) {\\n\\tjQuery.cssHooks[ dimension ] = {\\n\\t\\tget: function( elem, computed, extra ) {\\n\\t\\t\\tif ( computed ) {\\n\\n\\t\\t\\t\\t// Certain elements can have dimension info if we invisibly show them\\n\\t\\t\\t\\t// but it must have a current display style that would benefit\\n\\t\\t\\t\\treturn rdisplayswap.test( jQuery.css( elem, \\\"display\\\" ) ) &&\\n\\n\\t\\t\\t\\t\\t// Support: Safari 8+\\n\\t\\t\\t\\t\\t// Table columns in Safari have non-zero offsetWidth & zero\\n\\t\\t\\t\\t\\t// getBoundingClientRect().width unless display is changed.\\n\\t\\t\\t\\t\\t// Support: IE <=11 only\\n\\t\\t\\t\\t\\t// Running getBoundingClientRect on a disconnected node\\n\\t\\t\\t\\t\\t// in IE throws an error.\\n\\t\\t\\t\\t\\t( !elem.getClientRects().length || !elem.getBoundingClientRect().width ) ?\\n\\t\\t\\t\\t\\t\\tswap( elem, cssShow, function() {\\n\\t\\t\\t\\t\\t\\t\\treturn getWidthOrHeight( elem, dimension, extra );\\n\\t\\t\\t\\t\\t\\t} ) :\\n\\t\\t\\t\\t\\t\\tgetWidthOrHeight( elem, dimension, extra );\\n\\t\\t\\t}\\n\\t\\t},\\n\\n\\t\\tset: function( elem, value, extra ) {\\n\\t\\t\\tvar matches,\\n\\t\\t\\t\\tstyles = getStyles( elem ),\\n\\t\\t\\t\\tisBorderBox = jQuery.css( elem, \\\"boxSizing\\\", false, styles ) === \\\"border-box\\\",\\n\\t\\t\\t\\tsubtract = extra && boxModelAdjustment(\\n\\t\\t\\t\\t\\telem,\\n\\t\\t\\t\\t\\tdimension,\\n\\t\\t\\t\\t\\textra,\\n\\t\\t\\t\\t\\tisBorderBox,\\n\\t\\t\\t\\t\\tstyles\\n\\t\\t\\t\\t);\\n\\n\\t\\t\\t// Account for unreliable border-box dimensions by comparing offset* to computed and\\n\\t\\t\\t// faking a content-box to get border and padding (gh-3699)\\n\\t\\t\\tif ( isBorderBox && support.scrollboxSize() === styles.position ) {\\n\\t\\t\\t\\tsubtract -= Math.ceil(\\n\\t\\t\\t\\t\\telem[ \\\"offset\\\" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -\\n\\t\\t\\t\\t\\tparseFloat( styles[ dimension ] ) -\\n\\t\\t\\t\\t\\tboxModelAdjustment( elem, dimension, \\\"border\\\", false, styles ) -\\n\\t\\t\\t\\t\\t0.5\\n\\t\\t\\t\\t);\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Convert to pixels if value adjustment is needed\\n\\t\\t\\tif ( subtract && ( matches = rcssNum.exec( value ) ) &&\\n\\t\\t\\t\\t( matches[ 3 ] || \\\"px\\\" ) !== \\\"px\\\" ) {\\n\\n\\t\\t\\t\\telem.style[ dimension ] = value;\\n\\t\\t\\t\\tvalue = jQuery.css( elem, dimension );\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn setPositiveNumber( elem, value, subtract );\\n\\t\\t}\\n\\t};\\n} );\\n\\njQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,\\n\\tfunction( elem, computed ) {\\n\\t\\tif ( computed ) {\\n\\t\\t\\treturn ( parseFloat( curCSS( elem, \\\"marginLeft\\\" ) ) ||\\n\\t\\t\\t\\telem.getBoundingClientRect().left -\\n\\t\\t\\t\\t\\tswap( elem, { marginLeft: 0 }, function() {\\n\\t\\t\\t\\t\\t\\treturn elem.getBoundingClientRect().left;\\n\\t\\t\\t\\t\\t} )\\n\\t\\t\\t\\t) + \\\"px\\\";\\n\\t\\t}\\n\\t}\\n);\\n\\n// These hooks are used by animate to expand properties\\njQuery.each( {\\n\\tmargin: \\\"\\\",\\n\\tpadding: \\\"\\\",\\n\\tborder: \\\"Width\\\"\\n}, function( prefix, suffix ) {\\n\\tjQuery.cssHooks[ prefix + suffix ] = {\\n\\t\\texpand: function( value ) {\\n\\t\\t\\tvar i = 0,\\n\\t\\t\\t\\texpanded = {},\\n\\n\\t\\t\\t\\t// Assumes a single number if not a string\\n\\t\\t\\t\\tparts = typeof value === \\\"string\\\" ? value.split( \\\" \\\" ) : [ value ];\\n\\n\\t\\t\\tfor ( ; i < 4; i++ ) {\\n\\t\\t\\t\\texpanded[ prefix + cssExpand[ i ] + suffix ] =\\n\\t\\t\\t\\t\\tparts[ i ] || parts[ i - 2 ] || parts[ 0 ];\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn expanded;\\n\\t\\t}\\n\\t};\\n\\n\\tif ( prefix !== \\\"margin\\\" ) {\\n\\t\\tjQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;\\n\\t}\\n} );\\n\\njQuery.fn.extend( {\\n\\tcss: function( name, value ) {\\n\\t\\treturn access( this, function( elem, name, value ) {\\n\\t\\t\\tvar styles, len,\\n\\t\\t\\t\\tmap = {},\\n\\t\\t\\t\\ti = 0;\\n\\n\\t\\t\\tif ( Array.isArray( name ) ) {\\n\\t\\t\\t\\tstyles = getStyles( elem );\\n\\t\\t\\t\\tlen = name.length;\\n\\n\\t\\t\\t\\tfor ( ; i < len; i++ ) {\\n\\t\\t\\t\\t\\tmap[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn map;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn value !== undefined ?\\n\\t\\t\\t\\tjQuery.style( elem, name, value ) :\\n\\t\\t\\t\\tjQuery.css( elem, name );\\n\\t\\t}, name, value, arguments.length > 1 );\\n\\t}\\n} );\\n\\n\\nfunction Tween( elem, options, prop, end, easing ) {\\n\\treturn new Tween.prototype.init( elem, options, prop, end, easing );\\n}\\njQuery.Tween = Tween;\\n\\nTween.prototype = {\\n\\tconstructor: Tween,\\n\\tinit: function( elem, options, prop, end, easing, unit ) {\\n\\t\\tthis.elem = elem;\\n\\t\\tthis.prop = prop;\\n\\t\\tthis.easing = easing || jQuery.easing._default;\\n\\t\\tthis.options = options;\\n\\t\\tthis.start = this.now = this.cur();\\n\\t\\tthis.end = end;\\n\\t\\tthis.unit = unit || ( jQuery.cssNumber[ prop ] ? \\\"\\\" : \\\"px\\\" );\\n\\t},\\n\\tcur: function() {\\n\\t\\tvar hooks = Tween.propHooks[ this.prop ];\\n\\n\\t\\treturn hooks && hooks.get ?\\n\\t\\t\\thooks.get( this ) :\\n\\t\\t\\tTween.propHooks._default.get( this );\\n\\t},\\n\\trun: function( percent ) {\\n\\t\\tvar eased,\\n\\t\\t\\thooks = Tween.propHooks[ this.prop ];\\n\\n\\t\\tif ( this.options.duration ) {\\n\\t\\t\\tthis.pos = eased = jQuery.easing[ this.easing ](\\n\\t\\t\\t\\tpercent, this.options.duration * percent, 0, 1, this.options.duration\\n\\t\\t\\t);\\n\\t\\t} else {\\n\\t\\t\\tthis.pos = eased = percent;\\n\\t\\t}\\n\\t\\tthis.now = ( this.end - this.start ) * eased + this.start;\\n\\n\\t\\tif ( this.options.step ) {\\n\\t\\t\\tthis.options.step.call( this.elem, this.now, this );\\n\\t\\t}\\n\\n\\t\\tif ( hooks && hooks.set ) {\\n\\t\\t\\thooks.set( this );\\n\\t\\t} else {\\n\\t\\t\\tTween.propHooks._default.set( this );\\n\\t\\t}\\n\\t\\treturn this;\\n\\t}\\n};\\n\\nTween.prototype.init.prototype = Tween.prototype;\\n\\nTween.propHooks = {\\n\\t_default: {\\n\\t\\tget: function( tween ) {\\n\\t\\t\\tvar result;\\n\\n\\t\\t\\t// Use a property on the element directly when it is not a DOM element,\\n\\t\\t\\t// or when there is no matching style property that exists.\\n\\t\\t\\tif ( tween.elem.nodeType !== 1 ||\\n\\t\\t\\t\\ttween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {\\n\\t\\t\\t\\treturn tween.elem[ tween.prop ];\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Passing an empty string as a 3rd parameter to .css will automatically\\n\\t\\t\\t// attempt a parseFloat and fallback to a string if the parse fails.\\n\\t\\t\\t// Simple values such as \\\"10px\\\" are parsed to Float;\\n\\t\\t\\t// complex values such as \\\"rotate(1rad)\\\" are returned as-is.\\n\\t\\t\\tresult = jQuery.css( tween.elem, tween.prop, \\\"\\\" );\\n\\n\\t\\t\\t// Empty strings, null, undefined and \\\"auto\\\" are converted to 0.\\n\\t\\t\\treturn !result || result === \\\"auto\\\" ? 0 : result;\\n\\t\\t},\\n\\t\\tset: function( tween ) {\\n\\n\\t\\t\\t// Use step hook for back compat.\\n\\t\\t\\t// Use cssHook if its there.\\n\\t\\t\\t// Use .style if available and use plain properties where available.\\n\\t\\t\\tif ( jQuery.fx.step[ tween.prop ] ) {\\n\\t\\t\\t\\tjQuery.fx.step[ tween.prop ]( tween );\\n\\t\\t\\t} else if ( tween.elem.nodeType === 1 &&\\n\\t\\t\\t\\t( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null ||\\n\\t\\t\\t\\t\\tjQuery.cssHooks[ tween.prop ] ) ) {\\n\\t\\t\\t\\tjQuery.style( tween.elem, tween.prop, tween.now + tween.unit );\\n\\t\\t\\t} else {\\n\\t\\t\\t\\ttween.elem[ tween.prop ] = tween.now;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n};\\n\\n// Support: IE <=9 only\\n// Panic based approach to setting things on disconnected nodes\\nTween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {\\n\\tset: function( tween ) {\\n\\t\\tif ( tween.elem.nodeType && tween.elem.parentNode ) {\\n\\t\\t\\ttween.elem[ tween.prop ] = tween.now;\\n\\t\\t}\\n\\t}\\n};\\n\\njQuery.easing = {\\n\\tlinear: function( p ) {\\n\\t\\treturn p;\\n\\t},\\n\\tswing: function( p ) {\\n\\t\\treturn 0.5 - Math.cos( p * Math.PI ) / 2;\\n\\t},\\n\\t_default: \\\"swing\\\"\\n};\\n\\njQuery.fx = Tween.prototype.init;\\n\\n// Back compat <1.8 extension point\\njQuery.fx.step = {};\\n\\n\\n\\n\\nvar\\n\\tfxNow, inProgress,\\n\\trfxtypes = /^(?:toggle|show|hide)$/,\\n\\trrun = /queueHooks$/;\\n\\nfunction schedule() {\\n\\tif ( inProgress ) {\\n\\t\\tif ( document.hidden === false && window.requestAnimationFrame ) {\\n\\t\\t\\twindow.requestAnimationFrame( schedule );\\n\\t\\t} else {\\n\\t\\t\\twindow.setTimeout( schedule, jQuery.fx.interval );\\n\\t\\t}\\n\\n\\t\\tjQuery.fx.tick();\\n\\t}\\n}\\n\\n// Animations created synchronously will run synchronously\\nfunction createFxNow() {\\n\\twindow.setTimeout( function() {\\n\\t\\tfxNow = undefined;\\n\\t} );\\n\\treturn ( fxNow = Date.now() );\\n}\\n\\n// Generate parameters to create a standard animation\\nfunction genFx( type, includeWidth ) {\\n\\tvar which,\\n\\t\\ti = 0,\\n\\t\\tattrs = { height: type };\\n\\n\\t// If we include width, step value is 1 to do all cssExpand values,\\n\\t// otherwise step value is 2 to skip over Left and Right\\n\\tincludeWidth = includeWidth ? 1 : 0;\\n\\tfor ( ; i < 4; i += 2 - includeWidth ) {\\n\\t\\twhich = cssExpand[ i ];\\n\\t\\tattrs[ \\\"margin\\\" + which ] = attrs[ \\\"padding\\\" + which ] = type;\\n\\t}\\n\\n\\tif ( includeWidth ) {\\n\\t\\tattrs.opacity = attrs.width = type;\\n\\t}\\n\\n\\treturn attrs;\\n}\\n\\nfunction createTween( value, prop, animation ) {\\n\\tvar tween,\\n\\t\\tcollection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ \\\"*\\\" ] ),\\n\\t\\tindex = 0,\\n\\t\\tlength = collection.length;\\n\\tfor ( ; index < length; index++ ) {\\n\\t\\tif ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {\\n\\n\\t\\t\\t// We're done with this property\\n\\t\\t\\treturn tween;\\n\\t\\t}\\n\\t}\\n}\\n\\nfunction defaultPrefilter( elem, props, opts ) {\\n\\tvar prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,\\n\\t\\tisBox = \\\"width\\\" in props || \\\"height\\\" in props,\\n\\t\\tanim = this,\\n\\t\\torig = {},\\n\\t\\tstyle = elem.style,\\n\\t\\thidden = elem.nodeType && isHiddenWithinTree( elem ),\\n\\t\\tdataShow = dataPriv.get( elem, \\\"fxshow\\\" );\\n\\n\\t// Queue-skipping animations hijack the fx hooks\\n\\tif ( !opts.queue ) {\\n\\t\\thooks = jQuery._queueHooks( elem, \\\"fx\\\" );\\n\\t\\tif ( hooks.unqueued == null ) {\\n\\t\\t\\thooks.unqueued = 0;\\n\\t\\t\\toldfire = hooks.empty.fire;\\n\\t\\t\\thooks.empty.fire = function() {\\n\\t\\t\\t\\tif ( !hooks.unqueued ) {\\n\\t\\t\\t\\t\\toldfire();\\n\\t\\t\\t\\t}\\n\\t\\t\\t};\\n\\t\\t}\\n\\t\\thooks.unqueued++;\\n\\n\\t\\tanim.always( function() {\\n\\n\\t\\t\\t// Ensure the complete handler is called before this completes\\n\\t\\t\\tanim.always( function() {\\n\\t\\t\\t\\thooks.unqueued--;\\n\\t\\t\\t\\tif ( !jQuery.queue( elem, \\\"fx\\\" ).length ) {\\n\\t\\t\\t\\t\\thooks.empty.fire();\\n\\t\\t\\t\\t}\\n\\t\\t\\t} );\\n\\t\\t} );\\n\\t}\\n\\n\\t// Detect show/hide animations\\n\\tfor ( prop in props ) {\\n\\t\\tvalue = props[ prop ];\\n\\t\\tif ( rfxtypes.test( value ) ) {\\n\\t\\t\\tdelete props[ prop ];\\n\\t\\t\\ttoggle = toggle || value === \\\"toggle\\\";\\n\\t\\t\\tif ( value === ( hidden ? \\\"hide\\\" : \\\"show\\\" ) ) {\\n\\n\\t\\t\\t\\t// Pretend to be hidden if this is a \\\"show\\\" and\\n\\t\\t\\t\\t// there is still data from a stopped show/hide\\n\\t\\t\\t\\tif ( value === \\\"show\\\" && dataShow && dataShow[ prop ] !== undefined ) {\\n\\t\\t\\t\\t\\thidden = true;\\n\\n\\t\\t\\t\\t// Ignore all other no-op show/hide data\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\torig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );\\n\\t\\t}\\n\\t}\\n\\n\\t// Bail out if this is a no-op like .hide().hide()\\n\\tpropTween = !jQuery.isEmptyObject( props );\\n\\tif ( !propTween && jQuery.isEmptyObject( orig ) ) {\\n\\t\\treturn;\\n\\t}\\n\\n\\t// Restrict \\\"overflow\\\" and \\\"display\\\" styles during box animations\\n\\tif ( isBox && elem.nodeType === 1 ) {\\n\\n\\t\\t// Support: IE <=9 - 11, Edge 12 - 15\\n\\t\\t// Record all 3 overflow attributes because IE does not infer the shorthand\\n\\t\\t// from identically-valued overflowX and overflowY and Edge just mirrors\\n\\t\\t// the overflowX value there.\\n\\t\\topts.overflow = [ style.overflow, style.overflowX, style.overflowY ];\\n\\n\\t\\t// Identify a display type, preferring old show/hide data over the CSS cascade\\n\\t\\trestoreDisplay = dataShow && dataShow.display;\\n\\t\\tif ( restoreDisplay == null ) {\\n\\t\\t\\trestoreDisplay = dataPriv.get( elem, \\\"display\\\" );\\n\\t\\t}\\n\\t\\tdisplay = jQuery.css( elem, \\\"display\\\" );\\n\\t\\tif ( display === \\\"none\\\" ) {\\n\\t\\t\\tif ( restoreDisplay ) {\\n\\t\\t\\t\\tdisplay = restoreDisplay;\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t// Get nonempty value(s) by temporarily forcing visibility\\n\\t\\t\\t\\tshowHide( [ elem ], true );\\n\\t\\t\\t\\trestoreDisplay = elem.style.display || restoreDisplay;\\n\\t\\t\\t\\tdisplay = jQuery.css( elem, \\\"display\\\" );\\n\\t\\t\\t\\tshowHide( [ elem ] );\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// Animate inline elements as inline-block\\n\\t\\tif ( display === \\\"inline\\\" || display === \\\"inline-block\\\" && restoreDisplay != null ) {\\n\\t\\t\\tif ( jQuery.css( elem, \\\"float\\\" ) === \\\"none\\\" ) {\\n\\n\\t\\t\\t\\t// Restore the original display value at the end of pure show/hide animations\\n\\t\\t\\t\\tif ( !propTween ) {\\n\\t\\t\\t\\t\\tanim.done( function() {\\n\\t\\t\\t\\t\\t\\tstyle.display = restoreDisplay;\\n\\t\\t\\t\\t\\t} );\\n\\t\\t\\t\\t\\tif ( restoreDisplay == null ) {\\n\\t\\t\\t\\t\\t\\tdisplay = style.display;\\n\\t\\t\\t\\t\\t\\trestoreDisplay = display === \\\"none\\\" ? \\\"\\\" : display;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tstyle.display = \\\"inline-block\\\";\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tif ( opts.overflow ) {\\n\\t\\tstyle.overflow = \\\"hidden\\\";\\n\\t\\tanim.always( function() {\\n\\t\\t\\tstyle.overflow = opts.overflow[ 0 ];\\n\\t\\t\\tstyle.overflowX = opts.overflow[ 1 ];\\n\\t\\t\\tstyle.overflowY = opts.overflow[ 2 ];\\n\\t\\t} );\\n\\t}\\n\\n\\t// Implement show/hide animations\\n\\tpropTween = false;\\n\\tfor ( prop in orig ) {\\n\\n\\t\\t// General show/hide setup for this element animation\\n\\t\\tif ( !propTween ) {\\n\\t\\t\\tif ( dataShow ) {\\n\\t\\t\\t\\tif ( \\\"hidden\\\" in dataShow ) {\\n\\t\\t\\t\\t\\thidden = dataShow.hidden;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tdataShow = dataPriv.access( elem, \\\"fxshow\\\", { display: restoreDisplay } );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Store hidden/visible for toggle so `.stop().toggle()` \\\"reverses\\\"\\n\\t\\t\\tif ( toggle ) {\\n\\t\\t\\t\\tdataShow.hidden = !hidden;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Show elements before animating them\\n\\t\\t\\tif ( hidden ) {\\n\\t\\t\\t\\tshowHide( [ elem ], true );\\n\\t\\t\\t}\\n\\n\\t\\t\\t/* eslint-disable no-loop-func */\\n\\n\\t\\t\\tanim.done( function() {\\n\\n\\t\\t\\t/* eslint-enable no-loop-func */\\n\\n\\t\\t\\t\\t// The final step of a \\\"hide\\\" animation is actually hiding the element\\n\\t\\t\\t\\tif ( !hidden ) {\\n\\t\\t\\t\\t\\tshowHide( [ elem ] );\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tdataPriv.remove( elem, \\\"fxshow\\\" );\\n\\t\\t\\t\\tfor ( prop in orig ) {\\n\\t\\t\\t\\t\\tjQuery.style( elem, prop, orig[ prop ] );\\n\\t\\t\\t\\t}\\n\\t\\t\\t} );\\n\\t\\t}\\n\\n\\t\\t// Per-property setup\\n\\t\\tpropTween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );\\n\\t\\tif ( !( prop in dataShow ) ) {\\n\\t\\t\\tdataShow[ prop ] = propTween.start;\\n\\t\\t\\tif ( hidden ) {\\n\\t\\t\\t\\tpropTween.end = propTween.start;\\n\\t\\t\\t\\tpropTween.start = 0;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n}\\n\\nfunction propFilter( props, specialEasing ) {\\n\\tvar index, name, easing, value, hooks;\\n\\n\\t// camelCase, specialEasing and expand cssHook pass\\n\\tfor ( index in props ) {\\n\\t\\tname = camelCase( index );\\n\\t\\teasing = specialEasing[ name ];\\n\\t\\tvalue = props[ index ];\\n\\t\\tif ( Array.isArray( value ) ) {\\n\\t\\t\\teasing = value[ 1 ];\\n\\t\\t\\tvalue = props[ index ] = value[ 0 ];\\n\\t\\t}\\n\\n\\t\\tif ( index !== name ) {\\n\\t\\t\\tprops[ name ] = value;\\n\\t\\t\\tdelete props[ index ];\\n\\t\\t}\\n\\n\\t\\thooks = jQuery.cssHooks[ name ];\\n\\t\\tif ( hooks && \\\"expand\\\" in hooks ) {\\n\\t\\t\\tvalue = hooks.expand( value );\\n\\t\\t\\tdelete props[ name ];\\n\\n\\t\\t\\t// Not quite $.extend, this won't overwrite existing keys.\\n\\t\\t\\t// Reusing 'index' because we have the correct \\\"name\\\"\\n\\t\\t\\tfor ( index in value ) {\\n\\t\\t\\t\\tif ( !( index in props ) ) {\\n\\t\\t\\t\\t\\tprops[ index ] = value[ index ];\\n\\t\\t\\t\\t\\tspecialEasing[ index ] = easing;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\tspecialEasing[ name ] = easing;\\n\\t\\t}\\n\\t}\\n}\\n\\nfunction Animation( elem, properties, options ) {\\n\\tvar result,\\n\\t\\tstopped,\\n\\t\\tindex = 0,\\n\\t\\tlength = Animation.prefilters.length,\\n\\t\\tdeferred = jQuery.Deferred().always( function() {\\n\\n\\t\\t\\t// Don't match elem in the :animated selector\\n\\t\\t\\tdelete tick.elem;\\n\\t\\t} ),\\n\\t\\ttick = function() {\\n\\t\\t\\tif ( stopped ) {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t\\tvar currentTime = fxNow || createFxNow(),\\n\\t\\t\\t\\tremaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),\\n\\n\\t\\t\\t\\t// Support: Android 2.3 only\\n\\t\\t\\t\\t// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)\\n\\t\\t\\t\\ttemp = remaining / animation.duration || 0,\\n\\t\\t\\t\\tpercent = 1 - temp,\\n\\t\\t\\t\\tindex = 0,\\n\\t\\t\\t\\tlength = animation.tweens.length;\\n\\n\\t\\t\\tfor ( ; index < length; index++ ) {\\n\\t\\t\\t\\tanimation.tweens[ index ].run( percent );\\n\\t\\t\\t}\\n\\n\\t\\t\\tdeferred.notifyWith( elem, [ animation, percent, remaining ] );\\n\\n\\t\\t\\t// If there's more to do, yield\\n\\t\\t\\tif ( percent < 1 && length ) {\\n\\t\\t\\t\\treturn remaining;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// If this was an empty animation, synthesize a final progress notification\\n\\t\\t\\tif ( !length ) {\\n\\t\\t\\t\\tdeferred.notifyWith( elem, [ animation, 1, 0 ] );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Resolve the animation and report its conclusion\\n\\t\\t\\tdeferred.resolveWith( elem, [ animation ] );\\n\\t\\t\\treturn false;\\n\\t\\t},\\n\\t\\tanimation = deferred.promise( {\\n\\t\\t\\telem: elem,\\n\\t\\t\\tprops: jQuery.extend( {}, properties ),\\n\\t\\t\\topts: jQuery.extend( true, {\\n\\t\\t\\t\\tspecialEasing: {},\\n\\t\\t\\t\\teasing: jQuery.easing._default\\n\\t\\t\\t}, options ),\\n\\t\\t\\toriginalProperties: properties,\\n\\t\\t\\toriginalOptions: options,\\n\\t\\t\\tstartTime: fxNow || createFxNow(),\\n\\t\\t\\tduration: options.duration,\\n\\t\\t\\ttweens: [],\\n\\t\\t\\tcreateTween: function( prop, end ) {\\n\\t\\t\\t\\tvar tween = jQuery.Tween( elem, animation.opts, prop, end,\\n\\t\\t\\t\\t\\t\\tanimation.opts.specialEasing[ prop ] || animation.opts.easing );\\n\\t\\t\\t\\tanimation.tweens.push( tween );\\n\\t\\t\\t\\treturn tween;\\n\\t\\t\\t},\\n\\t\\t\\tstop: function( gotoEnd ) {\\n\\t\\t\\t\\tvar index = 0,\\n\\n\\t\\t\\t\\t\\t// If we are going to the end, we want to run all the tweens\\n\\t\\t\\t\\t\\t// otherwise we skip this part\\n\\t\\t\\t\\t\\tlength = gotoEnd ? animation.tweens.length : 0;\\n\\t\\t\\t\\tif ( stopped ) {\\n\\t\\t\\t\\t\\treturn this;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tstopped = true;\\n\\t\\t\\t\\tfor ( ; index < length; index++ ) {\\n\\t\\t\\t\\t\\tanimation.tweens[ index ].run( 1 );\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Resolve when we played the last frame; otherwise, reject\\n\\t\\t\\t\\tif ( gotoEnd ) {\\n\\t\\t\\t\\t\\tdeferred.notifyWith( elem, [ animation, 1, 0 ] );\\n\\t\\t\\t\\t\\tdeferred.resolveWith( elem, [ animation, gotoEnd ] );\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tdeferred.rejectWith( elem, [ animation, gotoEnd ] );\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn this;\\n\\t\\t\\t}\\n\\t\\t} ),\\n\\t\\tprops = animation.props;\\n\\n\\tpropFilter( props, animation.opts.specialEasing );\\n\\n\\tfor ( ; index < length; index++ ) {\\n\\t\\tresult = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );\\n\\t\\tif ( result ) {\\n\\t\\t\\tif ( isFunction( result.stop ) ) {\\n\\t\\t\\t\\tjQuery._queueHooks( animation.elem, animation.opts.queue ).stop =\\n\\t\\t\\t\\t\\tresult.stop.bind( result );\\n\\t\\t\\t}\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\t}\\n\\n\\tjQuery.map( props, createTween, animation );\\n\\n\\tif ( isFunction( animation.opts.start ) ) {\\n\\t\\tanimation.opts.start.call( elem, animation );\\n\\t}\\n\\n\\t// Attach callbacks from options\\n\\tanimation\\n\\t\\t.progress( animation.opts.progress )\\n\\t\\t.done( animation.opts.done, animation.opts.complete )\\n\\t\\t.fail( animation.opts.fail )\\n\\t\\t.always( animation.opts.always );\\n\\n\\tjQuery.fx.timer(\\n\\t\\tjQuery.extend( tick, {\\n\\t\\t\\telem: elem,\\n\\t\\t\\tanim: animation,\\n\\t\\t\\tqueue: animation.opts.queue\\n\\t\\t} )\\n\\t);\\n\\n\\treturn animation;\\n}\\n\\njQuery.Animation = jQuery.extend( Animation, {\\n\\n\\ttweeners: {\\n\\t\\t\\\"*\\\": [ function( prop, value ) {\\n\\t\\t\\tvar tween = this.createTween( prop, value );\\n\\t\\t\\tadjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );\\n\\t\\t\\treturn tween;\\n\\t\\t} ]\\n\\t},\\n\\n\\ttweener: function( props, callback ) {\\n\\t\\tif ( isFunction( props ) ) {\\n\\t\\t\\tcallback = props;\\n\\t\\t\\tprops = [ \\\"*\\\" ];\\n\\t\\t} else {\\n\\t\\t\\tprops = props.match( rnothtmlwhite );\\n\\t\\t}\\n\\n\\t\\tvar prop,\\n\\t\\t\\tindex = 0,\\n\\t\\t\\tlength = props.length;\\n\\n\\t\\tfor ( ; index < length; index++ ) {\\n\\t\\t\\tprop = props[ index ];\\n\\t\\t\\tAnimation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];\\n\\t\\t\\tAnimation.tweeners[ prop ].unshift( callback );\\n\\t\\t}\\n\\t},\\n\\n\\tprefilters: [ defaultPrefilter ],\\n\\n\\tprefilter: function( callback, prepend ) {\\n\\t\\tif ( prepend ) {\\n\\t\\t\\tAnimation.prefilters.unshift( callback );\\n\\t\\t} else {\\n\\t\\t\\tAnimation.prefilters.push( callback );\\n\\t\\t}\\n\\t}\\n} );\\n\\njQuery.speed = function( speed, easing, fn ) {\\n\\tvar opt = speed && typeof speed === \\\"object\\\" ? jQuery.extend( {}, speed ) : {\\n\\t\\tcomplete: fn || !fn && easing ||\\n\\t\\t\\tisFunction( speed ) && speed,\\n\\t\\tduration: speed,\\n\\t\\teasing: fn && easing || easing && !isFunction( easing ) && easing\\n\\t};\\n\\n\\t// Go to the end state if fx are off\\n\\tif ( jQuery.fx.off ) {\\n\\t\\topt.duration = 0;\\n\\n\\t} else {\\n\\t\\tif ( typeof opt.duration !== \\\"number\\\" ) {\\n\\t\\t\\tif ( opt.duration in jQuery.fx.speeds ) {\\n\\t\\t\\t\\topt.duration = jQuery.fx.speeds[ opt.duration ];\\n\\n\\t\\t\\t} else {\\n\\t\\t\\t\\topt.duration = jQuery.fx.speeds._default;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t// Normalize opt.queue - true/undefined/null -> \\\"fx\\\"\\n\\tif ( opt.queue == null || opt.queue === true ) {\\n\\t\\topt.queue = \\\"fx\\\";\\n\\t}\\n\\n\\t// Queueing\\n\\topt.old = opt.complete;\\n\\n\\topt.complete = function() {\\n\\t\\tif ( isFunction( opt.old ) ) {\\n\\t\\t\\topt.old.call( this );\\n\\t\\t}\\n\\n\\t\\tif ( opt.queue ) {\\n\\t\\t\\tjQuery.dequeue( this, opt.queue );\\n\\t\\t}\\n\\t};\\n\\n\\treturn opt;\\n};\\n\\njQuery.fn.extend( {\\n\\tfadeTo: function( speed, to, easing, callback ) {\\n\\n\\t\\t// Show any hidden elements after setting opacity to 0\\n\\t\\treturn this.filter( isHiddenWithinTree ).css( \\\"opacity\\\", 0 ).show()\\n\\n\\t\\t\\t// Animate to the value specified\\n\\t\\t\\t.end().animate( { opacity: to }, speed, easing, callback );\\n\\t},\\n\\tanimate: function( prop, speed, easing, callback ) {\\n\\t\\tvar empty = jQuery.isEmptyObject( prop ),\\n\\t\\t\\toptall = jQuery.speed( speed, easing, callback ),\\n\\t\\t\\tdoAnimation = function() {\\n\\n\\t\\t\\t\\t// Operate on a copy of prop so per-property easing won't be lost\\n\\t\\t\\t\\tvar anim = Animation( this, jQuery.extend( {}, prop ), optall );\\n\\n\\t\\t\\t\\t// Empty animations, or finishing resolves immediately\\n\\t\\t\\t\\tif ( empty || dataPriv.get( this, \\\"finish\\\" ) ) {\\n\\t\\t\\t\\t\\tanim.stop( true );\\n\\t\\t\\t\\t}\\n\\t\\t\\t};\\n\\t\\t\\tdoAnimation.finish = doAnimation;\\n\\n\\t\\treturn empty || optall.queue === false ?\\n\\t\\t\\tthis.each( doAnimation ) :\\n\\t\\t\\tthis.queue( optall.queue, doAnimation );\\n\\t},\\n\\tstop: function( type, clearQueue, gotoEnd ) {\\n\\t\\tvar stopQueue = function( hooks ) {\\n\\t\\t\\tvar stop = hooks.stop;\\n\\t\\t\\tdelete hooks.stop;\\n\\t\\t\\tstop( gotoEnd );\\n\\t\\t};\\n\\n\\t\\tif ( typeof type !== \\\"string\\\" ) {\\n\\t\\t\\tgotoEnd = clearQueue;\\n\\t\\t\\tclearQueue = type;\\n\\t\\t\\ttype = undefined;\\n\\t\\t}\\n\\t\\tif ( clearQueue && type !== false ) {\\n\\t\\t\\tthis.queue( type || \\\"fx\\\", [] );\\n\\t\\t}\\n\\n\\t\\treturn this.each( function() {\\n\\t\\t\\tvar dequeue = true,\\n\\t\\t\\t\\tindex = type != null && type + \\\"queueHooks\\\",\\n\\t\\t\\t\\ttimers = jQuery.timers,\\n\\t\\t\\t\\tdata = dataPriv.get( this );\\n\\n\\t\\t\\tif ( index ) {\\n\\t\\t\\t\\tif ( data[ index ] && data[ index ].stop ) {\\n\\t\\t\\t\\t\\tstopQueue( data[ index ] );\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tfor ( index in data ) {\\n\\t\\t\\t\\t\\tif ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {\\n\\t\\t\\t\\t\\t\\tstopQueue( data[ index ] );\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor ( index = timers.length; index--; ) {\\n\\t\\t\\t\\tif ( timers[ index ].elem === this &&\\n\\t\\t\\t\\t\\t( type == null || timers[ index ].queue === type ) ) {\\n\\n\\t\\t\\t\\t\\ttimers[ index ].anim.stop( gotoEnd );\\n\\t\\t\\t\\t\\tdequeue = false;\\n\\t\\t\\t\\t\\ttimers.splice( index, 1 );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Start the next in the queue if the last step wasn't forced.\\n\\t\\t\\t// Timers currently will call their complete callbacks, which\\n\\t\\t\\t// will dequeue but only if they were gotoEnd.\\n\\t\\t\\tif ( dequeue || !gotoEnd ) {\\n\\t\\t\\t\\tjQuery.dequeue( this, type );\\n\\t\\t\\t}\\n\\t\\t} );\\n\\t},\\n\\tfinish: function( type ) {\\n\\t\\tif ( type !== false ) {\\n\\t\\t\\ttype = type || \\\"fx\\\";\\n\\t\\t}\\n\\t\\treturn this.each( function() {\\n\\t\\t\\tvar index,\\n\\t\\t\\t\\tdata = dataPriv.get( this ),\\n\\t\\t\\t\\tqueue = data[ type + \\\"queue\\\" ],\\n\\t\\t\\t\\thooks = data[ type + \\\"queueHooks\\\" ],\\n\\t\\t\\t\\ttimers = jQuery.timers,\\n\\t\\t\\t\\tlength = queue ? queue.length : 0;\\n\\n\\t\\t\\t// Enable finishing flag on private data\\n\\t\\t\\tdata.finish = true;\\n\\n\\t\\t\\t// Empty the queue first\\n\\t\\t\\tjQuery.queue( this, type, [] );\\n\\n\\t\\t\\tif ( hooks && hooks.stop ) {\\n\\t\\t\\t\\thooks.stop.call( this, true );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Look for any active animations, and finish them\\n\\t\\t\\tfor ( index = timers.length; index--; ) {\\n\\t\\t\\t\\tif ( timers[ index ].elem === this && timers[ index ].queue === type ) {\\n\\t\\t\\t\\t\\ttimers[ index ].anim.stop( true );\\n\\t\\t\\t\\t\\ttimers.splice( index, 1 );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Look for any animations in the old queue and finish them\\n\\t\\t\\tfor ( index = 0; index < length; index++ ) {\\n\\t\\t\\t\\tif ( queue[ index ] && queue[ index ].finish ) {\\n\\t\\t\\t\\t\\tqueue[ index ].finish.call( this );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Turn off finishing flag\\n\\t\\t\\tdelete data.finish;\\n\\t\\t} );\\n\\t}\\n} );\\n\\njQuery.each( [ \\\"toggle\\\", \\\"show\\\", \\\"hide\\\" ], function( i, name ) {\\n\\tvar cssFn = jQuery.fn[ name ];\\n\\tjQuery.fn[ name ] = function( speed, easing, callback ) {\\n\\t\\treturn speed == null || typeof speed === \\\"boolean\\\" ?\\n\\t\\t\\tcssFn.apply( this, arguments ) :\\n\\t\\t\\tthis.animate( genFx( name, true ), speed, easing, callback );\\n\\t};\\n} );\\n\\n// Generate shortcuts for custom animations\\njQuery.each( {\\n\\tslideDown: genFx( \\\"show\\\" ),\\n\\tslideUp: genFx( \\\"hide\\\" ),\\n\\tslideToggle: genFx( \\\"toggle\\\" ),\\n\\tfadeIn: { opacity: \\\"show\\\" },\\n\\tfadeOut: { opacity: \\\"hide\\\" },\\n\\tfadeToggle: { opacity: \\\"toggle\\\" }\\n}, function( name, props ) {\\n\\tjQuery.fn[ name ] = function( speed, easing, callback ) {\\n\\t\\treturn this.animate( props, speed, easing, callback );\\n\\t};\\n} );\\n\\njQuery.timers = [];\\njQuery.fx.tick = function() {\\n\\tvar timer,\\n\\t\\ti = 0,\\n\\t\\ttimers = jQuery.timers;\\n\\n\\tfxNow = Date.now();\\n\\n\\tfor ( ; i < timers.length; i++ ) {\\n\\t\\ttimer = timers[ i ];\\n\\n\\t\\t// Run the timer and safely remove it when done (allowing for external removal)\\n\\t\\tif ( !timer() && timers[ i ] === timer ) {\\n\\t\\t\\ttimers.splice( i--, 1 );\\n\\t\\t}\\n\\t}\\n\\n\\tif ( !timers.length ) {\\n\\t\\tjQuery.fx.stop();\\n\\t}\\n\\tfxNow = undefined;\\n};\\n\\njQuery.fx.timer = function( timer ) {\\n\\tjQuery.timers.push( timer );\\n\\tjQuery.fx.start();\\n};\\n\\njQuery.fx.interval = 13;\\njQuery.fx.start = function() {\\n\\tif ( inProgress ) {\\n\\t\\treturn;\\n\\t}\\n\\n\\tinProgress = true;\\n\\tschedule();\\n};\\n\\njQuery.fx.stop = function() {\\n\\tinProgress = null;\\n};\\n\\njQuery.fx.speeds = {\\n\\tslow: 600,\\n\\tfast: 200,\\n\\n\\t// Default speed\\n\\t_default: 400\\n};\\n\\n\\n// Based off of the plugin by Clint Helfers, with permission.\\n// https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/\\njQuery.fn.delay = function( time, type ) {\\n\\ttime = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;\\n\\ttype = type || \\\"fx\\\";\\n\\n\\treturn this.queue( type, function( next, hooks ) {\\n\\t\\tvar timeout = window.setTimeout( next, time );\\n\\t\\thooks.stop = function() {\\n\\t\\t\\twindow.clearTimeout( timeout );\\n\\t\\t};\\n\\t} );\\n};\\n\\n\\n( function() {\\n\\tvar input = document.createElement( \\\"input\\\" ),\\n\\t\\tselect = document.createElement( \\\"select\\\" ),\\n\\t\\topt = select.appendChild( document.createElement( \\\"option\\\" ) );\\n\\n\\tinput.type = \\\"checkbox\\\";\\n\\n\\t// Support: Android <=4.3 only\\n\\t// Default value for a checkbox should be \\\"on\\\"\\n\\tsupport.checkOn = input.value !== \\\"\\\";\\n\\n\\t// Support: IE <=11 only\\n\\t// Must access selectedIndex to make default options select\\n\\tsupport.optSelected = opt.selected;\\n\\n\\t// Support: IE <=11 only\\n\\t// An input loses its value after becoming a radio\\n\\tinput = document.createElement( \\\"input\\\" );\\n\\tinput.value = \\\"t\\\";\\n\\tinput.type = \\\"radio\\\";\\n\\tsupport.radioValue = input.value === \\\"t\\\";\\n} )();\\n\\n\\nvar boolHook,\\n\\tattrHandle = jQuery.expr.attrHandle;\\n\\njQuery.fn.extend( {\\n\\tattr: function( name, value ) {\\n\\t\\treturn access( this, jQuery.attr, name, value, arguments.length > 1 );\\n\\t},\\n\\n\\tremoveAttr: function( name ) {\\n\\t\\treturn this.each( function() {\\n\\t\\t\\tjQuery.removeAttr( this, name );\\n\\t\\t} );\\n\\t}\\n} );\\n\\njQuery.extend( {\\n\\tattr: function( elem, name, value ) {\\n\\t\\tvar ret, hooks,\\n\\t\\t\\tnType = elem.nodeType;\\n\\n\\t\\t// Don't get/set attributes on text, comment and attribute nodes\\n\\t\\tif ( nType === 3 || nType === 8 || nType === 2 ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\t// Fallback to prop when attributes are not supported\\n\\t\\tif ( typeof elem.getAttribute === \\\"undefined\\\" ) {\\n\\t\\t\\treturn jQuery.prop( elem, name, value );\\n\\t\\t}\\n\\n\\t\\t// Attribute hooks are determined by the lowercase version\\n\\t\\t// Grab necessary hook if one is defined\\n\\t\\tif ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {\\n\\t\\t\\thooks = jQuery.attrHooks[ name.toLowerCase() ] ||\\n\\t\\t\\t\\t( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );\\n\\t\\t}\\n\\n\\t\\tif ( value !== undefined ) {\\n\\t\\t\\tif ( value === null ) {\\n\\t\\t\\t\\tjQuery.removeAttr( elem, name );\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( hooks && \\\"set\\\" in hooks &&\\n\\t\\t\\t\\t( ret = hooks.set( elem, value, name ) ) !== undefined ) {\\n\\t\\t\\t\\treturn ret;\\n\\t\\t\\t}\\n\\n\\t\\t\\telem.setAttribute( name, value + \\\"\\\" );\\n\\t\\t\\treturn value;\\n\\t\\t}\\n\\n\\t\\tif ( hooks && \\\"get\\\" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {\\n\\t\\t\\treturn ret;\\n\\t\\t}\\n\\n\\t\\tret = jQuery.find.attr( elem, name );\\n\\n\\t\\t// Non-existent attributes return null, we normalize to undefined\\n\\t\\treturn ret == null ? undefined : ret;\\n\\t},\\n\\n\\tattrHooks: {\\n\\t\\ttype: {\\n\\t\\t\\tset: function( elem, value ) {\\n\\t\\t\\t\\tif ( !support.radioValue && value === \\\"radio\\\" &&\\n\\t\\t\\t\\t\\tnodeName( elem, \\\"input\\\" ) ) {\\n\\t\\t\\t\\t\\tvar val = elem.value;\\n\\t\\t\\t\\t\\telem.setAttribute( \\\"type\\\", value );\\n\\t\\t\\t\\t\\tif ( val ) {\\n\\t\\t\\t\\t\\t\\telem.value = val;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\treturn value;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t},\\n\\n\\tremoveAttr: function( elem, value ) {\\n\\t\\tvar name,\\n\\t\\t\\ti = 0,\\n\\n\\t\\t\\t// Attribute names can contain non-HTML whitespace characters\\n\\t\\t\\t// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2\\n\\t\\t\\tattrNames = value && value.match( rnothtmlwhite );\\n\\n\\t\\tif ( attrNames && elem.nodeType === 1 ) {\\n\\t\\t\\twhile ( ( name = attrNames[ i++ ] ) ) {\\n\\t\\t\\t\\telem.removeAttribute( name );\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n} );\\n\\n// Hooks for boolean attributes\\nboolHook = {\\n\\tset: function( elem, value, name ) {\\n\\t\\tif ( value === false ) {\\n\\n\\t\\t\\t// Remove boolean attributes when set to false\\n\\t\\t\\tjQuery.removeAttr( elem, name );\\n\\t\\t} else {\\n\\t\\t\\telem.setAttribute( name, name );\\n\\t\\t}\\n\\t\\treturn name;\\n\\t}\\n};\\n\\njQuery.each( jQuery.expr.match.bool.source.match( /\\\\w+/g ), function( i, name ) {\\n\\tvar getter = attrHandle[ name ] || jQuery.find.attr;\\n\\n\\tattrHandle[ name ] = function( elem, name, isXML ) {\\n\\t\\tvar ret, handle,\\n\\t\\t\\tlowercaseName = name.toLowerCase();\\n\\n\\t\\tif ( !isXML ) {\\n\\n\\t\\t\\t// Avoid an infinite loop by temporarily removing this function from the getter\\n\\t\\t\\thandle = attrHandle[ lowercaseName ];\\n\\t\\t\\tattrHandle[ lowercaseName ] = ret;\\n\\t\\t\\tret = getter( elem, name, isXML ) != null ?\\n\\t\\t\\t\\tlowercaseName :\\n\\t\\t\\t\\tnull;\\n\\t\\t\\tattrHandle[ lowercaseName ] = handle;\\n\\t\\t}\\n\\t\\treturn ret;\\n\\t};\\n} );\\n\\n\\n\\n\\nvar rfocusable = /^(?:input|select|textarea|button)$/i,\\n\\trclickable = /^(?:a|area)$/i;\\n\\njQuery.fn.extend( {\\n\\tprop: function( name, value ) {\\n\\t\\treturn access( this, jQuery.prop, name, value, arguments.length > 1 );\\n\\t},\\n\\n\\tremoveProp: function( name ) {\\n\\t\\treturn this.each( function() {\\n\\t\\t\\tdelete this[ jQuery.propFix[ name ] || name ];\\n\\t\\t} );\\n\\t}\\n} );\\n\\njQuery.extend( {\\n\\tprop: function( elem, name, value ) {\\n\\t\\tvar ret, hooks,\\n\\t\\t\\tnType = elem.nodeType;\\n\\n\\t\\t// Don't get/set properties on text, comment and attribute nodes\\n\\t\\tif ( nType === 3 || nType === 8 || nType === 2 ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tif ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {\\n\\n\\t\\t\\t// Fix name and attach hooks\\n\\t\\t\\tname = jQuery.propFix[ name ] || name;\\n\\t\\t\\thooks = jQuery.propHooks[ name ];\\n\\t\\t}\\n\\n\\t\\tif ( value !== undefined ) {\\n\\t\\t\\tif ( hooks && \\\"set\\\" in hooks &&\\n\\t\\t\\t\\t( ret = hooks.set( elem, value, name ) ) !== undefined ) {\\n\\t\\t\\t\\treturn ret;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn ( elem[ name ] = value );\\n\\t\\t}\\n\\n\\t\\tif ( hooks && \\\"get\\\" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {\\n\\t\\t\\treturn ret;\\n\\t\\t}\\n\\n\\t\\treturn elem[ name ];\\n\\t},\\n\\n\\tpropHooks: {\\n\\t\\ttabIndex: {\\n\\t\\t\\tget: function( elem ) {\\n\\n\\t\\t\\t\\t// Support: IE <=9 - 11 only\\n\\t\\t\\t\\t// elem.tabIndex doesn't always return the\\n\\t\\t\\t\\t// correct value when it hasn't been explicitly set\\n\\t\\t\\t\\t// https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/\\n\\t\\t\\t\\t// Use proper attribute retrieval(#12072)\\n\\t\\t\\t\\tvar tabindex = jQuery.find.attr( elem, \\\"tabindex\\\" );\\n\\n\\t\\t\\t\\tif ( tabindex ) {\\n\\t\\t\\t\\t\\treturn parseInt( tabindex, 10 );\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif (\\n\\t\\t\\t\\t\\trfocusable.test( elem.nodeName ) ||\\n\\t\\t\\t\\t\\trclickable.test( elem.nodeName ) &&\\n\\t\\t\\t\\t\\telem.href\\n\\t\\t\\t\\t) {\\n\\t\\t\\t\\t\\treturn 0;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn -1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t},\\n\\n\\tpropFix: {\\n\\t\\t\\\"for\\\": \\\"htmlFor\\\",\\n\\t\\t\\\"class\\\": \\\"className\\\"\\n\\t}\\n} );\\n\\n// Support: IE <=11 only\\n// Accessing the selectedIndex property\\n// forces the browser to respect setting selected\\n// on the option\\n// The getter ensures a default option is selected\\n// when in an optgroup\\n// eslint rule \\\"no-unused-expressions\\\" is disabled for this code\\n// since it considers such accessions noop\\nif ( !support.optSelected ) {\\n\\tjQuery.propHooks.selected = {\\n\\t\\tget: function( elem ) {\\n\\n\\t\\t\\t/* eslint no-unused-expressions: \\\"off\\\" */\\n\\n\\t\\t\\tvar parent = elem.parentNode;\\n\\t\\t\\tif ( parent && parent.parentNode ) {\\n\\t\\t\\t\\tparent.parentNode.selectedIndex;\\n\\t\\t\\t}\\n\\t\\t\\treturn null;\\n\\t\\t},\\n\\t\\tset: function( elem ) {\\n\\n\\t\\t\\t/* eslint no-unused-expressions: \\\"off\\\" */\\n\\n\\t\\t\\tvar parent = elem.parentNode;\\n\\t\\t\\tif ( parent ) {\\n\\t\\t\\t\\tparent.selectedIndex;\\n\\n\\t\\t\\t\\tif ( parent.parentNode ) {\\n\\t\\t\\t\\t\\tparent.parentNode.selectedIndex;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t};\\n}\\n\\njQuery.each( [\\n\\t\\\"tabIndex\\\",\\n\\t\\\"readOnly\\\",\\n\\t\\\"maxLength\\\",\\n\\t\\\"cellSpacing\\\",\\n\\t\\\"cellPadding\\\",\\n\\t\\\"rowSpan\\\",\\n\\t\\\"colSpan\\\",\\n\\t\\\"useMap\\\",\\n\\t\\\"frameBorder\\\",\\n\\t\\\"contentEditable\\\"\\n], function() {\\n\\tjQuery.propFix[ this.toLowerCase() ] = this;\\n} );\\n\\n\\n\\n\\n\\t// Strip and collapse whitespace according to HTML spec\\n\\t// https://infra.spec.whatwg.org/#strip-and-collapse-ascii-whitespace\\n\\tfunction stripAndCollapse( value ) {\\n\\t\\tvar tokens = value.match( rnothtmlwhite ) || [];\\n\\t\\treturn tokens.join( \\\" \\\" );\\n\\t}\\n\\n\\nfunction getClass( elem ) {\\n\\treturn elem.getAttribute && elem.getAttribute( \\\"class\\\" ) || \\\"\\\";\\n}\\n\\nfunction classesToArray( value ) {\\n\\tif ( Array.isArray( value ) ) {\\n\\t\\treturn value;\\n\\t}\\n\\tif ( typeof value === \\\"string\\\" ) {\\n\\t\\treturn value.match( rnothtmlwhite ) || [];\\n\\t}\\n\\treturn [];\\n}\\n\\njQuery.fn.extend( {\\n\\taddClass: function( value ) {\\n\\t\\tvar classes, elem, cur, curValue, clazz, j, finalValue,\\n\\t\\t\\ti = 0;\\n\\n\\t\\tif ( isFunction( value ) ) {\\n\\t\\t\\treturn this.each( function( j ) {\\n\\t\\t\\t\\tjQuery( this ).addClass( value.call( this, j, getClass( this ) ) );\\n\\t\\t\\t} );\\n\\t\\t}\\n\\n\\t\\tclasses = classesToArray( value );\\n\\n\\t\\tif ( classes.length ) {\\n\\t\\t\\twhile ( ( elem = this[ i++ ] ) ) {\\n\\t\\t\\t\\tcurValue = getClass( elem );\\n\\t\\t\\t\\tcur = elem.nodeType === 1 && ( \\\" \\\" + stripAndCollapse( curValue ) + \\\" \\\" );\\n\\n\\t\\t\\t\\tif ( cur ) {\\n\\t\\t\\t\\t\\tj = 0;\\n\\t\\t\\t\\t\\twhile ( ( clazz = classes[ j++ ] ) ) {\\n\\t\\t\\t\\t\\t\\tif ( cur.indexOf( \\\" \\\" + clazz + \\\" \\\" ) < 0 ) {\\n\\t\\t\\t\\t\\t\\t\\tcur += clazz + \\\" \\\";\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t// Only assign if different to avoid unneeded rendering.\\n\\t\\t\\t\\t\\tfinalValue = stripAndCollapse( cur );\\n\\t\\t\\t\\t\\tif ( curValue !== finalValue ) {\\n\\t\\t\\t\\t\\t\\telem.setAttribute( \\\"class\\\", finalValue );\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn this;\\n\\t},\\n\\n\\tremoveClass: function( value ) {\\n\\t\\tvar classes, elem, cur, curValue, clazz, j, finalValue,\\n\\t\\t\\ti = 0;\\n\\n\\t\\tif ( isFunction( value ) ) {\\n\\t\\t\\treturn this.each( function( j ) {\\n\\t\\t\\t\\tjQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );\\n\\t\\t\\t} );\\n\\t\\t}\\n\\n\\t\\tif ( !arguments.length ) {\\n\\t\\t\\treturn this.attr( \\\"class\\\", \\\"\\\" );\\n\\t\\t}\\n\\n\\t\\tclasses = classesToArray( value );\\n\\n\\t\\tif ( classes.length ) {\\n\\t\\t\\twhile ( ( elem = this[ i++ ] ) ) {\\n\\t\\t\\t\\tcurValue = getClass( elem );\\n\\n\\t\\t\\t\\t// This expression is here for better compressibility (see addClass)\\n\\t\\t\\t\\tcur = elem.nodeType === 1 && ( \\\" \\\" + stripAndCollapse( curValue ) + \\\" \\\" );\\n\\n\\t\\t\\t\\tif ( cur ) {\\n\\t\\t\\t\\t\\tj = 0;\\n\\t\\t\\t\\t\\twhile ( ( clazz = classes[ j++ ] ) ) {\\n\\n\\t\\t\\t\\t\\t\\t// Remove *all* instances\\n\\t\\t\\t\\t\\t\\twhile ( cur.indexOf( \\\" \\\" + clazz + \\\" \\\" ) > -1 ) {\\n\\t\\t\\t\\t\\t\\t\\tcur = cur.replace( \\\" \\\" + clazz + \\\" \\\", \\\" \\\" );\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t// Only assign if different to avoid unneeded rendering.\\n\\t\\t\\t\\t\\tfinalValue = stripAndCollapse( cur );\\n\\t\\t\\t\\t\\tif ( curValue !== finalValue ) {\\n\\t\\t\\t\\t\\t\\telem.setAttribute( \\\"class\\\", finalValue );\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn this;\\n\\t},\\n\\n\\ttoggleClass: function( value, stateVal ) {\\n\\t\\tvar type = typeof value,\\n\\t\\t\\tisValidValue = type === \\\"string\\\" || Array.isArray( value );\\n\\n\\t\\tif ( typeof stateVal === \\\"boolean\\\" && isValidValue ) {\\n\\t\\t\\treturn stateVal ? this.addClass( value ) : this.removeClass( value );\\n\\t\\t}\\n\\n\\t\\tif ( isFunction( value ) ) {\\n\\t\\t\\treturn this.each( function( i ) {\\n\\t\\t\\t\\tjQuery( this ).toggleClass(\\n\\t\\t\\t\\t\\tvalue.call( this, i, getClass( this ), stateVal ),\\n\\t\\t\\t\\t\\tstateVal\\n\\t\\t\\t\\t);\\n\\t\\t\\t} );\\n\\t\\t}\\n\\n\\t\\treturn this.each( function() {\\n\\t\\t\\tvar className, i, self, classNames;\\n\\n\\t\\t\\tif ( isValidValue ) {\\n\\n\\t\\t\\t\\t// Toggle individual class names\\n\\t\\t\\t\\ti = 0;\\n\\t\\t\\t\\tself = jQuery( this );\\n\\t\\t\\t\\tclassNames = classesToArray( value );\\n\\n\\t\\t\\t\\twhile ( ( className = classNames[ i++ ] ) ) {\\n\\n\\t\\t\\t\\t\\t// Check each className given, space separated list\\n\\t\\t\\t\\t\\tif ( self.hasClass( className ) ) {\\n\\t\\t\\t\\t\\t\\tself.removeClass( className );\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tself.addClass( className );\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t// Toggle whole class name\\n\\t\\t\\t} else if ( value === undefined || type === \\\"boolean\\\" ) {\\n\\t\\t\\t\\tclassName = getClass( this );\\n\\t\\t\\t\\tif ( className ) {\\n\\n\\t\\t\\t\\t\\t// Store className if set\\n\\t\\t\\t\\t\\tdataPriv.set( this, \\\"__className__\\\", className );\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// If the element has a class name or if we're passed `false`,\\n\\t\\t\\t\\t// then remove the whole classname (if there was one, the above saved it).\\n\\t\\t\\t\\t// Otherwise bring back whatever was previously saved (if anything),\\n\\t\\t\\t\\t// falling back to the empty string if nothing was stored.\\n\\t\\t\\t\\tif ( this.setAttribute ) {\\n\\t\\t\\t\\t\\tthis.setAttribute( \\\"class\\\",\\n\\t\\t\\t\\t\\t\\tclassName || value === false ?\\n\\t\\t\\t\\t\\t\\t\\\"\\\" :\\n\\t\\t\\t\\t\\t\\tdataPriv.get( this, \\\"__className__\\\" ) || \\\"\\\"\\n\\t\\t\\t\\t\\t);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t} );\\n\\t},\\n\\n\\thasClass: function( selector ) {\\n\\t\\tvar className, elem,\\n\\t\\t\\ti = 0;\\n\\n\\t\\tclassName = \\\" \\\" + selector + \\\" \\\";\\n\\t\\twhile ( ( elem = this[ i++ ] ) ) {\\n\\t\\t\\tif ( elem.nodeType === 1 &&\\n\\t\\t\\t\\t( \\\" \\\" + stripAndCollapse( getClass( elem ) ) + \\\" \\\" ).indexOf( className ) > -1 ) {\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn false;\\n\\t}\\n} );\\n\\n\\n\\n\\nvar rreturn = /\\\\r/g;\\n\\njQuery.fn.extend( {\\n\\tval: function( value ) {\\n\\t\\tvar hooks, ret, valueIsFunction,\\n\\t\\t\\telem = this[ 0 ];\\n\\n\\t\\tif ( !arguments.length ) {\\n\\t\\t\\tif ( elem ) {\\n\\t\\t\\t\\thooks = jQuery.valHooks[ elem.type ] ||\\n\\t\\t\\t\\t\\tjQuery.valHooks[ elem.nodeName.toLowerCase() ];\\n\\n\\t\\t\\t\\tif ( hooks &&\\n\\t\\t\\t\\t\\t\\\"get\\\" in hooks &&\\n\\t\\t\\t\\t\\t( ret = hooks.get( elem, \\\"value\\\" ) ) !== undefined\\n\\t\\t\\t\\t) {\\n\\t\\t\\t\\t\\treturn ret;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tret = elem.value;\\n\\n\\t\\t\\t\\t// Handle most common string cases\\n\\t\\t\\t\\tif ( typeof ret === \\\"string\\\" ) {\\n\\t\\t\\t\\t\\treturn ret.replace( rreturn, \\\"\\\" );\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Handle cases where value is null/undef or number\\n\\t\\t\\t\\treturn ret == null ? \\\"\\\" : ret;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tvalueIsFunction = isFunction( value );\\n\\n\\t\\treturn this.each( function( i ) {\\n\\t\\t\\tvar val;\\n\\n\\t\\t\\tif ( this.nodeType !== 1 ) {\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( valueIsFunction ) {\\n\\t\\t\\t\\tval = value.call( this, i, jQuery( this ).val() );\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tval = value;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Treat null/undefined as \\\"\\\"; convert numbers to string\\n\\t\\t\\tif ( val == null ) {\\n\\t\\t\\t\\tval = \\\"\\\";\\n\\n\\t\\t\\t} else if ( typeof val === \\\"number\\\" ) {\\n\\t\\t\\t\\tval += \\\"\\\";\\n\\n\\t\\t\\t} else if ( Array.isArray( val ) ) {\\n\\t\\t\\t\\tval = jQuery.map( val, function( value ) {\\n\\t\\t\\t\\t\\treturn value == null ? \\\"\\\" : value + \\\"\\\";\\n\\t\\t\\t\\t} );\\n\\t\\t\\t}\\n\\n\\t\\t\\thooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];\\n\\n\\t\\t\\t// If set returns undefined, fall back to normal setting\\n\\t\\t\\tif ( !hooks || !( \\\"set\\\" in hooks ) || hooks.set( this, val, \\\"value\\\" ) === undefined ) {\\n\\t\\t\\t\\tthis.value = val;\\n\\t\\t\\t}\\n\\t\\t} );\\n\\t}\\n} );\\n\\njQuery.extend( {\\n\\tvalHooks: {\\n\\t\\toption: {\\n\\t\\t\\tget: function( elem ) {\\n\\n\\t\\t\\t\\tvar val = jQuery.find.attr( elem, \\\"value\\\" );\\n\\t\\t\\t\\treturn val != null ?\\n\\t\\t\\t\\t\\tval :\\n\\n\\t\\t\\t\\t\\t// Support: IE <=10 - 11 only\\n\\t\\t\\t\\t\\t// option.text throws exceptions (#14686, #14858)\\n\\t\\t\\t\\t\\t// Strip and collapse whitespace\\n\\t\\t\\t\\t\\t// https://html.spec.whatwg.org/#strip-and-collapse-whitespace\\n\\t\\t\\t\\t\\tstripAndCollapse( jQuery.text( elem ) );\\n\\t\\t\\t}\\n\\t\\t},\\n\\t\\tselect: {\\n\\t\\t\\tget: function( elem ) {\\n\\t\\t\\t\\tvar value, option, i,\\n\\t\\t\\t\\t\\toptions = elem.options,\\n\\t\\t\\t\\t\\tindex = elem.selectedIndex,\\n\\t\\t\\t\\t\\tone = elem.type === \\\"select-one\\\",\\n\\t\\t\\t\\t\\tvalues = one ? null : [],\\n\\t\\t\\t\\t\\tmax = one ? index + 1 : options.length;\\n\\n\\t\\t\\t\\tif ( index < 0 ) {\\n\\t\\t\\t\\t\\ti = max;\\n\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\ti = one ? index : 0;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Loop through all the selected options\\n\\t\\t\\t\\tfor ( ; i < max; i++ ) {\\n\\t\\t\\t\\t\\toption = options[ i ];\\n\\n\\t\\t\\t\\t\\t// Support: IE <=9 only\\n\\t\\t\\t\\t\\t// IE8-9 doesn't update selected after form reset (#2551)\\n\\t\\t\\t\\t\\tif ( ( option.selected || i === index ) &&\\n\\n\\t\\t\\t\\t\\t\\t\\t// Don't return options that are disabled or in a disabled optgroup\\n\\t\\t\\t\\t\\t\\t\\t!option.disabled &&\\n\\t\\t\\t\\t\\t\\t\\t( !option.parentNode.disabled ||\\n\\t\\t\\t\\t\\t\\t\\t\\t!nodeName( option.parentNode, \\\"optgroup\\\" ) ) ) {\\n\\n\\t\\t\\t\\t\\t\\t// Get the specific value for the option\\n\\t\\t\\t\\t\\t\\tvalue = jQuery( option ).val();\\n\\n\\t\\t\\t\\t\\t\\t// We don't need an array for one selects\\n\\t\\t\\t\\t\\t\\tif ( one ) {\\n\\t\\t\\t\\t\\t\\t\\treturn value;\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t// Multi-Selects return an array\\n\\t\\t\\t\\t\\t\\tvalues.push( value );\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn values;\\n\\t\\t\\t},\\n\\n\\t\\t\\tset: function( elem, value ) {\\n\\t\\t\\t\\tvar optionSet, option,\\n\\t\\t\\t\\t\\toptions = elem.options,\\n\\t\\t\\t\\t\\tvalues = jQuery.makeArray( value ),\\n\\t\\t\\t\\t\\ti = options.length;\\n\\n\\t\\t\\t\\twhile ( i-- ) {\\n\\t\\t\\t\\t\\toption = options[ i ];\\n\\n\\t\\t\\t\\t\\t/* eslint-disable no-cond-assign */\\n\\n\\t\\t\\t\\t\\tif ( option.selected =\\n\\t\\t\\t\\t\\t\\tjQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1\\n\\t\\t\\t\\t\\t) {\\n\\t\\t\\t\\t\\t\\toptionSet = true;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t/* eslint-enable no-cond-assign */\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Force browsers to behave consistently when non-matching value is set\\n\\t\\t\\t\\tif ( !optionSet ) {\\n\\t\\t\\t\\t\\telem.selectedIndex = -1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn values;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n} );\\n\\n// Radios and checkboxes getter/setter\\njQuery.each( [ \\\"radio\\\", \\\"checkbox\\\" ], function() {\\n\\tjQuery.valHooks[ this ] = {\\n\\t\\tset: function( elem, value ) {\\n\\t\\t\\tif ( Array.isArray( value ) ) {\\n\\t\\t\\t\\treturn ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );\\n\\t\\t\\t}\\n\\t\\t}\\n\\t};\\n\\tif ( !support.checkOn ) {\\n\\t\\tjQuery.valHooks[ this ].get = function( elem ) {\\n\\t\\t\\treturn elem.getAttribute( \\\"value\\\" ) === null ? \\\"on\\\" : elem.value;\\n\\t\\t};\\n\\t}\\n} );\\n\\n\\n\\n\\n// Return jQuery for attributes-only inclusion\\n\\n\\nsupport.focusin = \\\"onfocusin\\\" in window;\\n\\n\\nvar rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,\\n\\tstopPropagationCallback = function( e ) {\\n\\t\\te.stopPropagation();\\n\\t};\\n\\njQuery.extend( jQuery.event, {\\n\\n\\ttrigger: function( event, data, elem, onlyHandlers ) {\\n\\n\\t\\tvar i, cur, tmp, bubbleType, ontype, handle, special, lastElement,\\n\\t\\t\\teventPath = [ elem || document ],\\n\\t\\t\\ttype = hasOwn.call( event, \\\"type\\\" ) ? event.type : event,\\n\\t\\t\\tnamespaces = hasOwn.call( event, \\\"namespace\\\" ) ? event.namespace.split( \\\".\\\" ) : [];\\n\\n\\t\\tcur = lastElement = tmp = elem = elem || document;\\n\\n\\t\\t// Don't do events on text and comment nodes\\n\\t\\tif ( elem.nodeType === 3 || elem.nodeType === 8 ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\t// focus/blur morphs to focusin/out; ensure we're not firing them right now\\n\\t\\tif ( rfocusMorph.test( type + jQuery.event.triggered ) ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tif ( type.indexOf( \\\".\\\" ) > -1 ) {\\n\\n\\t\\t\\t// Namespaced trigger; create a regexp to match event type in handle()\\n\\t\\t\\tnamespaces = type.split( \\\".\\\" );\\n\\t\\t\\ttype = namespaces.shift();\\n\\t\\t\\tnamespaces.sort();\\n\\t\\t}\\n\\t\\tontype = type.indexOf( \\\":\\\" ) < 0 && \\\"on\\\" + type;\\n\\n\\t\\t// Caller can pass in a jQuery.Event object, Object, or just an event type string\\n\\t\\tevent = event[ jQuery.expando ] ?\\n\\t\\t\\tevent :\\n\\t\\t\\tnew jQuery.Event( type, typeof event === \\\"object\\\" && event );\\n\\n\\t\\t// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)\\n\\t\\tevent.isTrigger = onlyHandlers ? 2 : 3;\\n\\t\\tevent.namespace = namespaces.join( \\\".\\\" );\\n\\t\\tevent.rnamespace = event.namespace ?\\n\\t\\t\\tnew RegExp( \\\"(^|\\\\\\\\.)\\\" + namespaces.join( \\\"\\\\\\\\.(?:.*\\\\\\\\.|)\\\" ) + \\\"(\\\\\\\\.|$)\\\" ) :\\n\\t\\t\\tnull;\\n\\n\\t\\t// Clean up the event in case it is being reused\\n\\t\\tevent.result = undefined;\\n\\t\\tif ( !event.target ) {\\n\\t\\t\\tevent.target = elem;\\n\\t\\t}\\n\\n\\t\\t// Clone any incoming data and prepend the event, creating the handler arg list\\n\\t\\tdata = data == null ?\\n\\t\\t\\t[ event ] :\\n\\t\\t\\tjQuery.makeArray( data, [ event ] );\\n\\n\\t\\t// Allow special events to draw outside the lines\\n\\t\\tspecial = jQuery.event.special[ type ] || {};\\n\\t\\tif ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\t// Determine event propagation path in advance, per W3C events spec (#9951)\\n\\t\\t// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)\\n\\t\\tif ( !onlyHandlers && !special.noBubble && !isWindow( elem ) ) {\\n\\n\\t\\t\\tbubbleType = special.delegateType || type;\\n\\t\\t\\tif ( !rfocusMorph.test( bubbleType + type ) ) {\\n\\t\\t\\t\\tcur = cur.parentNode;\\n\\t\\t\\t}\\n\\t\\t\\tfor ( ; cur; cur = cur.parentNode ) {\\n\\t\\t\\t\\teventPath.push( cur );\\n\\t\\t\\t\\ttmp = cur;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Only add window if we got to document (e.g., not plain obj or detached DOM)\\n\\t\\t\\tif ( tmp === ( elem.ownerDocument || document ) ) {\\n\\t\\t\\t\\teventPath.push( tmp.defaultView || tmp.parentWindow || window );\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// Fire handlers on the event path\\n\\t\\ti = 0;\\n\\t\\twhile ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {\\n\\t\\t\\tlastElement = cur;\\n\\t\\t\\tevent.type = i > 1 ?\\n\\t\\t\\t\\tbubbleType :\\n\\t\\t\\t\\tspecial.bindType || type;\\n\\n\\t\\t\\t// jQuery handler\\n\\t\\t\\thandle = ( dataPriv.get( cur, \\\"events\\\" ) || {} )[ event.type ] &&\\n\\t\\t\\t\\tdataPriv.get( cur, \\\"handle\\\" );\\n\\t\\t\\tif ( handle ) {\\n\\t\\t\\t\\thandle.apply( cur, data );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Native handler\\n\\t\\t\\thandle = ontype && cur[ ontype ];\\n\\t\\t\\tif ( handle && handle.apply && acceptData( cur ) ) {\\n\\t\\t\\t\\tevent.result = handle.apply( cur, data );\\n\\t\\t\\t\\tif ( event.result === false ) {\\n\\t\\t\\t\\t\\tevent.preventDefault();\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tevent.type = type;\\n\\n\\t\\t// If nobody prevented the default action, do it now\\n\\t\\tif ( !onlyHandlers && !event.isDefaultPrevented() ) {\\n\\n\\t\\t\\tif ( ( !special._default ||\\n\\t\\t\\t\\tspecial._default.apply( eventPath.pop(), data ) === false ) &&\\n\\t\\t\\t\\tacceptData( elem ) ) {\\n\\n\\t\\t\\t\\t// Call a native DOM method on the target with the same name as the event.\\n\\t\\t\\t\\t// Don't do default actions on window, that's where global variables be (#6170)\\n\\t\\t\\t\\tif ( ontype && isFunction( elem[ type ] ) && !isWindow( elem ) ) {\\n\\n\\t\\t\\t\\t\\t// Don't re-trigger an onFOO event when we call its FOO() method\\n\\t\\t\\t\\t\\ttmp = elem[ ontype ];\\n\\n\\t\\t\\t\\t\\tif ( tmp ) {\\n\\t\\t\\t\\t\\t\\telem[ ontype ] = null;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t// Prevent re-triggering of the same event, since we already bubbled it above\\n\\t\\t\\t\\t\\tjQuery.event.triggered = type;\\n\\n\\t\\t\\t\\t\\tif ( event.isPropagationStopped() ) {\\n\\t\\t\\t\\t\\t\\tlastElement.addEventListener( type, stopPropagationCallback );\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\telem[ type ]();\\n\\n\\t\\t\\t\\t\\tif ( event.isPropagationStopped() ) {\\n\\t\\t\\t\\t\\t\\tlastElement.removeEventListener( type, stopPropagationCallback );\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tjQuery.event.triggered = undefined;\\n\\n\\t\\t\\t\\t\\tif ( tmp ) {\\n\\t\\t\\t\\t\\t\\telem[ ontype ] = tmp;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn event.result;\\n\\t},\\n\\n\\t// Piggyback on a donor event to simulate a different one\\n\\t// Used only for `focus(in | out)` events\\n\\tsimulate: function( type, elem, event ) {\\n\\t\\tvar e = jQuery.extend(\\n\\t\\t\\tnew jQuery.Event(),\\n\\t\\t\\tevent,\\n\\t\\t\\t{\\n\\t\\t\\t\\ttype: type,\\n\\t\\t\\t\\tisSimulated: true\\n\\t\\t\\t}\\n\\t\\t);\\n\\n\\t\\tjQuery.event.trigger( e, null, elem );\\n\\t}\\n\\n} );\\n\\njQuery.fn.extend( {\\n\\n\\ttrigger: function( type, data ) {\\n\\t\\treturn this.each( function() {\\n\\t\\t\\tjQuery.event.trigger( type, data, this );\\n\\t\\t} );\\n\\t},\\n\\ttriggerHandler: function( type, data ) {\\n\\t\\tvar elem = this[ 0 ];\\n\\t\\tif ( elem ) {\\n\\t\\t\\treturn jQuery.event.trigger( type, data, elem, true );\\n\\t\\t}\\n\\t}\\n} );\\n\\n\\n// Support: Firefox <=44\\n// Firefox doesn't have focus(in | out) events\\n// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787\\n//\\n// Support: Chrome <=48 - 49, Safari <=9.0 - 9.1\\n// focus(in | out) events fire after focus & blur events,\\n// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order\\n// Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857\\nif ( !support.focusin ) {\\n\\tjQuery.each( { focus: \\\"focusin\\\", blur: \\\"focusout\\\" }, function( orig, fix ) {\\n\\n\\t\\t// Attach a single capturing handler on the document while someone wants focusin/focusout\\n\\t\\tvar handler = function( event ) {\\n\\t\\t\\tjQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );\\n\\t\\t};\\n\\n\\t\\tjQuery.event.special[ fix ] = {\\n\\t\\t\\tsetup: function() {\\n\\t\\t\\t\\tvar doc = this.ownerDocument || this,\\n\\t\\t\\t\\t\\tattaches = dataPriv.access( doc, fix );\\n\\n\\t\\t\\t\\tif ( !attaches ) {\\n\\t\\t\\t\\t\\tdoc.addEventListener( orig, handler, true );\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tdataPriv.access( doc, fix, ( attaches || 0 ) + 1 );\\n\\t\\t\\t},\\n\\t\\t\\tteardown: function() {\\n\\t\\t\\t\\tvar doc = this.ownerDocument || this,\\n\\t\\t\\t\\t\\tattaches = dataPriv.access( doc, fix ) - 1;\\n\\n\\t\\t\\t\\tif ( !attaches ) {\\n\\t\\t\\t\\t\\tdoc.removeEventListener( orig, handler, true );\\n\\t\\t\\t\\t\\tdataPriv.remove( doc, fix );\\n\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tdataPriv.access( doc, fix, attaches );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t};\\n\\t} );\\n}\\nvar location = window.location;\\n\\nvar nonce = Date.now();\\n\\nvar rquery = ( /\\\\?/ );\\n\\n\\n\\n// Cross-browser xml parsing\\njQuery.parseXML = function( data ) {\\n\\tvar xml;\\n\\tif ( !data || typeof data !== \\\"string\\\" ) {\\n\\t\\treturn null;\\n\\t}\\n\\n\\t// Support: IE 9 - 11 only\\n\\t// IE throws on parseFromString with invalid input.\\n\\ttry {\\n\\t\\txml = ( new window.DOMParser() ).parseFromString( data, \\\"text/xml\\\" );\\n\\t} catch ( e ) {\\n\\t\\txml = undefined;\\n\\t}\\n\\n\\tif ( !xml || xml.getElementsByTagName( \\\"parsererror\\\" ).length ) {\\n\\t\\tjQuery.error( \\\"Invalid XML: \\\" + data );\\n\\t}\\n\\treturn xml;\\n};\\n\\n\\nvar\\n\\trbracket = /\\\\[\\\\]$/,\\n\\trCRLF = /\\\\r?\\\\n/g,\\n\\trsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,\\n\\trsubmittable = /^(?:input|select|textarea|keygen)/i;\\n\\nfunction buildParams( prefix, obj, traditional, add ) {\\n\\tvar name;\\n\\n\\tif ( Array.isArray( obj ) ) {\\n\\n\\t\\t// Serialize array item.\\n\\t\\tjQuery.each( obj, function( i, v ) {\\n\\t\\t\\tif ( traditional || rbracket.test( prefix ) ) {\\n\\n\\t\\t\\t\\t// Treat each array item as a scalar.\\n\\t\\t\\t\\tadd( prefix, v );\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t// Item is non-scalar (array or object), encode its numeric index.\\n\\t\\t\\t\\tbuildParams(\\n\\t\\t\\t\\t\\tprefix + \\\"[\\\" + ( typeof v === \\\"object\\\" && v != null ? i : \\\"\\\" ) + \\\"]\\\",\\n\\t\\t\\t\\t\\tv,\\n\\t\\t\\t\\t\\ttraditional,\\n\\t\\t\\t\\t\\tadd\\n\\t\\t\\t\\t);\\n\\t\\t\\t}\\n\\t\\t} );\\n\\n\\t} else if ( !traditional && toType( obj ) === \\\"object\\\" ) {\\n\\n\\t\\t// Serialize object item.\\n\\t\\tfor ( name in obj ) {\\n\\t\\t\\tbuildParams( prefix + \\\"[\\\" + name + \\\"]\\\", obj[ name ], traditional, add );\\n\\t\\t}\\n\\n\\t} else {\\n\\n\\t\\t// Serialize scalar item.\\n\\t\\tadd( prefix, obj );\\n\\t}\\n}\\n\\n// Serialize an array of form elements or a set of\\n// key/values into a query string\\njQuery.param = function( a, traditional ) {\\n\\tvar prefix,\\n\\t\\ts = [],\\n\\t\\tadd = function( key, valueOrFunction ) {\\n\\n\\t\\t\\t// If value is a function, invoke it and use its return value\\n\\t\\t\\tvar value = isFunction( valueOrFunction ) ?\\n\\t\\t\\t\\tvalueOrFunction() :\\n\\t\\t\\t\\tvalueOrFunction;\\n\\n\\t\\t\\ts[ s.length ] = encodeURIComponent( key ) + \\\"=\\\" +\\n\\t\\t\\t\\tencodeURIComponent( value == null ? \\\"\\\" : value );\\n\\t\\t};\\n\\n\\t// If an array was passed in, assume that it is an array of form elements.\\n\\tif ( Array.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {\\n\\n\\t\\t// Serialize the form elements\\n\\t\\tjQuery.each( a, function() {\\n\\t\\t\\tadd( this.name, this.value );\\n\\t\\t} );\\n\\n\\t} else {\\n\\n\\t\\t// If traditional, encode the \\\"old\\\" way (the way 1.3.2 or older\\n\\t\\t// did it), otherwise encode params recursively.\\n\\t\\tfor ( prefix in a ) {\\n\\t\\t\\tbuildParams( prefix, a[ prefix ], traditional, add );\\n\\t\\t}\\n\\t}\\n\\n\\t// Return the resulting serialization\\n\\treturn s.join( \\\"&\\\" );\\n};\\n\\njQuery.fn.extend( {\\n\\tserialize: function() {\\n\\t\\treturn jQuery.param( this.serializeArray() );\\n\\t},\\n\\tserializeArray: function() {\\n\\t\\treturn this.map( function() {\\n\\n\\t\\t\\t// Can add propHook for \\\"elements\\\" to filter or add form elements\\n\\t\\t\\tvar elements = jQuery.prop( this, \\\"elements\\\" );\\n\\t\\t\\treturn elements ? jQuery.makeArray( elements ) : this;\\n\\t\\t} )\\n\\t\\t.filter( function() {\\n\\t\\t\\tvar type = this.type;\\n\\n\\t\\t\\t// Use .is( \\\":disabled\\\" ) so that fieldset[disabled] works\\n\\t\\t\\treturn this.name && !jQuery( this ).is( \\\":disabled\\\" ) &&\\n\\t\\t\\t\\trsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&\\n\\t\\t\\t\\t( this.checked || !rcheckableType.test( type ) );\\n\\t\\t} )\\n\\t\\t.map( function( i, elem ) {\\n\\t\\t\\tvar val = jQuery( this ).val();\\n\\n\\t\\t\\tif ( val == null ) {\\n\\t\\t\\t\\treturn null;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( Array.isArray( val ) ) {\\n\\t\\t\\t\\treturn jQuery.map( val, function( val ) {\\n\\t\\t\\t\\t\\treturn { name: elem.name, value: val.replace( rCRLF, \\\"\\\\r\\\\n\\\" ) };\\n\\t\\t\\t\\t} );\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn { name: elem.name, value: val.replace( rCRLF, \\\"\\\\r\\\\n\\\" ) };\\n\\t\\t} ).get();\\n\\t}\\n} );\\n\\n\\nvar\\n\\tr20 = /%20/g,\\n\\trhash = /#.*$/,\\n\\trantiCache = /([?&])_=[^&]*/,\\n\\trheaders = /^(.*?):[ \\\\t]*([^\\\\r\\\\n]*)$/mg,\\n\\n\\t// #7653, #8125, #8152: local protocol detection\\n\\trlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,\\n\\trnoContent = /^(?:GET|HEAD)$/,\\n\\trprotocol = /^\\\\/\\\\//,\\n\\n\\t/* Prefilters\\n\\t * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)\\n\\t * 2) These are called:\\n\\t *    - BEFORE asking for a transport\\n\\t *    - AFTER param serialization (s.data is a string if s.processData is true)\\n\\t * 3) key is the dataType\\n\\t * 4) the catchall symbol \\\"*\\\" can be used\\n\\t * 5) execution will start with transport dataType and THEN continue down to \\\"*\\\" if needed\\n\\t */\\n\\tprefilters = {},\\n\\n\\t/* Transports bindings\\n\\t * 1) key is the dataType\\n\\t * 2) the catchall symbol \\\"*\\\" can be used\\n\\t * 3) selection will start with transport dataType and THEN go to \\\"*\\\" if needed\\n\\t */\\n\\ttransports = {},\\n\\n\\t// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression\\n\\tallTypes = \\\"*/\\\".concat( \\\"*\\\" ),\\n\\n\\t// Anchor tag for parsing the document origin\\n\\toriginAnchor = document.createElement( \\\"a\\\" );\\n\\toriginAnchor.href = location.href;\\n\\n// Base \\\"constructor\\\" for jQuery.ajaxPrefilter and jQuery.ajaxTransport\\nfunction addToPrefiltersOrTransports( structure ) {\\n\\n\\t// dataTypeExpression is optional and defaults to \\\"*\\\"\\n\\treturn function( dataTypeExpression, func ) {\\n\\n\\t\\tif ( typeof dataTypeExpression !== \\\"string\\\" ) {\\n\\t\\t\\tfunc = dataTypeExpression;\\n\\t\\t\\tdataTypeExpression = \\\"*\\\";\\n\\t\\t}\\n\\n\\t\\tvar dataType,\\n\\t\\t\\ti = 0,\\n\\t\\t\\tdataTypes = dataTypeExpression.toLowerCase().match( rnothtmlwhite ) || [];\\n\\n\\t\\tif ( isFunction( func ) ) {\\n\\n\\t\\t\\t// For each dataType in the dataTypeExpression\\n\\t\\t\\twhile ( ( dataType = dataTypes[ i++ ] ) ) {\\n\\n\\t\\t\\t\\t// Prepend if requested\\n\\t\\t\\t\\tif ( dataType[ 0 ] === \\\"+\\\" ) {\\n\\t\\t\\t\\t\\tdataType = dataType.slice( 1 ) || \\\"*\\\";\\n\\t\\t\\t\\t\\t( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );\\n\\n\\t\\t\\t\\t// Otherwise append\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t( structure[ dataType ] = structure[ dataType ] || [] ).push( func );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t};\\n}\\n\\n// Base inspection function for prefilters and transports\\nfunction inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {\\n\\n\\tvar inspected = {},\\n\\t\\tseekingTransport = ( structure === transports );\\n\\n\\tfunction inspect( dataType ) {\\n\\t\\tvar selected;\\n\\t\\tinspected[ dataType ] = true;\\n\\t\\tjQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {\\n\\t\\t\\tvar dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );\\n\\t\\t\\tif ( typeof dataTypeOrTransport === \\\"string\\\" &&\\n\\t\\t\\t\\t!seekingTransport && !inspected[ dataTypeOrTransport ] ) {\\n\\n\\t\\t\\t\\toptions.dataTypes.unshift( dataTypeOrTransport );\\n\\t\\t\\t\\tinspect( dataTypeOrTransport );\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t} else if ( seekingTransport ) {\\n\\t\\t\\t\\treturn !( selected = dataTypeOrTransport );\\n\\t\\t\\t}\\n\\t\\t} );\\n\\t\\treturn selected;\\n\\t}\\n\\n\\treturn inspect( options.dataTypes[ 0 ] ) || !inspected[ \\\"*\\\" ] && inspect( \\\"*\\\" );\\n}\\n\\n// A special extend for ajax options\\n// that takes \\\"flat\\\" options (not to be deep extended)\\n// Fixes #9887\\nfunction ajaxExtend( target, src ) {\\n\\tvar key, deep,\\n\\t\\tflatOptions = jQuery.ajaxSettings.flatOptions || {};\\n\\n\\tfor ( key in src ) {\\n\\t\\tif ( src[ key ] !== undefined ) {\\n\\t\\t\\t( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];\\n\\t\\t}\\n\\t}\\n\\tif ( deep ) {\\n\\t\\tjQuery.extend( true, target, deep );\\n\\t}\\n\\n\\treturn target;\\n}\\n\\n/* Handles responses to an ajax request:\\n * - finds the right dataType (mediates between content-type and expected dataType)\\n * - returns the corresponding response\\n */\\nfunction ajaxHandleResponses( s, jqXHR, responses ) {\\n\\n\\tvar ct, type, finalDataType, firstDataType,\\n\\t\\tcontents = s.contents,\\n\\t\\tdataTypes = s.dataTypes;\\n\\n\\t// Remove auto dataType and get content-type in the process\\n\\twhile ( dataTypes[ 0 ] === \\\"*\\\" ) {\\n\\t\\tdataTypes.shift();\\n\\t\\tif ( ct === undefined ) {\\n\\t\\t\\tct = s.mimeType || jqXHR.getResponseHeader( \\\"Content-Type\\\" );\\n\\t\\t}\\n\\t}\\n\\n\\t// Check if we're dealing with a known content-type\\n\\tif ( ct ) {\\n\\t\\tfor ( type in contents ) {\\n\\t\\t\\tif ( contents[ type ] && contents[ type ].test( ct ) ) {\\n\\t\\t\\t\\tdataTypes.unshift( type );\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t// Check to see if we have a response for the expected dataType\\n\\tif ( dataTypes[ 0 ] in responses ) {\\n\\t\\tfinalDataType = dataTypes[ 0 ];\\n\\t} else {\\n\\n\\t\\t// Try convertible dataTypes\\n\\t\\tfor ( type in responses ) {\\n\\t\\t\\tif ( !dataTypes[ 0 ] || s.converters[ type + \\\" \\\" + dataTypes[ 0 ] ] ) {\\n\\t\\t\\t\\tfinalDataType = type;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\tif ( !firstDataType ) {\\n\\t\\t\\t\\tfirstDataType = type;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// Or just use first one\\n\\t\\tfinalDataType = finalDataType || firstDataType;\\n\\t}\\n\\n\\t// If we found a dataType\\n\\t// We add the dataType to the list if needed\\n\\t// and return the corresponding response\\n\\tif ( finalDataType ) {\\n\\t\\tif ( finalDataType !== dataTypes[ 0 ] ) {\\n\\t\\t\\tdataTypes.unshift( finalDataType );\\n\\t\\t}\\n\\t\\treturn responses[ finalDataType ];\\n\\t}\\n}\\n\\n/* Chain conversions given the request and the original response\\n * Also sets the responseXXX fields on the jqXHR instance\\n */\\nfunction ajaxConvert( s, response, jqXHR, isSuccess ) {\\n\\tvar conv2, current, conv, tmp, prev,\\n\\t\\tconverters = {},\\n\\n\\t\\t// Work with a copy of dataTypes in case we need to modify it for conversion\\n\\t\\tdataTypes = s.dataTypes.slice();\\n\\n\\t// Create converters map with lowercased keys\\n\\tif ( dataTypes[ 1 ] ) {\\n\\t\\tfor ( conv in s.converters ) {\\n\\t\\t\\tconverters[ conv.toLowerCase() ] = s.converters[ conv ];\\n\\t\\t}\\n\\t}\\n\\n\\tcurrent = dataTypes.shift();\\n\\n\\t// Convert to each sequential dataType\\n\\twhile ( current ) {\\n\\n\\t\\tif ( s.responseFields[ current ] ) {\\n\\t\\t\\tjqXHR[ s.responseFields[ current ] ] = response;\\n\\t\\t}\\n\\n\\t\\t// Apply the dataFilter if provided\\n\\t\\tif ( !prev && isSuccess && s.dataFilter ) {\\n\\t\\t\\tresponse = s.dataFilter( response, s.dataType );\\n\\t\\t}\\n\\n\\t\\tprev = current;\\n\\t\\tcurrent = dataTypes.shift();\\n\\n\\t\\tif ( current ) {\\n\\n\\t\\t\\t// There's only work to do if current dataType is non-auto\\n\\t\\t\\tif ( current === \\\"*\\\" ) {\\n\\n\\t\\t\\t\\tcurrent = prev;\\n\\n\\t\\t\\t// Convert response if prev dataType is non-auto and differs from current\\n\\t\\t\\t} else if ( prev !== \\\"*\\\" && prev !== current ) {\\n\\n\\t\\t\\t\\t// Seek a direct converter\\n\\t\\t\\t\\tconv = converters[ prev + \\\" \\\" + current ] || converters[ \\\"* \\\" + current ];\\n\\n\\t\\t\\t\\t// If none found, seek a pair\\n\\t\\t\\t\\tif ( !conv ) {\\n\\t\\t\\t\\t\\tfor ( conv2 in converters ) {\\n\\n\\t\\t\\t\\t\\t\\t// If conv2 outputs current\\n\\t\\t\\t\\t\\t\\ttmp = conv2.split( \\\" \\\" );\\n\\t\\t\\t\\t\\t\\tif ( tmp[ 1 ] === current ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t// If prev can be converted to accepted input\\n\\t\\t\\t\\t\\t\\t\\tconv = converters[ prev + \\\" \\\" + tmp[ 0 ] ] ||\\n\\t\\t\\t\\t\\t\\t\\t\\tconverters[ \\\"* \\\" + tmp[ 0 ] ];\\n\\t\\t\\t\\t\\t\\t\\tif ( conv ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t// Condense equivalence converters\\n\\t\\t\\t\\t\\t\\t\\t\\tif ( conv === true ) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tconv = converters[ conv2 ];\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t// Otherwise, insert the intermediate dataType\\n\\t\\t\\t\\t\\t\\t\\t\\t} else if ( converters[ conv2 ] !== true ) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tcurrent = tmp[ 0 ];\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tdataTypes.unshift( tmp[ 1 ] );\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Apply converter (if not an equivalence)\\n\\t\\t\\t\\tif ( conv !== true ) {\\n\\n\\t\\t\\t\\t\\t// Unless errors are allowed to bubble, catch and return them\\n\\t\\t\\t\\t\\tif ( conv && s.throws ) {\\n\\t\\t\\t\\t\\t\\tresponse = conv( response );\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\ttry {\\n\\t\\t\\t\\t\\t\\t\\tresponse = conv( response );\\n\\t\\t\\t\\t\\t\\t} catch ( e ) {\\n\\t\\t\\t\\t\\t\\t\\treturn {\\n\\t\\t\\t\\t\\t\\t\\t\\tstate: \\\"parsererror\\\",\\n\\t\\t\\t\\t\\t\\t\\t\\terror: conv ? e : \\\"No conversion from \\\" + prev + \\\" to \\\" + current\\n\\t\\t\\t\\t\\t\\t\\t};\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn { state: \\\"success\\\", data: response };\\n}\\n\\njQuery.extend( {\\n\\n\\t// Counter for holding the number of active queries\\n\\tactive: 0,\\n\\n\\t// Last-Modified header cache for next request\\n\\tlastModified: {},\\n\\tetag: {},\\n\\n\\tajaxSettings: {\\n\\t\\turl: location.href,\\n\\t\\ttype: \\\"GET\\\",\\n\\t\\tisLocal: rlocalProtocol.test( location.protocol ),\\n\\t\\tglobal: true,\\n\\t\\tprocessData: true,\\n\\t\\tasync: true,\\n\\t\\tcontentType: \\\"application/x-www-form-urlencoded; charset=UTF-8\\\",\\n\\n\\t\\t/*\\n\\t\\ttimeout: 0,\\n\\t\\tdata: null,\\n\\t\\tdataType: null,\\n\\t\\tusername: null,\\n\\t\\tpassword: null,\\n\\t\\tcache: null,\\n\\t\\tthrows: false,\\n\\t\\ttraditional: false,\\n\\t\\theaders: {},\\n\\t\\t*/\\n\\n\\t\\taccepts: {\\n\\t\\t\\t\\\"*\\\": allTypes,\\n\\t\\t\\ttext: \\\"text/plain\\\",\\n\\t\\t\\thtml: \\\"text/html\\\",\\n\\t\\t\\txml: \\\"application/xml, text/xml\\\",\\n\\t\\t\\tjson: \\\"application/json, text/javascript\\\"\\n\\t\\t},\\n\\n\\t\\tcontents: {\\n\\t\\t\\txml: /\\\\bxml\\\\b/,\\n\\t\\t\\thtml: /\\\\bhtml/,\\n\\t\\t\\tjson: /\\\\bjson\\\\b/\\n\\t\\t},\\n\\n\\t\\tresponseFields: {\\n\\t\\t\\txml: \\\"responseXML\\\",\\n\\t\\t\\ttext: \\\"responseText\\\",\\n\\t\\t\\tjson: \\\"responseJSON\\\"\\n\\t\\t},\\n\\n\\t\\t// Data converters\\n\\t\\t// Keys separate source (or catchall \\\"*\\\") and destination types with a single space\\n\\t\\tconverters: {\\n\\n\\t\\t\\t// Convert anything to text\\n\\t\\t\\t\\\"* text\\\": String,\\n\\n\\t\\t\\t// Text to html (true = no transformation)\\n\\t\\t\\t\\\"text html\\\": true,\\n\\n\\t\\t\\t// Evaluate text as a json expression\\n\\t\\t\\t\\\"text json\\\": JSON.parse,\\n\\n\\t\\t\\t// Parse text as xml\\n\\t\\t\\t\\\"text xml\\\": jQuery.parseXML\\n\\t\\t},\\n\\n\\t\\t// For options that shouldn't be deep extended:\\n\\t\\t// you can add your own custom options here if\\n\\t\\t// and when you create one that shouldn't be\\n\\t\\t// deep extended (see ajaxExtend)\\n\\t\\tflatOptions: {\\n\\t\\t\\turl: true,\\n\\t\\t\\tcontext: true\\n\\t\\t}\\n\\t},\\n\\n\\t// Creates a full fledged settings object into target\\n\\t// with both ajaxSettings and settings fields.\\n\\t// If target is omitted, writes into ajaxSettings.\\n\\tajaxSetup: function( target, settings ) {\\n\\t\\treturn settings ?\\n\\n\\t\\t\\t// Building a settings object\\n\\t\\t\\tajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :\\n\\n\\t\\t\\t// Extending ajaxSettings\\n\\t\\t\\tajaxExtend( jQuery.ajaxSettings, target );\\n\\t},\\n\\n\\tajaxPrefilter: addToPrefiltersOrTransports( prefilters ),\\n\\tajaxTransport: addToPrefiltersOrTransports( transports ),\\n\\n\\t// Main method\\n\\tajax: function( url, options ) {\\n\\n\\t\\t// If url is an object, simulate pre-1.5 signature\\n\\t\\tif ( typeof url === \\\"object\\\" ) {\\n\\t\\t\\toptions = url;\\n\\t\\t\\turl = undefined;\\n\\t\\t}\\n\\n\\t\\t// Force options to be an object\\n\\t\\toptions = options || {};\\n\\n\\t\\tvar transport,\\n\\n\\t\\t\\t// URL without anti-cache param\\n\\t\\t\\tcacheURL,\\n\\n\\t\\t\\t// Response headers\\n\\t\\t\\tresponseHeadersString,\\n\\t\\t\\tresponseHeaders,\\n\\n\\t\\t\\t// timeout handle\\n\\t\\t\\ttimeoutTimer,\\n\\n\\t\\t\\t// Url cleanup var\\n\\t\\t\\turlAnchor,\\n\\n\\t\\t\\t// Request state (becomes false upon send and true upon completion)\\n\\t\\t\\tcompleted,\\n\\n\\t\\t\\t// To know if global events are to be dispatched\\n\\t\\t\\tfireGlobals,\\n\\n\\t\\t\\t// Loop variable\\n\\t\\t\\ti,\\n\\n\\t\\t\\t// uncached part of the url\\n\\t\\t\\tuncached,\\n\\n\\t\\t\\t// Create the final options object\\n\\t\\t\\ts = jQuery.ajaxSetup( {}, options ),\\n\\n\\t\\t\\t// Callbacks context\\n\\t\\t\\tcallbackContext = s.context || s,\\n\\n\\t\\t\\t// Context for global events is callbackContext if it is a DOM node or jQuery collection\\n\\t\\t\\tglobalEventContext = s.context &&\\n\\t\\t\\t\\t( callbackContext.nodeType || callbackContext.jquery ) ?\\n\\t\\t\\t\\t\\tjQuery( callbackContext ) :\\n\\t\\t\\t\\t\\tjQuery.event,\\n\\n\\t\\t\\t// Deferreds\\n\\t\\t\\tdeferred = jQuery.Deferred(),\\n\\t\\t\\tcompleteDeferred = jQuery.Callbacks( \\\"once memory\\\" ),\\n\\n\\t\\t\\t// Status-dependent callbacks\\n\\t\\t\\tstatusCode = s.statusCode || {},\\n\\n\\t\\t\\t// Headers (they are sent all at once)\\n\\t\\t\\trequestHeaders = {},\\n\\t\\t\\trequestHeadersNames = {},\\n\\n\\t\\t\\t// Default abort message\\n\\t\\t\\tstrAbort = \\\"canceled\\\",\\n\\n\\t\\t\\t// Fake xhr\\n\\t\\t\\tjqXHR = {\\n\\t\\t\\t\\treadyState: 0,\\n\\n\\t\\t\\t\\t// Builds headers hashtable if needed\\n\\t\\t\\t\\tgetResponseHeader: function( key ) {\\n\\t\\t\\t\\t\\tvar match;\\n\\t\\t\\t\\t\\tif ( completed ) {\\n\\t\\t\\t\\t\\t\\tif ( !responseHeaders ) {\\n\\t\\t\\t\\t\\t\\t\\tresponseHeaders = {};\\n\\t\\t\\t\\t\\t\\t\\twhile ( ( match = rheaders.exec( responseHeadersString ) ) ) {\\n\\t\\t\\t\\t\\t\\t\\t\\tresponseHeaders[ match[ 1 ].toLowerCase() ] = match[ 2 ];\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tmatch = responseHeaders[ key.toLowerCase() ];\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\treturn match == null ? null : match;\\n\\t\\t\\t\\t},\\n\\n\\t\\t\\t\\t// Raw string\\n\\t\\t\\t\\tgetAllResponseHeaders: function() {\\n\\t\\t\\t\\t\\treturn completed ? responseHeadersString : null;\\n\\t\\t\\t\\t},\\n\\n\\t\\t\\t\\t// Caches the header\\n\\t\\t\\t\\tsetRequestHeader: function( name, value ) {\\n\\t\\t\\t\\t\\tif ( completed == null ) {\\n\\t\\t\\t\\t\\t\\tname = requestHeadersNames[ name.toLowerCase() ] =\\n\\t\\t\\t\\t\\t\\t\\trequestHeadersNames[ name.toLowerCase() ] || name;\\n\\t\\t\\t\\t\\t\\trequestHeaders[ name ] = value;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\treturn this;\\n\\t\\t\\t\\t},\\n\\n\\t\\t\\t\\t// Overrides response content-type header\\n\\t\\t\\t\\toverrideMimeType: function( type ) {\\n\\t\\t\\t\\t\\tif ( completed == null ) {\\n\\t\\t\\t\\t\\t\\ts.mimeType = type;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\treturn this;\\n\\t\\t\\t\\t},\\n\\n\\t\\t\\t\\t// Status-dependent callbacks\\n\\t\\t\\t\\tstatusCode: function( map ) {\\n\\t\\t\\t\\t\\tvar code;\\n\\t\\t\\t\\t\\tif ( map ) {\\n\\t\\t\\t\\t\\t\\tif ( completed ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t// Execute the appropriate callbacks\\n\\t\\t\\t\\t\\t\\t\\tjqXHR.always( map[ jqXHR.status ] );\\n\\t\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\t\\t// Lazy-add the new callbacks in a way that preserves old ones\\n\\t\\t\\t\\t\\t\\t\\tfor ( code in map ) {\\n\\t\\t\\t\\t\\t\\t\\t\\tstatusCode[ code ] = [ statusCode[ code ], map[ code ] ];\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\treturn this;\\n\\t\\t\\t\\t},\\n\\n\\t\\t\\t\\t// Cancel the request\\n\\t\\t\\t\\tabort: function( statusText ) {\\n\\t\\t\\t\\t\\tvar finalText = statusText || strAbort;\\n\\t\\t\\t\\t\\tif ( transport ) {\\n\\t\\t\\t\\t\\t\\ttransport.abort( finalText );\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tdone( 0, finalText );\\n\\t\\t\\t\\t\\treturn this;\\n\\t\\t\\t\\t}\\n\\t\\t\\t};\\n\\n\\t\\t// Attach deferreds\\n\\t\\tdeferred.promise( jqXHR );\\n\\n\\t\\t// Add protocol if not provided (prefilters might expect it)\\n\\t\\t// Handle falsy url in the settings object (#10093: consistency with old signature)\\n\\t\\t// We also use the url parameter if available\\n\\t\\ts.url = ( ( url || s.url || location.href ) + \\\"\\\" )\\n\\t\\t\\t.replace( rprotocol, location.protocol + \\\"//\\\" );\\n\\n\\t\\t// Alias method option to type as per ticket #12004\\n\\t\\ts.type = options.method || options.type || s.method || s.type;\\n\\n\\t\\t// Extract dataTypes list\\n\\t\\ts.dataTypes = ( s.dataType || \\\"*\\\" ).toLowerCase().match( rnothtmlwhite ) || [ \\\"\\\" ];\\n\\n\\t\\t// A cross-domain request is in order when the origin doesn't match the current origin.\\n\\t\\tif ( s.crossDomain == null ) {\\n\\t\\t\\turlAnchor = document.createElement( \\\"a\\\" );\\n\\n\\t\\t\\t// Support: IE <=8 - 11, Edge 12 - 15\\n\\t\\t\\t// IE throws exception on accessing the href property if url is malformed,\\n\\t\\t\\t// e.g. http://example.com:80x/\\n\\t\\t\\ttry {\\n\\t\\t\\t\\turlAnchor.href = s.url;\\n\\n\\t\\t\\t\\t// Support: IE <=8 - 11 only\\n\\t\\t\\t\\t// Anchor's host property isn't correctly set when s.url is relative\\n\\t\\t\\t\\turlAnchor.href = urlAnchor.href;\\n\\t\\t\\t\\ts.crossDomain = originAnchor.protocol + \\\"//\\\" + originAnchor.host !==\\n\\t\\t\\t\\t\\turlAnchor.protocol + \\\"//\\\" + urlAnchor.host;\\n\\t\\t\\t} catch ( e ) {\\n\\n\\t\\t\\t\\t// If there is an error parsing the URL, assume it is crossDomain,\\n\\t\\t\\t\\t// it can be rejected by the transport if it is invalid\\n\\t\\t\\t\\ts.crossDomain = true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// Convert data if not already a string\\n\\t\\tif ( s.data && s.processData && typeof s.data !== \\\"string\\\" ) {\\n\\t\\t\\ts.data = jQuery.param( s.data, s.traditional );\\n\\t\\t}\\n\\n\\t\\t// Apply prefilters\\n\\t\\tinspectPrefiltersOrTransports( prefilters, s, options, jqXHR );\\n\\n\\t\\t// If request was aborted inside a prefilter, stop there\\n\\t\\tif ( completed ) {\\n\\t\\t\\treturn jqXHR;\\n\\t\\t}\\n\\n\\t\\t// We can fire global events as of now if asked to\\n\\t\\t// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)\\n\\t\\tfireGlobals = jQuery.event && s.global;\\n\\n\\t\\t// Watch for a new set of requests\\n\\t\\tif ( fireGlobals && jQuery.active++ === 0 ) {\\n\\t\\t\\tjQuery.event.trigger( \\\"ajaxStart\\\" );\\n\\t\\t}\\n\\n\\t\\t// Uppercase the type\\n\\t\\ts.type = s.type.toUpperCase();\\n\\n\\t\\t// Determine if request has content\\n\\t\\ts.hasContent = !rnoContent.test( s.type );\\n\\n\\t\\t// Save the URL in case we're toying with the If-Modified-Since\\n\\t\\t// and/or If-None-Match header later on\\n\\t\\t// Remove hash to simplify url manipulation\\n\\t\\tcacheURL = s.url.replace( rhash, \\\"\\\" );\\n\\n\\t\\t// More options handling for requests with no content\\n\\t\\tif ( !s.hasContent ) {\\n\\n\\t\\t\\t// Remember the hash so we can put it back\\n\\t\\t\\tuncached = s.url.slice( cacheURL.length );\\n\\n\\t\\t\\t// If data is available and should be processed, append data to url\\n\\t\\t\\tif ( s.data && ( s.processData || typeof s.data === \\\"string\\\" ) ) {\\n\\t\\t\\t\\tcacheURL += ( rquery.test( cacheURL ) ? \\\"&\\\" : \\\"?\\\" ) + s.data;\\n\\n\\t\\t\\t\\t// #9682: remove data so that it's not used in an eventual retry\\n\\t\\t\\t\\tdelete s.data;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Add or update anti-cache param if needed\\n\\t\\t\\tif ( s.cache === false ) {\\n\\t\\t\\t\\tcacheURL = cacheURL.replace( rantiCache, \\\"$1\\\" );\\n\\t\\t\\t\\tuncached = ( rquery.test( cacheURL ) ? \\\"&\\\" : \\\"?\\\" ) + \\\"_=\\\" + ( nonce++ ) + uncached;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Put hash and anti-cache on the URL that will be requested (gh-1732)\\n\\t\\t\\ts.url = cacheURL + uncached;\\n\\n\\t\\t// Change '%20' to '+' if this is encoded form body content (gh-2658)\\n\\t\\t} else if ( s.data && s.processData &&\\n\\t\\t\\t( s.contentType || \\\"\\\" ).indexOf( \\\"application/x-www-form-urlencoded\\\" ) === 0 ) {\\n\\t\\t\\ts.data = s.data.replace( r20, \\\"+\\\" );\\n\\t\\t}\\n\\n\\t\\t// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\\n\\t\\tif ( s.ifModified ) {\\n\\t\\t\\tif ( jQuery.lastModified[ cacheURL ] ) {\\n\\t\\t\\t\\tjqXHR.setRequestHeader( \\\"If-Modified-Since\\\", jQuery.lastModified[ cacheURL ] );\\n\\t\\t\\t}\\n\\t\\t\\tif ( jQuery.etag[ cacheURL ] ) {\\n\\t\\t\\t\\tjqXHR.setRequestHeader( \\\"If-None-Match\\\", jQuery.etag[ cacheURL ] );\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// Set the correct header, if data is being sent\\n\\t\\tif ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {\\n\\t\\t\\tjqXHR.setRequestHeader( \\\"Content-Type\\\", s.contentType );\\n\\t\\t}\\n\\n\\t\\t// Set the Accepts header for the server, depending on the dataType\\n\\t\\tjqXHR.setRequestHeader(\\n\\t\\t\\t\\\"Accept\\\",\\n\\t\\t\\ts.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?\\n\\t\\t\\t\\ts.accepts[ s.dataTypes[ 0 ] ] +\\n\\t\\t\\t\\t\\t( s.dataTypes[ 0 ] !== \\\"*\\\" ? \\\", \\\" + allTypes + \\\"; q=0.01\\\" : \\\"\\\" ) :\\n\\t\\t\\t\\ts.accepts[ \\\"*\\\" ]\\n\\t\\t);\\n\\n\\t\\t// Check for headers option\\n\\t\\tfor ( i in s.headers ) {\\n\\t\\t\\tjqXHR.setRequestHeader( i, s.headers[ i ] );\\n\\t\\t}\\n\\n\\t\\t// Allow custom headers/mimetypes and early abort\\n\\t\\tif ( s.beforeSend &&\\n\\t\\t\\t( s.beforeSend.call( callbackContext, jqXHR, s ) === false || completed ) ) {\\n\\n\\t\\t\\t// Abort if not done already and return\\n\\t\\t\\treturn jqXHR.abort();\\n\\t\\t}\\n\\n\\t\\t// Aborting is no longer a cancellation\\n\\t\\tstrAbort = \\\"abort\\\";\\n\\n\\t\\t// Install callbacks on deferreds\\n\\t\\tcompleteDeferred.add( s.complete );\\n\\t\\tjqXHR.done( s.success );\\n\\t\\tjqXHR.fail( s.error );\\n\\n\\t\\t// Get transport\\n\\t\\ttransport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );\\n\\n\\t\\t// If no transport, we auto-abort\\n\\t\\tif ( !transport ) {\\n\\t\\t\\tdone( -1, \\\"No Transport\\\" );\\n\\t\\t} else {\\n\\t\\t\\tjqXHR.readyState = 1;\\n\\n\\t\\t\\t// Send global event\\n\\t\\t\\tif ( fireGlobals ) {\\n\\t\\t\\t\\tglobalEventContext.trigger( \\\"ajaxSend\\\", [ jqXHR, s ] );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// If request was aborted inside ajaxSend, stop there\\n\\t\\t\\tif ( completed ) {\\n\\t\\t\\t\\treturn jqXHR;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Timeout\\n\\t\\t\\tif ( s.async && s.timeout > 0 ) {\\n\\t\\t\\t\\ttimeoutTimer = window.setTimeout( function() {\\n\\t\\t\\t\\t\\tjqXHR.abort( \\\"timeout\\\" );\\n\\t\\t\\t\\t}, s.timeout );\\n\\t\\t\\t}\\n\\n\\t\\t\\ttry {\\n\\t\\t\\t\\tcompleted = false;\\n\\t\\t\\t\\ttransport.send( requestHeaders, done );\\n\\t\\t\\t} catch ( e ) {\\n\\n\\t\\t\\t\\t// Rethrow post-completion exceptions\\n\\t\\t\\t\\tif ( completed ) {\\n\\t\\t\\t\\t\\tthrow e;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Propagate others as results\\n\\t\\t\\t\\tdone( -1, e );\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// Callback for when everything is done\\n\\t\\tfunction done( status, nativeStatusText, responses, headers ) {\\n\\t\\t\\tvar isSuccess, success, error, response, modified,\\n\\t\\t\\t\\tstatusText = nativeStatusText;\\n\\n\\t\\t\\t// Ignore repeat invocations\\n\\t\\t\\tif ( completed ) {\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\n\\t\\t\\tcompleted = true;\\n\\n\\t\\t\\t// Clear timeout if it exists\\n\\t\\t\\tif ( timeoutTimer ) {\\n\\t\\t\\t\\twindow.clearTimeout( timeoutTimer );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Dereference transport for early garbage collection\\n\\t\\t\\t// (no matter how long the jqXHR object will be used)\\n\\t\\t\\ttransport = undefined;\\n\\n\\t\\t\\t// Cache response headers\\n\\t\\t\\tresponseHeadersString = headers || \\\"\\\";\\n\\n\\t\\t\\t// Set readyState\\n\\t\\t\\tjqXHR.readyState = status > 0 ? 4 : 0;\\n\\n\\t\\t\\t// Determine if successful\\n\\t\\t\\tisSuccess = status >= 200 && status < 300 || status === 304;\\n\\n\\t\\t\\t// Get response data\\n\\t\\t\\tif ( responses ) {\\n\\t\\t\\t\\tresponse = ajaxHandleResponses( s, jqXHR, responses );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Convert no matter what (that way responseXXX fields are always set)\\n\\t\\t\\tresponse = ajaxConvert( s, response, jqXHR, isSuccess );\\n\\n\\t\\t\\t// If successful, handle type chaining\\n\\t\\t\\tif ( isSuccess ) {\\n\\n\\t\\t\\t\\t// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\\n\\t\\t\\t\\tif ( s.ifModified ) {\\n\\t\\t\\t\\t\\tmodified = jqXHR.getResponseHeader( \\\"Last-Modified\\\" );\\n\\t\\t\\t\\t\\tif ( modified ) {\\n\\t\\t\\t\\t\\t\\tjQuery.lastModified[ cacheURL ] = modified;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tmodified = jqXHR.getResponseHeader( \\\"etag\\\" );\\n\\t\\t\\t\\t\\tif ( modified ) {\\n\\t\\t\\t\\t\\t\\tjQuery.etag[ cacheURL ] = modified;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// if no content\\n\\t\\t\\t\\tif ( status === 204 || s.type === \\\"HEAD\\\" ) {\\n\\t\\t\\t\\t\\tstatusText = \\\"nocontent\\\";\\n\\n\\t\\t\\t\\t// if not modified\\n\\t\\t\\t\\t} else if ( status === 304 ) {\\n\\t\\t\\t\\t\\tstatusText = \\\"notmodified\\\";\\n\\n\\t\\t\\t\\t// If we have data, let's convert it\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tstatusText = response.state;\\n\\t\\t\\t\\t\\tsuccess = response.data;\\n\\t\\t\\t\\t\\terror = response.error;\\n\\t\\t\\t\\t\\tisSuccess = !error;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t// Extract error from statusText and normalize for non-aborts\\n\\t\\t\\t\\terror = statusText;\\n\\t\\t\\t\\tif ( status || !statusText ) {\\n\\t\\t\\t\\t\\tstatusText = \\\"error\\\";\\n\\t\\t\\t\\t\\tif ( status < 0 ) {\\n\\t\\t\\t\\t\\t\\tstatus = 0;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Set data for the fake xhr object\\n\\t\\t\\tjqXHR.status = status;\\n\\t\\t\\tjqXHR.statusText = ( nativeStatusText || statusText ) + \\\"\\\";\\n\\n\\t\\t\\t// Success/Error\\n\\t\\t\\tif ( isSuccess ) {\\n\\t\\t\\t\\tdeferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tdeferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Status-dependent callbacks\\n\\t\\t\\tjqXHR.statusCode( statusCode );\\n\\t\\t\\tstatusCode = undefined;\\n\\n\\t\\t\\tif ( fireGlobals ) {\\n\\t\\t\\t\\tglobalEventContext.trigger( isSuccess ? \\\"ajaxSuccess\\\" : \\\"ajaxError\\\",\\n\\t\\t\\t\\t\\t[ jqXHR, s, isSuccess ? success : error ] );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Complete\\n\\t\\t\\tcompleteDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );\\n\\n\\t\\t\\tif ( fireGlobals ) {\\n\\t\\t\\t\\tglobalEventContext.trigger( \\\"ajaxComplete\\\", [ jqXHR, s ] );\\n\\n\\t\\t\\t\\t// Handle the global AJAX counter\\n\\t\\t\\t\\tif ( !( --jQuery.active ) ) {\\n\\t\\t\\t\\t\\tjQuery.event.trigger( \\\"ajaxStop\\\" );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn jqXHR;\\n\\t},\\n\\n\\tgetJSON: function( url, data, callback ) {\\n\\t\\treturn jQuery.get( url, data, callback, \\\"json\\\" );\\n\\t},\\n\\n\\tgetScript: function( url, callback ) {\\n\\t\\treturn jQuery.get( url, undefined, callback, \\\"script\\\" );\\n\\t}\\n} );\\n\\njQuery.each( [ \\\"get\\\", \\\"post\\\" ], function( i, method ) {\\n\\tjQuery[ method ] = function( url, data, callback, type ) {\\n\\n\\t\\t// Shift arguments if data argument was omitted\\n\\t\\tif ( isFunction( data ) ) {\\n\\t\\t\\ttype = type || callback;\\n\\t\\t\\tcallback = data;\\n\\t\\t\\tdata = undefined;\\n\\t\\t}\\n\\n\\t\\t// The url can be an options object (which then must have .url)\\n\\t\\treturn jQuery.ajax( jQuery.extend( {\\n\\t\\t\\turl: url,\\n\\t\\t\\ttype: method,\\n\\t\\t\\tdataType: type,\\n\\t\\t\\tdata: data,\\n\\t\\t\\tsuccess: callback\\n\\t\\t}, jQuery.isPlainObject( url ) && url ) );\\n\\t};\\n} );\\n\\n\\njQuery._evalUrl = function( url ) {\\n\\treturn jQuery.ajax( {\\n\\t\\turl: url,\\n\\n\\t\\t// Make this explicit, since user can override this through ajaxSetup (#11264)\\n\\t\\ttype: \\\"GET\\\",\\n\\t\\tdataType: \\\"script\\\",\\n\\t\\tcache: true,\\n\\t\\tasync: false,\\n\\t\\tglobal: false,\\n\\t\\t\\\"throws\\\": true\\n\\t} );\\n};\\n\\n\\njQuery.fn.extend( {\\n\\twrapAll: function( html ) {\\n\\t\\tvar wrap;\\n\\n\\t\\tif ( this[ 0 ] ) {\\n\\t\\t\\tif ( isFunction( html ) ) {\\n\\t\\t\\t\\thtml = html.call( this[ 0 ] );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// The elements to wrap the target around\\n\\t\\t\\twrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );\\n\\n\\t\\t\\tif ( this[ 0 ].parentNode ) {\\n\\t\\t\\t\\twrap.insertBefore( this[ 0 ] );\\n\\t\\t\\t}\\n\\n\\t\\t\\twrap.map( function() {\\n\\t\\t\\t\\tvar elem = this;\\n\\n\\t\\t\\t\\twhile ( elem.firstElementChild ) {\\n\\t\\t\\t\\t\\telem = elem.firstElementChild;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn elem;\\n\\t\\t\\t} ).append( this );\\n\\t\\t}\\n\\n\\t\\treturn this;\\n\\t},\\n\\n\\twrapInner: function( html ) {\\n\\t\\tif ( isFunction( html ) ) {\\n\\t\\t\\treturn this.each( function( i ) {\\n\\t\\t\\t\\tjQuery( this ).wrapInner( html.call( this, i ) );\\n\\t\\t\\t} );\\n\\t\\t}\\n\\n\\t\\treturn this.each( function() {\\n\\t\\t\\tvar self = jQuery( this ),\\n\\t\\t\\t\\tcontents = self.contents();\\n\\n\\t\\t\\tif ( contents.length ) {\\n\\t\\t\\t\\tcontents.wrapAll( html );\\n\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tself.append( html );\\n\\t\\t\\t}\\n\\t\\t} );\\n\\t},\\n\\n\\twrap: function( html ) {\\n\\t\\tvar htmlIsFunction = isFunction( html );\\n\\n\\t\\treturn this.each( function( i ) {\\n\\t\\t\\tjQuery( this ).wrapAll( htmlIsFunction ? html.call( this, i ) : html );\\n\\t\\t} );\\n\\t},\\n\\n\\tunwrap: function( selector ) {\\n\\t\\tthis.parent( selector ).not( \\\"body\\\" ).each( function() {\\n\\t\\t\\tjQuery( this ).replaceWith( this.childNodes );\\n\\t\\t} );\\n\\t\\treturn this;\\n\\t}\\n} );\\n\\n\\njQuery.expr.pseudos.hidden = function( elem ) {\\n\\treturn !jQuery.expr.pseudos.visible( elem );\\n};\\njQuery.expr.pseudos.visible = function( elem ) {\\n\\treturn !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );\\n};\\n\\n\\n\\n\\njQuery.ajaxSettings.xhr = function() {\\n\\ttry {\\n\\t\\treturn new window.XMLHttpRequest();\\n\\t} catch ( e ) {}\\n};\\n\\nvar xhrSuccessStatus = {\\n\\n\\t\\t// File protocol always yields status code 0, assume 200\\n\\t\\t0: 200,\\n\\n\\t\\t// Support: IE <=9 only\\n\\t\\t// #1450: sometimes IE returns 1223 when it should be 204\\n\\t\\t1223: 204\\n\\t},\\n\\txhrSupported = jQuery.ajaxSettings.xhr();\\n\\nsupport.cors = !!xhrSupported && ( \\\"withCredentials\\\" in xhrSupported );\\nsupport.ajax = xhrSupported = !!xhrSupported;\\n\\njQuery.ajaxTransport( function( options ) {\\n\\tvar callback, errorCallback;\\n\\n\\t// Cross domain only allowed if supported through XMLHttpRequest\\n\\tif ( support.cors || xhrSupported && !options.crossDomain ) {\\n\\t\\treturn {\\n\\t\\t\\tsend: function( headers, complete ) {\\n\\t\\t\\t\\tvar i,\\n\\t\\t\\t\\t\\txhr = options.xhr();\\n\\n\\t\\t\\t\\txhr.open(\\n\\t\\t\\t\\t\\toptions.type,\\n\\t\\t\\t\\t\\toptions.url,\\n\\t\\t\\t\\t\\toptions.async,\\n\\t\\t\\t\\t\\toptions.username,\\n\\t\\t\\t\\t\\toptions.password\\n\\t\\t\\t\\t);\\n\\n\\t\\t\\t\\t// Apply custom fields if provided\\n\\t\\t\\t\\tif ( options.xhrFields ) {\\n\\t\\t\\t\\t\\tfor ( i in options.xhrFields ) {\\n\\t\\t\\t\\t\\t\\txhr[ i ] = options.xhrFields[ i ];\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Override mime type if needed\\n\\t\\t\\t\\tif ( options.mimeType && xhr.overrideMimeType ) {\\n\\t\\t\\t\\t\\txhr.overrideMimeType( options.mimeType );\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// X-Requested-With header\\n\\t\\t\\t\\t// For cross-domain requests, seeing as conditions for a preflight are\\n\\t\\t\\t\\t// akin to a jigsaw puzzle, we simply never set it to be sure.\\n\\t\\t\\t\\t// (it can always be set on a per-request basis or even using ajaxSetup)\\n\\t\\t\\t\\t// For same-domain requests, won't change header if already provided.\\n\\t\\t\\t\\tif ( !options.crossDomain && !headers[ \\\"X-Requested-With\\\" ] ) {\\n\\t\\t\\t\\t\\theaders[ \\\"X-Requested-With\\\" ] = \\\"XMLHttpRequest\\\";\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Set headers\\n\\t\\t\\t\\tfor ( i in headers ) {\\n\\t\\t\\t\\t\\txhr.setRequestHeader( i, headers[ i ] );\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Callback\\n\\t\\t\\t\\tcallback = function( type ) {\\n\\t\\t\\t\\t\\treturn function() {\\n\\t\\t\\t\\t\\t\\tif ( callback ) {\\n\\t\\t\\t\\t\\t\\t\\tcallback = errorCallback = xhr.onload =\\n\\t\\t\\t\\t\\t\\t\\t\\txhr.onerror = xhr.onabort = xhr.ontimeout =\\n\\t\\t\\t\\t\\t\\t\\t\\t\\txhr.onreadystatechange = null;\\n\\n\\t\\t\\t\\t\\t\\t\\tif ( type === \\\"abort\\\" ) {\\n\\t\\t\\t\\t\\t\\t\\t\\txhr.abort();\\n\\t\\t\\t\\t\\t\\t\\t} else if ( type === \\\"error\\\" ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t// Support: IE <=9 only\\n\\t\\t\\t\\t\\t\\t\\t\\t// On a manual native abort, IE9 throws\\n\\t\\t\\t\\t\\t\\t\\t\\t// errors on any property access that is not readyState\\n\\t\\t\\t\\t\\t\\t\\t\\tif ( typeof xhr.status !== \\\"number\\\" ) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tcomplete( 0, \\\"error\\\" );\\n\\t\\t\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tcomplete(\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// File: protocol always yields status 0; see #8605, #14207\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\txhr.status,\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\txhr.statusText\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t);\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\t\\tcomplete(\\n\\t\\t\\t\\t\\t\\t\\t\\t\\txhrSuccessStatus[ xhr.status ] || xhr.status,\\n\\t\\t\\t\\t\\t\\t\\t\\t\\txhr.statusText,\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// Support: IE <=9 only\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// IE9 has no XHR2 but throws on binary (trac-11426)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// For XHR2 non-text, let the caller handle it (gh-2498)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t( xhr.responseType || \\\"text\\\" ) !== \\\"text\\\"  ||\\n\\t\\t\\t\\t\\t\\t\\t\\t\\ttypeof xhr.responseText !== \\\"string\\\" ?\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t{ binary: xhr.response } :\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t{ text: xhr.responseText },\\n\\t\\t\\t\\t\\t\\t\\t\\t\\txhr.getAllResponseHeaders()\\n\\t\\t\\t\\t\\t\\t\\t\\t);\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t};\\n\\t\\t\\t\\t};\\n\\n\\t\\t\\t\\t// Listen to events\\n\\t\\t\\t\\txhr.onload = callback();\\n\\t\\t\\t\\terrorCallback = xhr.onerror = xhr.ontimeout = callback( \\\"error\\\" );\\n\\n\\t\\t\\t\\t// Support: IE 9 only\\n\\t\\t\\t\\t// Use onreadystatechange to replace onabort\\n\\t\\t\\t\\t// to handle uncaught aborts\\n\\t\\t\\t\\tif ( xhr.onabort !== undefined ) {\\n\\t\\t\\t\\t\\txhr.onabort = errorCallback;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\txhr.onreadystatechange = function() {\\n\\n\\t\\t\\t\\t\\t\\t// Check readyState before timeout as it changes\\n\\t\\t\\t\\t\\t\\tif ( xhr.readyState === 4 ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t// Allow onerror to be called first,\\n\\t\\t\\t\\t\\t\\t\\t// but that will not handle a native abort\\n\\t\\t\\t\\t\\t\\t\\t// Also, save errorCallback to a variable\\n\\t\\t\\t\\t\\t\\t\\t// as xhr.onerror cannot be accessed\\n\\t\\t\\t\\t\\t\\t\\twindow.setTimeout( function() {\\n\\t\\t\\t\\t\\t\\t\\t\\tif ( callback ) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\terrorCallback();\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t} );\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t};\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Create the abort callback\\n\\t\\t\\t\\tcallback = callback( \\\"abort\\\" );\\n\\n\\t\\t\\t\\ttry {\\n\\n\\t\\t\\t\\t\\t// Do send the request (this may raise an exception)\\n\\t\\t\\t\\t\\txhr.send( options.hasContent && options.data || null );\\n\\t\\t\\t\\t} catch ( e ) {\\n\\n\\t\\t\\t\\t\\t// #14683: Only rethrow if this hasn't been notified as an error yet\\n\\t\\t\\t\\t\\tif ( callback ) {\\n\\t\\t\\t\\t\\t\\tthrow e;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t},\\n\\n\\t\\t\\tabort: function() {\\n\\t\\t\\t\\tif ( callback ) {\\n\\t\\t\\t\\t\\tcallback();\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t};\\n\\t}\\n} );\\n\\n\\n\\n\\n// Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)\\njQuery.ajaxPrefilter( function( s ) {\\n\\tif ( s.crossDomain ) {\\n\\t\\ts.contents.script = false;\\n\\t}\\n} );\\n\\n// Install script dataType\\njQuery.ajaxSetup( {\\n\\taccepts: {\\n\\t\\tscript: \\\"text/javascript, application/javascript, \\\" +\\n\\t\\t\\t\\\"application/ecmascript, application/x-ecmascript\\\"\\n\\t},\\n\\tcontents: {\\n\\t\\tscript: /\\\\b(?:java|ecma)script\\\\b/\\n\\t},\\n\\tconverters: {\\n\\t\\t\\\"text script\\\": function( text ) {\\n\\t\\t\\tjQuery.globalEval( text );\\n\\t\\t\\treturn text;\\n\\t\\t}\\n\\t}\\n} );\\n\\n// Handle cache's special case and crossDomain\\njQuery.ajaxPrefilter( \\\"script\\\", function( s ) {\\n\\tif ( s.cache === undefined ) {\\n\\t\\ts.cache = false;\\n\\t}\\n\\tif ( s.crossDomain ) {\\n\\t\\ts.type = \\\"GET\\\";\\n\\t}\\n} );\\n\\n// Bind script tag hack transport\\njQuery.ajaxTransport( \\\"script\\\", function( s ) {\\n\\n\\t// This transport only deals with cross domain requests\\n\\tif ( s.crossDomain ) {\\n\\t\\tvar script, callback;\\n\\t\\treturn {\\n\\t\\t\\tsend: function( _, complete ) {\\n\\t\\t\\t\\tscript = jQuery( \\\"<script>\\\" ).prop( {\\n\\t\\t\\t\\t\\tcharset: s.scriptCharset,\\n\\t\\t\\t\\t\\tsrc: s.url\\n\\t\\t\\t\\t} ).on(\\n\\t\\t\\t\\t\\t\\\"load error\\\",\\n\\t\\t\\t\\t\\tcallback = function( evt ) {\\n\\t\\t\\t\\t\\t\\tscript.remove();\\n\\t\\t\\t\\t\\t\\tcallback = null;\\n\\t\\t\\t\\t\\t\\tif ( evt ) {\\n\\t\\t\\t\\t\\t\\t\\tcomplete( evt.type === \\\"error\\\" ? 404 : 200, evt.type );\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t);\\n\\n\\t\\t\\t\\t// Use native DOM manipulation to avoid our domManip AJAX trickery\\n\\t\\t\\t\\tdocument.head.appendChild( script[ 0 ] );\\n\\t\\t\\t},\\n\\t\\t\\tabort: function() {\\n\\t\\t\\t\\tif ( callback ) {\\n\\t\\t\\t\\t\\tcallback();\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t};\\n\\t}\\n} );\\n\\n\\n\\n\\nvar oldCallbacks = [],\\n\\trjsonp = /(=)\\\\?(?=&|$)|\\\\?\\\\?/;\\n\\n// Default jsonp settings\\njQuery.ajaxSetup( {\\n\\tjsonp: \\\"callback\\\",\\n\\tjsonpCallback: function() {\\n\\t\\tvar callback = oldCallbacks.pop() || ( jQuery.expando + \\\"_\\\" + ( nonce++ ) );\\n\\t\\tthis[ callback ] = true;\\n\\t\\treturn callback;\\n\\t}\\n} );\\n\\n// Detect, normalize options and install callbacks for jsonp requests\\njQuery.ajaxPrefilter( \\\"json jsonp\\\", function( s, originalSettings, jqXHR ) {\\n\\n\\tvar callbackName, overwritten, responseContainer,\\n\\t\\tjsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?\\n\\t\\t\\t\\\"url\\\" :\\n\\t\\t\\ttypeof s.data === \\\"string\\\" &&\\n\\t\\t\\t\\t( s.contentType || \\\"\\\" )\\n\\t\\t\\t\\t\\t.indexOf( \\\"application/x-www-form-urlencoded\\\" ) === 0 &&\\n\\t\\t\\t\\trjsonp.test( s.data ) && \\\"data\\\"\\n\\t\\t);\\n\\n\\t// Handle iff the expected data type is \\\"jsonp\\\" or we have a parameter to set\\n\\tif ( jsonProp || s.dataTypes[ 0 ] === \\\"jsonp\\\" ) {\\n\\n\\t\\t// Get callback name, remembering preexisting value associated with it\\n\\t\\tcallbackName = s.jsonpCallback = isFunction( s.jsonpCallback ) ?\\n\\t\\t\\ts.jsonpCallback() :\\n\\t\\t\\ts.jsonpCallback;\\n\\n\\t\\t// Insert callback into url or form data\\n\\t\\tif ( jsonProp ) {\\n\\t\\t\\ts[ jsonProp ] = s[ jsonProp ].replace( rjsonp, \\\"$1\\\" + callbackName );\\n\\t\\t} else if ( s.jsonp !== false ) {\\n\\t\\t\\ts.url += ( rquery.test( s.url ) ? \\\"&\\\" : \\\"?\\\" ) + s.jsonp + \\\"=\\\" + callbackName;\\n\\t\\t}\\n\\n\\t\\t// Use data converter to retrieve json after script execution\\n\\t\\ts.converters[ \\\"script json\\\" ] = function() {\\n\\t\\t\\tif ( !responseContainer ) {\\n\\t\\t\\t\\tjQuery.error( callbackName + \\\" was not called\\\" );\\n\\t\\t\\t}\\n\\t\\t\\treturn responseContainer[ 0 ];\\n\\t\\t};\\n\\n\\t\\t// Force json dataType\\n\\t\\ts.dataTypes[ 0 ] = \\\"json\\\";\\n\\n\\t\\t// Install callback\\n\\t\\toverwritten = window[ callbackName ];\\n\\t\\twindow[ callbackName ] = function() {\\n\\t\\t\\tresponseContainer = arguments;\\n\\t\\t};\\n\\n\\t\\t// Clean-up function (fires after converters)\\n\\t\\tjqXHR.always( function() {\\n\\n\\t\\t\\t// If previous value didn't exist - remove it\\n\\t\\t\\tif ( overwritten === undefined ) {\\n\\t\\t\\t\\tjQuery( window ).removeProp( callbackName );\\n\\n\\t\\t\\t// Otherwise restore preexisting value\\n\\t\\t\\t} else {\\n\\t\\t\\t\\twindow[ callbackName ] = overwritten;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Save back as free\\n\\t\\t\\tif ( s[ callbackName ] ) {\\n\\n\\t\\t\\t\\t// Make sure that re-using the options doesn't screw things around\\n\\t\\t\\t\\ts.jsonpCallback = originalSettings.jsonpCallback;\\n\\n\\t\\t\\t\\t// Save the callback name for future use\\n\\t\\t\\t\\toldCallbacks.push( callbackName );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Call if it was a function and we have a response\\n\\t\\t\\tif ( responseContainer && isFunction( overwritten ) ) {\\n\\t\\t\\t\\toverwritten( responseContainer[ 0 ] );\\n\\t\\t\\t}\\n\\n\\t\\t\\tresponseContainer = overwritten = undefined;\\n\\t\\t} );\\n\\n\\t\\t// Delegate to script\\n\\t\\treturn \\\"script\\\";\\n\\t}\\n} );\\n\\n\\n\\n\\n// Support: Safari 8 only\\n// In Safari 8 documents created via document.implementation.createHTMLDocument\\n// collapse sibling forms: the second one becomes a child of the first one.\\n// Because of that, this security measure has to be disabled in Safari 8.\\n// https://bugs.webkit.org/show_bug.cgi?id=137337\\nsupport.createHTMLDocument = ( function() {\\n\\tvar body = document.implementation.createHTMLDocument( \\\"\\\" ).body;\\n\\tbody.innerHTML = \\\"<form></form><form></form>\\\";\\n\\treturn body.childNodes.length === 2;\\n} )();\\n\\n\\n// Argument \\\"data\\\" should be string of html\\n// context (optional): If specified, the fragment will be created in this context,\\n// defaults to document\\n// keepScripts (optional): If true, will include scripts passed in the html string\\njQuery.parseHTML = function( data, context, keepScripts ) {\\n\\tif ( typeof data !== \\\"string\\\" ) {\\n\\t\\treturn [];\\n\\t}\\n\\tif ( typeof context === \\\"boolean\\\" ) {\\n\\t\\tkeepScripts = context;\\n\\t\\tcontext = false;\\n\\t}\\n\\n\\tvar base, parsed, scripts;\\n\\n\\tif ( !context ) {\\n\\n\\t\\t// Stop scripts or inline event handlers from being executed immediately\\n\\t\\t// by using document.implementation\\n\\t\\tif ( support.createHTMLDocument ) {\\n\\t\\t\\tcontext = document.implementation.createHTMLDocument( \\\"\\\" );\\n\\n\\t\\t\\t// Set the base href for the created document\\n\\t\\t\\t// so any parsed elements with URLs\\n\\t\\t\\t// are based on the document's URL (gh-2965)\\n\\t\\t\\tbase = context.createElement( \\\"base\\\" );\\n\\t\\t\\tbase.href = document.location.href;\\n\\t\\t\\tcontext.head.appendChild( base );\\n\\t\\t} else {\\n\\t\\t\\tcontext = document;\\n\\t\\t}\\n\\t}\\n\\n\\tparsed = rsingleTag.exec( data );\\n\\tscripts = !keepScripts && [];\\n\\n\\t// Single tag\\n\\tif ( parsed ) {\\n\\t\\treturn [ context.createElement( parsed[ 1 ] ) ];\\n\\t}\\n\\n\\tparsed = buildFragment( [ data ], context, scripts );\\n\\n\\tif ( scripts && scripts.length ) {\\n\\t\\tjQuery( scripts ).remove();\\n\\t}\\n\\n\\treturn jQuery.merge( [], parsed.childNodes );\\n};\\n\\n\\n/**\\n * Load a url into a page\\n */\\njQuery.fn.load = function( url, params, callback ) {\\n\\tvar selector, type, response,\\n\\t\\tself = this,\\n\\t\\toff = url.indexOf( \\\" \\\" );\\n\\n\\tif ( off > -1 ) {\\n\\t\\tselector = stripAndCollapse( url.slice( off ) );\\n\\t\\turl = url.slice( 0, off );\\n\\t}\\n\\n\\t// If it's a function\\n\\tif ( isFunction( params ) ) {\\n\\n\\t\\t// We assume that it's the callback\\n\\t\\tcallback = params;\\n\\t\\tparams = undefined;\\n\\n\\t// Otherwise, build a param string\\n\\t} else if ( params && typeof params === \\\"object\\\" ) {\\n\\t\\ttype = \\\"POST\\\";\\n\\t}\\n\\n\\t// If we have elements to modify, make the request\\n\\tif ( self.length > 0 ) {\\n\\t\\tjQuery.ajax( {\\n\\t\\t\\turl: url,\\n\\n\\t\\t\\t// If \\\"type\\\" variable is undefined, then \\\"GET\\\" method will be used.\\n\\t\\t\\t// Make value of this field explicit since\\n\\t\\t\\t// user can override it through ajaxSetup method\\n\\t\\t\\ttype: type || \\\"GET\\\",\\n\\t\\t\\tdataType: \\\"html\\\",\\n\\t\\t\\tdata: params\\n\\t\\t} ).done( function( responseText ) {\\n\\n\\t\\t\\t// Save response for use in complete callback\\n\\t\\t\\tresponse = arguments;\\n\\n\\t\\t\\tself.html( selector ?\\n\\n\\t\\t\\t\\t// If a selector was specified, locate the right elements in a dummy div\\n\\t\\t\\t\\t// Exclude scripts to avoid IE 'Permission Denied' errors\\n\\t\\t\\t\\tjQuery( \\\"<div>\\\" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :\\n\\n\\t\\t\\t\\t// Otherwise use the full result\\n\\t\\t\\t\\tresponseText );\\n\\n\\t\\t// If the request succeeds, this function gets \\\"data\\\", \\\"status\\\", \\\"jqXHR\\\"\\n\\t\\t// but they are ignored because response was set above.\\n\\t\\t// If it fails, this function gets \\\"jqXHR\\\", \\\"status\\\", \\\"error\\\"\\n\\t\\t} ).always( callback && function( jqXHR, status ) {\\n\\t\\t\\tself.each( function() {\\n\\t\\t\\t\\tcallback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );\\n\\t\\t\\t} );\\n\\t\\t} );\\n\\t}\\n\\n\\treturn this;\\n};\\n\\n\\n\\n\\n// Attach a bunch of functions for handling common AJAX events\\njQuery.each( [\\n\\t\\\"ajaxStart\\\",\\n\\t\\\"ajaxStop\\\",\\n\\t\\\"ajaxComplete\\\",\\n\\t\\\"ajaxError\\\",\\n\\t\\\"ajaxSuccess\\\",\\n\\t\\\"ajaxSend\\\"\\n], function( i, type ) {\\n\\tjQuery.fn[ type ] = function( fn ) {\\n\\t\\treturn this.on( type, fn );\\n\\t};\\n} );\\n\\n\\n\\n\\njQuery.expr.pseudos.animated = function( elem ) {\\n\\treturn jQuery.grep( jQuery.timers, function( fn ) {\\n\\t\\treturn elem === fn.elem;\\n\\t} ).length;\\n};\\n\\n\\n\\n\\njQuery.offset = {\\n\\tsetOffset: function( elem, options, i ) {\\n\\t\\tvar curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,\\n\\t\\t\\tposition = jQuery.css( elem, \\\"position\\\" ),\\n\\t\\t\\tcurElem = jQuery( elem ),\\n\\t\\t\\tprops = {};\\n\\n\\t\\t// Set position first, in-case top/left are set even on static elem\\n\\t\\tif ( position === \\\"static\\\" ) {\\n\\t\\t\\telem.style.position = \\\"relative\\\";\\n\\t\\t}\\n\\n\\t\\tcurOffset = curElem.offset();\\n\\t\\tcurCSSTop = jQuery.css( elem, \\\"top\\\" );\\n\\t\\tcurCSSLeft = jQuery.css( elem, \\\"left\\\" );\\n\\t\\tcalculatePosition = ( position === \\\"absolute\\\" || position === \\\"fixed\\\" ) &&\\n\\t\\t\\t( curCSSTop + curCSSLeft ).indexOf( \\\"auto\\\" ) > -1;\\n\\n\\t\\t// Need to be able to calculate position if either\\n\\t\\t// top or left is auto and position is either absolute or fixed\\n\\t\\tif ( calculatePosition ) {\\n\\t\\t\\tcurPosition = curElem.position();\\n\\t\\t\\tcurTop = curPosition.top;\\n\\t\\t\\tcurLeft = curPosition.left;\\n\\n\\t\\t} else {\\n\\t\\t\\tcurTop = parseFloat( curCSSTop ) || 0;\\n\\t\\t\\tcurLeft = parseFloat( curCSSLeft ) || 0;\\n\\t\\t}\\n\\n\\t\\tif ( isFunction( options ) ) {\\n\\n\\t\\t\\t// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)\\n\\t\\t\\toptions = options.call( elem, i, jQuery.extend( {}, curOffset ) );\\n\\t\\t}\\n\\n\\t\\tif ( options.top != null ) {\\n\\t\\t\\tprops.top = ( options.top - curOffset.top ) + curTop;\\n\\t\\t}\\n\\t\\tif ( options.left != null ) {\\n\\t\\t\\tprops.left = ( options.left - curOffset.left ) + curLeft;\\n\\t\\t}\\n\\n\\t\\tif ( \\\"using\\\" in options ) {\\n\\t\\t\\toptions.using.call( elem, props );\\n\\n\\t\\t} else {\\n\\t\\t\\tcurElem.css( props );\\n\\t\\t}\\n\\t}\\n};\\n\\njQuery.fn.extend( {\\n\\n\\t// offset() relates an element's border box to the document origin\\n\\toffset: function( options ) {\\n\\n\\t\\t// Preserve chaining for setter\\n\\t\\tif ( arguments.length ) {\\n\\t\\t\\treturn options === undefined ?\\n\\t\\t\\t\\tthis :\\n\\t\\t\\t\\tthis.each( function( i ) {\\n\\t\\t\\t\\t\\tjQuery.offset.setOffset( this, options, i );\\n\\t\\t\\t\\t} );\\n\\t\\t}\\n\\n\\t\\tvar rect, win,\\n\\t\\t\\telem = this[ 0 ];\\n\\n\\t\\tif ( !elem ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\t// Return zeros for disconnected and hidden (display: none) elements (gh-2310)\\n\\t\\t// Support: IE <=11 only\\n\\t\\t// Running getBoundingClientRect on a\\n\\t\\t// disconnected node in IE throws an error\\n\\t\\tif ( !elem.getClientRects().length ) {\\n\\t\\t\\treturn { top: 0, left: 0 };\\n\\t\\t}\\n\\n\\t\\t// Get document-relative position by adding viewport scroll to viewport-relative gBCR\\n\\t\\trect = elem.getBoundingClientRect();\\n\\t\\twin = elem.ownerDocument.defaultView;\\n\\t\\treturn {\\n\\t\\t\\ttop: rect.top + win.pageYOffset,\\n\\t\\t\\tleft: rect.left + win.pageXOffset\\n\\t\\t};\\n\\t},\\n\\n\\t// position() relates an element's margin box to its offset parent's padding box\\n\\t// This corresponds to the behavior of CSS absolute positioning\\n\\tposition: function() {\\n\\t\\tif ( !this[ 0 ] ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tvar offsetParent, offset, doc,\\n\\t\\t\\telem = this[ 0 ],\\n\\t\\t\\tparentOffset = { top: 0, left: 0 };\\n\\n\\t\\t// position:fixed elements are offset from the viewport, which itself always has zero offset\\n\\t\\tif ( jQuery.css( elem, \\\"position\\\" ) === \\\"fixed\\\" ) {\\n\\n\\t\\t\\t// Assume position:fixed implies availability of getBoundingClientRect\\n\\t\\t\\toffset = elem.getBoundingClientRect();\\n\\n\\t\\t} else {\\n\\t\\t\\toffset = this.offset();\\n\\n\\t\\t\\t// Account for the *real* offset parent, which can be the document or its root element\\n\\t\\t\\t// when a statically positioned element is identified\\n\\t\\t\\tdoc = elem.ownerDocument;\\n\\t\\t\\toffsetParent = elem.offsetParent || doc.documentElement;\\n\\t\\t\\twhile ( offsetParent &&\\n\\t\\t\\t\\t( offsetParent === doc.body || offsetParent === doc.documentElement ) &&\\n\\t\\t\\t\\tjQuery.css( offsetParent, \\\"position\\\" ) === \\\"static\\\" ) {\\n\\n\\t\\t\\t\\toffsetParent = offsetParent.parentNode;\\n\\t\\t\\t}\\n\\t\\t\\tif ( offsetParent && offsetParent !== elem && offsetParent.nodeType === 1 ) {\\n\\n\\t\\t\\t\\t// Incorporate borders into its offset, since they are outside its content origin\\n\\t\\t\\t\\tparentOffset = jQuery( offsetParent ).offset();\\n\\t\\t\\t\\tparentOffset.top += jQuery.css( offsetParent, \\\"borderTopWidth\\\", true );\\n\\t\\t\\t\\tparentOffset.left += jQuery.css( offsetParent, \\\"borderLeftWidth\\\", true );\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// Subtract parent offsets and element margins\\n\\t\\treturn {\\n\\t\\t\\ttop: offset.top - parentOffset.top - jQuery.css( elem, \\\"marginTop\\\", true ),\\n\\t\\t\\tleft: offset.left - parentOffset.left - jQuery.css( elem, \\\"marginLeft\\\", true )\\n\\t\\t};\\n\\t},\\n\\n\\t// This method will return documentElement in the following cases:\\n\\t// 1) For the element inside the iframe without offsetParent, this method will return\\n\\t//    documentElement of the parent window\\n\\t// 2) For the hidden or detached element\\n\\t// 3) For body or html element, i.e. in case of the html node - it will return itself\\n\\t//\\n\\t// but those exceptions were never presented as a real life use-cases\\n\\t// and might be considered as more preferable results.\\n\\t//\\n\\t// This logic, however, is not guaranteed and can change at any point in the future\\n\\toffsetParent: function() {\\n\\t\\treturn this.map( function() {\\n\\t\\t\\tvar offsetParent = this.offsetParent;\\n\\n\\t\\t\\twhile ( offsetParent && jQuery.css( offsetParent, \\\"position\\\" ) === \\\"static\\\" ) {\\n\\t\\t\\t\\toffsetParent = offsetParent.offsetParent;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn offsetParent || documentElement;\\n\\t\\t} );\\n\\t}\\n} );\\n\\n// Create scrollLeft and scrollTop methods\\njQuery.each( { scrollLeft: \\\"pageXOffset\\\", scrollTop: \\\"pageYOffset\\\" }, function( method, prop ) {\\n\\tvar top = \\\"pageYOffset\\\" === prop;\\n\\n\\tjQuery.fn[ method ] = function( val ) {\\n\\t\\treturn access( this, function( elem, method, val ) {\\n\\n\\t\\t\\t// Coalesce documents and windows\\n\\t\\t\\tvar win;\\n\\t\\t\\tif ( isWindow( elem ) ) {\\n\\t\\t\\t\\twin = elem;\\n\\t\\t\\t} else if ( elem.nodeType === 9 ) {\\n\\t\\t\\t\\twin = elem.defaultView;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( val === undefined ) {\\n\\t\\t\\t\\treturn win ? win[ prop ] : elem[ method ];\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( win ) {\\n\\t\\t\\t\\twin.scrollTo(\\n\\t\\t\\t\\t\\t!top ? val : win.pageXOffset,\\n\\t\\t\\t\\t\\ttop ? val : win.pageYOffset\\n\\t\\t\\t\\t);\\n\\n\\t\\t\\t} else {\\n\\t\\t\\t\\telem[ method ] = val;\\n\\t\\t\\t}\\n\\t\\t}, method, val, arguments.length );\\n\\t};\\n} );\\n\\n// Support: Safari <=7 - 9.1, Chrome <=37 - 49\\n// Add the top/left cssHooks using jQuery.fn.position\\n// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084\\n// Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347\\n// getComputedStyle returns percent when specified for top/left/bottom/right;\\n// rather than make the css module depend on the offset module, just check for it here\\njQuery.each( [ \\\"top\\\", \\\"left\\\" ], function( i, prop ) {\\n\\tjQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,\\n\\t\\tfunction( elem, computed ) {\\n\\t\\t\\tif ( computed ) {\\n\\t\\t\\t\\tcomputed = curCSS( elem, prop );\\n\\n\\t\\t\\t\\t// If curCSS returns percentage, fallback to offset\\n\\t\\t\\t\\treturn rnumnonpx.test( computed ) ?\\n\\t\\t\\t\\t\\tjQuery( elem ).position()[ prop ] + \\\"px\\\" :\\n\\t\\t\\t\\t\\tcomputed;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t);\\n} );\\n\\n\\n// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods\\njQuery.each( { Height: \\\"height\\\", Width: \\\"width\\\" }, function( name, type ) {\\n\\tjQuery.each( { padding: \\\"inner\\\" + name, content: type, \\\"\\\": \\\"outer\\\" + name },\\n\\t\\tfunction( defaultExtra, funcName ) {\\n\\n\\t\\t// Margin is only for outerHeight, outerWidth\\n\\t\\tjQuery.fn[ funcName ] = function( margin, value ) {\\n\\t\\t\\tvar chainable = arguments.length && ( defaultExtra || typeof margin !== \\\"boolean\\\" ),\\n\\t\\t\\t\\textra = defaultExtra || ( margin === true || value === true ? \\\"margin\\\" : \\\"border\\\" );\\n\\n\\t\\t\\treturn access( this, function( elem, type, value ) {\\n\\t\\t\\t\\tvar doc;\\n\\n\\t\\t\\t\\tif ( isWindow( elem ) ) {\\n\\n\\t\\t\\t\\t\\t// $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)\\n\\t\\t\\t\\t\\treturn funcName.indexOf( \\\"outer\\\" ) === 0 ?\\n\\t\\t\\t\\t\\t\\telem[ \\\"inner\\\" + name ] :\\n\\t\\t\\t\\t\\t\\telem.document.documentElement[ \\\"client\\\" + name ];\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Get document width or height\\n\\t\\t\\t\\tif ( elem.nodeType === 9 ) {\\n\\t\\t\\t\\t\\tdoc = elem.documentElement;\\n\\n\\t\\t\\t\\t\\t// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],\\n\\t\\t\\t\\t\\t// whichever is greatest\\n\\t\\t\\t\\t\\treturn Math.max(\\n\\t\\t\\t\\t\\t\\telem.body[ \\\"scroll\\\" + name ], doc[ \\\"scroll\\\" + name ],\\n\\t\\t\\t\\t\\t\\telem.body[ \\\"offset\\\" + name ], doc[ \\\"offset\\\" + name ],\\n\\t\\t\\t\\t\\t\\tdoc[ \\\"client\\\" + name ]\\n\\t\\t\\t\\t\\t);\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn value === undefined ?\\n\\n\\t\\t\\t\\t\\t// Get width or height on the element, requesting but not forcing parseFloat\\n\\t\\t\\t\\t\\tjQuery.css( elem, type, extra ) :\\n\\n\\t\\t\\t\\t\\t// Set width or height on the element\\n\\t\\t\\t\\t\\tjQuery.style( elem, type, value, extra );\\n\\t\\t\\t}, type, chainable ? margin : undefined, chainable );\\n\\t\\t};\\n\\t} );\\n} );\\n\\n\\njQuery.each( ( \\\"blur focus focusin focusout resize scroll click dblclick \\\" +\\n\\t\\\"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave \\\" +\\n\\t\\\"change select submit keydown keypress keyup contextmenu\\\" ).split( \\\" \\\" ),\\n\\tfunction( i, name ) {\\n\\n\\t// Handle event binding\\n\\tjQuery.fn[ name ] = function( data, fn ) {\\n\\t\\treturn arguments.length > 0 ?\\n\\t\\t\\tthis.on( name, null, data, fn ) :\\n\\t\\t\\tthis.trigger( name );\\n\\t};\\n} );\\n\\njQuery.fn.extend( {\\n\\thover: function( fnOver, fnOut ) {\\n\\t\\treturn this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );\\n\\t}\\n} );\\n\\n\\n\\n\\njQuery.fn.extend( {\\n\\n\\tbind: function( types, data, fn ) {\\n\\t\\treturn this.on( types, null, data, fn );\\n\\t},\\n\\tunbind: function( types, fn ) {\\n\\t\\treturn this.off( types, null, fn );\\n\\t},\\n\\n\\tdelegate: function( selector, types, data, fn ) {\\n\\t\\treturn this.on( types, selector, data, fn );\\n\\t},\\n\\tundelegate: function( selector, types, fn ) {\\n\\n\\t\\t// ( namespace ) or ( selector, types [, fn] )\\n\\t\\treturn arguments.length === 1 ?\\n\\t\\t\\tthis.off( selector, \\\"**\\\" ) :\\n\\t\\t\\tthis.off( types, selector || \\\"**\\\", fn );\\n\\t}\\n} );\\n\\n// Bind a function to a context, optionally partially applying any\\n// arguments.\\n// jQuery.proxy is deprecated to promote standards (specifically Function#bind)\\n// However, it is not slated for removal any time soon\\njQuery.proxy = function( fn, context ) {\\n\\tvar tmp, args, proxy;\\n\\n\\tif ( typeof context === \\\"string\\\" ) {\\n\\t\\ttmp = fn[ context ];\\n\\t\\tcontext = fn;\\n\\t\\tfn = tmp;\\n\\t}\\n\\n\\t// Quick check to determine if target is callable, in the spec\\n\\t// this throws a TypeError, but we will just return undefined.\\n\\tif ( !isFunction( fn ) ) {\\n\\t\\treturn undefined;\\n\\t}\\n\\n\\t// Simulated bind\\n\\targs = slice.call( arguments, 2 );\\n\\tproxy = function() {\\n\\t\\treturn fn.apply( context || this, args.concat( slice.call( arguments ) ) );\\n\\t};\\n\\n\\t// Set the guid of unique handler to the same of original handler, so it can be removed\\n\\tproxy.guid = fn.guid = fn.guid || jQuery.guid++;\\n\\n\\treturn proxy;\\n};\\n\\njQuery.holdReady = function( hold ) {\\n\\tif ( hold ) {\\n\\t\\tjQuery.readyWait++;\\n\\t} else {\\n\\t\\tjQuery.ready( true );\\n\\t}\\n};\\njQuery.isArray = Array.isArray;\\njQuery.parseJSON = JSON.parse;\\njQuery.nodeName = nodeName;\\njQuery.isFunction = isFunction;\\njQuery.isWindow = isWindow;\\njQuery.camelCase = camelCase;\\njQuery.type = toType;\\n\\njQuery.now = Date.now;\\n\\njQuery.isNumeric = function( obj ) {\\n\\n\\t// As of jQuery 3.0, isNumeric is limited to\\n\\t// strings and numbers (primitives or objects)\\n\\t// that can be coerced to finite numbers (gh-2662)\\n\\tvar type = jQuery.type( obj );\\n\\treturn ( type === \\\"number\\\" || type === \\\"string\\\" ) &&\\n\\n\\t\\t// parseFloat NaNs numeric-cast false positives (\\\"\\\")\\n\\t\\t// ...but misinterprets leading-number strings, particularly hex literals (\\\"0x...\\\")\\n\\t\\t// subtraction forces infinities to NaN\\n\\t\\t!isNaN( obj - parseFloat( obj ) );\\n};\\n\\n\\n\\n\\n// Register as a named AMD module, since jQuery can be concatenated with other\\n// files that may use define, but not via a proper concatenation script that\\n// understands anonymous AMD modules. A named AMD is safest and most robust\\n// way to register. Lowercase jquery is used because AMD module names are\\n// derived from file names, and jQuery is normally delivered in a lowercase\\n// file name. Do this after creating the global so that if an AMD module wants\\n// to call noConflict to hide this version of jQuery, it will work.\\n\\n// Note that for maximum portability, libraries that are not jQuery should\\n// declare themselves as anonymous modules, and avoid setting a global if an\\n// AMD loader is present. jQuery is a special case. For more information, see\\n// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon\\n\\nif ( true ) {\\n\\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function() {\\n\\t\\treturn jQuery;\\n\\t}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\\n\\t\\t\\t\\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\\n}\\n\\n\\n\\n\\nvar\\n\\n\\t// Map over jQuery in case of overwrite\\n\\t_jQuery = window.jQuery,\\n\\n\\t// Map over the $ in case of overwrite\\n\\t_$ = window.$;\\n\\njQuery.noConflict = function( deep ) {\\n\\tif ( window.$ === jQuery ) {\\n\\t\\twindow.$ = _$;\\n\\t}\\n\\n\\tif ( deep && window.jQuery === jQuery ) {\\n\\t\\twindow.jQuery = _jQuery;\\n\\t}\\n\\n\\treturn jQuery;\\n};\\n\\n// Expose jQuery and $ identifiers, even in AMD\\n// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)\\n// and CommonJS for browser emulators (#13566)\\nif ( !noGlobal ) {\\n\\twindow.jQuery = window.$ = jQuery;\\n}\\n\\n\\n\\n\\nreturn jQuery;\\n} );\\n\\n\\n//////////////////\\n// WEBPACK FOOTER\\n// ./~/jquery/dist/jquery.js\\n// module id = 1\\n// module chunks = 0\\n\\n//# sourceURL=webpack:///./~/jquery/dist/jquery.js?\");\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\neval(\"\\n\\n/**\\n * Copyright (c) 2013-present, Facebook, Inc.\\n *\\n * This source code is licensed under the MIT license found in the\\n * LICENSE file in the root directory of this source tree.\\n *\\n * \\n */\\n\\nfunction makeEmptyFunction(arg) {\\n  return function () {\\n    return arg;\\n  };\\n}\\n\\n/**\\n * This function accepts and discards inputs; it has no side effects. This is\\n * primarily useful idiomatically for overridable function endpoints which\\n * always need to be callable, since JS lacks a null-call idiom ala Cocoa.\\n */\\nvar emptyFunction = function emptyFunction() {};\\n\\nemptyFunction.thatReturns = makeEmptyFunction;\\nemptyFunction.thatReturnsFalse = makeEmptyFunction(false);\\nemptyFunction.thatReturnsTrue = makeEmptyFunction(true);\\nemptyFunction.thatReturnsNull = makeEmptyFunction(null);\\nemptyFunction.thatReturnsThis = function () {\\n  return this;\\n};\\nemptyFunction.thatReturnsArgument = function (arg) {\\n  return arg;\\n};\\n\\nmodule.exports = emptyFunction;\\n\\n//////////////////\\n// WEBPACK FOOTER\\n// ./~/fbjs/lib/emptyFunction.js\\n// module id = 2\\n// module chunks = 0\\n\\n//# sourceURL=webpack:///./~/fbjs/lib/emptyFunction.js?\");\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\neval(\"/* WEBPACK VAR INJECTION */(function(process) {/**\\n * Copyright (c) 2013-present, Facebook, Inc.\\n *\\n * This source code is licensed under the MIT license found in the\\n * LICENSE file in the root directory of this source tree.\\n *\\n */\\n\\n\\n\\n/**\\n * Use invariant() to assert state which your program assumes to be true.\\n *\\n * Provide sprintf-style format (only %s is supported) and arguments\\n * to provide information about what broke and what you were\\n * expecting.\\n *\\n * The invariant message will be stripped in production, but the invariant\\n * will remain to ensure logic does not differ in production.\\n */\\n\\nvar validateFormat = function validateFormat(format) {};\\n\\nif (process.env.NODE_ENV !== 'production') {\\n  validateFormat = function validateFormat(format) {\\n    if (format === undefined) {\\n      throw new Error('invariant requires an error message argument');\\n    }\\n  };\\n}\\n\\nfunction invariant(condition, format, a, b, c, d, e, f) {\\n  validateFormat(format);\\n\\n  if (!condition) {\\n    var error;\\n    if (format === undefined) {\\n      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');\\n    } else {\\n      var args = [a, b, c, d, e, f];\\n      var argIndex = 0;\\n      error = new Error(format.replace(/%s/g, function () {\\n        return args[argIndex++];\\n      }));\\n      error.name = 'Invariant Violation';\\n    }\\n\\n    error.framesToPop = 1; // we don't care about invariant's own frame\\n    throw error;\\n  }\\n}\\n\\nmodule.exports = invariant;\\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))\\n\\n//////////////////\\n// WEBPACK FOOTER\\n// ./~/fbjs/lib/invariant.js\\n// module id = 3\\n// module chunks = 0\\n\\n//# sourceURL=webpack:///./~/fbjs/lib/invariant.js?\");\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\neval(\"/**\\n * Copyright (c) 2013-present, Facebook, Inc.\\n *\\n * This source code is licensed under the MIT license found in the\\n * LICENSE file in the root directory of this source tree.\\n */\\n\\n\\n\\nvar ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';\\n\\nmodule.exports = ReactPropTypesSecret;\\n\\n\\n//////////////////\\n// WEBPACK FOOTER\\n// ./~/prop-types/lib/ReactPropTypesSecret.js\\n// module id = 4\\n// module chunks = 0\\n\\n//# sourceURL=webpack:///./~/prop-types/lib/ReactPropTypesSecret.js?\");\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports) {\n\neval(\"/*\\n\\tMIT License http://www.opensource.org/licenses/mit-license.php\\n\\tAuthor Tobias Koppers @sokra\\n*/\\n// css base code, injected by the css-loader\\nmodule.exports = function(useSourceMap) {\\n\\tvar list = [];\\n\\n\\t// return the list of modules as css string\\n\\tlist.toString = function toString() {\\n\\t\\treturn this.map(function (item) {\\n\\t\\t\\tvar content = cssWithMappingToString(item, useSourceMap);\\n\\t\\t\\tif(item[2]) {\\n\\t\\t\\t\\treturn \\\"@media \\\" + item[2] + \\\"{\\\" + content + \\\"}\\\";\\n\\t\\t\\t} else {\\n\\t\\t\\t\\treturn content;\\n\\t\\t\\t}\\n\\t\\t}).join(\\\"\\\");\\n\\t};\\n\\n\\t// import a list of modules into the list\\n\\tlist.i = function(modules, mediaQuery) {\\n\\t\\tif(typeof modules === \\\"string\\\")\\n\\t\\t\\tmodules = [[null, modules, \\\"\\\"]];\\n\\t\\tvar alreadyImportedModules = {};\\n\\t\\tfor(var i = 0; i < this.length; i++) {\\n\\t\\t\\tvar id = this[i][0];\\n\\t\\t\\tif(typeof id === \\\"number\\\")\\n\\t\\t\\t\\talreadyImportedModules[id] = true;\\n\\t\\t}\\n\\t\\tfor(i = 0; i < modules.length; i++) {\\n\\t\\t\\tvar item = modules[i];\\n\\t\\t\\t// skip already imported module\\n\\t\\t\\t// this implementation is not 100% perfect for weird media query combinations\\n\\t\\t\\t//  when a module is imported multiple times with different media queries.\\n\\t\\t\\t//  I hope this will never occur (Hey this way we have smaller bundles)\\n\\t\\t\\tif(typeof item[0] !== \\\"number\\\" || !alreadyImportedModules[item[0]]) {\\n\\t\\t\\t\\tif(mediaQuery && !item[2]) {\\n\\t\\t\\t\\t\\titem[2] = mediaQuery;\\n\\t\\t\\t\\t} else if(mediaQuery) {\\n\\t\\t\\t\\t\\titem[2] = \\\"(\\\" + item[2] + \\\") and (\\\" + mediaQuery + \\\")\\\";\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tlist.push(item);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t};\\n\\treturn list;\\n};\\n\\nfunction cssWithMappingToString(item, useSourceMap) {\\n\\tvar content = item[1] || '';\\n\\tvar cssMapping = item[3];\\n\\tif (!cssMapping) {\\n\\t\\treturn content;\\n\\t}\\n\\n\\tif (useSourceMap && typeof btoa === 'function') {\\n\\t\\tvar sourceMapping = toComment(cssMapping);\\n\\t\\tvar sourceURLs = cssMapping.sources.map(function (source) {\\n\\t\\t\\treturn '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */'\\n\\t\\t});\\n\\n\\t\\treturn [content].concat(sourceURLs).concat([sourceMapping]).join('\\\\n');\\n\\t}\\n\\n\\treturn [content].join('\\\\n');\\n}\\n\\n// Adapted from convert-source-map (MIT)\\nfunction toComment(sourceMap) {\\n\\t// eslint-disable-next-line no-undef\\n\\tvar base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));\\n\\tvar data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;\\n\\n\\treturn '/*# ' + data + ' */';\\n}\\n\\n\\n//////////////////\\n// WEBPACK FOOTER\\n// ./~/css-loader/lib/css-base.js\\n// module id = 5\\n// module chunks = 0\\n\\n//# sourceURL=webpack:///./~/css-loader/lib/css-base.js?\");\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\neval(\"/* WEBPACK VAR INJECTION */(function(process) {/**\\n * Copyright (c) 2014-present, Facebook, Inc.\\n *\\n * This source code is licensed under the MIT license found in the\\n * LICENSE file in the root directory of this source tree.\\n *\\n */\\n\\n\\n\\nvar emptyFunction = __webpack_require__(2);\\n\\n/**\\n * Similar to invariant but only logs a warning if the condition is not met.\\n * This can be used to log issues in development environments in critical\\n * paths. Removing the logging code for production environments will keep the\\n * same logic and follow the same code paths.\\n */\\n\\nvar warning = emptyFunction;\\n\\nif (process.env.NODE_ENV !== 'production') {\\n  var printWarning = function printWarning(format) {\\n    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\\n      args[_key - 1] = arguments[_key];\\n    }\\n\\n    var argIndex = 0;\\n    var message = 'Warning: ' + format.replace(/%s/g, function () {\\n      return args[argIndex++];\\n    });\\n    if (typeof console !== 'undefined') {\\n      console.error(message);\\n    }\\n    try {\\n      // --- Welcome to debugging React ---\\n      // This error was thrown as a convenience so that you can use this stack\\n      // to find the callsite that caused this warning to fire.\\n      throw new Error(message);\\n    } catch (x) {}\\n  };\\n\\n  warning = function warning(condition, format) {\\n    if (format === undefined) {\\n      throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');\\n    }\\n\\n    if (format.indexOf('Failed Composite propType: ') === 0) {\\n      return; // Ignore CompositeComponent proptype check.\\n    }\\n\\n    if (!condition) {\\n      for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {\\n        args[_key2 - 2] = arguments[_key2];\\n      }\\n\\n      printWarning.apply(undefined, [format].concat(args));\\n    }\\n  };\\n}\\n\\nmodule.exports = warning;\\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))\\n\\n//////////////////\\n// WEBPACK FOOTER\\n// ./~/fbjs/lib/warning.js\\n// module id = 6\\n// module chunks = 0\\n\\n//# sourceURL=webpack:///./~/fbjs/lib/warning.js?\");\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports, __webpack_require__) {\n\neval(\"/*\\n\\tMIT License http://www.opensource.org/licenses/mit-license.php\\n\\tAuthor Tobias Koppers @sokra\\n*/\\nvar stylesInDom = {},\\n\\tmemoize = function(fn) {\\n\\t\\tvar memo;\\n\\t\\treturn function () {\\n\\t\\t\\tif (typeof memo === \\\"undefined\\\") memo = fn.apply(this, arguments);\\n\\t\\t\\treturn memo;\\n\\t\\t};\\n\\t},\\n\\tisOldIE = memoize(function() {\\n\\t\\t// Test for IE <= 9 as proposed by Browserhacks\\n\\t\\t// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805\\n\\t\\t// Tests for existence of standard globals is to allow style-loader \\n\\t\\t// to operate correctly into non-standard environments\\n\\t\\t// @see https://github.com/webpack-contrib/style-loader/issues/177\\n\\t\\treturn window && document && document.all && !window.atob;\\n\\t}),\\n\\tgetElement = (function(fn) {\\n\\t\\tvar memo = {};\\n\\t\\treturn function(selector) {\\n\\t\\t\\tif (typeof memo[selector] === \\\"undefined\\\") {\\n\\t\\t\\t\\tmemo[selector] = fn.call(this, selector);\\n\\t\\t\\t}\\n\\t\\t\\treturn memo[selector]\\n\\t\\t};\\n\\t})(function (styleTarget) {\\n\\t\\treturn document.querySelector(styleTarget)\\n\\t}),\\n\\tsingletonElement = null,\\n\\tsingletonCounter = 0,\\n\\tstyleElementsInsertedAtTop = [],\\n\\tfixUrls = __webpack_require__(22);\\n\\nmodule.exports = function(list, options) {\\n\\tif(typeof DEBUG !== \\\"undefined\\\" && DEBUG) {\\n\\t\\tif(typeof document !== \\\"object\\\") throw new Error(\\\"The style-loader cannot be used in a non-browser environment\\\");\\n\\t}\\n\\n\\toptions = options || {};\\n\\toptions.attrs = typeof options.attrs === \\\"object\\\" ? options.attrs : {};\\n\\n\\t// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\\n\\t// tags it will allow on a page\\n\\tif (typeof options.singleton === \\\"undefined\\\") options.singleton = isOldIE();\\n\\n\\t// By default, add <style> tags to the <head> element\\n\\tif (typeof options.insertInto === \\\"undefined\\\") options.insertInto = \\\"head\\\";\\n\\n\\t// By default, add <style> tags to the bottom of the target\\n\\tif (typeof options.insertAt === \\\"undefined\\\") options.insertAt = \\\"bottom\\\";\\n\\n\\tvar styles = listToStyles(list, options);\\n\\taddStylesToDom(styles, options);\\n\\n\\treturn function update(newList) {\\n\\t\\tvar mayRemove = [];\\n\\t\\tfor(var i = 0; i < styles.length; i++) {\\n\\t\\t\\tvar item = styles[i];\\n\\t\\t\\tvar domStyle = stylesInDom[item.id];\\n\\t\\t\\tdomStyle.refs--;\\n\\t\\t\\tmayRemove.push(domStyle);\\n\\t\\t}\\n\\t\\tif(newList) {\\n\\t\\t\\tvar newStyles = listToStyles(newList, options);\\n\\t\\t\\taddStylesToDom(newStyles, options);\\n\\t\\t}\\n\\t\\tfor(var i = 0; i < mayRemove.length; i++) {\\n\\t\\t\\tvar domStyle = mayRemove[i];\\n\\t\\t\\tif(domStyle.refs === 0) {\\n\\t\\t\\t\\tfor(var j = 0; j < domStyle.parts.length; j++)\\n\\t\\t\\t\\t\\tdomStyle.parts[j]();\\n\\t\\t\\t\\tdelete stylesInDom[domStyle.id];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t};\\n};\\n\\nfunction addStylesToDom(styles, options) {\\n\\tfor(var i = 0; i < styles.length; i++) {\\n\\t\\tvar item = styles[i];\\n\\t\\tvar domStyle = stylesInDom[item.id];\\n\\t\\tif(domStyle) {\\n\\t\\t\\tdomStyle.refs++;\\n\\t\\t\\tfor(var j = 0; j < domStyle.parts.length; j++) {\\n\\t\\t\\t\\tdomStyle.parts[j](item.parts[j]);\\n\\t\\t\\t}\\n\\t\\t\\tfor(; j < item.parts.length; j++) {\\n\\t\\t\\t\\tdomStyle.parts.push(addStyle(item.parts[j], options));\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\tvar parts = [];\\n\\t\\t\\tfor(var j = 0; j < item.parts.length; j++) {\\n\\t\\t\\t\\tparts.push(addStyle(item.parts[j], options));\\n\\t\\t\\t}\\n\\t\\t\\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\\n\\t\\t}\\n\\t}\\n}\\n\\nfunction listToStyles(list, options) {\\n\\tvar styles = [];\\n\\tvar newStyles = {};\\n\\tfor(var i = 0; i < list.length; i++) {\\n\\t\\tvar item = list[i];\\n\\t\\tvar id = options.base ? item[0] + options.base : item[0];\\n\\t\\tvar css = item[1];\\n\\t\\tvar media = item[2];\\n\\t\\tvar sourceMap = item[3];\\n\\t\\tvar part = {css: css, media: media, sourceMap: sourceMap};\\n\\t\\tif(!newStyles[id])\\n\\t\\t\\tstyles.push(newStyles[id] = {id: id, parts: [part]});\\n\\t\\telse\\n\\t\\t\\tnewStyles[id].parts.push(part);\\n\\t}\\n\\treturn styles;\\n}\\n\\nfunction insertStyleElement(options, styleElement) {\\n\\tvar styleTarget = getElement(options.insertInto)\\n\\tif (!styleTarget) {\\n\\t\\tthrow new Error(\\\"Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.\\\");\\n\\t}\\n\\tvar lastStyleElementInsertedAtTop = styleElementsInsertedAtTop[styleElementsInsertedAtTop.length - 1];\\n\\tif (options.insertAt === \\\"top\\\") {\\n\\t\\tif(!lastStyleElementInsertedAtTop) {\\n\\t\\t\\tstyleTarget.insertBefore(styleElement, styleTarget.firstChild);\\n\\t\\t} else if(lastStyleElementInsertedAtTop.nextSibling) {\\n\\t\\t\\tstyleTarget.insertBefore(styleElement, lastStyleElementInsertedAtTop.nextSibling);\\n\\t\\t} else {\\n\\t\\t\\tstyleTarget.appendChild(styleElement);\\n\\t\\t}\\n\\t\\tstyleElementsInsertedAtTop.push(styleElement);\\n\\t} else if (options.insertAt === \\\"bottom\\\") {\\n\\t\\tstyleTarget.appendChild(styleElement);\\n\\t} else {\\n\\t\\tthrow new Error(\\\"Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.\\\");\\n\\t}\\n}\\n\\nfunction removeStyleElement(styleElement) {\\n\\tstyleElement.parentNode.removeChild(styleElement);\\n\\tvar idx = styleElementsInsertedAtTop.indexOf(styleElement);\\n\\tif(idx >= 0) {\\n\\t\\tstyleElementsInsertedAtTop.splice(idx, 1);\\n\\t}\\n}\\n\\nfunction createStyleElement(options) {\\n\\tvar styleElement = document.createElement(\\\"style\\\");\\n\\toptions.attrs.type = \\\"text/css\\\";\\n\\n\\tattachTagAttrs(styleElement, options.attrs);\\n\\tinsertStyleElement(options, styleElement);\\n\\treturn styleElement;\\n}\\n\\nfunction createLinkElement(options) {\\n\\tvar linkElement = document.createElement(\\\"link\\\");\\n\\toptions.attrs.type = \\\"text/css\\\";\\n\\toptions.attrs.rel = \\\"stylesheet\\\";\\n\\n\\tattachTagAttrs(linkElement, options.attrs);\\n\\tinsertStyleElement(options, linkElement);\\n\\treturn linkElement;\\n}\\n\\nfunction attachTagAttrs(element, attrs) {\\n\\tObject.keys(attrs).forEach(function (key) {\\n\\t\\telement.setAttribute(key, attrs[key]);\\n\\t});\\n}\\n\\nfunction addStyle(obj, options) {\\n\\tvar styleElement, update, remove, transformResult;\\n\\n\\t// If a transform function was defined, run it on the css\\n\\tif (options.transform && obj.css) {\\n\\t    transformResult = options.transform(obj.css);\\n\\t    \\n\\t    if (transformResult) {\\n\\t    \\t// If transform returns a value, use that instead of the original css.\\n\\t    \\t// This allows running runtime transformations on the css.\\n\\t    \\tobj.css = transformResult;\\n\\t    } else {\\n\\t    \\t// If the transform function returns a falsy value, don't add this css. \\n\\t    \\t// This allows conditional loading of css\\n\\t    \\treturn function() {\\n\\t    \\t\\t// noop\\n\\t    \\t};\\n\\t    }\\n\\t}\\n\\n\\tif (options.singleton) {\\n\\t\\tvar styleIndex = singletonCounter++;\\n\\t\\tstyleElement = singletonElement || (singletonElement = createStyleElement(options));\\n\\t\\tupdate = applyToSingletonTag.bind(null, styleElement, styleIndex, false);\\n\\t\\tremove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);\\n\\t} else if(obj.sourceMap &&\\n\\t\\ttypeof URL === \\\"function\\\" &&\\n\\t\\ttypeof URL.createObjectURL === \\\"function\\\" &&\\n\\t\\ttypeof URL.revokeObjectURL === \\\"function\\\" &&\\n\\t\\ttypeof Blob === \\\"function\\\" &&\\n\\t\\ttypeof btoa === \\\"function\\\") {\\n\\t\\tstyleElement = createLinkElement(options);\\n\\t\\tupdate = updateLink.bind(null, styleElement, options);\\n\\t\\tremove = function() {\\n\\t\\t\\tremoveStyleElement(styleElement);\\n\\t\\t\\tif(styleElement.href)\\n\\t\\t\\t\\tURL.revokeObjectURL(styleElement.href);\\n\\t\\t};\\n\\t} else {\\n\\t\\tstyleElement = createStyleElement(options);\\n\\t\\tupdate = applyToTag.bind(null, styleElement);\\n\\t\\tremove = function() {\\n\\t\\t\\tremoveStyleElement(styleElement);\\n\\t\\t};\\n\\t}\\n\\n\\tupdate(obj);\\n\\n\\treturn function updateStyle(newObj) {\\n\\t\\tif(newObj) {\\n\\t\\t\\tif(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)\\n\\t\\t\\t\\treturn;\\n\\t\\t\\tupdate(obj = newObj);\\n\\t\\t} else {\\n\\t\\t\\tremove();\\n\\t\\t}\\n\\t};\\n}\\n\\nvar replaceText = (function () {\\n\\tvar textStore = [];\\n\\n\\treturn function (index, replacement) {\\n\\t\\ttextStore[index] = replacement;\\n\\t\\treturn textStore.filter(Boolean).join('\\\\n');\\n\\t};\\n})();\\n\\nfunction applyToSingletonTag(styleElement, index, remove, obj) {\\n\\tvar css = remove ? \\\"\\\" : obj.css;\\n\\n\\tif (styleElement.styleSheet) {\\n\\t\\tstyleElement.styleSheet.cssText = replaceText(index, css);\\n\\t} else {\\n\\t\\tvar cssNode = document.createTextNode(css);\\n\\t\\tvar childNodes = styleElement.childNodes;\\n\\t\\tif (childNodes[index]) styleElement.removeChild(childNodes[index]);\\n\\t\\tif (childNodes.length) {\\n\\t\\t\\tstyleElement.insertBefore(cssNode, childNodes[index]);\\n\\t\\t} else {\\n\\t\\t\\tstyleElement.appendChild(cssNode);\\n\\t\\t}\\n\\t}\\n}\\n\\nfunction applyToTag(styleElement, obj) {\\n\\tvar css = obj.css;\\n\\tvar media = obj.media;\\n\\n\\tif(media) {\\n\\t\\tstyleElement.setAttribute(\\\"media\\\", media)\\n\\t}\\n\\n\\tif(styleElement.styleSheet) {\\n\\t\\tstyleElement.styleSheet.cssText = css;\\n\\t} else {\\n\\t\\twhile(styleElement.firstChild) {\\n\\t\\t\\tstyleElement.removeChild(styleElement.firstChild);\\n\\t\\t}\\n\\t\\tstyleElement.appendChild(document.createTextNode(css));\\n\\t}\\n}\\n\\nfunction updateLink(linkElement, options, obj) {\\n\\tvar css = obj.css;\\n\\tvar sourceMap = obj.sourceMap;\\n\\n\\t/* If convertToAbsoluteUrls isn't defined, but sourcemaps are enabled\\n\\tand there is no publicPath defined then lets turn convertToAbsoluteUrls\\n\\ton by default.  Otherwise default to the convertToAbsoluteUrls option\\n\\tdirectly\\n\\t*/\\n\\tvar autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;\\n\\n\\tif (options.convertToAbsoluteUrls || autoFixUrls){\\n\\t\\tcss = fixUrls(css);\\n\\t}\\n\\n\\tif(sourceMap) {\\n\\t\\t// http://stackoverflow.com/a/26603875\\n\\t\\tcss += \\\"\\\\n/*# sourceMappingURL=data:application/json;base64,\\\" + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + \\\" */\\\";\\n\\t}\\n\\n\\tvar blob = new Blob([css], { type: \\\"text/css\\\" });\\n\\n\\tvar oldSrc = linkElement.href;\\n\\n\\tlinkElement.href = URL.createObjectURL(blob);\\n\\n\\tif(oldSrc)\\n\\t\\tURL.revokeObjectURL(oldSrc);\\n}\\n\\n\\n//////////////////\\n// WEBPACK FOOTER\\n// ./~/style-loader/addStyles.js\\n// module id = 7\\n// module chunks = 0\\n\\n//# sourceURL=webpack:///./~/style-loader/addStyles.js?\");\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports, __webpack_require__) {\n\neval(\"/* WEBPACK VAR INJECTION */(function(__webpack_provided_window_dot_jQuery, jQuery) {/**\\n * Owl Carousel v2.2.0\\n * Copyright 2013-2016 David Deutsch\\n * Licensed under MIT (https://github.com/OwlCarousel2/OwlCarousel2/blob/master/LICENSE)\\n */\\n/**\\n * Owl carousel\\n * @version 2.1.6\\n * @author Bartosz Wojciechowski\\n * @author David Deutsch\\n * @license The MIT License (MIT)\\n * @todo Lazy Load Icon\\n * @todo prevent animationend bubling\\n * @todo itemsScaleUp\\n * @todo Test Zepto\\n * @todo stagePadding calculate wrong active classes\\n */\\n;(function($, window, document, undefined) {\\n\\n\\t/**\\n\\t * Creates a carousel.\\n\\t * @class The Owl Carousel.\\n\\t * @public\\n\\t * @param {HTMLElement|jQuery} element - The element to create the carousel for.\\n\\t * @param {Object} [options] - The options\\n\\t */\\n\\tfunction Owl(element, options) {\\n\\n\\t\\t/**\\n\\t\\t * Current settings for the carousel.\\n\\t\\t * @public\\n\\t\\t */\\n\\t\\tthis.settings = null;\\n\\n\\t\\t/**\\n\\t\\t * Current options set by the caller including defaults.\\n\\t\\t * @public\\n\\t\\t */\\n\\t\\tthis.options = $.extend({}, Owl.Defaults, options);\\n\\n\\t\\t/**\\n\\t\\t * Plugin element.\\n\\t\\t * @public\\n\\t\\t */\\n\\t\\tthis.$element = $(element);\\n\\n\\t\\t/**\\n\\t\\t * Proxied event handlers.\\n\\t\\t * @protected\\n\\t\\t */\\n\\t\\tthis._handlers = {};\\n\\n\\t\\t/**\\n\\t\\t * References to the running plugins of this carousel.\\n\\t\\t * @protected\\n\\t\\t */\\n\\t\\tthis._plugins = {};\\n\\n\\t\\t/**\\n\\t\\t * Currently suppressed events to prevent them from beeing retriggered.\\n\\t\\t * @protected\\n\\t\\t */\\n\\t\\tthis._supress = {};\\n\\n\\t\\t/**\\n\\t\\t * Absolute current position.\\n\\t\\t * @protected\\n\\t\\t */\\n\\t\\tthis._current = null;\\n\\n\\t\\t/**\\n\\t\\t * Animation speed in milliseconds.\\n\\t\\t * @protected\\n\\t\\t */\\n\\t\\tthis._speed = null;\\n\\n\\t\\t/**\\n\\t\\t * Coordinates of all items in pixel.\\n\\t\\t * @todo The name of this member is missleading.\\n\\t\\t * @protected\\n\\t\\t */\\n\\t\\tthis._coordinates = [];\\n\\n\\t\\t/**\\n\\t\\t * Current breakpoint.\\n\\t\\t * @todo Real media queries would be nice.\\n\\t\\t * @protected\\n\\t\\t */\\n\\t\\tthis._breakpoint = null;\\n\\n\\t\\t/**\\n\\t\\t * Current width of the plugin element.\\n\\t\\t */\\n\\t\\tthis._width = null;\\n\\n\\t\\t/**\\n\\t\\t * All real items.\\n\\t\\t * @protected\\n\\t\\t */\\n\\t\\tthis._items = [];\\n\\n\\t\\t/**\\n\\t\\t * All cloned items.\\n\\t\\t * @protected\\n\\t\\t */\\n\\t\\tthis._clones = [];\\n\\n\\t\\t/**\\n\\t\\t * Merge values of all items.\\n\\t\\t * @todo Maybe this could be part of a plugin.\\n\\t\\t * @protected\\n\\t\\t */\\n\\t\\tthis._mergers = [];\\n\\n\\t\\t/**\\n\\t\\t * Widths of all items.\\n\\t\\t */\\n\\t\\tthis._widths = [];\\n\\n\\t\\t/**\\n\\t\\t * Invalidated parts within the update process.\\n\\t\\t * @protected\\n\\t\\t */\\n\\t\\tthis._invalidated = {};\\n\\n\\t\\t/**\\n\\t\\t * Ordered list of workers for the update process.\\n\\t\\t * @protected\\n\\t\\t */\\n\\t\\tthis._pipe = [];\\n\\n\\t\\t/**\\n\\t\\t * Current state information for the drag operation.\\n\\t\\t * @todo #261\\n\\t\\t * @protected\\n\\t\\t */\\n\\t\\tthis._drag = {\\n\\t\\t\\ttime: null,\\n\\t\\t\\ttarget: null,\\n\\t\\t\\tpointer: null,\\n\\t\\t\\tstage: {\\n\\t\\t\\t\\tstart: null,\\n\\t\\t\\t\\tcurrent: null\\n\\t\\t\\t},\\n\\t\\t\\tdirection: null\\n\\t\\t};\\n\\n\\t\\t/**\\n\\t\\t * Current state information and their tags.\\n\\t\\t * @type {Object}\\n\\t\\t * @protected\\n\\t\\t */\\n\\t\\tthis._states = {\\n\\t\\t\\tcurrent: {},\\n\\t\\t\\ttags: {\\n\\t\\t\\t\\t'initializing': [ 'busy' ],\\n\\t\\t\\t\\t'animating': [ 'busy' ],\\n\\t\\t\\t\\t'dragging': [ 'interacting' ]\\n\\t\\t\\t}\\n\\t\\t};\\n\\n\\t\\t$.each([ 'onResize', 'onThrottledResize' ], $.proxy(function(i, handler) {\\n\\t\\t\\tthis._handlers[handler] = $.proxy(this[handler], this);\\n\\t\\t}, this));\\n\\n\\t\\t$.each(Owl.Plugins, $.proxy(function(key, plugin) {\\n\\t\\t\\tthis._plugins[key.charAt(0).toLowerCase() + key.slice(1)]\\n\\t\\t\\t\\t= new plugin(this);\\n\\t\\t}, this));\\n\\n\\t\\t$.each(Owl.Workers, $.proxy(function(priority, worker) {\\n\\t\\t\\tthis._pipe.push({\\n\\t\\t\\t\\t'filter': worker.filter,\\n\\t\\t\\t\\t'run': $.proxy(worker.run, this)\\n\\t\\t\\t});\\n\\t\\t}, this));\\n\\n\\t\\tthis.setup();\\n\\t\\tthis.initialize();\\n\\t}\\n\\n\\t/**\\n\\t * Default options for the carousel.\\n\\t * @public\\n\\t */\\n\\tOwl.Defaults = {\\n\\t\\titems: 3,\\n\\t\\tloop: false,\\n\\t\\tcenter: false,\\n\\t\\trewind: false,\\n\\n\\t\\tmouseDrag: true,\\n\\t\\ttouchDrag: true,\\n\\t\\tpullDrag: true,\\n\\t\\tfreeDrag: false,\\n\\n\\t\\tmargin: 0,\\n\\t\\tstagePadding: 0,\\n\\n\\t\\tmerge: false,\\n\\t\\tmergeFit: true,\\n\\t\\tautoWidth: false,\\n\\n\\t\\tstartPosition: 0,\\n\\t\\trtl: false,\\n\\n\\t\\tsmartSpeed: 250,\\n\\t\\tfluidSpeed: false,\\n\\t\\tdragEndSpeed: false,\\n\\n\\t\\tresponsive: {},\\n\\t\\tresponsiveRefreshRate: 200,\\n\\t\\tresponsiveBaseElement: window,\\n\\n\\t\\tfallbackEasing: 'swing',\\n\\n\\t\\tinfo: false,\\n\\n\\t\\tnestedItemSelector: false,\\n\\t\\titemElement: 'div',\\n\\t\\tstageElement: 'div',\\n\\n\\t\\trefreshClass: 'owl-refresh',\\n\\t\\tloadedClass: 'owl-loaded',\\n\\t\\tloadingClass: 'owl-loading',\\n\\t\\trtlClass: 'owl-rtl',\\n\\t\\tresponsiveClass: 'owl-responsive',\\n\\t\\tdragClass: 'owl-drag',\\n\\t\\titemClass: 'owl-item',\\n\\t\\tstageClass: 'owl-stage',\\n\\t\\tstageOuterClass: 'owl-stage-outer',\\n\\t\\tgrabClass: 'owl-grab'\\n\\t};\\n\\n\\t/**\\n\\t * Enumeration for width.\\n\\t * @public\\n\\t * @readonly\\n\\t * @enum {String}\\n\\t */\\n\\tOwl.Width = {\\n\\t\\tDefault: 'default',\\n\\t\\tInner: 'inner',\\n\\t\\tOuter: 'outer'\\n\\t};\\n\\n\\t/**\\n\\t * Enumeration for types.\\n\\t * @public\\n\\t * @readonly\\n\\t * @enum {String}\\n\\t */\\n\\tOwl.Type = {\\n\\t\\tEvent: 'event',\\n\\t\\tState: 'state'\\n\\t};\\n\\n\\t/**\\n\\t * Contains all registered plugins.\\n\\t * @public\\n\\t */\\n\\tOwl.Plugins = {};\\n\\n\\t/**\\n\\t * List of workers involved in the update process.\\n\\t */\\n\\tOwl.Workers = [ {\\n\\t\\tfilter: [ 'width', 'settings' ],\\n\\t\\trun: function() {\\n\\t\\t\\tthis._width = this.$element.width();\\n\\t\\t}\\n\\t}, {\\n\\t\\tfilter: [ 'width', 'items', 'settings' ],\\n\\t\\trun: function(cache) {\\n\\t\\t\\tcache.current = this._items && this._items[this.relative(this._current)];\\n\\t\\t}\\n\\t}, {\\n\\t\\tfilter: [ 'items', 'settings' ],\\n\\t\\trun: function() {\\n\\t\\t\\tthis.$stage.children('.cloned').remove();\\n\\t\\t}\\n\\t}, {\\n\\t\\tfilter: [ 'width', 'items', 'settings' ],\\n\\t\\trun: function(cache) {\\n\\t\\t\\tvar margin = this.settings.margin || '',\\n\\t\\t\\t\\tgrid = !this.settings.autoWidth,\\n\\t\\t\\t\\trtl = this.settings.rtl,\\n\\t\\t\\t\\tcss = {\\n\\t\\t\\t\\t\\t'width': 'auto',\\n\\t\\t\\t\\t\\t'margin-left': rtl ? margin : '',\\n\\t\\t\\t\\t\\t'margin-right': rtl ? '' : margin\\n\\t\\t\\t\\t};\\n\\n\\t\\t\\t!grid && this.$stage.children().css(css);\\n\\n\\t\\t\\tcache.css = css;\\n\\t\\t}\\n\\t}, {\\n\\t\\tfilter: [ 'width', 'items', 'settings' ],\\n\\t\\trun: function(cache) {\\n\\t\\t\\tvar width = (this.width() / this.settings.items).toFixed(3) - this.settings.margin,\\n\\t\\t\\t\\tmerge = null,\\n\\t\\t\\t\\titerator = this._items.length,\\n\\t\\t\\t\\tgrid = !this.settings.autoWidth,\\n\\t\\t\\t\\twidths = [];\\n\\n\\t\\t\\tcache.items = {\\n\\t\\t\\t\\tmerge: false,\\n\\t\\t\\t\\twidth: width\\n\\t\\t\\t};\\n\\n\\t\\t\\twhile (iterator--) {\\n\\t\\t\\t\\tmerge = this._mergers[iterator];\\n\\t\\t\\t\\tmerge = this.settings.mergeFit && Math.min(merge, this.settings.items) || merge;\\n\\n\\t\\t\\t\\tcache.items.merge = merge > 1 || cache.items.merge;\\n\\n\\t\\t\\t\\twidths[iterator] = !grid ? this._items[iterator].width() : width * merge;\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis._widths = widths;\\n\\t\\t}\\n\\t}, {\\n\\t\\tfilter: [ 'items', 'settings' ],\\n\\t\\trun: function() {\\n\\t\\t\\tvar clones = [],\\n\\t\\t\\t\\titems = this._items,\\n\\t\\t\\t\\tsettings = this.settings,\\n\\t\\t\\t\\tview = Math.max(settings.items * 2, 4),\\n\\t\\t\\t\\tsize = Math.ceil(items.length / 2) * 2,\\n\\t\\t\\t\\trepeat = settings.loop && items.length ? settings.rewind ? view : Math.max(view, size) : 0,\\n\\t\\t\\t\\tappend = '',\\n\\t\\t\\t\\tprepend = '';\\n\\n\\t\\t\\trepeat /= 2;\\n\\n\\t\\t\\twhile (repeat--) {\\n\\t\\t\\t\\tclones.push(this.normalize(clones.length / 2, true));\\n\\t\\t\\t\\tappend = append + items[clones[clones.length - 1]][0].outerHTML;\\n\\t\\t\\t\\tclones.push(this.normalize(items.length - 1 - (clones.length - 1) / 2, true));\\n\\t\\t\\t\\tprepend = items[clones[clones.length - 1]][0].outerHTML + prepend;\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis._clones = clones;\\n\\n\\t\\t\\t$(append).addClass('cloned').appendTo(this.$stage);\\n\\t\\t\\t$(prepend).addClass('cloned').prependTo(this.$stage);\\n\\t\\t}\\n\\t}, {\\n\\t\\tfilter: [ 'width', 'items', 'settings' ],\\n\\t\\trun: function() {\\n\\t\\t\\tvar rtl = this.settings.rtl ? 1 : -1,\\n\\t\\t\\t\\tsize = this._clones.length + this._items.length,\\n\\t\\t\\t\\titerator = -1,\\n\\t\\t\\t\\tprevious = 0,\\n\\t\\t\\t\\tcurrent = 0,\\n\\t\\t\\t\\tcoordinates = [];\\n\\n\\t\\t\\twhile (++iterator < size) {\\n\\t\\t\\t\\tprevious = coordinates[iterator - 1] || 0;\\n\\t\\t\\t\\tcurrent = this._widths[this.relative(iterator)] + this.settings.margin;\\n\\t\\t\\t\\tcoordinates.push(previous + current * rtl);\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis._coordinates = coordinates;\\n\\t\\t}\\n\\t}, {\\n\\t\\tfilter: [ 'width', 'items', 'settings' ],\\n\\t\\trun: function() {\\n\\t\\t\\tvar padding = this.settings.stagePadding,\\n\\t\\t\\t\\tcoordinates = this._coordinates,\\n\\t\\t\\t\\tcss = {\\n\\t\\t\\t\\t\\t'width': Math.ceil(Math.abs(coordinates[coordinates.length - 1])) + padding * 2,\\n\\t\\t\\t\\t\\t'padding-left': padding || '',\\n\\t\\t\\t\\t\\t'padding-right': padding || ''\\n\\t\\t\\t\\t};\\n\\n\\t\\t\\tthis.$stage.css(css);\\n\\t\\t}\\n\\t}, {\\n\\t\\tfilter: [ 'width', 'items', 'settings' ],\\n\\t\\trun: function(cache) {\\n\\t\\t\\tvar iterator = this._coordinates.length,\\n\\t\\t\\t\\tgrid = !this.settings.autoWidth,\\n\\t\\t\\t\\titems = this.$stage.children();\\n\\n\\t\\t\\tif (grid && cache.items.merge) {\\n\\t\\t\\t\\twhile (iterator--) {\\n\\t\\t\\t\\t\\tcache.css.width = this._widths[this.relative(iterator)];\\n\\t\\t\\t\\t\\titems.eq(iterator).css(cache.css);\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else if (grid) {\\n\\t\\t\\t\\tcache.css.width = cache.items.width;\\n\\t\\t\\t\\titems.css(cache.css);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}, {\\n\\t\\tfilter: [ 'items' ],\\n\\t\\trun: function() {\\n\\t\\t\\tthis._coordinates.length < 1 && this.$stage.removeAttr('style');\\n\\t\\t}\\n\\t}, {\\n\\t\\tfilter: [ 'width', 'items', 'settings' ],\\n\\t\\trun: function(cache) {\\n\\t\\t\\tcache.current = cache.current ? this.$stage.children().index(cache.current) : 0;\\n\\t\\t\\tcache.current = Math.max(this.minimum(), Math.min(this.maximum(), cache.current));\\n\\t\\t\\tthis.reset(cache.current);\\n\\t\\t}\\n\\t}, {\\n\\t\\tfilter: [ 'position' ],\\n\\t\\trun: function() {\\n\\t\\t\\tthis.animate(this.coordinates(this._current));\\n\\t\\t}\\n\\t}, {\\n\\t\\tfilter: [ 'width', 'position', 'items', 'settings' ],\\n\\t\\trun: function() {\\n\\t\\t\\tvar rtl = this.settings.rtl ? 1 : -1,\\n\\t\\t\\t\\tpadding = this.settings.stagePadding * 2,\\n\\t\\t\\t\\tbegin = this.coordinates(this.current()) + padding,\\n\\t\\t\\t\\tend = begin + this.width() * rtl,\\n\\t\\t\\t\\tinner, outer, matches = [], i, n;\\n\\n\\t\\t\\tfor (i = 0, n = this._coordinates.length; i < n; i++) {\\n\\t\\t\\t\\tinner = this._coordinates[i - 1] || 0;\\n\\t\\t\\t\\touter = Math.abs(this._coordinates[i]) + padding * rtl;\\n\\n\\t\\t\\t\\tif ((this.op(inner, '<=', begin) && (this.op(inner, '>', end)))\\n\\t\\t\\t\\t\\t|| (this.op(outer, '<', begin) && this.op(outer, '>', end))) {\\n\\t\\t\\t\\t\\tmatches.push(i);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.$stage.children('.active').removeClass('active');\\n\\t\\t\\tthis.$stage.children(':eq(' + matches.join('), :eq(') + ')').addClass('active');\\n\\n\\t\\t\\tif (this.settings.center) {\\n\\t\\t\\t\\tthis.$stage.children('.center').removeClass('center');\\n\\t\\t\\t\\tthis.$stage.children().eq(this.current()).addClass('center');\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} ];\\n\\n\\t/**\\n\\t * Initializes the carousel.\\n\\t * @protected\\n\\t */\\n\\tOwl.prototype.initialize = function() {\\n\\t\\tthis.enter('initializing');\\n\\t\\tthis.trigger('initialize');\\n\\n\\t\\tthis.$element.toggleClass(this.settings.rtlClass, this.settings.rtl);\\n\\n\\t\\tif (this.settings.autoWidth && !this.is('pre-loading')) {\\n\\t\\t\\tvar imgs, nestedSelector, width;\\n\\t\\t\\timgs = this.$element.find('img');\\n\\t\\t\\tnestedSelector = this.settings.nestedItemSelector ? '.' + this.settings.nestedItemSelector : undefined;\\n\\t\\t\\twidth = this.$element.children(nestedSelector).width();\\n\\n\\t\\t\\tif (imgs.length && width <= 0) {\\n\\t\\t\\t\\tthis.preloadAutoWidthImages(imgs);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tthis.$element.addClass(this.options.loadingClass);\\n\\n\\t\\t// create stage\\n\\t\\tthis.$stage = $('<' + this.settings.stageElement + ' class=\\\"' + this.settings.stageClass + '\\\"/>')\\n\\t\\t\\t.wrap('<div class=\\\"' + this.settings.stageOuterClass + '\\\"/>');\\n\\n\\t\\t// append stage\\n\\t\\tthis.$element.append(this.$stage.parent());\\n\\n\\t\\t// append content\\n\\t\\tthis.replace(this.$element.children().not(this.$stage.parent()));\\n\\n\\t\\t// check visibility\\n\\t\\tif (this.$element.is(':visible')) {\\n\\t\\t\\t// update view\\n\\t\\t\\tthis.refresh();\\n\\t\\t} else {\\n\\t\\t\\t// invalidate width\\n\\t\\t\\tthis.invalidate('width');\\n\\t\\t}\\n\\n\\t\\tthis.$element\\n\\t\\t\\t.removeClass(this.options.loadingClass)\\n\\t\\t\\t.addClass(this.options.loadedClass);\\n\\n\\t\\t// register event handlers\\n\\t\\tthis.registerEventHandlers();\\n\\n\\t\\tthis.leave('initializing');\\n\\t\\tthis.trigger('initialized');\\n\\t};\\n\\n\\t/**\\n\\t * Setups the current settings.\\n\\t * @todo Remove responsive classes. Why should adaptive designs be brought into IE8?\\n\\t * @todo Support for media queries by using `matchMedia` would be nice.\\n\\t * @public\\n\\t */\\n\\tOwl.prototype.setup = function() {\\n\\t\\tvar viewport = this.viewport(),\\n\\t\\t\\toverwrites = this.options.responsive,\\n\\t\\t\\tmatch = -1,\\n\\t\\t\\tsettings = null;\\n\\n\\t\\tif (!overwrites) {\\n\\t\\t\\tsettings = $.extend({}, this.options);\\n\\t\\t} else {\\n\\t\\t\\t$.each(overwrites, function(breakpoint) {\\n\\t\\t\\t\\tif (breakpoint <= viewport && breakpoint > match) {\\n\\t\\t\\t\\t\\tmatch = Number(breakpoint);\\n\\t\\t\\t\\t}\\n\\t\\t\\t});\\n\\n\\t\\t\\tsettings = $.extend({}, this.options, overwrites[match]);\\n\\t\\t\\tif (typeof settings.stagePadding === 'function') {\\n\\t\\t\\t\\tsettings.stagePadding = settings.stagePadding();\\n\\t\\t\\t}\\n\\t\\t\\tdelete settings.responsive;\\n\\n\\t\\t\\t// responsive class\\n\\t\\t\\tif (settings.responsiveClass) {\\n\\t\\t\\t\\tthis.$element.attr('class',\\n\\t\\t\\t\\t\\tthis.$element.attr('class').replace(new RegExp('(' + this.options.responsiveClass + '-)\\\\\\\\S+\\\\\\\\s', 'g'), '$1' + match)\\n\\t\\t\\t\\t);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tthis.trigger('change', { property: { name: 'settings', value: settings } });\\n\\t\\tthis._breakpoint = match;\\n\\t\\tthis.settings = settings;\\n\\t\\tthis.invalidate('settings');\\n\\t\\tthis.trigger('changed', { property: { name: 'settings', value: this.settings } });\\n\\t};\\n\\n\\t/**\\n\\t * Updates option logic if necessery.\\n\\t * @protected\\n\\t */\\n\\tOwl.prototype.optionsLogic = function() {\\n\\t\\tif (this.settings.autoWidth) {\\n\\t\\t\\tthis.settings.stagePadding = false;\\n\\t\\t\\tthis.settings.merge = false;\\n\\t\\t}\\n\\t};\\n\\n\\t/**\\n\\t * Prepares an item before add.\\n\\t * @todo Rename event parameter `content` to `item`.\\n\\t * @protected\\n\\t * @returns {jQuery|HTMLElement} - The item container.\\n\\t */\\n\\tOwl.prototype.prepare = function(item) {\\n\\t\\tvar event = this.trigger('prepare', { content: item });\\n\\n\\t\\tif (!event.data) {\\n\\t\\t\\tevent.data = $('<' + this.settings.itemElement + '/>')\\n\\t\\t\\t\\t.addClass(this.options.itemClass).append(item)\\n\\t\\t}\\n\\n\\t\\tthis.trigger('prepared', { content: event.data });\\n\\n\\t\\treturn event.data;\\n\\t};\\n\\n\\t/**\\n\\t * Updates the view.\\n\\t * @public\\n\\t */\\n\\tOwl.prototype.update = function() {\\n\\t\\tvar i = 0,\\n\\t\\t\\tn = this._pipe.length,\\n\\t\\t\\tfilter = $.proxy(function(p) { return this[p] }, this._invalidated),\\n\\t\\t\\tcache = {};\\n\\n\\t\\twhile (i < n) {\\n\\t\\t\\tif (this._invalidated.all || $.grep(this._pipe[i].filter, filter).length > 0) {\\n\\t\\t\\t\\tthis._pipe[i].run(cache);\\n\\t\\t\\t}\\n\\t\\t\\ti++;\\n\\t\\t}\\n\\n\\t\\tthis._invalidated = {};\\n\\n\\t\\t!this.is('valid') && this.enter('valid');\\n\\t};\\n\\n\\t/**\\n\\t * Gets the width of the view.\\n\\t * @public\\n\\t * @param {Owl.Width} [dimension=Owl.Width.Default] - The dimension to return.\\n\\t * @returns {Number} - The width of the view in pixel.\\n\\t */\\n\\tOwl.prototype.width = function(dimension) {\\n\\t\\tdimension = dimension || Owl.Width.Default;\\n\\t\\tswitch (dimension) {\\n\\t\\t\\tcase Owl.Width.Inner:\\n\\t\\t\\tcase Owl.Width.Outer:\\n\\t\\t\\t\\treturn this._width;\\n\\t\\t\\tdefault:\\n\\t\\t\\t\\treturn this._width - this.settings.stagePadding * 2 + this.settings.margin;\\n\\t\\t}\\n\\t};\\n\\n\\t/**\\n\\t * Refreshes the carousel primarily for adaptive purposes.\\n\\t * @public\\n\\t */\\n\\tOwl.prototype.refresh = function() {\\n\\t\\tthis.enter('refreshing');\\n\\t\\tthis.trigger('refresh');\\n\\n\\t\\tthis.setup();\\n\\n\\t\\tthis.optionsLogic();\\n\\n\\t\\tthis.$element.addClass(this.options.refreshClass);\\n\\n\\t\\tthis.update();\\n\\n\\t\\tthis.$element.removeClass(this.options.refreshClass);\\n\\n\\t\\tthis.leave('refreshing');\\n\\t\\tthis.trigger('refreshed');\\n\\t};\\n\\n\\t/**\\n\\t * Checks window `resize` event.\\n\\t * @protected\\n\\t */\\n\\tOwl.prototype.onThrottledResize = function() {\\n\\t\\twindow.clearTimeout(this.resizeTimer);\\n\\t\\tthis.resizeTimer = window.setTimeout(this._handlers.onResize, this.settings.responsiveRefreshRate);\\n\\t};\\n\\n\\t/**\\n\\t * Checks window `resize` event.\\n\\t * @protected\\n\\t */\\n\\tOwl.prototype.onResize = function() {\\n\\t\\tif (!this._items.length) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\tif (this._width === this.$element.width()) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\tif (!this.$element.is(':visible')) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\tthis.enter('resizing');\\n\\n\\t\\tif (this.trigger('resize').isDefaultPrevented()) {\\n\\t\\t\\tthis.leave('resizing');\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\tthis.invalidate('width');\\n\\n\\t\\tthis.refresh();\\n\\n\\t\\tthis.leave('resizing');\\n\\t\\tthis.trigger('resized');\\n\\t};\\n\\n\\t/**\\n\\t * Registers event handlers.\\n\\t * @todo Check `msPointerEnabled`\\n\\t * @todo #261\\n\\t * @protected\\n\\t */\\n\\tOwl.prototype.registerEventHandlers = function() {\\n\\t\\tif ($.support.transition) {\\n\\t\\t\\tthis.$stage.on($.support.transition.end + '.owl.core', $.proxy(this.onTransitionEnd, this));\\n\\t\\t}\\n\\n\\t\\tif (this.settings.responsive !== false) {\\n\\t\\t\\tthis.on(window, 'resize', this._handlers.onThrottledResize);\\n\\t\\t}\\n\\n\\t\\tif (this.settings.mouseDrag) {\\n\\t\\t\\tthis.$element.addClass(this.options.dragClass);\\n\\t\\t\\tthis.$stage.on('mousedown.owl.core', $.proxy(this.onDragStart, this));\\n\\t\\t\\tthis.$stage.on('dragstart.owl.core selectstart.owl.core', function() { return false });\\n\\t\\t}\\n\\n\\t\\tif (this.settings.touchDrag){\\n\\t\\t\\tthis.$stage.on('touchstart.owl.core', $.proxy(this.onDragStart, this));\\n\\t\\t\\tthis.$stage.on('touchcancel.owl.core', $.proxy(this.onDragEnd, this));\\n\\t\\t}\\n\\t};\\n\\n\\t/**\\n\\t * Handles `touchstart` and `mousedown` events.\\n\\t * @todo Horizontal swipe threshold as option\\n\\t * @todo #261\\n\\t * @protected\\n\\t * @param {Event} event - The event arguments.\\n\\t */\\n\\tOwl.prototype.onDragStart = function(event) {\\n\\t\\tvar stage = null;\\n\\n\\t\\tif (event.which === 3) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tif ($.support.transform) {\\n\\t\\t\\tstage = this.$stage.css('transform').replace(/.*\\\\(|\\\\)| /g, '').split(',');\\n\\t\\t\\tstage = {\\n\\t\\t\\t\\tx: stage[stage.length === 16 ? 12 : 4],\\n\\t\\t\\t\\ty: stage[stage.length === 16 ? 13 : 5]\\n\\t\\t\\t};\\n\\t\\t} else {\\n\\t\\t\\tstage = this.$stage.position();\\n\\t\\t\\tstage = {\\n\\t\\t\\t\\tx: this.settings.rtl ?\\n\\t\\t\\t\\t\\tstage.left + this.$stage.width() - this.width() + this.settings.margin :\\n\\t\\t\\t\\t\\tstage.left,\\n\\t\\t\\t\\ty: stage.top\\n\\t\\t\\t};\\n\\t\\t}\\n\\n\\t\\tif (this.is('animating')) {\\n\\t\\t\\t$.support.transform ? this.animate(stage.x) : this.$stage.stop()\\n\\t\\t\\tthis.invalidate('position');\\n\\t\\t}\\n\\n\\t\\tthis.$element.toggleClass(this.options.grabClass, event.type === 'mousedown');\\n\\n\\t\\tthis.speed(0);\\n\\n\\t\\tthis._drag.time = new Date().getTime();\\n\\t\\tthis._drag.target = $(event.target);\\n\\t\\tthis._drag.stage.start = stage;\\n\\t\\tthis._drag.stage.current = stage;\\n\\t\\tthis._drag.pointer = this.pointer(event);\\n\\n\\t\\t$(document).on('mouseup.owl.core touchend.owl.core', $.proxy(this.onDragEnd, this));\\n\\n\\t\\t$(document).one('mousemove.owl.core touchmove.owl.core', $.proxy(function(event) {\\n\\t\\t\\tvar delta = this.difference(this._drag.pointer, this.pointer(event));\\n\\n\\t\\t\\t$(document).on('mousemove.owl.core touchmove.owl.core', $.proxy(this.onDragMove, this));\\n\\n\\t\\t\\tif (Math.abs(delta.x) < Math.abs(delta.y) && this.is('valid')) {\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\n\\t\\t\\tevent.preventDefault();\\n\\n\\t\\t\\tthis.enter('dragging');\\n\\t\\t\\tthis.trigger('drag');\\n\\t\\t}, this));\\n\\t};\\n\\n\\t/**\\n\\t * Handles the `touchmove` and `mousemove` events.\\n\\t * @todo #261\\n\\t * @protected\\n\\t * @param {Event} event - The event arguments.\\n\\t */\\n\\tOwl.prototype.onDragMove = function(event) {\\n\\t\\tvar minimum = null,\\n\\t\\t\\tmaximum = null,\\n\\t\\t\\tpull = null,\\n\\t\\t\\tdelta = this.difference(this._drag.pointer, this.pointer(event)),\\n\\t\\t\\tstage = this.difference(this._drag.stage.start, delta);\\n\\n\\t\\tif (!this.is('dragging')) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tevent.preventDefault();\\n\\n\\t\\tif (this.settings.loop) {\\n\\t\\t\\tminimum = this.coordinates(this.minimum());\\n\\t\\t\\tmaximum = this.coordinates(this.maximum() + 1) - minimum;\\n\\t\\t\\tstage.x = (((stage.x - minimum) % maximum + maximum) % maximum) + minimum;\\n\\t\\t} else {\\n\\t\\t\\tminimum = this.settings.rtl ? this.coordinates(this.maximum()) : this.coordinates(this.minimum());\\n\\t\\t\\tmaximum = this.settings.rtl ? this.coordinates(this.minimum()) : this.coordinates(this.maximum());\\n\\t\\t\\tpull = this.settings.pullDrag ? -1 * delta.x / 5 : 0;\\n\\t\\t\\tstage.x = Math.max(Math.min(stage.x, minimum + pull), maximum + pull);\\n\\t\\t}\\n\\n\\t\\tthis._drag.stage.current = stage;\\n\\n\\t\\tthis.animate(stage.x);\\n\\t};\\n\\n\\t/**\\n\\t * Handles the `touchend` and `mouseup` events.\\n\\t * @todo #261\\n\\t * @todo Threshold for click event\\n\\t * @protected\\n\\t * @param {Event} event - The event arguments.\\n\\t */\\n\\tOwl.prototype.onDragEnd = function(event) {\\n\\t\\tvar delta = this.difference(this._drag.pointer, this.pointer(event)),\\n\\t\\t\\tstage = this._drag.stage.current,\\n\\t\\t\\tdirection = delta.x > 0 ^ this.settings.rtl ? 'left' : 'right';\\n\\n\\t\\t$(document).off('.owl.core');\\n\\n\\t\\tthis.$element.removeClass(this.options.grabClass);\\n\\n\\t\\tif (delta.x !== 0 && this.is('dragging') || !this.is('valid')) {\\n\\t\\t\\tthis.speed(this.settings.dragEndSpeed || this.settings.smartSpeed);\\n\\t\\t\\tthis.current(this.closest(stage.x, delta.x !== 0 ? direction : this._drag.direction));\\n\\t\\t\\tthis.invalidate('position');\\n\\t\\t\\tthis.update();\\n\\n\\t\\t\\tthis._drag.direction = direction;\\n\\n\\t\\t\\tif (Math.abs(delta.x) > 3 || new Date().getTime() - this._drag.time > 300) {\\n\\t\\t\\t\\tthis._drag.target.one('click.owl.core', function() { return false; });\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif (!this.is('dragging')) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tthis.leave('dragging');\\n\\t\\tthis.trigger('dragged');\\n\\t};\\n\\n\\t/**\\n\\t * Gets absolute position of the closest item for a coordinate.\\n\\t * @todo Setting `freeDrag` makes `closest` not reusable. See #165.\\n\\t * @protected\\n\\t * @param {Number} coordinate - The coordinate in pixel.\\n\\t * @param {String} direction - The direction to check for the closest item. Ether `left` or `right`.\\n\\t * @return {Number} - The absolute position of the closest item.\\n\\t */\\n\\tOwl.prototype.closest = function(coordinate, direction) {\\n\\t\\tvar position = -1,\\n\\t\\t\\tpull = 30,\\n\\t\\t\\twidth = this.width(),\\n\\t\\t\\tcoordinates = this.coordinates();\\n\\n\\t\\tif (!this.settings.freeDrag) {\\n\\t\\t\\t// check closest item\\n\\t\\t\\t$.each(coordinates, $.proxy(function(index, value) {\\n\\t\\t\\t\\t// on a left pull, check on current index\\n\\t\\t\\t\\tif (direction === 'left' && coordinate > value - pull && coordinate < value + pull) {\\n\\t\\t\\t\\t\\tposition = index;\\n\\t\\t\\t\\t// on a right pull, check on previous index\\n\\t\\t\\t\\t// to do so, subtract width from value and set position = index + 1\\n\\t\\t\\t\\t} else if (direction === 'right' && coordinate > value - width - pull && coordinate < value - width + pull) {\\n\\t\\t\\t\\t\\tposition = index + 1;\\n\\t\\t\\t\\t} else if (this.op(coordinate, '<', value)\\n\\t\\t\\t\\t\\t&& this.op(coordinate, '>', coordinates[index + 1] || value - width)) {\\n\\t\\t\\t\\t\\tposition = direction === 'left' ? index + 1 : index;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn position === -1;\\n\\t\\t\\t}, this));\\n\\t\\t}\\n\\n\\t\\tif (!this.settings.loop) {\\n\\t\\t\\t// non loop boundries\\n\\t\\t\\tif (this.op(coordinate, '>', coordinates[this.minimum()])) {\\n\\t\\t\\t\\tposition = coordinate = this.minimum();\\n\\t\\t\\t} else if (this.op(coordinate, '<', coordinates[this.maximum()])) {\\n\\t\\t\\t\\tposition = coordinate = this.maximum();\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn position;\\n\\t};\\n\\n\\t/**\\n\\t * Animates the stage.\\n\\t * @todo #270\\n\\t * @public\\n\\t * @param {Number} coordinate - The coordinate in pixels.\\n\\t */\\n\\tOwl.prototype.animate = function(coordinate) {\\n\\t\\tvar animate = this.speed() > 0;\\n\\n\\t\\tthis.is('animating') && this.onTransitionEnd();\\n\\n\\t\\tif (animate) {\\n\\t\\t\\tthis.enter('animating');\\n\\t\\t\\tthis.trigger('translate');\\n\\t\\t}\\n\\n\\t\\tif ($.support.transform3d && $.support.transition) {\\n\\t\\t\\tthis.$stage.css({\\n\\t\\t\\t\\ttransform: 'translate3d(' + coordinate + 'px,0px,0px)',\\n\\t\\t\\t\\ttransition: (this.speed() / 1000) + 's'\\n\\t\\t\\t});\\n\\t\\t} else if (animate) {\\n\\t\\t\\tthis.$stage.animate({\\n\\t\\t\\t\\tleft: coordinate + 'px'\\n\\t\\t\\t}, this.speed(), this.settings.fallbackEasing, $.proxy(this.onTransitionEnd, this));\\n\\t\\t} else {\\n\\t\\t\\tthis.$stage.css({\\n\\t\\t\\t\\tleft: coordinate + 'px'\\n\\t\\t\\t});\\n\\t\\t}\\n\\t};\\n\\n\\t/**\\n\\t * Checks whether the carousel is in a specific state or not.\\n\\t * @param {String} state - The state to check.\\n\\t * @returns {Boolean} - The flag which indicates if the carousel is busy.\\n\\t */\\n\\tOwl.prototype.is = function(state) {\\n\\t\\treturn this._states.current[state] && this._states.current[state] > 0;\\n\\t};\\n\\n\\t/**\\n\\t * Sets the absolute position of the current item.\\n\\t * @public\\n\\t * @param {Number} [position] - The new absolute position or nothing to leave it unchanged.\\n\\t * @returns {Number} - The absolute position of the current item.\\n\\t */\\n\\tOwl.prototype.current = function(position) {\\n\\t\\tif (position === undefined) {\\n\\t\\t\\treturn this._current;\\n\\t\\t}\\n\\n\\t\\tif (this._items.length === 0) {\\n\\t\\t\\treturn undefined;\\n\\t\\t}\\n\\n\\t\\tposition = this.normalize(position);\\n\\n\\t\\tif (this._current !== position) {\\n\\t\\t\\tvar event = this.trigger('change', { property: { name: 'position', value: position } });\\n\\n\\t\\t\\tif (event.data !== undefined) {\\n\\t\\t\\t\\tposition = this.normalize(event.data);\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis._current = position;\\n\\n\\t\\t\\tthis.invalidate('position');\\n\\n\\t\\t\\tthis.trigger('changed', { property: { name: 'position', value: this._current } });\\n\\t\\t}\\n\\n\\t\\treturn this._current;\\n\\t};\\n\\n\\t/**\\n\\t * Invalidates the given part of the update routine.\\n\\t * @param {String} [part] - The part to invalidate.\\n\\t * @returns {Array.<String>} - The invalidated parts.\\n\\t */\\n\\tOwl.prototype.invalidate = function(part) {\\n\\t\\tif ($.type(part) === 'string') {\\n\\t\\t\\tthis._invalidated[part] = true;\\n\\t\\t\\tthis.is('valid') && this.leave('valid');\\n\\t\\t}\\n\\t\\treturn $.map(this._invalidated, function(v, i) { return i });\\n\\t};\\n\\n\\t/**\\n\\t * Resets the absolute position of the current item.\\n\\t * @public\\n\\t * @param {Number} position - The absolute position of the new item.\\n\\t */\\n\\tOwl.prototype.reset = function(position) {\\n\\t\\tposition = this.normalize(position);\\n\\n\\t\\tif (position === undefined) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tthis._speed = 0;\\n\\t\\tthis._current = position;\\n\\n\\t\\tthis.suppress([ 'translate', 'translated' ]);\\n\\n\\t\\tthis.animate(this.coordinates(position));\\n\\n\\t\\tthis.release([ 'translate', 'translated' ]);\\n\\t};\\n\\n\\t/**\\n\\t * Normalizes an absolute or a relative position of an item.\\n\\t * @public\\n\\t * @param {Number} position - The absolute or relative position to normalize.\\n\\t * @param {Boolean} [relative=false] - Whether the given position is relative or not.\\n\\t * @returns {Number} - The normalized position.\\n\\t */\\n\\tOwl.prototype.normalize = function(position, relative) {\\n\\t\\tvar n = this._items.length,\\n\\t\\t\\tm = relative ? 0 : this._clones.length;\\n\\n\\t\\tif (!this.isNumeric(position) || n < 1) {\\n\\t\\t\\tposition = undefined;\\n\\t\\t} else if (position < 0 || position >= n + m) {\\n\\t\\t\\tposition = ((position - m / 2) % n + n) % n + m / 2;\\n\\t\\t}\\n\\n\\t\\treturn position;\\n\\t};\\n\\n\\t/**\\n\\t * Converts an absolute position of an item into a relative one.\\n\\t * @public\\n\\t * @param {Number} position - The absolute position to convert.\\n\\t * @returns {Number} - The converted position.\\n\\t */\\n\\tOwl.prototype.relative = function(position) {\\n\\t\\tposition -= this._clones.length / 2;\\n\\t\\treturn this.normalize(position, true);\\n\\t};\\n\\n\\t/**\\n\\t * Gets the maximum position for the current item.\\n\\t * @public\\n\\t * @param {Boolean} [relative=false] - Whether to return an absolute position or a relative position.\\n\\t * @returns {Number}\\n\\t */\\n\\tOwl.prototype.maximum = function(relative) {\\n\\t\\tvar settings = this.settings,\\n\\t\\t\\tmaximum = this._coordinates.length,\\n\\t\\t\\titerator,\\n\\t\\t\\treciprocalItemsWidth,\\n\\t\\t\\telementWidth;\\n\\n\\t\\tif (settings.loop) {\\n\\t\\t\\tmaximum = this._clones.length / 2 + this._items.length - 1;\\n\\t\\t} else if (settings.autoWidth || settings.merge) {\\n\\t\\t\\titerator = this._items.length;\\n\\t\\t\\treciprocalItemsWidth = this._items[--iterator].width();\\n\\t\\t\\telementWidth = this.$element.width();\\n\\t\\t\\twhile (iterator--) {\\n\\t\\t\\t\\treciprocalItemsWidth += this._items[iterator].width() + this.settings.margin;\\n\\t\\t\\t\\tif (reciprocalItemsWidth > elementWidth) {\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tmaximum = iterator + 1;\\n\\t\\t} else if (settings.center) {\\n\\t\\t\\tmaximum = this._items.length - 1;\\n\\t\\t} else {\\n\\t\\t\\tmaximum = this._items.length - settings.items;\\n\\t\\t}\\n\\n\\t\\tif (relative) {\\n\\t\\t\\tmaximum -= this._clones.length / 2;\\n\\t\\t}\\n\\n\\t\\treturn Math.max(maximum, 0);\\n\\t};\\n\\n\\t/**\\n\\t * Gets the minimum position for the current item.\\n\\t * @public\\n\\t * @param {Boolean} [relative=false] - Whether to return an absolute position or a relative position.\\n\\t * @returns {Number}\\n\\t */\\n\\tOwl.prototype.minimum = function(relative) {\\n\\t\\treturn relative ? 0 : this._clones.length / 2;\\n\\t};\\n\\n\\t/**\\n\\t * Gets an item at the specified relative position.\\n\\t * @public\\n\\t * @param {Number} [position] - The relative position of the item.\\n\\t * @return {jQuery|Array.<jQuery>} - The item at the given position or all items if no position was given.\\n\\t */\\n\\tOwl.prototype.items = function(position) {\\n\\t\\tif (position === undefined) {\\n\\t\\t\\treturn this._items.slice();\\n\\t\\t}\\n\\n\\t\\tposition = this.normalize(position, true);\\n\\t\\treturn this._items[position];\\n\\t};\\n\\n\\t/**\\n\\t * Gets an item at the specified relative position.\\n\\t * @public\\n\\t * @param {Number} [position] - The relative position of the item.\\n\\t * @return {jQuery|Array.<jQuery>} - The item at the given position or all items if no position was given.\\n\\t */\\n\\tOwl.prototype.mergers = function(position) {\\n\\t\\tif (position === undefined) {\\n\\t\\t\\treturn this._mergers.slice();\\n\\t\\t}\\n\\n\\t\\tposition = this.normalize(position, true);\\n\\t\\treturn this._mergers[position];\\n\\t};\\n\\n\\t/**\\n\\t * Gets the absolute positions of clones for an item.\\n\\t * @public\\n\\t * @param {Number} [position] - The relative position of the item.\\n\\t * @returns {Array.<Number>} - The absolute positions of clones for the item or all if no position was given.\\n\\t */\\n\\tOwl.prototype.clones = function(position) {\\n\\t\\tvar odd = this._clones.length / 2,\\n\\t\\t\\teven = odd + this._items.length,\\n\\t\\t\\tmap = function(index) { return index % 2 === 0 ? even + index / 2 : odd - (index + 1) / 2 };\\n\\n\\t\\tif (position === undefined) {\\n\\t\\t\\treturn $.map(this._clones, function(v, i) { return map(i) });\\n\\t\\t}\\n\\n\\t\\treturn $.map(this._clones, function(v, i) { return v === position ? map(i) : null });\\n\\t};\\n\\n\\t/**\\n\\t * Sets the current animation speed.\\n\\t * @public\\n\\t * @param {Number} [speed] - The animation speed in milliseconds or nothing to leave it unchanged.\\n\\t * @returns {Number} - The current animation speed in milliseconds.\\n\\t */\\n\\tOwl.prototype.speed = function(speed) {\\n\\t\\tif (speed !== undefined) {\\n\\t\\t\\tthis._speed = speed;\\n\\t\\t}\\n\\n\\t\\treturn this._speed;\\n\\t};\\n\\n\\t/**\\n\\t * Gets the coordinate of an item.\\n\\t * @todo The name of this method is missleanding.\\n\\t * @public\\n\\t * @param {Number} position - The absolute position of the item within `minimum()` and `maximum()`.\\n\\t * @returns {Number|Array.<Number>} - The coordinate of the item in pixel or all coordinates.\\n\\t */\\n\\tOwl.prototype.coordinates = function(position) {\\n\\t\\tvar multiplier = 1,\\n\\t\\t\\tnewPosition = position - 1,\\n\\t\\t\\tcoordinate;\\n\\n\\t\\tif (position === undefined) {\\n\\t\\t\\treturn $.map(this._coordinates, $.proxy(function(coordinate, index) {\\n\\t\\t\\t\\treturn this.coordinates(index);\\n\\t\\t\\t}, this));\\n\\t\\t}\\n\\n\\t\\tif (this.settings.center) {\\n\\t\\t\\tif (this.settings.rtl) {\\n\\t\\t\\t\\tmultiplier = -1;\\n\\t\\t\\t\\tnewPosition = position + 1;\\n\\t\\t\\t}\\n\\n\\t\\t\\tcoordinate = this._coordinates[position];\\n\\t\\t\\tcoordinate += (this.width() - coordinate + (this._coordinates[newPosition] || 0)) / 2 * multiplier;\\n\\t\\t} else {\\n\\t\\t\\tcoordinate = this._coordinates[newPosition] || 0;\\n\\t\\t}\\n\\n\\t\\tcoordinate = Math.ceil(coordinate);\\n\\n\\t\\treturn coordinate;\\n\\t};\\n\\n\\t/**\\n\\t * Calculates the speed for a translation.\\n\\t * @protected\\n\\t * @param {Number} from - The absolute position of the start item.\\n\\t * @param {Number} to - The absolute position of the target item.\\n\\t * @param {Number} [factor=undefined] - The time factor in milliseconds.\\n\\t * @returns {Number} - The time in milliseconds for the translation.\\n\\t */\\n\\tOwl.prototype.duration = function(from, to, factor) {\\n\\t\\tif (factor === 0) {\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\n\\t\\treturn Math.min(Math.max(Math.abs(to - from), 1), 6) * Math.abs((factor || this.settings.smartSpeed));\\n\\t};\\n\\n\\t/**\\n\\t * Slides to the specified item.\\n\\t * @public\\n\\t * @param {Number} position - The position of the item.\\n\\t * @param {Number} [speed] - The time in milliseconds for the transition.\\n\\t */\\n\\tOwl.prototype.to = function(position, speed) {\\n\\t\\tvar current = this.current(),\\n\\t\\t\\trevert = null,\\n\\t\\t\\tdistance = position - this.relative(current),\\n\\t\\t\\tdirection = (distance > 0) - (distance < 0),\\n\\t\\t\\titems = this._items.length,\\n\\t\\t\\tminimum = this.minimum(),\\n\\t\\t\\tmaximum = this.maximum();\\n\\n\\t\\tif (this.settings.loop) {\\n\\t\\t\\tif (!this.settings.rewind && Math.abs(distance) > items / 2) {\\n\\t\\t\\t\\tdistance += direction * -1 * items;\\n\\t\\t\\t}\\n\\n\\t\\t\\tposition = current + distance;\\n\\t\\t\\trevert = ((position - minimum) % items + items) % items + minimum;\\n\\n\\t\\t\\tif (revert !== position && revert - distance <= maximum && revert - distance > 0) {\\n\\t\\t\\t\\tcurrent = revert - distance;\\n\\t\\t\\t\\tposition = revert;\\n\\t\\t\\t\\tthis.reset(current);\\n\\t\\t\\t}\\n\\t\\t} else if (this.settings.rewind) {\\n\\t\\t\\tmaximum += 1;\\n\\t\\t\\tposition = (position % maximum + maximum) % maximum;\\n\\t\\t} else {\\n\\t\\t\\tposition = Math.max(minimum, Math.min(maximum, position));\\n\\t\\t}\\n\\n\\t\\tthis.speed(this.duration(current, position, speed));\\n\\t\\tthis.current(position);\\n\\n\\t\\tif (this.$element.is(':visible')) {\\n\\t\\t\\tthis.update();\\n\\t\\t}\\n\\t};\\n\\n\\t/**\\n\\t * Slides to the next item.\\n\\t * @public\\n\\t * @param {Number} [speed] - The time in milliseconds for the transition.\\n\\t */\\n\\tOwl.prototype.next = function(speed) {\\n\\t\\tspeed = speed || false;\\n\\t\\tthis.to(this.relative(this.current()) + 1, speed);\\n\\t};\\n\\n\\t/**\\n\\t * Slides to the previous item.\\n\\t * @public\\n\\t * @param {Number} [speed] - The time in milliseconds for the transition.\\n\\t */\\n\\tOwl.prototype.prev = function(speed) {\\n\\t\\tspeed = speed || false;\\n\\t\\tthis.to(this.relative(this.current()) - 1, speed);\\n\\t};\\n\\n\\t/**\\n\\t * Handles the end of an animation.\\n\\t * @protected\\n\\t * @param {Event} event - The event arguments.\\n\\t */\\n\\tOwl.prototype.onTransitionEnd = function(event) {\\n\\n\\t\\t// if css2 animation then event object is undefined\\n\\t\\tif (event !== undefined) {\\n\\t\\t\\tevent.stopPropagation();\\n\\n\\t\\t\\t// Catch only owl-stage transitionEnd event\\n\\t\\t\\tif ((event.target || event.srcElement || event.originalTarget) !== this.$stage.get(0)) {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tthis.leave('animating');\\n\\t\\tthis.trigger('translated');\\n\\t};\\n\\n\\t/**\\n\\t * Gets viewport width.\\n\\t * @protected\\n\\t * @return {Number} - The width in pixel.\\n\\t */\\n\\tOwl.prototype.viewport = function() {\\n\\t\\tvar width;\\n\\t\\tif (this.options.responsiveBaseElement !== window) {\\n\\t\\t\\twidth = $(this.options.responsiveBaseElement).width();\\n\\t\\t} else if (window.innerWidth) {\\n\\t\\t\\twidth = window.innerWidth;\\n\\t\\t} else if (document.documentElement && document.documentElement.clientWidth) {\\n\\t\\t\\twidth = document.documentElement.clientWidth;\\n\\t\\t} else {\\n\\t\\t\\tthrow 'Can not detect viewport width.';\\n\\t\\t}\\n\\t\\treturn width;\\n\\t};\\n\\n\\t/**\\n\\t * Replaces the current content.\\n\\t * @public\\n\\t * @param {HTMLElement|jQuery|String} content - The new content.\\n\\t */\\n\\tOwl.prototype.replace = function(content) {\\n\\t\\tthis.$stage.empty();\\n\\t\\tthis._items = [];\\n\\n\\t\\tif (content) {\\n\\t\\t\\tcontent = (content instanceof jQuery) ? content : $(content);\\n\\t\\t}\\n\\n\\t\\tif (this.settings.nestedItemSelector) {\\n\\t\\t\\tcontent = content.find('.' + this.settings.nestedItemSelector);\\n\\t\\t}\\n\\n\\t\\tcontent.filter(function() {\\n\\t\\t\\treturn this.nodeType === 1;\\n\\t\\t}).each($.proxy(function(index, item) {\\n\\t\\t\\titem = this.prepare(item);\\n\\t\\t\\tthis.$stage.append(item);\\n\\t\\t\\tthis._items.push(item);\\n\\t\\t\\tthis._mergers.push(item.find('[data-merge]').addBack('[data-merge]').attr('data-merge') * 1 || 1);\\n\\t\\t}, this));\\n\\n\\t\\tthis.reset(this.isNumeric(this.settings.startPosition) ? this.settings.startPosition : 0);\\n\\n\\t\\tthis.invalidate('items');\\n\\t};\\n\\n\\t/**\\n\\t * Adds an item.\\n\\t * @todo Use `item` instead of `content` for the event arguments.\\n\\t * @public\\n\\t * @param {HTMLElement|jQuery|String} content - The item content to add.\\n\\t * @param {Number} [position] - The relative position at which to insert the item otherwise the item will be added to the end.\\n\\t */\\n\\tOwl.prototype.add = function(content, position) {\\n\\t\\tvar current = this.relative(this._current);\\n\\n\\t\\tposition = position === undefined ? this._items.length : this.normalize(position, true);\\n\\t\\tcontent = content instanceof jQuery ? content : $(content);\\n\\n\\t\\tthis.trigger('add', { content: content, position: position });\\n\\n\\t\\tcontent = this.prepare(content);\\n\\n\\t\\tif (this._items.length === 0 || position === this._items.length) {\\n\\t\\t\\tthis._items.length === 0 && this.$stage.append(content);\\n\\t\\t\\tthis._items.length !== 0 && this._items[position - 1].after(content);\\n\\t\\t\\tthis._items.push(content);\\n\\t\\t\\tthis._mergers.push(content.find('[data-merge]').addBack('[data-merge]').attr('data-merge') * 1 || 1);\\n\\t\\t} else {\\n\\t\\t\\tthis._items[position].before(content);\\n\\t\\t\\tthis._items.splice(position, 0, content);\\n\\t\\t\\tthis._mergers.splice(position, 0, content.find('[data-merge]').addBack('[data-merge]').attr('data-merge') * 1 || 1);\\n\\t\\t}\\n\\n\\t\\tthis._items[current] && this.reset(this._items[current].index());\\n\\n\\t\\tthis.invalidate('items');\\n\\n\\t\\tthis.trigger('added', { content: content, position: position });\\n\\t};\\n\\n\\t/**\\n\\t * Removes an item by its position.\\n\\t * @todo Use `item` instead of `content` for the event arguments.\\n\\t * @public\\n\\t * @param {Number} position - The relative position of the item to remove.\\n\\t */\\n\\tOwl.prototype.remove = function(position) {\\n\\t\\tposition = this.normalize(position, true);\\n\\n\\t\\tif (position === undefined) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tthis.trigger('remove', { content: this._items[position], position: position });\\n\\n\\t\\tthis._items[position].remove();\\n\\t\\tthis._items.splice(position, 1);\\n\\t\\tthis._mergers.splice(position, 1);\\n\\n\\t\\tthis.invalidate('items');\\n\\n\\t\\tthis.trigger('removed', { content: null, position: position });\\n\\t};\\n\\n\\t/**\\n\\t * Preloads images with auto width.\\n\\t * @todo Replace by a more generic approach\\n\\t * @protected\\n\\t */\\n\\tOwl.prototype.preloadAutoWidthImages = function(images) {\\n\\t\\timages.each($.proxy(function(i, element) {\\n\\t\\t\\tthis.enter('pre-loading');\\n\\t\\t\\telement = $(element);\\n\\t\\t\\t$(new Image()).one('load', $.proxy(function(e) {\\n\\t\\t\\t\\telement.attr('src', e.target.src);\\n\\t\\t\\t\\telement.css('opacity', 1);\\n\\t\\t\\t\\tthis.leave('pre-loading');\\n\\t\\t\\t\\t!this.is('pre-loading') && !this.is('initializing') && this.refresh();\\n\\t\\t\\t}, this)).attr('src', element.attr('src') || element.attr('data-src') || element.attr('data-src-retina'));\\n\\t\\t}, this));\\n\\t};\\n\\n\\t/**\\n\\t * Destroys the carousel.\\n\\t * @public\\n\\t */\\n\\tOwl.prototype.destroy = function() {\\n\\n\\t\\tthis.$element.off('.owl.core');\\n\\t\\tthis.$stage.off('.owl.core');\\n\\t\\t$(document).off('.owl.core');\\n\\n\\t\\tif (this.settings.responsive !== false) {\\n\\t\\t\\twindow.clearTimeout(this.resizeTimer);\\n\\t\\t\\tthis.off(window, 'resize', this._handlers.onThrottledResize);\\n\\t\\t}\\n\\n\\t\\tfor (var i in this._plugins) {\\n\\t\\t\\tthis._plugins[i].destroy();\\n\\t\\t}\\n\\n\\t\\tthis.$stage.children('.cloned').remove();\\n\\n\\t\\tthis.$stage.unwrap();\\n\\t\\tthis.$stage.children().contents().unwrap();\\n\\t\\tthis.$stage.children().unwrap();\\n\\n\\t\\tthis.$element\\n\\t\\t\\t.removeClass(this.options.refreshClass)\\n\\t\\t\\t.removeClass(this.options.loadingClass)\\n\\t\\t\\t.removeClass(this.options.loadedClass)\\n\\t\\t\\t.removeClass(this.options.rtlClass)\\n\\t\\t\\t.removeClass(this.options.dragClass)\\n\\t\\t\\t.removeClass(this.options.grabClass)\\n\\t\\t\\t.attr('class', this.$element.attr('class').replace(new RegExp(this.options.responsiveClass + '-\\\\\\\\S+\\\\\\\\s', 'g'), ''))\\n\\t\\t\\t.removeData('owl.carousel');\\n\\t};\\n\\n\\t/**\\n\\t * Operators to calculate right-to-left and left-to-right.\\n\\t * @protected\\n\\t * @param {Number} [a] - The left side operand.\\n\\t * @param {String} [o] - The operator.\\n\\t * @param {Number} [b] - The right side operand.\\n\\t */\\n\\tOwl.prototype.op = function(a, o, b) {\\n\\t\\tvar rtl = this.settings.rtl;\\n\\t\\tswitch (o) {\\n\\t\\t\\tcase '<':\\n\\t\\t\\t\\treturn rtl ? a > b : a < b;\\n\\t\\t\\tcase '>':\\n\\t\\t\\t\\treturn rtl ? a < b : a > b;\\n\\t\\t\\tcase '>=':\\n\\t\\t\\t\\treturn rtl ? a <= b : a >= b;\\n\\t\\t\\tcase '<=':\\n\\t\\t\\t\\treturn rtl ? a >= b : a <= b;\\n\\t\\t\\tdefault:\\n\\t\\t\\t\\tbreak;\\n\\t\\t}\\n\\t};\\n\\n\\t/**\\n\\t * Attaches to an internal event.\\n\\t * @protected\\n\\t * @param {HTMLElement} element - The event source.\\n\\t * @param {String} event - The event name.\\n\\t * @param {Function} listener - The event handler to attach.\\n\\t * @param {Boolean} capture - Wether the event should be handled at the capturing phase or not.\\n\\t */\\n\\tOwl.prototype.on = function(element, event, listener, capture) {\\n\\t\\tif (element.addEventListener) {\\n\\t\\t\\telement.addEventListener(event, listener, capture);\\n\\t\\t} else if (element.attachEvent) {\\n\\t\\t\\telement.attachEvent('on' + event, listener);\\n\\t\\t}\\n\\t};\\n\\n\\t/**\\n\\t * Detaches from an internal event.\\n\\t * @protected\\n\\t * @param {HTMLElement} element - The event source.\\n\\t * @param {String} event - The event name.\\n\\t * @param {Function} listener - The attached event handler to detach.\\n\\t * @param {Boolean} capture - Wether the attached event handler was registered as a capturing listener or not.\\n\\t */\\n\\tOwl.prototype.off = function(element, event, listener, capture) {\\n\\t\\tif (element.removeEventListener) {\\n\\t\\t\\telement.removeEventListener(event, listener, capture);\\n\\t\\t} else if (element.detachEvent) {\\n\\t\\t\\telement.detachEvent('on' + event, listener);\\n\\t\\t}\\n\\t};\\n\\n\\t/**\\n\\t * Triggers a public event.\\n\\t * @todo Remove `status`, `relatedTarget` should be used instead.\\n\\t * @protected\\n\\t * @param {String} name - The event name.\\n\\t * @param {*} [data=null] - The event data.\\n\\t * @param {String} [namespace=carousel] - The event namespace.\\n\\t * @param {String} [state] - The state which is associated with the event.\\n\\t * @param {Boolean} [enter=false] - Indicates if the call enters the specified state or not.\\n\\t * @returns {Event} - The event arguments.\\n\\t */\\n\\tOwl.prototype.trigger = function(name, data, namespace, state, enter) {\\n\\t\\tvar status = {\\n\\t\\t\\titem: { count: this._items.length, index: this.current() }\\n\\t\\t}, handler = $.camelCase(\\n\\t\\t\\t$.grep([ 'on', name, namespace ], function(v) { return v })\\n\\t\\t\\t\\t.join('-').toLowerCase()\\n\\t\\t), event = $.Event(\\n\\t\\t\\t[ name, 'owl', namespace || 'carousel' ].join('.').toLowerCase(),\\n\\t\\t\\t$.extend({ relatedTarget: this }, status, data)\\n\\t\\t);\\n\\n\\t\\tif (!this._supress[name]) {\\n\\t\\t\\t$.each(this._plugins, function(name, plugin) {\\n\\t\\t\\t\\tif (plugin.onTrigger) {\\n\\t\\t\\t\\t\\tplugin.onTrigger(event);\\n\\t\\t\\t\\t}\\n\\t\\t\\t});\\n\\n\\t\\t\\tthis.register({ type: Owl.Type.Event, name: name });\\n\\t\\t\\tthis.$element.trigger(event);\\n\\n\\t\\t\\tif (this.settings && typeof this.settings[handler] === 'function') {\\n\\t\\t\\t\\tthis.settings[handler].call(this, event);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn event;\\n\\t};\\n\\n\\t/**\\n\\t * Enters a state.\\n\\t * @param name - The state name.\\n\\t */\\n\\tOwl.prototype.enter = function(name) {\\n\\t\\t$.each([ name ].concat(this._states.tags[name] || []), $.proxy(function(i, name) {\\n\\t\\t\\tif (this._states.current[name] === undefined) {\\n\\t\\t\\t\\tthis._states.current[name] = 0;\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis._states.current[name]++;\\n\\t\\t}, this));\\n\\t};\\n\\n\\t/**\\n\\t * Leaves a state.\\n\\t * @param name - The state name.\\n\\t */\\n\\tOwl.prototype.leave = function(name) {\\n\\t\\t$.each([ name ].concat(this._states.tags[name] || []), $.proxy(function(i, name) {\\n\\t\\t\\tthis._states.current[name]--;\\n\\t\\t}, this));\\n\\t};\\n\\n\\t/**\\n\\t * Registers an event or state.\\n\\t * @public\\n\\t * @param {Object} object - The event or state to register.\\n\\t */\\n\\tOwl.prototype.register = function(object) {\\n\\t\\tif (object.type === Owl.Type.Event) {\\n\\t\\t\\tif (!$.event.special[object.name]) {\\n\\t\\t\\t\\t$.event.special[object.name] = {};\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (!$.event.special[object.name].owl) {\\n\\t\\t\\t\\tvar _default = $.event.special[object.name]._default;\\n\\t\\t\\t\\t$.event.special[object.name]._default = function(e) {\\n\\t\\t\\t\\t\\tif (_default && _default.apply && (!e.namespace || e.namespace.indexOf('owl') === -1)) {\\n\\t\\t\\t\\t\\t\\treturn _default.apply(this, arguments);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\treturn e.namespace && e.namespace.indexOf('owl') > -1;\\n\\t\\t\\t\\t};\\n\\t\\t\\t\\t$.event.special[object.name].owl = true;\\n\\t\\t\\t}\\n\\t\\t} else if (object.type === Owl.Type.State) {\\n\\t\\t\\tif (!this._states.tags[object.name]) {\\n\\t\\t\\t\\tthis._states.tags[object.name] = object.tags;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tthis._states.tags[object.name] = this._states.tags[object.name].concat(object.tags);\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis._states.tags[object.name] = $.grep(this._states.tags[object.name], $.proxy(function(tag, i) {\\n\\t\\t\\t\\treturn $.inArray(tag, this._states.tags[object.name]) === i;\\n\\t\\t\\t}, this));\\n\\t\\t}\\n\\t};\\n\\n\\t/**\\n\\t * Suppresses events.\\n\\t * @protected\\n\\t * @param {Array.<String>} events - The events to suppress.\\n\\t */\\n\\tOwl.prototype.suppress = function(events) {\\n\\t\\t$.each(events, $.proxy(function(index, event) {\\n\\t\\t\\tthis._supress[event] = true;\\n\\t\\t}, this));\\n\\t};\\n\\n\\t/**\\n\\t * Releases suppressed events.\\n\\t * @protected\\n\\t * @param {Array.<String>} events - The events to release.\\n\\t */\\n\\tOwl.prototype.release = function(events) {\\n\\t\\t$.each(events, $.proxy(function(index, event) {\\n\\t\\t\\tdelete this._supress[event];\\n\\t\\t}, this));\\n\\t};\\n\\n\\t/**\\n\\t * Gets unified pointer coordinates from event.\\n\\t * @todo #261\\n\\t * @protected\\n\\t * @param {Event} - The `mousedown` or `touchstart` event.\\n\\t * @returns {Object} - Contains `x` and `y` coordinates of current pointer position.\\n\\t */\\n\\tOwl.prototype.pointer = function(event) {\\n\\t\\tvar result = { x: null, y: null };\\n\\n\\t\\tevent = event.originalEvent || event || window.event;\\n\\n\\t\\tevent = event.touches && event.touches.length ?\\n\\t\\t\\tevent.touches[0] : event.changedTouches && event.changedTouches.length ?\\n\\t\\t\\t\\tevent.changedTouches[0] : event;\\n\\n\\t\\tif (event.pageX) {\\n\\t\\t\\tresult.x = event.pageX;\\n\\t\\t\\tresult.y = event.pageY;\\n\\t\\t} else {\\n\\t\\t\\tresult.x = event.clientX;\\n\\t\\t\\tresult.y = event.clientY;\\n\\t\\t}\\n\\n\\t\\treturn result;\\n\\t};\\n\\n\\t/**\\n\\t * Determines if the input is a Number or something that can be coerced to a Number\\n\\t * @protected\\n\\t * @param {Number|String|Object|Array|Boolean|RegExp|Function|Symbol} - The input to be tested\\n\\t * @returns {Boolean} - An indication if the input is a Number or can be coerced to a Number\\n\\t */\\n\\tOwl.prototype.isNumeric = function(number) {\\n\\t\\treturn !isNaN(parseFloat(number));\\n\\t};\\n\\n\\t/**\\n\\t * Gets the difference of two vectors.\\n\\t * @todo #261\\n\\t * @protected\\n\\t * @param {Object} - The first vector.\\n\\t * @param {Object} - The second vector.\\n\\t * @returns {Object} - The difference.\\n\\t */\\n\\tOwl.prototype.difference = function(first, second) {\\n\\t\\treturn {\\n\\t\\t\\tx: first.x - second.x,\\n\\t\\t\\ty: first.y - second.y\\n\\t\\t};\\n\\t};\\n\\n\\t/**\\n\\t * The jQuery Plugin for the Owl Carousel\\n\\t * @todo Navigation plugin `next` and `prev`\\n\\t * @public\\n\\t */\\n\\t$.fn.owlCarousel = function(option) {\\n\\t\\tvar args = Array.prototype.slice.call(arguments, 1);\\n\\n\\t\\treturn this.each(function() {\\n\\t\\t\\tvar $this = $(this),\\n\\t\\t\\t\\tdata = $this.data('owl.carousel');\\n\\n\\t\\t\\tif (!data) {\\n\\t\\t\\t\\tdata = new Owl(this, typeof option == 'object' && option);\\n\\t\\t\\t\\t$this.data('owl.carousel', data);\\n\\n\\t\\t\\t\\t$.each([\\n\\t\\t\\t\\t\\t'next', 'prev', 'to', 'destroy', 'refresh', 'replace', 'add', 'remove'\\n\\t\\t\\t\\t], function(i, event) {\\n\\t\\t\\t\\t\\tdata.register({ type: Owl.Type.Event, name: event });\\n\\t\\t\\t\\t\\tdata.$element.on(event + '.owl.carousel.core', $.proxy(function(e) {\\n\\t\\t\\t\\t\\t\\tif (e.namespace && e.relatedTarget !== this) {\\n\\t\\t\\t\\t\\t\\t\\tthis.suppress([ event ]);\\n\\t\\t\\t\\t\\t\\t\\tdata[event].apply(this, [].slice.call(arguments, 1));\\n\\t\\t\\t\\t\\t\\t\\tthis.release([ event ]);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}, data));\\n\\t\\t\\t\\t});\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (typeof option == 'string' && option.charAt(0) !== '_') {\\n\\t\\t\\t\\tdata[option].apply(data, args);\\n\\t\\t\\t}\\n\\t\\t});\\n\\t};\\n\\n\\t/**\\n\\t * The constructor for the jQuery Plugin\\n\\t * @public\\n\\t */\\n\\t$.fn.owlCarousel.Constructor = Owl;\\n\\n})(window.Zepto || __webpack_provided_window_dot_jQuery, window, document);\\n\\n/**\\n * AutoRefresh Plugin\\n * @version 2.1.0\\n * @author Artus Kolanowski\\n * @author David Deutsch\\n * @license The MIT License (MIT)\\n */\\n;(function($, window, document, undefined) {\\n\\n\\t/**\\n\\t * Creates the auto refresh plugin.\\n\\t * @class The Auto Refresh Plugin\\n\\t * @param {Owl} carousel - The Owl Carousel\\n\\t */\\n\\tvar AutoRefresh = function(carousel) {\\n\\t\\t/**\\n\\t\\t * Reference to the core.\\n\\t\\t * @protected\\n\\t\\t * @type {Owl}\\n\\t\\t */\\n\\t\\tthis._core = carousel;\\n\\n\\t\\t/**\\n\\t\\t * Refresh interval.\\n\\t\\t * @protected\\n\\t\\t * @type {number}\\n\\t\\t */\\n\\t\\tthis._interval = null;\\n\\n\\t\\t/**\\n\\t\\t * Whether the element is currently visible or not.\\n\\t\\t * @protected\\n\\t\\t * @type {Boolean}\\n\\t\\t */\\n\\t\\tthis._visible = null;\\n\\n\\t\\t/**\\n\\t\\t * All event handlers.\\n\\t\\t * @protected\\n\\t\\t * @type {Object}\\n\\t\\t */\\n\\t\\tthis._handlers = {\\n\\t\\t\\t'initialized.owl.carousel': $.proxy(function(e) {\\n\\t\\t\\t\\tif (e.namespace && this._core.settings.autoRefresh) {\\n\\t\\t\\t\\t\\tthis.watch();\\n\\t\\t\\t\\t}\\n\\t\\t\\t}, this)\\n\\t\\t};\\n\\n\\t\\t// set default options\\n\\t\\tthis._core.options = $.extend({}, AutoRefresh.Defaults, this._core.options);\\n\\n\\t\\t// register event handlers\\n\\t\\tthis._core.$element.on(this._handlers);\\n\\t};\\n\\n\\t/**\\n\\t * Default options.\\n\\t * @public\\n\\t */\\n\\tAutoRefresh.Defaults = {\\n\\t\\tautoRefresh: true,\\n\\t\\tautoRefreshInterval: 500\\n\\t};\\n\\n\\t/**\\n\\t * Watches the element.\\n\\t */\\n\\tAutoRefresh.prototype.watch = function() {\\n\\t\\tif (this._interval) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tthis._visible = this._core.$element.is(':visible');\\n\\t\\tthis._interval = window.setInterval($.proxy(this.refresh, this), this._core.settings.autoRefreshInterval);\\n\\t};\\n\\n\\t/**\\n\\t * Refreshes the element.\\n\\t */\\n\\tAutoRefresh.prototype.refresh = function() {\\n\\t\\tif (this._core.$element.is(':visible') === this._visible) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tthis._visible = !this._visible;\\n\\n\\t\\tthis._core.$element.toggleClass('owl-hidden', !this._visible);\\n\\n\\t\\tthis._visible && (this._core.invalidate('width') && this._core.refresh());\\n\\t};\\n\\n\\t/**\\n\\t * Destroys the plugin.\\n\\t */\\n\\tAutoRefresh.prototype.destroy = function() {\\n\\t\\tvar handler, property;\\n\\n\\t\\twindow.clearInterval(this._interval);\\n\\n\\t\\tfor (handler in this._handlers) {\\n\\t\\t\\tthis._core.$element.off(handler, this._handlers[handler]);\\n\\t\\t}\\n\\t\\tfor (property in Object.getOwnPropertyNames(this)) {\\n\\t\\t\\ttypeof this[property] != 'function' && (this[property] = null);\\n\\t\\t}\\n\\t};\\n\\n\\t$.fn.owlCarousel.Constructor.Plugins.AutoRefresh = AutoRefresh;\\n\\n})(window.Zepto || __webpack_provided_window_dot_jQuery, window, document);\\n\\n/**\\n * Lazy Plugin\\n * @version 2.1.0\\n * @author Bartosz Wojciechowski\\n * @author David Deutsch\\n * @license The MIT License (MIT)\\n */\\n;(function($, window, document, undefined) {\\n\\n\\t/**\\n\\t * Creates the lazy plugin.\\n\\t * @class The Lazy Plugin\\n\\t * @param {Owl} carousel - The Owl Carousel\\n\\t */\\n\\tvar Lazy = function(carousel) {\\n\\n\\t\\t/**\\n\\t\\t * Reference to the core.\\n\\t\\t * @protected\\n\\t\\t * @type {Owl}\\n\\t\\t */\\n\\t\\tthis._core = carousel;\\n\\n\\t\\t/**\\n\\t\\t * Already loaded items.\\n\\t\\t * @protected\\n\\t\\t * @type {Array.<jQuery>}\\n\\t\\t */\\n\\t\\tthis._loaded = [];\\n\\n\\t\\t/**\\n\\t\\t * Event handlers.\\n\\t\\t * @protected\\n\\t\\t * @type {Object}\\n\\t\\t */\\n\\t\\tthis._handlers = {\\n\\t\\t\\t'initialized.owl.carousel change.owl.carousel resized.owl.carousel': $.proxy(function(e) {\\n\\t\\t\\t\\tif (!e.namespace) {\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif (!this._core.settings || !this._core.settings.lazyLoad) {\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ((e.property && e.property.name == 'position') || e.type == 'initialized') {\\n\\t\\t\\t\\t\\tvar settings = this._core.settings,\\n\\t\\t\\t\\t\\t\\tn = (settings.center && Math.ceil(settings.items / 2) || settings.items),\\n\\t\\t\\t\\t\\t\\ti = ((settings.center && n * -1) || 0),\\n\\t\\t\\t\\t\\t\\tposition = (e.property && e.property.value !== undefined ? e.property.value : this._core.current()) + i,\\n\\t\\t\\t\\t\\t\\tclones = this._core.clones().length,\\n\\t\\t\\t\\t\\t\\tload = $.proxy(function(i, v) { this.load(v) }, this);\\n\\n\\t\\t\\t\\t\\twhile (i++ < n) {\\n\\t\\t\\t\\t\\t\\tthis.load(clones / 2 + this._core.relative(position));\\n\\t\\t\\t\\t\\t\\tclones && $.each(this._core.clones(this._core.relative(position)), load);\\n\\t\\t\\t\\t\\t\\tposition++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}, this)\\n\\t\\t};\\n\\n\\t\\t// set the default options\\n\\t\\tthis._core.options = $.extend({}, Lazy.Defaults, this._core.options);\\n\\n\\t\\t// register event handler\\n\\t\\tthis._core.$element.on(this._handlers);\\n\\t};\\n\\n\\t/**\\n\\t * Default options.\\n\\t * @public\\n\\t */\\n\\tLazy.Defaults = {\\n\\t\\tlazyLoad: false\\n\\t};\\n\\n\\t/**\\n\\t * Loads all resources of an item at the specified position.\\n\\t * @param {Number} position - The absolute position of the item.\\n\\t * @protected\\n\\t */\\n\\tLazy.prototype.load = function(position) {\\n\\t\\tvar $item = this._core.$stage.children().eq(position),\\n\\t\\t\\t$elements = $item && $item.find('.owl-lazy');\\n\\n\\t\\tif (!$elements || $.inArray($item.get(0), this._loaded) > -1) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\t$elements.each($.proxy(function(index, element) {\\n\\t\\t\\tvar $element = $(element), image,\\n\\t\\t\\t\\turl = (window.devicePixelRatio > 1 && $element.attr('data-src-retina')) || $element.attr('data-src');\\n\\n\\t\\t\\tthis._core.trigger('load', { element: $element, url: url }, 'lazy');\\n\\n\\t\\t\\tif ($element.is('img')) {\\n\\t\\t\\t\\t$element.one('load.owl.lazy', $.proxy(function() {\\n\\t\\t\\t\\t\\t$element.css('opacity', 1);\\n\\t\\t\\t\\t\\tthis._core.trigger('loaded', { element: $element, url: url }, 'lazy');\\n\\t\\t\\t\\t}, this)).attr('src', url);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\timage = new Image();\\n\\t\\t\\t\\timage.onload = $.proxy(function() {\\n\\t\\t\\t\\t\\t$element.css({\\n\\t\\t\\t\\t\\t\\t'background-image': 'url(' + url + ')',\\n\\t\\t\\t\\t\\t\\t'opacity': '1'\\n\\t\\t\\t\\t\\t});\\n\\t\\t\\t\\t\\tthis._core.trigger('loaded', { element: $element, url: url }, 'lazy');\\n\\t\\t\\t\\t}, this);\\n\\t\\t\\t\\timage.src = url;\\n\\t\\t\\t}\\n\\t\\t}, this));\\n\\n\\t\\tthis._loaded.push($item.get(0));\\n\\t};\\n\\n\\t/**\\n\\t * Destroys the plugin.\\n\\t * @public\\n\\t */\\n\\tLazy.prototype.destroy = function() {\\n\\t\\tvar handler, property;\\n\\n\\t\\tfor (handler in this.handlers) {\\n\\t\\t\\tthis._core.$element.off(handler, this.handlers[handler]);\\n\\t\\t}\\n\\t\\tfor (property in Object.getOwnPropertyNames(this)) {\\n\\t\\t\\ttypeof this[property] != 'function' && (this[property] = null);\\n\\t\\t}\\n\\t};\\n\\n\\t$.fn.owlCarousel.Constructor.Plugins.Lazy = Lazy;\\n\\n})(window.Zepto || __webpack_provided_window_dot_jQuery, window, document);\\n\\n/**\\n * AutoHeight Plugin\\n * @version 2.1.0\\n * @author Bartosz Wojciechowski\\n * @author David Deutsch\\n * @license The MIT License (MIT)\\n */\\n;(function($, window, document, undefined) {\\n\\n\\t/**\\n\\t * Creates the auto height plugin.\\n\\t * @class The Auto Height Plugin\\n\\t * @param {Owl} carousel - The Owl Carousel\\n\\t */\\n\\tvar AutoHeight = function(carousel) {\\n\\t\\t/**\\n\\t\\t * Reference to the core.\\n\\t\\t * @protected\\n\\t\\t * @type {Owl}\\n\\t\\t */\\n\\t\\tthis._core = carousel;\\n\\n\\t\\t/**\\n\\t\\t * All event handlers.\\n\\t\\t * @protected\\n\\t\\t * @type {Object}\\n\\t\\t */\\n\\t\\tthis._handlers = {\\n\\t\\t\\t'initialized.owl.carousel refreshed.owl.carousel': $.proxy(function(e) {\\n\\t\\t\\t\\tif (e.namespace && this._core.settings.autoHeight) {\\n\\t\\t\\t\\t\\tthis.update();\\n\\t\\t\\t\\t}\\n\\t\\t\\t}, this),\\n\\t\\t\\t'changed.owl.carousel': $.proxy(function(e) {\\n\\t\\t\\t\\tif (e.namespace && this._core.settings.autoHeight && e.property.name == 'position'){\\n\\t\\t\\t\\t\\tthis.update();\\n\\t\\t\\t\\t}\\n\\t\\t\\t}, this),\\n\\t\\t\\t'loaded.owl.lazy': $.proxy(function(e) {\\n\\t\\t\\t\\tif (e.namespace && this._core.settings.autoHeight\\n\\t\\t\\t\\t\\t&& e.element.closest('.' + this._core.settings.itemClass).index() === this._core.current()) {\\n\\t\\t\\t\\t\\tthis.update();\\n\\t\\t\\t\\t}\\n\\t\\t\\t}, this)\\n\\t\\t};\\n\\n\\t\\t// set default options\\n\\t\\tthis._core.options = $.extend({}, AutoHeight.Defaults, this._core.options);\\n\\n\\t\\t// register event handlers\\n\\t\\tthis._core.$element.on(this._handlers);\\n\\t};\\n\\n\\t/**\\n\\t * Default options.\\n\\t * @public\\n\\t */\\n\\tAutoHeight.Defaults = {\\n\\t\\tautoHeight: false,\\n\\t\\tautoHeightClass: 'owl-height'\\n\\t};\\n\\n\\t/**\\n\\t * Updates the view.\\n\\t */\\n\\tAutoHeight.prototype.update = function() {\\n\\t\\tvar start = this._core._current,\\n\\t\\t\\tend = start + this._core.settings.items,\\n\\t\\t\\tvisible = this._core.$stage.children().toArray().slice(start, end),\\n\\t\\t\\theights = [],\\n\\t\\t\\tmaxheight = 0;\\n\\n\\t\\t$.each(visible, function(index, item) {\\n\\t\\t\\theights.push($(item).height());\\n\\t\\t});\\n\\n\\t\\tmaxheight = Math.max.apply(null, heights);\\n\\n\\t\\tthis._core.$stage.parent()\\n\\t\\t\\t.height(maxheight)\\n\\t\\t\\t.addClass(this._core.settings.autoHeightClass);\\n\\t};\\n\\n\\tAutoHeight.prototype.destroy = function() {\\n\\t\\tvar handler, property;\\n\\n\\t\\tfor (handler in this._handlers) {\\n\\t\\t\\tthis._core.$element.off(handler, this._handlers[handler]);\\n\\t\\t}\\n\\t\\tfor (property in Object.getOwnPropertyNames(this)) {\\n\\t\\t\\ttypeof this[property] != 'function' && (this[property] = null);\\n\\t\\t}\\n\\t};\\n\\n\\t$.fn.owlCarousel.Constructor.Plugins.AutoHeight = AutoHeight;\\n\\n})(window.Zepto || __webpack_provided_window_dot_jQuery, window, document);\\n\\n/**\\n * Video Plugin\\n * @version 2.1.0\\n * @author Bartosz Wojciechowski\\n * @author David Deutsch\\n * @license The MIT License (MIT)\\n */\\n;(function($, window, document, undefined) {\\n\\n\\t/**\\n\\t * Creates the video plugin.\\n\\t * @class The Video Plugin\\n\\t * @param {Owl} carousel - The Owl Carousel\\n\\t */\\n\\tvar Video = function(carousel) {\\n\\t\\t/**\\n\\t\\t * Reference to the core.\\n\\t\\t * @protected\\n\\t\\t * @type {Owl}\\n\\t\\t */\\n\\t\\tthis._core = carousel;\\n\\n\\t\\t/**\\n\\t\\t * Cache all video URLs.\\n\\t\\t * @protected\\n\\t\\t * @type {Object}\\n\\t\\t */\\n\\t\\tthis._videos = {};\\n\\n\\t\\t/**\\n\\t\\t * Current playing item.\\n\\t\\t * @protected\\n\\t\\t * @type {jQuery}\\n\\t\\t */\\n\\t\\tthis._playing = null;\\n\\n\\t\\t/**\\n\\t\\t * All event handlers.\\n\\t\\t * @todo The cloned content removale is too late\\n\\t\\t * @protected\\n\\t\\t * @type {Object}\\n\\t\\t */\\n\\t\\tthis._handlers = {\\n\\t\\t\\t'initialized.owl.carousel': $.proxy(function(e) {\\n\\t\\t\\t\\tif (e.namespace) {\\n\\t\\t\\t\\t\\tthis._core.register({ type: 'state', name: 'playing', tags: [ 'interacting' ] });\\n\\t\\t\\t\\t}\\n\\t\\t\\t}, this),\\n\\t\\t\\t'resize.owl.carousel': $.proxy(function(e) {\\n\\t\\t\\t\\tif (e.namespace && this._core.settings.video && this.isInFullScreen()) {\\n\\t\\t\\t\\t\\te.preventDefault();\\n\\t\\t\\t\\t}\\n\\t\\t\\t}, this),\\n\\t\\t\\t'refreshed.owl.carousel': $.proxy(function(e) {\\n\\t\\t\\t\\tif (e.namespace && this._core.is('resizing')) {\\n\\t\\t\\t\\t\\tthis._core.$stage.find('.cloned .owl-video-frame').remove();\\n\\t\\t\\t\\t}\\n\\t\\t\\t}, this),\\n\\t\\t\\t'changed.owl.carousel': $.proxy(function(e) {\\n\\t\\t\\t\\tif (e.namespace && e.property.name === 'position' && this._playing) {\\n\\t\\t\\t\\t\\tthis.stop();\\n\\t\\t\\t\\t}\\n\\t\\t\\t}, this),\\n\\t\\t\\t'prepared.owl.carousel': $.proxy(function(e) {\\n\\t\\t\\t\\tif (!e.namespace) {\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tvar $element = $(e.content).find('.owl-video');\\n\\n\\t\\t\\t\\tif ($element.length) {\\n\\t\\t\\t\\t\\t$element.css('display', 'none');\\n\\t\\t\\t\\t\\tthis.fetch($element, $(e.content));\\n\\t\\t\\t\\t}\\n\\t\\t\\t}, this)\\n\\t\\t};\\n\\n\\t\\t// set default options\\n\\t\\tthis._core.options = $.extend({}, Video.Defaults, this._core.options);\\n\\n\\t\\t// register event handlers\\n\\t\\tthis._core.$element.on(this._handlers);\\n\\n\\t\\tthis._core.$element.on('click.owl.video', '.owl-video-play-icon', $.proxy(function(e) {\\n\\t\\t\\tthis.play(e);\\n\\t\\t}, this));\\n\\t};\\n\\n\\t/**\\n\\t * Default options.\\n\\t * @public\\n\\t */\\n\\tVideo.Defaults = {\\n\\t\\tvideo: false,\\n\\t\\tvideoHeight: false,\\n\\t\\tvideoWidth: false\\n\\t};\\n\\n\\t/**\\n\\t * Gets the video ID and the type (YouTube/Vimeo/vzaar only).\\n\\t * @protected\\n\\t * @param {jQuery} target - The target containing the video data.\\n\\t * @param {jQuery} item - The item containing the video.\\n\\t */\\n\\tVideo.prototype.fetch = function(target, item) {\\n\\t\\t\\tvar type = (function() {\\n\\t\\t\\t\\t\\tif (target.attr('data-vimeo-id')) {\\n\\t\\t\\t\\t\\t\\treturn 'vimeo';\\n\\t\\t\\t\\t\\t} else if (target.attr('data-vzaar-id')) {\\n\\t\\t\\t\\t\\t\\treturn 'vzaar'\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\treturn 'youtube';\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t})(),\\n\\t\\t\\t\\tid = target.attr('data-vimeo-id') || target.attr('data-youtube-id') || target.attr('data-vzaar-id'),\\n\\t\\t\\t\\twidth = target.attr('data-width') || this._core.settings.videoWidth,\\n\\t\\t\\t\\theight = target.attr('data-height') || this._core.settings.videoHeight,\\n\\t\\t\\t\\turl = target.attr('href');\\n\\n\\t\\tif (url) {\\n\\n\\t\\t\\t/*\\n\\t\\t\\t\\t\\tParses the id's out of the following urls (and probably more):\\n\\t\\t\\t\\t\\thttps://www.youtube.com/watch?v=:id\\n\\t\\t\\t\\t\\thttps://youtu.be/:id\\n\\t\\t\\t\\t\\thttps://vimeo.com/:id\\n\\t\\t\\t\\t\\thttps://vimeo.com/channels/:channel/:id\\n\\t\\t\\t\\t\\thttps://vimeo.com/groups/:group/videos/:id\\n\\t\\t\\t\\t\\thttps://app.vzaar.com/videos/:id\\n\\n\\t\\t\\t\\t\\tVisual example: https://regexper.com/#(http%3A%7Chttps%3A%7C)%5C%2F%5C%2F(player.%7Cwww.%7Capp.)%3F(vimeo%5C.com%7Cyoutu(be%5C.com%7C%5C.be%7Cbe%5C.googleapis%5C.com)%7Cvzaar%5C.com)%5C%2F(video%5C%2F%7Cvideos%5C%2F%7Cembed%5C%2F%7Cchannels%5C%2F.%2B%5C%2F%7Cgroups%5C%2F.%2B%5C%2F%7Cwatch%5C%3Fv%3D%7Cv%5C%2F)%3F(%5BA-Za-z0-9._%25-%5D*)(%5C%26%5CS%2B)%3F\\n\\t\\t\\t*/\\n\\n\\t\\t\\tid = url.match(/(http:|https:|)\\\\/\\\\/(player.|www.|app.)?(vimeo\\\\.com|youtu(be\\\\.com|\\\\.be|be\\\\.googleapis\\\\.com)|vzaar\\\\.com)\\\\/(video\\\\/|videos\\\\/|embed\\\\/|channels\\\\/.+\\\\/|groups\\\\/.+\\\\/|watch\\\\?v=|v\\\\/)?([A-Za-z0-9._%-]*)(\\\\&\\\\S+)?/);\\n\\n\\t\\t\\tif (id[3].indexOf('youtu') > -1) {\\n\\t\\t\\t\\ttype = 'youtube';\\n\\t\\t\\t} else if (id[3].indexOf('vimeo') > -1) {\\n\\t\\t\\t\\ttype = 'vimeo';\\n\\t\\t\\t} else if (id[3].indexOf('vzaar') > -1) {\\n\\t\\t\\t\\ttype = 'vzaar';\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tthrow new Error('Video URL not supported.');\\n\\t\\t\\t}\\n\\t\\t\\tid = id[6];\\n\\t\\t} else {\\n\\t\\t\\tthrow new Error('Missing video URL.');\\n\\t\\t}\\n\\n\\t\\tthis._videos[url] = {\\n\\t\\t\\ttype: type,\\n\\t\\t\\tid: id,\\n\\t\\t\\twidth: width,\\n\\t\\t\\theight: height\\n\\t\\t};\\n\\n\\t\\titem.attr('data-video', url);\\n\\n\\t\\tthis.thumbnail(target, this._videos[url]);\\n\\t};\\n\\n\\t/**\\n\\t * Creates video thumbnail.\\n\\t * @protected\\n\\t * @param {jQuery} target - The target containing the video data.\\n\\t * @param {Object} info - The video info object.\\n\\t * @see `fetch`\\n\\t */\\n\\tVideo.prototype.thumbnail = function(target, video) {\\n\\t\\tvar tnLink,\\n\\t\\t\\ticon,\\n\\t\\t\\tpath,\\n\\t\\t\\tdimensions = video.width && video.height ? 'style=\\\"width:' + video.width + 'px;height:' + video.height + 'px;\\\"' : '',\\n\\t\\t\\tcustomTn = target.find('img'),\\n\\t\\t\\tsrcType = 'src',\\n\\t\\t\\tlazyClass = '',\\n\\t\\t\\tsettings = this._core.settings,\\n\\t\\t\\tcreate = function(path) {\\n\\t\\t\\t\\ticon = '<div class=\\\"owl-video-play-icon\\\"></div>';\\n\\n\\t\\t\\t\\tif (settings.lazyLoad) {\\n\\t\\t\\t\\t\\ttnLink = '<div class=\\\"owl-video-tn ' + lazyClass + '\\\" ' + srcType + '=\\\"' + path + '\\\"></div>';\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\ttnLink = '<div class=\\\"owl-video-tn\\\" style=\\\"opacity:1;background-image:url(' + path + ')\\\"></div>';\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\ttarget.after(tnLink);\\n\\t\\t\\t\\ttarget.after(icon);\\n\\t\\t\\t};\\n\\n\\t\\t// wrap video content into owl-video-wrapper div\\n\\t\\ttarget.wrap('<div class=\\\"owl-video-wrapper\\\"' + dimensions + '></div>');\\n\\n\\t\\tif (this._core.settings.lazyLoad) {\\n\\t\\t\\tsrcType = 'data-src';\\n\\t\\t\\tlazyClass = 'owl-lazy';\\n\\t\\t}\\n\\n\\t\\t// custom thumbnail\\n\\t\\tif (customTn.length) {\\n\\t\\t\\tcreate(customTn.attr(srcType));\\n\\t\\t\\tcustomTn.remove();\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\tif (video.type === 'youtube') {\\n\\t\\t\\tpath = \\\"//img.youtube.com/vi/\\\" + video.id + \\\"/hqdefault.jpg\\\";\\n\\t\\t\\tcreate(path);\\n\\t\\t} else if (video.type === 'vimeo') {\\n\\t\\t\\t$.ajax({\\n\\t\\t\\t\\ttype: 'GET',\\n\\t\\t\\t\\turl: '//vimeo.com/api/v2/video/' + video.id + '.json',\\n\\t\\t\\t\\tjsonp: 'callback',\\n\\t\\t\\t\\tdataType: 'jsonp',\\n\\t\\t\\t\\tsuccess: function(data) {\\n\\t\\t\\t\\t\\tpath = data[0].thumbnail_large;\\n\\t\\t\\t\\t\\tcreate(path);\\n\\t\\t\\t\\t}\\n\\t\\t\\t});\\n\\t\\t} else if (video.type === 'vzaar') {\\n\\t\\t\\t$.ajax({\\n\\t\\t\\t\\ttype: 'GET',\\n\\t\\t\\t\\turl: '//vzaar.com/api/videos/' + video.id + '.json',\\n\\t\\t\\t\\tjsonp: 'callback',\\n\\t\\t\\t\\tdataType: 'jsonp',\\n\\t\\t\\t\\tsuccess: function(data) {\\n\\t\\t\\t\\t\\tpath = data.framegrab_url;\\n\\t\\t\\t\\t\\tcreate(path);\\n\\t\\t\\t\\t}\\n\\t\\t\\t});\\n\\t\\t}\\n\\t};\\n\\n\\t/**\\n\\t * Stops the current video.\\n\\t * @public\\n\\t */\\n\\tVideo.prototype.stop = function() {\\n\\t\\tthis._core.trigger('stop', null, 'video');\\n\\t\\tthis._playing.find('.owl-video-frame').remove();\\n\\t\\tthis._playing.removeClass('owl-video-playing');\\n\\t\\tthis._playing = null;\\n\\t\\tthis._core.leave('playing');\\n\\t\\tthis._core.trigger('stopped', null, 'video');\\n\\t};\\n\\n\\t/**\\n\\t * Starts the current video.\\n\\t * @public\\n\\t * @param {Event} event - The event arguments.\\n\\t */\\n\\tVideo.prototype.play = function(event) {\\n\\t\\tvar target = $(event.target),\\n\\t\\t\\titem = target.closest('.' + this._core.settings.itemClass),\\n\\t\\t\\tvideo = this._videos[item.attr('data-video')],\\n\\t\\t\\twidth = video.width || '100%',\\n\\t\\t\\theight = video.height || this._core.$stage.height(),\\n\\t\\t\\thtml;\\n\\n\\t\\tif (this._playing) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tthis._core.enter('playing');\\n\\t\\tthis._core.trigger('play', null, 'video');\\n\\n\\t\\titem = this._core.items(this._core.relative(item.index()));\\n\\n\\t\\tthis._core.reset(item.index());\\n\\n\\t\\tif (video.type === 'youtube') {\\n\\t\\t\\thtml = '<iframe width=\\\"' + width + '\\\" height=\\\"' + height + '\\\" src=\\\"//www.youtube.com/embed/' +\\n\\t\\t\\t\\tvideo.id + '?autoplay=1&v=' + video.id + '\\\" frameborder=\\\"0\\\" allowfullscreen></iframe>';\\n\\t\\t} else if (video.type === 'vimeo') {\\n\\t\\t\\thtml = '<iframe src=\\\"//player.vimeo.com/video/' + video.id +\\n\\t\\t\\t\\t'?autoplay=1\\\" width=\\\"' + width + '\\\" height=\\\"' + height +\\n\\t\\t\\t\\t'\\\" frameborder=\\\"0\\\" webkitallowfullscreen mozallowfullscreen allowfullscreen></iframe>';\\n\\t\\t} else if (video.type === 'vzaar') {\\n\\t\\t\\thtml = '<iframe frameborder=\\\"0\\\"' + 'height=\\\"' + height + '\\\"' + 'width=\\\"' + width +\\n\\t\\t\\t\\t'\\\" allowfullscreen mozallowfullscreen webkitAllowFullScreen ' +\\n\\t\\t\\t\\t'src=\\\"//view.vzaar.com/' + video.id + '/player?autoplay=true\\\"></iframe>';\\n\\t\\t}\\n\\n\\t\\t$('<div class=\\\"owl-video-frame\\\">' + html + '</div>').insertAfter(item.find('.owl-video'));\\n\\n\\t\\tthis._playing = item.addClass('owl-video-playing');\\n\\t};\\n\\n\\t/**\\n\\t * Checks whether an video is currently in full screen mode or not.\\n\\t * @todo Bad style because looks like a readonly method but changes members.\\n\\t * @protected\\n\\t * @returns {Boolean}\\n\\t */\\n\\tVideo.prototype.isInFullScreen = function() {\\n\\t\\tvar element = document.fullscreenElement || document.mozFullScreenElement ||\\n\\t\\t\\t\\tdocument.webkitFullscreenElement;\\n\\n\\t\\treturn element && $(element).parent().hasClass('owl-video-frame');\\n\\t};\\n\\n\\t/**\\n\\t * Destroys the plugin.\\n\\t */\\n\\tVideo.prototype.destroy = function() {\\n\\t\\tvar handler, property;\\n\\n\\t\\tthis._core.$element.off('click.owl.video');\\n\\n\\t\\tfor (handler in this._handlers) {\\n\\t\\t\\tthis._core.$element.off(handler, this._handlers[handler]);\\n\\t\\t}\\n\\t\\tfor (property in Object.getOwnPropertyNames(this)) {\\n\\t\\t\\ttypeof this[property] != 'function' && (this[property] = null);\\n\\t\\t}\\n\\t};\\n\\n\\t$.fn.owlCarousel.Constructor.Plugins.Video = Video;\\n\\n})(window.Zepto || __webpack_provided_window_dot_jQuery, window, document);\\n\\n/**\\n * Animate Plugin\\n * @version 2.1.0\\n * @author Bartosz Wojciechowski\\n * @author David Deutsch\\n * @license The MIT License (MIT)\\n */\\n;(function($, window, document, undefined) {\\n\\n\\t/**\\n\\t * Creates the animate plugin.\\n\\t * @class The Navigation Plugin\\n\\t * @param {Owl} scope - The Owl Carousel\\n\\t */\\n\\tvar Animate = function(scope) {\\n\\t\\tthis.core = scope;\\n\\t\\tthis.core.options = $.extend({}, Animate.Defaults, this.core.options);\\n\\t\\tthis.swapping = true;\\n\\t\\tthis.previous = undefined;\\n\\t\\tthis.next = undefined;\\n\\n\\t\\tthis.handlers = {\\n\\t\\t\\t'change.owl.carousel': $.proxy(function(e) {\\n\\t\\t\\t\\tif (e.namespace && e.property.name == 'position') {\\n\\t\\t\\t\\t\\tthis.previous = this.core.current();\\n\\t\\t\\t\\t\\tthis.next = e.property.value;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}, this),\\n\\t\\t\\t'drag.owl.carousel dragged.owl.carousel translated.owl.carousel': $.proxy(function(e) {\\n\\t\\t\\t\\tif (e.namespace) {\\n\\t\\t\\t\\t\\tthis.swapping = e.type == 'translated';\\n\\t\\t\\t\\t}\\n\\t\\t\\t}, this),\\n\\t\\t\\t'translate.owl.carousel': $.proxy(function(e) {\\n\\t\\t\\t\\tif (e.namespace && this.swapping && (this.core.options.animateOut || this.core.options.animateIn)) {\\n\\t\\t\\t\\t\\tthis.swap();\\n\\t\\t\\t\\t}\\n\\t\\t\\t}, this)\\n\\t\\t};\\n\\n\\t\\tthis.core.$element.on(this.handlers);\\n\\t};\\n\\n\\t/**\\n\\t * Default options.\\n\\t * @public\\n\\t */\\n\\tAnimate.Defaults = {\\n\\t\\tanimateOut: false,\\n\\t\\tanimateIn: false\\n\\t};\\n\\n\\t/**\\n\\t * Toggles the animation classes whenever an translations starts.\\n\\t * @protected\\n\\t * @returns {Boolean|undefined}\\n\\t */\\n\\tAnimate.prototype.swap = function() {\\n\\n\\t\\tif (this.core.settings.items !== 1) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tif (!$.support.animation || !$.support.transition) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tthis.core.speed(0);\\n\\n\\t\\tvar left,\\n\\t\\t\\tclear = $.proxy(this.clear, this),\\n\\t\\t\\tprevious = this.core.$stage.children().eq(this.previous),\\n\\t\\t\\tnext = this.core.$stage.children().eq(this.next),\\n\\t\\t\\tincoming = this.core.settings.animateIn,\\n\\t\\t\\toutgoing = this.core.settings.animateOut;\\n\\n\\t\\tif (this.core.current() === this.previous) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tif (outgoing) {\\n\\t\\t\\tleft = this.core.coordinates(this.previous) - this.core.coordinates(this.next);\\n\\t\\t\\tprevious.one($.support.animation.end, clear)\\n\\t\\t\\t\\t.css( { 'left': left + 'px' } )\\n\\t\\t\\t\\t.addClass('animated owl-animated-out')\\n\\t\\t\\t\\t.addClass(outgoing);\\n\\t\\t}\\n\\n\\t\\tif (incoming) {\\n\\t\\t\\tnext.one($.support.animation.end, clear)\\n\\t\\t\\t\\t.addClass('animated owl-animated-in')\\n\\t\\t\\t\\t.addClass(incoming);\\n\\t\\t}\\n\\t};\\n\\n\\tAnimate.prototype.clear = function(e) {\\n\\t\\t$(e.target).css( { 'left': '' } )\\n\\t\\t\\t.removeClass('animated owl-animated-out owl-animated-in')\\n\\t\\t\\t.removeClass(this.core.settings.animateIn)\\n\\t\\t\\t.removeClass(this.core.settings.animateOut);\\n\\t\\tthis.core.onTransitionEnd();\\n\\t};\\n\\n\\t/**\\n\\t * Destroys the plugin.\\n\\t * @public\\n\\t */\\n\\tAnimate.prototype.destroy = function() {\\n\\t\\tvar handler, property;\\n\\n\\t\\tfor (handler in this.handlers) {\\n\\t\\t\\tthis.core.$element.off(handler, this.handlers[handler]);\\n\\t\\t}\\n\\t\\tfor (property in Object.getOwnPropertyNames(this)) {\\n\\t\\t\\ttypeof this[property] != 'function' && (this[property] = null);\\n\\t\\t}\\n\\t};\\n\\n\\t$.fn.owlCarousel.Constructor.Plugins.Animate = Animate;\\n\\n})(window.Zepto || __webpack_provided_window_dot_jQuery, window, document);\\n\\n/**\\n * Autoplay Plugin\\n * @version 2.1.0\\n * @author Bartosz Wojciechowski\\n * @author Artus Kolanowski\\n * @author David Deutsch\\n * @license The MIT License (MIT)\\n */\\n;(function($, window, document, undefined) {\\n\\n\\t/**\\n\\t * Creates the autoplay plugin.\\n\\t * @class The Autoplay Plugin\\n\\t * @param {Owl} scope - The Owl Carousel\\n\\t */\\n\\tvar Autoplay = function(carousel) {\\n\\t\\t/**\\n\\t\\t * Reference to the core.\\n\\t\\t * @protected\\n\\t\\t * @type {Owl}\\n\\t\\t */\\n\\t\\tthis._core = carousel;\\n\\n\\t\\t/**\\n\\t\\t * The autoplay timeout.\\n\\t\\t * @type {Timeout}\\n\\t\\t */\\n\\t\\tthis._timeout = null;\\n\\n\\t\\t/**\\n\\t\\t * Indicates whenever the autoplay is paused.\\n\\t\\t * @type {Boolean}\\n\\t\\t */\\n\\t\\tthis._paused = false;\\n\\n\\t\\t/**\\n\\t\\t * All event handlers.\\n\\t\\t * @protected\\n\\t\\t * @type {Object}\\n\\t\\t */\\n\\t\\tthis._handlers = {\\n\\t\\t\\t'changed.owl.carousel': $.proxy(function(e) {\\n\\t\\t\\t\\tif (e.namespace && e.property.name === 'settings') {\\n\\t\\t\\t\\t\\tif (this._core.settings.autoplay) {\\n\\t\\t\\t\\t\\t\\tthis.play();\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tthis.stop();\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t} else if (e.namespace && e.property.name === 'position') {\\n\\t\\t\\t\\t\\t//console.log('play?', e);\\n\\t\\t\\t\\t\\tif (this._core.settings.autoplay) {\\n\\t\\t\\t\\t\\t\\tthis._setAutoPlayInterval();\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}, this),\\n\\t\\t\\t'initialized.owl.carousel': $.proxy(function(e) {\\n\\t\\t\\t\\tif (e.namespace && this._core.settings.autoplay) {\\n\\t\\t\\t\\t\\tthis.play();\\n\\t\\t\\t\\t}\\n\\t\\t\\t}, this),\\n\\t\\t\\t'play.owl.autoplay': $.proxy(function(e, t, s) {\\n\\t\\t\\t\\tif (e.namespace) {\\n\\t\\t\\t\\t\\tthis.play(t, s);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}, this),\\n\\t\\t\\t'stop.owl.autoplay': $.proxy(function(e) {\\n\\t\\t\\t\\tif (e.namespace) {\\n\\t\\t\\t\\t\\tthis.stop();\\n\\t\\t\\t\\t}\\n\\t\\t\\t}, this),\\n\\t\\t\\t'mouseover.owl.autoplay': $.proxy(function() {\\n\\t\\t\\t\\tif (this._core.settings.autoplayHoverPause && this._core.is('rotating')) {\\n\\t\\t\\t\\t\\tthis.pause();\\n\\t\\t\\t\\t}\\n\\t\\t\\t}, this),\\n\\t\\t\\t'mouseleave.owl.autoplay': $.proxy(function() {\\n\\t\\t\\t\\tif (this._core.settings.autoplayHoverPause && this._core.is('rotating')) {\\n\\t\\t\\t\\t\\tthis.play();\\n\\t\\t\\t\\t}\\n\\t\\t\\t}, this),\\n\\t\\t\\t'touchstart.owl.core': $.proxy(function() {\\n\\t\\t\\t\\tif (this._core.settings.autoplayHoverPause && this._core.is('rotating')) {\\n\\t\\t\\t\\t\\tthis.pause();\\n\\t\\t\\t\\t}\\n\\t\\t\\t}, this),\\n\\t\\t\\t'touchend.owl.core': $.proxy(function() {\\n\\t\\t\\t\\tif (this._core.settings.autoplayHoverPause) {\\n\\t\\t\\t\\t\\tthis.play();\\n\\t\\t\\t\\t}\\n\\t\\t\\t}, this)\\n\\t\\t};\\n\\n\\t\\t// register event handlers\\n\\t\\tthis._core.$element.on(this._handlers);\\n\\n\\t\\t// set default options\\n\\t\\tthis._core.options = $.extend({}, Autoplay.Defaults, this._core.options);\\n\\t};\\n\\n\\t/**\\n\\t * Default options.\\n\\t * @public\\n\\t */\\n\\tAutoplay.Defaults = {\\n\\t\\tautoplay: false,\\n\\t\\tautoplayTimeout: 5000,\\n\\t\\tautoplayHoverPause: false,\\n\\t\\tautoplaySpeed: false\\n\\t};\\n\\n\\t/**\\n\\t * Starts the autoplay.\\n\\t * @public\\n\\t * @param {Number} [timeout] - The interval before the next animation starts.\\n\\t * @param {Number} [speed] - The animation speed for the animations.\\n\\t */\\n\\tAutoplay.prototype.play = function(timeout, speed) {\\n\\t\\tthis._paused = false;\\n\\n\\t\\tif (this._core.is('rotating')) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tthis._core.enter('rotating');\\n\\n\\t\\tthis._setAutoPlayInterval();\\n\\t};\\n\\n\\t/**\\n\\t * Gets a new timeout\\n\\t * @private\\n\\t * @param {Number} [timeout] - The interval before the next animation starts.\\n\\t * @param {Number} [speed] - The animation speed for the animations.\\n\\t * @return {Timeout}\\n\\t */\\n\\tAutoplay.prototype._getNextTimeout = function(timeout, speed) {\\n\\t\\tif ( this._timeout ) {\\n\\t\\t\\twindow.clearTimeout(this._timeout);\\n\\t\\t}\\n\\t\\treturn window.setTimeout($.proxy(function() {\\n\\t\\t\\tif (this._paused || this._core.is('busy') || this._core.is('interacting') || document.hidden) {\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tthis._core.next(speed || this._core.settings.autoplaySpeed);\\n\\t\\t}, this), timeout || this._core.settings.autoplayTimeout);\\n\\t};\\n\\n\\t/**\\n\\t * Sets autoplay in motion.\\n\\t * @private\\n\\t */\\n\\tAutoplay.prototype._setAutoPlayInterval = function() {\\n\\t\\tthis._timeout = this._getNextTimeout();\\n\\t};\\n\\n\\t/**\\n\\t * Stops the autoplay.\\n\\t * @public\\n\\t */\\n\\tAutoplay.prototype.stop = function() {\\n\\t\\tif (!this._core.is('rotating')) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\twindow.clearTimeout(this._timeout);\\n\\t\\tthis._core.leave('rotating');\\n\\t};\\n\\n\\t/**\\n\\t * Stops the autoplay.\\n\\t * @public\\n\\t */\\n\\tAutoplay.prototype.pause = function() {\\n\\t\\tif (!this._core.is('rotating')) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tthis._paused = true;\\n\\t};\\n\\n\\t/**\\n\\t * Destroys the plugin.\\n\\t */\\n\\tAutoplay.prototype.destroy = function() {\\n\\t\\tvar handler, property;\\n\\n\\t\\tthis.stop();\\n\\n\\t\\tfor (handler in this._handlers) {\\n\\t\\t\\tthis._core.$element.off(handler, this._handlers[handler]);\\n\\t\\t}\\n\\t\\tfor (property in Object.getOwnPropertyNames(this)) {\\n\\t\\t\\ttypeof this[property] != 'function' && (this[property] = null);\\n\\t\\t}\\n\\t};\\n\\n\\t$.fn.owlCarousel.Constructor.Plugins.autoplay = Autoplay;\\n\\n})(window.Zepto || __webpack_provided_window_dot_jQuery, window, document);\\n\\n/**\\n * Navigation Plugin\\n * @version 2.1.0\\n * @author Artus Kolanowski\\n * @author David Deutsch\\n * @license The MIT License (MIT)\\n */\\n;(function($, window, document, undefined) {\\n\\t'use strict';\\n\\n\\t/**\\n\\t * Creates the navigation plugin.\\n\\t * @class The Navigation Plugin\\n\\t * @param {Owl} carousel - The Owl Carousel.\\n\\t */\\n\\tvar Navigation = function(carousel) {\\n\\t\\t/**\\n\\t\\t * Reference to the core.\\n\\t\\t * @protected\\n\\t\\t * @type {Owl}\\n\\t\\t */\\n\\t\\tthis._core = carousel;\\n\\n\\t\\t/**\\n\\t\\t * Indicates whether the plugin is initialized or not.\\n\\t\\t * @protected\\n\\t\\t * @type {Boolean}\\n\\t\\t */\\n\\t\\tthis._initialized = false;\\n\\n\\t\\t/**\\n\\t\\t * The current paging indexes.\\n\\t\\t * @protected\\n\\t\\t * @type {Array}\\n\\t\\t */\\n\\t\\tthis._pages = [];\\n\\n\\t\\t/**\\n\\t\\t * All DOM elements of the user interface.\\n\\t\\t * @protected\\n\\t\\t * @type {Object}\\n\\t\\t */\\n\\t\\tthis._controls = {};\\n\\n\\t\\t/**\\n\\t\\t * Markup for an indicator.\\n\\t\\t * @protected\\n\\t\\t * @type {Array.<String>}\\n\\t\\t */\\n\\t\\tthis._templates = [];\\n\\n\\t\\t/**\\n\\t\\t * The carousel element.\\n\\t\\t * @type {jQuery}\\n\\t\\t */\\n\\t\\tthis.$element = this._core.$element;\\n\\n\\t\\t/**\\n\\t\\t * Overridden methods of the carousel.\\n\\t\\t * @protected\\n\\t\\t * @type {Object}\\n\\t\\t */\\n\\t\\tthis._overrides = {\\n\\t\\t\\tnext: this._core.next,\\n\\t\\t\\tprev: this._core.prev,\\n\\t\\t\\tto: this._core.to\\n\\t\\t};\\n\\n\\t\\t/**\\n\\t\\t * All event handlers.\\n\\t\\t * @protected\\n\\t\\t * @type {Object}\\n\\t\\t */\\n\\t\\tthis._handlers = {\\n\\t\\t\\t'prepared.owl.carousel': $.proxy(function(e) {\\n\\t\\t\\t\\tif (e.namespace && this._core.settings.dotsData) {\\n\\t\\t\\t\\t\\tthis._templates.push('<div class=\\\"' + this._core.settings.dotClass + '\\\">' +\\n\\t\\t\\t\\t\\t\\t$(e.content).find('[data-dot]').addBack('[data-dot]').attr('data-dot') + '</div>');\\n\\t\\t\\t\\t}\\n\\t\\t\\t}, this),\\n\\t\\t\\t'added.owl.carousel': $.proxy(function(e) {\\n\\t\\t\\t\\tif (e.namespace && this._core.settings.dotsData) {\\n\\t\\t\\t\\t\\tthis._templates.splice(e.position, 0, this._templates.pop());\\n\\t\\t\\t\\t}\\n\\t\\t\\t}, this),\\n\\t\\t\\t'remove.owl.carousel': $.proxy(function(e) {\\n\\t\\t\\t\\tif (e.namespace && this._core.settings.dotsData) {\\n\\t\\t\\t\\t\\tthis._templates.splice(e.position, 1);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}, this),\\n\\t\\t\\t'changed.owl.carousel': $.proxy(function(e) {\\n\\t\\t\\t\\tif (e.namespace && e.property.name == 'position') {\\n\\t\\t\\t\\t\\tthis.draw();\\n\\t\\t\\t\\t}\\n\\t\\t\\t}, this),\\n\\t\\t\\t'initialized.owl.carousel': $.proxy(function(e) {\\n\\t\\t\\t\\tif (e.namespace && !this._initialized) {\\n\\t\\t\\t\\t\\tthis._core.trigger('initialize', null, 'navigation');\\n\\t\\t\\t\\t\\tthis.initialize();\\n\\t\\t\\t\\t\\tthis.update();\\n\\t\\t\\t\\t\\tthis.draw();\\n\\t\\t\\t\\t\\tthis._initialized = true;\\n\\t\\t\\t\\t\\tthis._core.trigger('initialized', null, 'navigation');\\n\\t\\t\\t\\t}\\n\\t\\t\\t}, this),\\n\\t\\t\\t'refreshed.owl.carousel': $.proxy(function(e) {\\n\\t\\t\\t\\tif (e.namespace && this._initialized) {\\n\\t\\t\\t\\t\\tthis._core.trigger('refresh', null, 'navigation');\\n\\t\\t\\t\\t\\tthis.update();\\n\\t\\t\\t\\t\\tthis.draw();\\n\\t\\t\\t\\t\\tthis._core.trigger('refreshed', null, 'navigation');\\n\\t\\t\\t\\t}\\n\\t\\t\\t}, this)\\n\\t\\t};\\n\\n\\t\\t// set default options\\n\\t\\tthis._core.options = $.extend({}, Navigation.Defaults, this._core.options);\\n\\n\\t\\t// register event handlers\\n\\t\\tthis.$element.on(this._handlers);\\n\\t};\\n\\n\\t/**\\n\\t * Default options.\\n\\t * @public\\n\\t * @todo Rename `slideBy` to `navBy`\\n\\t */\\n\\tNavigation.Defaults = {\\n\\t\\tnav: false,\\n\\t\\tnavText: [ 'prev', 'next' ],\\n\\t\\tnavSpeed: false,\\n\\t\\tnavElement: 'div',\\n\\t\\tnavContainer: false,\\n\\t\\tnavContainerClass: 'owl-nav',\\n\\t\\tnavClass: [ 'owl-prev', 'owl-next' ],\\n\\t\\tslideBy: 1,\\n\\t\\tdotClass: 'owl-dot',\\n\\t\\tdotsClass: 'owl-dots',\\n\\t\\tdots: true,\\n\\t\\tdotsEach: false,\\n\\t\\tdotsData: false,\\n\\t\\tdotsSpeed: false,\\n\\t\\tdotsContainer: false\\n\\t};\\n\\n\\t/**\\n\\t * Initializes the layout of the plugin and extends the carousel.\\n\\t * @protected\\n\\t */\\n\\tNavigation.prototype.initialize = function() {\\n\\t\\tvar override,\\n\\t\\t\\tsettings = this._core.settings;\\n\\n\\t\\t// create DOM structure for relative navigation\\n\\t\\tthis._controls.$relative = (settings.navContainer ? $(settings.navContainer)\\n\\t\\t\\t: $('<div>').addClass(settings.navContainerClass).appendTo(this.$element)).addClass('disabled');\\n\\n\\t\\tthis._controls.$previous = $('<' + settings.navElement + '>')\\n\\t\\t\\t.addClass(settings.navClass[0])\\n\\t\\t\\t.html(settings.navText[0])\\n\\t\\t\\t.prependTo(this._controls.$relative)\\n\\t\\t\\t.on('click', $.proxy(function(e) {\\n\\t\\t\\t\\tthis.prev(settings.navSpeed);\\n\\t\\t\\t}, this));\\n\\t\\tthis._controls.$next = $('<' + settings.navElement + '>')\\n\\t\\t\\t.addClass(settings.navClass[1])\\n\\t\\t\\t.html(settings.navText[1])\\n\\t\\t\\t.appendTo(this._controls.$relative)\\n\\t\\t\\t.on('click', $.proxy(function(e) {\\n\\t\\t\\t\\tthis.next(settings.navSpeed);\\n\\t\\t\\t}, this));\\n\\n\\t\\t// create DOM structure for absolute navigation\\n\\t\\tif (!settings.dotsData) {\\n\\t\\t\\tthis._templates = [ $('<div>')\\n\\t\\t\\t\\t.addClass(settings.dotClass)\\n\\t\\t\\t\\t.append($('<span>'))\\n\\t\\t\\t\\t.prop('outerHTML') ];\\n\\t\\t}\\n\\n\\t\\tthis._controls.$absolute = (settings.dotsContainer ? $(settings.dotsContainer)\\n\\t\\t\\t: $('<div>').addClass(settings.dotsClass).appendTo(this.$element)).addClass('disabled');\\n\\n\\t\\tthis._controls.$absolute.on('click', 'div', $.proxy(function(e) {\\n\\t\\t\\tvar index = $(e.target).parent().is(this._controls.$absolute)\\n\\t\\t\\t\\t? $(e.target).index() : $(e.target).parent().index();\\n\\n\\t\\t\\te.preventDefault();\\n\\n\\t\\t\\tthis.to(index, settings.dotsSpeed);\\n\\t\\t}, this));\\n\\n\\t\\t// override public methods of the carousel\\n\\t\\tfor (override in this._overrides) {\\n\\t\\t\\tthis._core[override] = $.proxy(this[override], this);\\n\\t\\t}\\n\\t};\\n\\n\\t/**\\n\\t * Destroys the plugin.\\n\\t * @protected\\n\\t */\\n\\tNavigation.prototype.destroy = function() {\\n\\t\\tvar handler, control, property, override;\\n\\n\\t\\tfor (handler in this._handlers) {\\n\\t\\t\\tthis.$element.off(handler, this._handlers[handler]);\\n\\t\\t}\\n\\t\\tfor (control in this._controls) {\\n\\t\\t\\tthis._controls[control].remove();\\n\\t\\t}\\n\\t\\tfor (override in this.overides) {\\n\\t\\t\\tthis._core[override] = this._overrides[override];\\n\\t\\t}\\n\\t\\tfor (property in Object.getOwnPropertyNames(this)) {\\n\\t\\t\\ttypeof this[property] != 'function' && (this[property] = null);\\n\\t\\t}\\n\\t};\\n\\n\\t/**\\n\\t * Updates the internal state.\\n\\t * @protected\\n\\t */\\n\\tNavigation.prototype.update = function() {\\n\\t\\tvar i, j, k,\\n\\t\\t\\tlower = this._core.clones().length / 2,\\n\\t\\t\\tupper = lower + this._core.items().length,\\n\\t\\t\\tmaximum = this._core.maximum(true),\\n\\t\\t\\tsettings = this._core.settings,\\n\\t\\t\\tsize = settings.center || settings.autoWidth || settings.dotsData\\n\\t\\t\\t\\t? 1 : settings.dotsEach || settings.items;\\n\\n\\t\\tif (settings.slideBy !== 'page') {\\n\\t\\t\\tsettings.slideBy = Math.min(settings.slideBy, settings.items);\\n\\t\\t}\\n\\n\\t\\tif (settings.dots || settings.slideBy == 'page') {\\n\\t\\t\\tthis._pages = [];\\n\\n\\t\\t\\tfor (i = lower, j = 0, k = 0; i < upper; i++) {\\n\\t\\t\\t\\tif (j >= size || j === 0) {\\n\\t\\t\\t\\t\\tthis._pages.push({\\n\\t\\t\\t\\t\\t\\tstart: Math.min(maximum, i - lower),\\n\\t\\t\\t\\t\\t\\tend: i - lower + size - 1\\n\\t\\t\\t\\t\\t});\\n\\t\\t\\t\\t\\tif (Math.min(maximum, i - lower) === maximum) {\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tj = 0, ++k;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tj += this._core.mergers(this._core.relative(i));\\n\\t\\t\\t}\\n\\t\\t}\\n\\t};\\n\\n\\t/**\\n\\t * Draws the user interface.\\n\\t * @todo The option `dotsData` wont work.\\n\\t * @protected\\n\\t */\\n\\tNavigation.prototype.draw = function() {\\n\\t\\tvar difference,\\n\\t\\t\\tsettings = this._core.settings,\\n\\t\\t\\tdisabled = this._core.items().length <= settings.items,\\n\\t\\t\\tindex = this._core.relative(this._core.current()),\\n\\t\\t\\tloop = settings.loop || settings.rewind;\\n\\n\\t\\tthis._controls.$relative.toggleClass('disabled', !settings.nav || disabled);\\n\\n\\t\\tif (settings.nav) {\\n\\t\\t\\tthis._controls.$previous.toggleClass('disabled', !loop && index <= this._core.minimum(true));\\n\\t\\t\\tthis._controls.$next.toggleClass('disabled', !loop && index >= this._core.maximum(true));\\n\\t\\t}\\n\\n\\t\\tthis._controls.$absolute.toggleClass('disabled', !settings.dots || disabled);\\n\\n\\t\\tif (settings.dots) {\\n\\t\\t\\tdifference = this._pages.length - this._controls.$absolute.children().length;\\n\\n\\t\\t\\tif (settings.dotsData && difference !== 0) {\\n\\t\\t\\t\\tthis._controls.$absolute.html(this._templates.join(''));\\n\\t\\t\\t} else if (difference > 0) {\\n\\t\\t\\t\\tthis._controls.$absolute.append(new Array(difference + 1).join(this._templates[0]));\\n\\t\\t\\t} else if (difference < 0) {\\n\\t\\t\\t\\tthis._controls.$absolute.children().slice(difference).remove();\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis._controls.$absolute.find('.active').removeClass('active');\\n\\t\\t\\tthis._controls.$absolute.children().eq($.inArray(this.current(), this._pages)).addClass('active');\\n\\t\\t}\\n\\t};\\n\\n\\t/**\\n\\t * Extends event data.\\n\\t * @protected\\n\\t * @param {Event} event - The event object which gets thrown.\\n\\t */\\n\\tNavigation.prototype.onTrigger = function(event) {\\n\\t\\tvar settings = this._core.settings;\\n\\n\\t\\tevent.page = {\\n\\t\\t\\tindex: $.inArray(this.current(), this._pages),\\n\\t\\t\\tcount: this._pages.length,\\n\\t\\t\\tsize: settings && (settings.center || settings.autoWidth || settings.dotsData\\n\\t\\t\\t\\t? 1 : settings.dotsEach || settings.items)\\n\\t\\t};\\n\\t};\\n\\n\\t/**\\n\\t * Gets the current page position of the carousel.\\n\\t * @protected\\n\\t * @returns {Number}\\n\\t */\\n\\tNavigation.prototype.current = function() {\\n\\t\\tvar current = this._core.relative(this._core.current());\\n\\t\\treturn $.grep(this._pages, $.proxy(function(page, index) {\\n\\t\\t\\treturn page.start <= current && page.end >= current;\\n\\t\\t}, this)).pop();\\n\\t};\\n\\n\\t/**\\n\\t * Gets the current succesor/predecessor position.\\n\\t * @protected\\n\\t * @returns {Number}\\n\\t */\\n\\tNavigation.prototype.getPosition = function(successor) {\\n\\t\\tvar position, length,\\n\\t\\t\\tsettings = this._core.settings;\\n\\n\\t\\tif (settings.slideBy == 'page') {\\n\\t\\t\\tposition = $.inArray(this.current(), this._pages);\\n\\t\\t\\tlength = this._pages.length;\\n\\t\\t\\tsuccessor ? ++position : --position;\\n\\t\\t\\tposition = this._pages[((position % length) + length) % length].start;\\n\\t\\t} else {\\n\\t\\t\\tposition = this._core.relative(this._core.current());\\n\\t\\t\\tlength = this._core.items().length;\\n\\t\\t\\tsuccessor ? position += settings.slideBy : position -= settings.slideBy;\\n\\t\\t}\\n\\n\\t\\treturn position;\\n\\t};\\n\\n\\t/**\\n\\t * Slides to the next item or page.\\n\\t * @public\\n\\t * @param {Number} [speed=false] - The time in milliseconds for the transition.\\n\\t */\\n\\tNavigation.prototype.next = function(speed) {\\n\\t\\t$.proxy(this._overrides.to, this._core)(this.getPosition(true), speed);\\n\\t};\\n\\n\\t/**\\n\\t * Slides to the previous item or page.\\n\\t * @public\\n\\t * @param {Number} [speed=false] - The time in milliseconds for the transition.\\n\\t */\\n\\tNavigation.prototype.prev = function(speed) {\\n\\t\\t$.proxy(this._overrides.to, this._core)(this.getPosition(false), speed);\\n\\t};\\n\\n\\t/**\\n\\t * Slides to the specified item or page.\\n\\t * @public\\n\\t * @param {Number} position - The position of the item or page.\\n\\t * @param {Number} [speed] - The time in milliseconds for the transition.\\n\\t * @param {Boolean} [standard=false] - Whether to use the standard behaviour or not.\\n\\t */\\n\\tNavigation.prototype.to = function(position, speed, standard) {\\n\\t\\tvar length;\\n\\n\\t\\tif (!standard && this._pages.length) {\\n\\t\\t\\tlength = this._pages.length;\\n\\t\\t\\t$.proxy(this._overrides.to, this._core)(this._pages[((position % length) + length) % length].start, speed);\\n\\t\\t} else {\\n\\t\\t\\t$.proxy(this._overrides.to, this._core)(position, speed);\\n\\t\\t}\\n\\t};\\n\\n\\t$.fn.owlCarousel.Constructor.Plugins.Navigation = Navigation;\\n\\n})(window.Zepto || __webpack_provided_window_dot_jQuery, window, document);\\n\\n/**\\n * Hash Plugin\\n * @version 2.1.0\\n * @author Artus Kolanowski\\n * @author David Deutsch\\n * @license The MIT License (MIT)\\n */\\n;(function($, window, document, undefined) {\\n\\t'use strict';\\n\\n\\t/**\\n\\t * Creates the hash plugin.\\n\\t * @class The Hash Plugin\\n\\t * @param {Owl} carousel - The Owl Carousel\\n\\t */\\n\\tvar Hash = function(carousel) {\\n\\t\\t/**\\n\\t\\t * Reference to the core.\\n\\t\\t * @protected\\n\\t\\t * @type {Owl}\\n\\t\\t */\\n\\t\\tthis._core = carousel;\\n\\n\\t\\t/**\\n\\t\\t * Hash index for the items.\\n\\t\\t * @protected\\n\\t\\t * @type {Object}\\n\\t\\t */\\n\\t\\tthis._hashes = {};\\n\\n\\t\\t/**\\n\\t\\t * The carousel element.\\n\\t\\t * @type {jQuery}\\n\\t\\t */\\n\\t\\tthis.$element = this._core.$element;\\n\\n\\t\\t/**\\n\\t\\t * All event handlers.\\n\\t\\t * @protected\\n\\t\\t * @type {Object}\\n\\t\\t */\\n\\t\\tthis._handlers = {\\n\\t\\t\\t'initialized.owl.carousel': $.proxy(function(e) {\\n\\t\\t\\t\\tif (e.namespace && this._core.settings.startPosition === 'URLHash') {\\n\\t\\t\\t\\t\\t$(window).trigger('hashchange.owl.navigation');\\n\\t\\t\\t\\t}\\n\\t\\t\\t}, this),\\n\\t\\t\\t'prepared.owl.carousel': $.proxy(function(e) {\\n\\t\\t\\t\\tif (e.namespace) {\\n\\t\\t\\t\\t\\tvar hash = $(e.content).find('[data-hash]').addBack('[data-hash]').attr('data-hash');\\n\\n\\t\\t\\t\\t\\tif (!hash) {\\n\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tthis._hashes[hash] = e.content;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}, this),\\n\\t\\t\\t'changed.owl.carousel': $.proxy(function(e) {\\n\\t\\t\\t\\tif (e.namespace && e.property.name === 'position') {\\n\\t\\t\\t\\t\\tvar current = this._core.items(this._core.relative(this._core.current())),\\n\\t\\t\\t\\t\\t\\thash = $.map(this._hashes, function(item, hash) {\\n\\t\\t\\t\\t\\t\\t\\treturn item === current ? hash : null;\\n\\t\\t\\t\\t\\t\\t}).join();\\n\\n\\t\\t\\t\\t\\tif (!hash || window.location.hash.slice(1) === hash) {\\n\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\twindow.location.hash = hash;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}, this)\\n\\t\\t};\\n\\n\\t\\t// set default options\\n\\t\\tthis._core.options = $.extend({}, Hash.Defaults, this._core.options);\\n\\n\\t\\t// register the event handlers\\n\\t\\tthis.$element.on(this._handlers);\\n\\n\\t\\t// register event listener for hash navigation\\n\\t\\t$(window).on('hashchange.owl.navigation', $.proxy(function(e) {\\n\\t\\t\\tvar hash = window.location.hash.substring(1),\\n\\t\\t\\t\\titems = this._core.$stage.children(),\\n\\t\\t\\t\\tposition = this._hashes[hash] && items.index(this._hashes[hash]);\\n\\n\\t\\t\\tif (position === undefined || position === this._core.current()) {\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis._core.to(this._core.relative(position), false, true);\\n\\t\\t}, this));\\n\\t};\\n\\n\\t/**\\n\\t * Default options.\\n\\t * @public\\n\\t */\\n\\tHash.Defaults = {\\n\\t\\tURLhashListener: false\\n\\t};\\n\\n\\t/**\\n\\t * Destroys the plugin.\\n\\t * @public\\n\\t */\\n\\tHash.prototype.destroy = function() {\\n\\t\\tvar handler, property;\\n\\n\\t\\t$(window).off('hashchange.owl.navigation');\\n\\n\\t\\tfor (handler in this._handlers) {\\n\\t\\t\\tthis._core.$element.off(handler, this._handlers[handler]);\\n\\t\\t}\\n\\t\\tfor (property in Object.getOwnPropertyNames(this)) {\\n\\t\\t\\ttypeof this[property] != 'function' && (this[property] = null);\\n\\t\\t}\\n\\t};\\n\\n\\t$.fn.owlCarousel.Constructor.Plugins.Hash = Hash;\\n\\n})(window.Zepto || __webpack_provided_window_dot_jQuery, window, document);\\n\\n/**\\n * Support Plugin\\n *\\n * @version 2.1.0\\n * @author Vivid Planet Software GmbH\\n * @author Artus Kolanowski\\n * @author David Deutsch\\n * @license The MIT License (MIT)\\n */\\n;(function($, window, document, undefined) {\\n\\n\\tvar style = $('<support>').get(0).style,\\n\\t\\tprefixes = 'Webkit Moz O ms'.split(' '),\\n\\t\\tevents = {\\n\\t\\t\\ttransition: {\\n\\t\\t\\t\\tend: {\\n\\t\\t\\t\\t\\tWebkitTransition: 'webkitTransitionEnd',\\n\\t\\t\\t\\t\\tMozTransition: 'transitionend',\\n\\t\\t\\t\\t\\tOTransition: 'oTransitionEnd',\\n\\t\\t\\t\\t\\ttransition: 'transitionend'\\n\\t\\t\\t\\t}\\n\\t\\t\\t},\\n\\t\\t\\tanimation: {\\n\\t\\t\\t\\tend: {\\n\\t\\t\\t\\t\\tWebkitAnimation: 'webkitAnimationEnd',\\n\\t\\t\\t\\t\\tMozAnimation: 'animationend',\\n\\t\\t\\t\\t\\tOAnimation: 'oAnimationEnd',\\n\\t\\t\\t\\t\\tanimation: 'animationend'\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t},\\n\\t\\ttests = {\\n\\t\\t\\tcsstransforms: function() {\\n\\t\\t\\t\\treturn !!test('transform');\\n\\t\\t\\t},\\n\\t\\t\\tcsstransforms3d: function() {\\n\\t\\t\\t\\treturn !!test('perspective');\\n\\t\\t\\t},\\n\\t\\t\\tcsstransitions: function() {\\n\\t\\t\\t\\treturn !!test('transition');\\n\\t\\t\\t},\\n\\t\\t\\tcssanimations: function() {\\n\\t\\t\\t\\treturn !!test('animation');\\n\\t\\t\\t}\\n\\t\\t};\\n\\n\\tfunction test(property, prefixed) {\\n\\t\\tvar result = false,\\n\\t\\t\\tupper = property.charAt(0).toUpperCase() + property.slice(1);\\n\\n\\t\\t$.each((property + ' ' + prefixes.join(upper + ' ') + upper).split(' '), function(i, property) {\\n\\t\\t\\tif (style[property] !== undefined) {\\n\\t\\t\\t\\tresult = prefixed ? property : true;\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t});\\n\\n\\t\\treturn result;\\n\\t}\\n\\n\\tfunction prefixed(property) {\\n\\t\\treturn test(property, true);\\n\\t}\\n\\n\\tif (tests.csstransitions()) {\\n\\t\\t/* jshint -W053 */\\n\\t\\t$.support.transition = new String(prefixed('transition'))\\n\\t\\t$.support.transition.end = events.transition.end[ $.support.transition ];\\n\\t}\\n\\n\\tif (tests.cssanimations()) {\\n\\t\\t/* jshint -W053 */\\n\\t\\t$.support.animation = new String(prefixed('animation'))\\n\\t\\t$.support.animation.end = events.animation.end[ $.support.animation ];\\n\\t}\\n\\n\\tif (tests.csstransforms()) {\\n\\t\\t/* jshint -W053 */\\n\\t\\t$.support.transform = new String(prefixed('transform'));\\n\\t\\t$.support.transform3d = tests.csstransforms3d();\\n\\t}\\n\\n})(window.Zepto || __webpack_provided_window_dot_jQuery, window, document);\\n\\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1), __webpack_require__(1)))\\n\\n//////////////////\\n// WEBPACK FOOTER\\n// ./~/owl.carousel/dist/owl.carousel.js\\n// module id = 8\\n// module chunks = 0\\n\\n//# sourceURL=webpack:///./~/owl.carousel/dist/owl.carousel.js?\");\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports, __webpack_require__) {\n\neval(\"/* WEBPACK VAR INJECTION */(function(process) {/**\\n * Copyright (c) 2013-present, Facebook, Inc.\\n *\\n * This source code is licensed under the MIT license found in the\\n * LICENSE file in the root directory of this source tree.\\n */\\n\\nif (process.env.NODE_ENV !== 'production') {\\n  var REACT_ELEMENT_TYPE = (typeof Symbol === 'function' &&\\n    Symbol.for &&\\n    Symbol.for('react.element')) ||\\n    0xeac7;\\n\\n  var isValidElement = function(object) {\\n    return typeof object === 'object' &&\\n      object !== null &&\\n      object.$$typeof === REACT_ELEMENT_TYPE;\\n  };\\n\\n  // By explicitly using `prop-types` you are opting into new development behavior.\\n  // http://fb.me/prop-types-in-prod\\n  var throwOnDirectAccess = true;\\n  module.exports = __webpack_require__(21)(isValidElement, throwOnDirectAccess);\\n} else {\\n  // By explicitly using `prop-types` you are opting into new production behavior.\\n  // http://fb.me/prop-types-in-prod\\n  module.exports = __webpack_require__(20)();\\n}\\n\\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))\\n\\n//////////////////\\n// WEBPACK FOOTER\\n// ./~/prop-types/index.js\\n// module id = 9\\n// module chunks = 0\\n\\n//# sourceURL=webpack:///./~/prop-types/index.js?\");\n\n/***/ }),\n/* 10 */\n/***/ (function(module, exports, __webpack_require__) {\n\neval(\"// style-loader: Adds some css to the DOM by adding a <style> tag\\n\\n// load the styles\\nvar content = __webpack_require__(14);\\nif(typeof content === 'string') content = [[module.i, content, '']];\\n// Prepare cssTransformation\\nvar transform;\\n\\nvar options = {}\\noptions.transform = transform\\n// add the styles to the DOM\\nvar update = __webpack_require__(7)(content, options);\\nif(content.locals) module.exports = content.locals;\\n// Hot Module Replacement\\nif(false) {\\n\\t// When the styles change, update the <style> tags\\n\\tif(!content.locals) {\\n\\t\\tmodule.hot.accept(\\\"!!../../../css-loader/index.js!./owl.carousel.min.css\\\", function() {\\n\\t\\t\\tvar newContent = require(\\\"!!../../../css-loader/index.js!./owl.carousel.min.css\\\");\\n\\t\\t\\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\\n\\t\\t\\tupdate(newContent);\\n\\t\\t});\\n\\t}\\n\\t// When the module is disposed, remove the <style> tags\\n\\tmodule.hot.dispose(function() { update(); });\\n}\\n\\n//////////////////\\n// WEBPACK FOOTER\\n// ./~/owl.carousel/dist/assets/owl.carousel.min.css\\n// module id = 10\\n// module chunks = 0\\n\\n//# sourceURL=webpack:///./~/owl.carousel/dist/assets/owl.carousel.min.css?\");\n\n/***/ }),\n/* 11 */\n/***/ (function(module, exports, __webpack_require__) {\n\neval(\"// style-loader: Adds some css to the DOM by adding a <style> tag\\n\\n// load the styles\\nvar content = __webpack_require__(15);\\nif(typeof content === 'string') content = [[module.i, content, '']];\\n// Prepare cssTransformation\\nvar transform;\\n\\nvar options = {}\\noptions.transform = transform\\n// add the styles to the DOM\\nvar update = __webpack_require__(7)(content, options);\\nif(content.locals) module.exports = content.locals;\\n// Hot Module Replacement\\nif(false) {\\n\\t// When the styles change, update the <style> tags\\n\\tif(!content.locals) {\\n\\t\\tmodule.hot.accept(\\\"!!../../../css-loader/index.js!./owl.theme.default.min.css\\\", function() {\\n\\t\\t\\tvar newContent = require(\\\"!!../../../css-loader/index.js!./owl.theme.default.min.css\\\");\\n\\t\\t\\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\\n\\t\\t\\tupdate(newContent);\\n\\t\\t});\\n\\t}\\n\\t// When the module is disposed, remove the <style> tags\\n\\tmodule.hot.dispose(function() { update(); });\\n}\\n\\n//////////////////\\n// WEBPACK FOOTER\\n// ./~/owl.carousel/dist/assets/owl.theme.default.min.css\\n// module id = 11\\n// module chunks = 0\\n\\n//# sourceURL=webpack:///./~/owl.carousel/dist/assets/owl.theme.default.min.css?\");\n\n/***/ }),\n/* 12 */\n/***/ (function(module, exports) {\n\neval(\"module.exports = __WEBPACK_EXTERNAL_MODULE_12__;\\n\\n//////////////////\\n// WEBPACK FOOTER\\n// external {\\\"root\\\":\\\"React\\\",\\\"commonjs2\\\":\\\"react\\\",\\\"commonjs\\\":\\\"react\\\",\\\"amd\\\":\\\"react\\\"}\\n// module id = 12\\n// module chunks = 0\\n\\n//# sourceURL=webpack:///external_%7B%22root%22:%22React%22,%22commonjs2%22:%22react%22,%22commonjs%22:%22react%22,%22amd%22:%22react%22%7D?\");\n\n/***/ }),\n/* 13 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\neval(\"Object.defineProperty(__webpack_exports__, \\\"__esModule\\\", { value: true });\\n/* WEBPACK VAR INJECTION */(function($) {/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(12);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_prop_types__ = __webpack_require__(9);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_prop_types___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_prop_types__);\\n\\n\\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\\n\\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\\\"value\\\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\\n\\nfunction _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\\\"this hasn't been initialised - super() hasn't been called\\\"); } return call && (typeof call === \\\"object\\\" || typeof call === \\\"function\\\") ? call : self; }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \\\"function\\\" && superClass !== null) { throw new TypeError(\\\"Super expression must either be null or a function, not \\\" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\n\\n\\n\\nvar Owl_Carousel_Options = {\\n\\n    // options\\n    items: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.number,\\n    margin: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.number,\\n    loop: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,\\n    center: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,\\n    mouseDrag: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,\\n    touchDrag: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,\\n    pullDrag: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,\\n    freeDrag: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,\\n    stagePadding: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.number,\\n    merge: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,\\n    mergeFit: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,\\n    autoWidth: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,\\n    startPosition: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.oneOfType([__WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.number, __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string]),\\n    URLhashListener: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,\\n    nav: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,\\n    rewind: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,\\n    navText: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.oneOfType([__WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.arrayOf(__WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string), __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.arrayOf(__WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.element)]),\\n    navElement: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string,\\n    slideBy: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.oneOfType([__WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.number, __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string]),\\n    dots: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,\\n    dotsEach: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.oneOfType([__WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.number, __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool]),\\n    dotData: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,\\n    lazyLoad: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,\\n    lazyContent: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,\\n    autoplay: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,\\n    autoplayTimeout: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.number,\\n    autoplayHoverPause: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,\\n    smartSpeed: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.number,\\n    fluidSpeed: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,\\n    autoplaySpeed: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.oneOfType([__WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.number, __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool]),\\n    navSpeed: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.oneOfType([__WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.number, __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool]),\\n    dotsSpeed: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.oneOfType([__WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.number, __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool]),\\n    dragEndSpeed: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.oneOfType([__WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.number, __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool]),\\n    callbacks: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,\\n    responsive: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.object,\\n    responsiveRefreshRate: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.number,\\n    responsiveBaseElement: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.element,\\n    video: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,\\n    videoHeight: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.oneOfType([__WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.number, __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool]),\\n    videoWidth: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.oneOfType([__WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.number, __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool]),\\n    animateOut: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.oneOfType([__WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string, __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool]),\\n    animateIn: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.oneOfType([__WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string, __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool]),\\n    fallbackEasing: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string,\\n    info: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.oneOfType([__WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func, __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool]),\\n    nestedItemSelector: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.oneOfType([__WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string, __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool]),\\n    itemElement: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string,\\n    stageElement: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string,\\n    navContainer: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.oneOfType([__WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string, __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool]),\\n    dotsContainer: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.oneOfType([__WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string, __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool]),\\n\\n    // dom class\\n    refreshClass: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string,\\n    loadingClass: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string,\\n    loadedClass: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string,\\n    rtlClass: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string,\\n    dragClass: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string,\\n    grabClass: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string,\\n    stageClass: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string,\\n    stageOuterClass: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string,\\n    navContainerClass: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string,\\n    navClass: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.arrayOf(__WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string),\\n    controlsClass: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string,\\n    dotClass: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string,\\n    dotsClass: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string,\\n    autoHeightClass: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string,\\n    responsiveClass: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.oneOfType([__WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string, __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool]),\\n\\n    // event\\n    onInitialize: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,\\n    onInitialized: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,\\n    onResize: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,\\n    onResized: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,\\n    onRefresh: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,\\n    onRefreshed: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,\\n    onDrag: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,\\n    onDragged: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,\\n    onTranslate: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,\\n    onTranslated: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,\\n    onChange: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,\\n    onChanged: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,\\n    onLoadLazy: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,\\n    onLoadedLazy: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,\\n    onStopVideo: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,\\n    onPlayVideo: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func\\n};\\n\\nvar OwlCarousel = function (_Component) {\\n    _inherits(OwlCarousel, _Component);\\n\\n    function OwlCarousel(props, context) {\\n        _classCallCheck(this, OwlCarousel);\\n\\n        var _this = _possibleConstructorReturn(this, (OwlCarousel.__proto__ || Object.getPrototypeOf(OwlCarousel)).call(this, props, context));\\n\\n        _this.next = _this.next.bind(_this);\\n        _this.prev = _this.prev.bind(_this);\\n        _this.to = _this.to.bind(_this);\\n        _this.create = _this.create.bind(_this);\\n        _this.destory = _this.destory.bind(_this);\\n        _this.play = _this.play.bind(_this);\\n        _this.stop = _this.stop.bind(_this);\\n        return _this;\\n    }\\n\\n    _createClass(OwlCarousel, [{\\n        key: 'componentWillMount',\\n        value: function componentWillMount() {\\n            __webpack_require__(10);\\n            __webpack_require__(11);\\n            __webpack_require__(8);\\n\\n            this._filterProps(this.props);\\n        }\\n    }, {\\n        key: 'componentDidMount',\\n        value: function componentDidMount() {\\n            this.owlCarousel = $(this.inst);\\n            this.owlCarousel.owlCarousel(this.options);\\n        }\\n    }, {\\n        key: 'componentWillReceiveProps',\\n        value: function componentWillReceiveProps(nextProps) {\\n            this._filterProps(nextProps);\\n            this.destory();\\n        }\\n    }, {\\n        key: 'componentDidUpdate',\\n        value: function componentDidUpdate() {\\n            this.owlCarousel = $(this.inst);\\n            this.owlCarousel.owlCarousel(this.options);\\n        }\\n    }, {\\n        key: 'componentWillUnmount',\\n        value: function componentWillUnmount() {\\n            this.destory();\\n        }\\n    }, {\\n        key: 'next',\\n        value: function next(speed) {\\n            if (typeof speed == 'number') {\\n                this.owlCarousel.trigger('next.owl.carousel', [speed]);\\n            } else {\\n                this.owlCarousel.trigger('next.owl.carousel');\\n            }\\n        }\\n    }, {\\n        key: 'prev',\\n        value: function prev(speed) {\\n            if (typeof speed == 'number') {\\n                this.owlCarousel.trigger('prev.owl.carousel', [speed]);\\n            } else {\\n                this.owlCarousel.trigger('prev.owl.carousel');\\n            }\\n        }\\n\\n        // refresh(event, speed) {\\n        // }\\n\\n    }, {\\n        key: 'to',\\n        value: function to(position, speed) {\\n            if (typeof position == 'number' && typeof speed == 'number') {\\n                this.owlCarousel.trigger('to.owl.carousel', [position, speed]);\\n            } else {\\n                this.owlCarousel.trigger('to.owl.carousel');\\n            }\\n        }\\n    }, {\\n        key: 'create',\\n        value: function create() {\\n            this.owlCarousel.owlCarousel(this.options);\\n        }\\n    }, {\\n        key: 'destory',\\n        value: function destory() {\\n            this.owlCarousel.trigger('destroy.owl.carousel');\\n        }\\n\\n        // replace(data) {\\n\\n        // }\\n\\n        // add(data, position) {\\n\\n        // }\\n\\n        // remove(position) {\\n\\n        // }\\n\\n    }, {\\n        key: 'play',\\n        value: function play(timeout, speed) {\\n            if (typeof timeout == 'number' && typeof speed == 'number') {\\n                this.owlCarousel.trigger('play.owl.autoplay', [timeout, speed]);\\n            } else {\\n                this.owlCarousel.trigger('play.owl.autoplay');\\n            }\\n        }\\n    }, {\\n        key: 'stop',\\n        value: function stop() {\\n            this.owlCarousel.trigger('stop.owl.autoplay');\\n        }\\n    }, {\\n        key: '_filterProps',\\n        value: function _filterProps(props) {\\n            var _this2 = this;\\n\\n            this.options = {};\\n            this.propsWithoutOptions = {};\\n            Object.keys(props).forEach(function (key) {\\n                if (Owl_Carousel_Options.hasOwnProperty(key)) {\\n                    _this2.options[key] = props[key];\\n                } else {\\n                    _this2.propsWithoutOptions[key] = props[key];\\n                }\\n            });\\n        }\\n    }, {\\n        key: 'render',\\n        value: function render() {\\n            var _this3 = this;\\n\\n            var _propsWithoutOptions = this.propsWithoutOptions,\\n                className = _propsWithoutOptions.className,\\n                children = _propsWithoutOptions.children,\\n                props = _objectWithoutProperties(_propsWithoutOptions, ['className', 'children']);\\n\\n            return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(\\n                'div',\\n                _extends({\\n                    className: 'owl-carousel ' + className,\\n                    ref: function ref(inst) {\\n                        return _this3.inst = inst;\\n                    }\\n                }, props),\\n                children\\n            );\\n        }\\n    }]);\\n\\n    return OwlCarousel;\\n}(__WEBPACK_IMPORTED_MODULE_0_react__[\\\"Component\\\"]);\\n\\nOwlCarousel.propTypes = Owl_Carousel_Options;\\n\\nOwlCarousel.defaultProps = {\\n    className: ''\\n};\\n\\n/* harmony default export */ __webpack_exports__[\\\"default\\\"] = (OwlCarousel);\\n/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__(1)))\\n\\n//////////////////\\n// WEBPACK FOOTER\\n// ./components/OwlCarousel.jsx\\n// module id = 13\\n// module chunks = 0\\n\\n//# sourceURL=webpack:///./components/OwlCarousel.jsx?\");\n\n/***/ }),\n/* 14 */\n/***/ (function(module, exports, __webpack_require__) {\n\neval(\"var escape = __webpack_require__(16);\\nexports = module.exports = __webpack_require__(5)(false);\\n// imports\\n\\n\\n// module\\nexports.push([module.i, \\\"/**\\\\n * Owl Carousel v2.2.0\\\\n * Copyright 2013-2016 David Deutsch\\\\n * Licensed under MIT (https://github.com/OwlCarousel2/OwlCarousel2/blob/master/LICENSE)\\\\n */\\\\n.owl-carousel,.owl-carousel .owl-item{-webkit-tap-highlight-color:transparent;position:relative}.owl-carousel{display:none;width:100%;z-index:1}.owl-carousel .owl-stage{position:relative;-ms-touch-action:pan-Y}.owl-carousel .owl-stage:after{content:\\\\\\\".\\\\\\\";display:block;clear:both;visibility:hidden;line-height:0;height:0}.owl-carousel .owl-stage-outer{position:relative;overflow:hidden;-webkit-transform:translate3d(0,0,0)}.owl-carousel .owl-item{min-height:1px;float:left;-webkit-backface-visibility:hidden;-webkit-touch-callout:none}.owl-carousel .owl-item img{display:block;width:100%;-webkit-transform-style:preserve-3d}.owl-carousel .owl-dots.disabled,.owl-carousel .owl-nav.disabled{display:none}.no-js .owl-carousel,.owl-carousel.owl-loaded{display:block}.owl-carousel .owl-dot,.owl-carousel .owl-nav .owl-next,.owl-carousel .owl-nav .owl-prev{cursor:pointer;cursor:hand;-webkit-user-select:none;-khtml-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.owl-carousel.owl-loading{opacity:0;display:block}.owl-carousel.owl-hidden{opacity:0}.owl-carousel.owl-refresh .owl-item{visibility:hidden}.owl-carousel.owl-drag .owl-item{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.owl-carousel.owl-grab{cursor:move;cursor:grab}.owl-carousel.owl-rtl{direction:rtl}.owl-carousel.owl-rtl .owl-item{float:right}.owl-carousel .animated{-webkit-animation-duration:1s;animation-duration:1s;-webkit-animation-fill-mode:both;animation-fill-mode:both}.owl-carousel .owl-animated-in{z-index:0}.owl-carousel .owl-animated-out{z-index:1}.owl-carousel .fadeOut{-webkit-animation-name:fadeOut;animation-name:fadeOut}@-webkit-keyframes fadeOut{0%{opacity:1}100%{opacity:0}}@keyframes fadeOut{0%{opacity:1}100%{opacity:0}}.owl-height{transition:height .5s ease-in-out}.owl-carousel .owl-item .owl-lazy{opacity:0;transition:opacity .4s ease}.owl-carousel .owl-item img.owl-lazy{-webkit-transform-style:preserve-3d;transform-style:preserve-3d}.owl-carousel .owl-video-wrapper{position:relative;height:100%;background:#000}.owl-carousel .owl-video-play-icon{position:absolute;height:80px;width:80px;left:50%;top:50%;margin-left:-40px;margin-top:-40px;background:url(\\\" + escape(__webpack_require__(17)) + \\\") no-repeat;cursor:pointer;z-index:1;-webkit-backface-visibility:hidden;transition:-webkit-transform .1s ease;transition:transform .1s ease}.owl-carousel .owl-video-play-icon:hover{-webkit-transform:scale(1.3,1.3);-ms-transform:scale(1.3,1.3);transform:scale(1.3,1.3)}.owl-carousel .owl-video-playing .owl-video-play-icon,.owl-carousel .owl-video-playing .owl-video-tn{display:none}.owl-carousel .owl-video-tn{opacity:0;height:100%;background-position:center center;background-repeat:no-repeat;background-size:contain;transition:opacity .4s ease}.owl-carousel .owl-video-frame{position:relative;z-index:1;height:100%;width:100%}\\\", \\\"\\\"]);\\n\\n// exports\\n\\n\\n//////////////////\\n// WEBPACK FOOTER\\n// ./~/css-loader!./~/owl.carousel/dist/assets/owl.carousel.min.css\\n// module id = 14\\n// module chunks = 0\\n\\n//# sourceURL=webpack:///./~/owl.carousel/dist/assets/owl.carousel.min.css?./~/css-loader\");\n\n/***/ }),\n/* 15 */\n/***/ (function(module, exports, __webpack_require__) {\n\neval(\"exports = module.exports = __webpack_require__(5)(false);\\n// imports\\n\\n\\n// module\\nexports.push([module.i, \\\"/**\\\\n * Owl Carousel v2.2.0\\\\n * Copyright 2013-2016 David Deutsch\\\\n * Licensed under MIT (https://github.com/OwlCarousel2/OwlCarousel2/blob/master/LICENSE)\\\\n */\\\\n.owl-theme .owl-dots,.owl-theme .owl-nav{text-align:center;-webkit-tap-highlight-color:transparent}.owl-theme .owl-nav{margin-top:10px}.owl-theme .owl-nav [class*=owl-]{color:#FFF;font-size:14px;margin:5px;padding:4px 7px;background:#D6D6D6;display:inline-block;cursor:pointer;border-radius:3px}.owl-theme .owl-nav [class*=owl-]:hover{background:#869791;color:#FFF;text-decoration:none}.owl-theme .owl-nav .disabled{opacity:.5;cursor:default}.owl-theme .owl-nav.disabled+.owl-dots{margin-top:10px}.owl-theme .owl-dots .owl-dot{display:inline-block;zoom:1}.owl-theme .owl-dots .owl-dot span{width:10px;height:10px;margin:5px 7px;background:#D6D6D6;display:block;-webkit-backface-visibility:visible;transition:opacity .2s ease;border-radius:30px}.owl-theme .owl-dots .owl-dot.active span,.owl-theme .owl-dots .owl-dot:hover span{background:#869791}\\\", \\\"\\\"]);\\n\\n// exports\\n\\n\\n//////////////////\\n// WEBPACK FOOTER\\n// ./~/css-loader!./~/owl.carousel/dist/assets/owl.theme.default.min.css\\n// module id = 15\\n// module chunks = 0\\n\\n//# sourceURL=webpack:///./~/owl.carousel/dist/assets/owl.theme.default.min.css?./~/css-loader\");\n\n/***/ }),\n/* 16 */\n/***/ (function(module, exports) {\n\neval(\"module.exports = function escape(url) {\\n    if (typeof url !== 'string') {\\n        return url\\n    }\\n    // If url is already wrapped in quotes, remove them\\n    if (/^['\\\"].*['\\\"]$/.test(url)) {\\n        url = url.slice(1, -1);\\n    }\\n    // Should url be wrapped?\\n    // See https://drafts.csswg.org/css-values-3/#urls\\n    if (/[\\\"'() \\\\t\\\\n]/.test(url)) {\\n        return '\\\"' + url.replace(/\\\"/g, '\\\\\\\\\\\"').replace(/\\\\n/g, '\\\\\\\\n') + '\\\"'\\n    }\\n\\n    return url\\n}\\n\\n\\n//////////////////\\n// WEBPACK FOOTER\\n// ./~/css-loader/lib/url/escape.js\\n// module id = 16\\n// module chunks = 0\\n\\n//# sourceURL=webpack:///./~/css-loader/lib/url/escape.js?\");\n\n/***/ }),\n/* 17 */\n/***/ (function(module, exports, __webpack_require__) {\n\neval(\"module.exports = __webpack_require__.p + \\\"4a37f8008959c75f619bf0a3a4e2d7a2.png\\\";\\n\\n//////////////////\\n// WEBPACK FOOTER\\n// ./~/owl.carousel/dist/assets/owl.video.play.png\\n// module id = 17\\n// module chunks = 0\\n\\n//# sourceURL=webpack:///./~/owl.carousel/dist/assets/owl.video.play.png?\");\n\n/***/ }),\n/* 18 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\neval(\"/*\\nobject-assign\\n(c) Sindre Sorhus\\n@license MIT\\n*/\\n\\n\\n/* eslint-disable no-unused-vars */\\nvar getOwnPropertySymbols = Object.getOwnPropertySymbols;\\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\\nvar propIsEnumerable = Object.prototype.propertyIsEnumerable;\\n\\nfunction toObject(val) {\\n\\tif (val === null || val === undefined) {\\n\\t\\tthrow new TypeError('Object.assign cannot be called with null or undefined');\\n\\t}\\n\\n\\treturn Object(val);\\n}\\n\\nfunction shouldUseNative() {\\n\\ttry {\\n\\t\\tif (!Object.assign) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\t// Detect buggy property enumeration order in older V8 versions.\\n\\n\\t\\t// https://bugs.chromium.org/p/v8/issues/detail?id=4118\\n\\t\\tvar test1 = new String('abc');  // eslint-disable-line no-new-wrappers\\n\\t\\ttest1[5] = 'de';\\n\\t\\tif (Object.getOwnPropertyNames(test1)[0] === '5') {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\\n\\t\\tvar test2 = {};\\n\\t\\tfor (var i = 0; i < 10; i++) {\\n\\t\\t\\ttest2['_' + String.fromCharCode(i)] = i;\\n\\t\\t}\\n\\t\\tvar order2 = Object.getOwnPropertyNames(test2).map(function (n) {\\n\\t\\t\\treturn test2[n];\\n\\t\\t});\\n\\t\\tif (order2.join('') !== '0123456789') {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\\n\\t\\tvar test3 = {};\\n\\t\\t'abcdefghijklmnopqrst'.split('').forEach(function (letter) {\\n\\t\\t\\ttest3[letter] = letter;\\n\\t\\t});\\n\\t\\tif (Object.keys(Object.assign({}, test3)).join('') !==\\n\\t\\t\\t\\t'abcdefghijklmnopqrst') {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\treturn true;\\n\\t} catch (err) {\\n\\t\\t// We don't expect any of the above to throw, but better to be safe.\\n\\t\\treturn false;\\n\\t}\\n}\\n\\nmodule.exports = shouldUseNative() ? Object.assign : function (target, source) {\\n\\tvar from;\\n\\tvar to = toObject(target);\\n\\tvar symbols;\\n\\n\\tfor (var s = 1; s < arguments.length; s++) {\\n\\t\\tfrom = Object(arguments[s]);\\n\\n\\t\\tfor (var key in from) {\\n\\t\\t\\tif (hasOwnProperty.call(from, key)) {\\n\\t\\t\\t\\tto[key] = from[key];\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif (getOwnPropertySymbols) {\\n\\t\\t\\tsymbols = getOwnPropertySymbols(from);\\n\\t\\t\\tfor (var i = 0; i < symbols.length; i++) {\\n\\t\\t\\t\\tif (propIsEnumerable.call(from, symbols[i])) {\\n\\t\\t\\t\\t\\tto[symbols[i]] = from[symbols[i]];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn to;\\n};\\n\\n\\n//////////////////\\n// WEBPACK FOOTER\\n// ./~/object-assign/index.js\\n// module id = 18\\n// module chunks = 0\\n\\n//# sourceURL=webpack:///./~/object-assign/index.js?\");\n\n/***/ }),\n/* 19 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\neval(\"/* WEBPACK VAR INJECTION */(function(process) {/**\\n * Copyright (c) 2013-present, Facebook, Inc.\\n *\\n * This source code is licensed under the MIT license found in the\\n * LICENSE file in the root directory of this source tree.\\n */\\n\\n\\n\\nif (process.env.NODE_ENV !== 'production') {\\n  var invariant = __webpack_require__(3);\\n  var warning = __webpack_require__(6);\\n  var ReactPropTypesSecret = __webpack_require__(4);\\n  var loggedTypeFailures = {};\\n}\\n\\n/**\\n * Assert that the values match with the type specs.\\n * Error messages are memorized and will only be shown once.\\n *\\n * @param {object} typeSpecs Map of name to a ReactPropType\\n * @param {object} values Runtime values that need to be type-checked\\n * @param {string} location e.g. \\\"prop\\\", \\\"context\\\", \\\"child context\\\"\\n * @param {string} componentName Name of the component for error messages.\\n * @param {?Function} getStack Returns the component stack.\\n * @private\\n */\\nfunction checkPropTypes(typeSpecs, values, location, componentName, getStack) {\\n  if (process.env.NODE_ENV !== 'production') {\\n    for (var typeSpecName in typeSpecs) {\\n      if (typeSpecs.hasOwnProperty(typeSpecName)) {\\n        var error;\\n        // Prop type validation may throw. In case they do, we don't want to\\n        // fail the render phase where it didn't fail before. So we log it.\\n        // After these have been cleaned up, we'll let them throw.\\n        try {\\n          // This is intentionally an invariant that gets caught. It's the same\\n          // behavior as without this statement except with a better message.\\n          invariant(typeof typeSpecs[typeSpecName] === 'function', '%s: %s type `%s` is invalid; it must be a function, usually from ' + 'the `prop-types` package, but received `%s`.', componentName || 'React class', location, typeSpecName, typeof typeSpecs[typeSpecName]);\\n          error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);\\n        } catch (ex) {\\n          error = ex;\\n        }\\n        warning(!error || error instanceof Error, '%s: type specification of %s `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error);\\n        if (error instanceof Error && !(error.message in loggedTypeFailures)) {\\n          // Only monitor this failure once because there tends to be a lot of the\\n          // same error.\\n          loggedTypeFailures[error.message] = true;\\n\\n          var stack = getStack ? getStack() : '';\\n\\n          warning(false, 'Failed %s type: %s%s', location, error.message, stack != null ? stack : '');\\n        }\\n      }\\n    }\\n  }\\n}\\n\\nmodule.exports = checkPropTypes;\\n\\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))\\n\\n//////////////////\\n// WEBPACK FOOTER\\n// ./~/prop-types/checkPropTypes.js\\n// module id = 19\\n// module chunks = 0\\n\\n//# sourceURL=webpack:///./~/prop-types/checkPropTypes.js?\");\n\n/***/ }),\n/* 20 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\neval(\"/**\\n * Copyright (c) 2013-present, Facebook, Inc.\\n *\\n * This source code is licensed under the MIT license found in the\\n * LICENSE file in the root directory of this source tree.\\n */\\n\\n\\n\\nvar emptyFunction = __webpack_require__(2);\\nvar invariant = __webpack_require__(3);\\nvar ReactPropTypesSecret = __webpack_require__(4);\\n\\nmodule.exports = function() {\\n  function shim(props, propName, componentName, location, propFullName, secret) {\\n    if (secret === ReactPropTypesSecret) {\\n      // It is still safe when called from React.\\n      return;\\n    }\\n    invariant(\\n      false,\\n      'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +\\n      'Use PropTypes.checkPropTypes() to call them. ' +\\n      'Read more at http://fb.me/use-check-prop-types'\\n    );\\n  };\\n  shim.isRequired = shim;\\n  function getShim() {\\n    return shim;\\n  };\\n  // Important!\\n  // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.\\n  var ReactPropTypes = {\\n    array: shim,\\n    bool: shim,\\n    func: shim,\\n    number: shim,\\n    object: shim,\\n    string: shim,\\n    symbol: shim,\\n\\n    any: shim,\\n    arrayOf: getShim,\\n    element: shim,\\n    instanceOf: getShim,\\n    node: shim,\\n    objectOf: getShim,\\n    oneOf: getShim,\\n    oneOfType: getShim,\\n    shape: getShim,\\n    exact: getShim\\n  };\\n\\n  ReactPropTypes.checkPropTypes = emptyFunction;\\n  ReactPropTypes.PropTypes = ReactPropTypes;\\n\\n  return ReactPropTypes;\\n};\\n\\n\\n//////////////////\\n// WEBPACK FOOTER\\n// ./~/prop-types/factoryWithThrowingShims.js\\n// module id = 20\\n// module chunks = 0\\n\\n//# sourceURL=webpack:///./~/prop-types/factoryWithThrowingShims.js?\");\n\n/***/ }),\n/* 21 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\neval(\"/* WEBPACK VAR INJECTION */(function(process) {/**\\n * Copyright (c) 2013-present, Facebook, Inc.\\n *\\n * This source code is licensed under the MIT license found in the\\n * LICENSE file in the root directory of this source tree.\\n */\\n\\n\\n\\nvar emptyFunction = __webpack_require__(2);\\nvar invariant = __webpack_require__(3);\\nvar warning = __webpack_require__(6);\\nvar assign = __webpack_require__(18);\\n\\nvar ReactPropTypesSecret = __webpack_require__(4);\\nvar checkPropTypes = __webpack_require__(19);\\n\\nmodule.exports = function(isValidElement, throwOnDirectAccess) {\\n  /* global Symbol */\\n  var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;\\n  var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.\\n\\n  /**\\n   * Returns the iterator method function contained on the iterable object.\\n   *\\n   * Be sure to invoke the function with the iterable as context:\\n   *\\n   *     var iteratorFn = getIteratorFn(myIterable);\\n   *     if (iteratorFn) {\\n   *       var iterator = iteratorFn.call(myIterable);\\n   *       ...\\n   *     }\\n   *\\n   * @param {?object} maybeIterable\\n   * @return {?function}\\n   */\\n  function getIteratorFn(maybeIterable) {\\n    var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);\\n    if (typeof iteratorFn === 'function') {\\n      return iteratorFn;\\n    }\\n  }\\n\\n  /**\\n   * Collection of methods that allow declaration and validation of props that are\\n   * supplied to React components. Example usage:\\n   *\\n   *   var Props = require('ReactPropTypes');\\n   *   var MyArticle = React.createClass({\\n   *     propTypes: {\\n   *       // An optional string prop named \\\"description\\\".\\n   *       description: Props.string,\\n   *\\n   *       // A required enum prop named \\\"category\\\".\\n   *       category: Props.oneOf(['News','Photos']).isRequired,\\n   *\\n   *       // A prop named \\\"dialog\\\" that requires an instance of Dialog.\\n   *       dialog: Props.instanceOf(Dialog).isRequired\\n   *     },\\n   *     render: function() { ... }\\n   *   });\\n   *\\n   * A more formal specification of how these methods are used:\\n   *\\n   *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)\\n   *   decl := ReactPropTypes.{type}(.isRequired)?\\n   *\\n   * Each and every declaration produces a function with the same signature. This\\n   * allows the creation of custom validation functions. For example:\\n   *\\n   *  var MyLink = React.createClass({\\n   *    propTypes: {\\n   *      // An optional string or URI prop named \\\"href\\\".\\n   *      href: function(props, propName, componentName) {\\n   *        var propValue = props[propName];\\n   *        if (propValue != null && typeof propValue !== 'string' &&\\n   *            !(propValue instanceof URI)) {\\n   *          return new Error(\\n   *            'Expected a string or an URI for ' + propName + ' in ' +\\n   *            componentName\\n   *          );\\n   *        }\\n   *      }\\n   *    },\\n   *    render: function() {...}\\n   *  });\\n   *\\n   * @internal\\n   */\\n\\n  var ANONYMOUS = '<<anonymous>>';\\n\\n  // Important!\\n  // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.\\n  var ReactPropTypes = {\\n    array: createPrimitiveTypeChecker('array'),\\n    bool: createPrimitiveTypeChecker('boolean'),\\n    func: createPrimitiveTypeChecker('function'),\\n    number: createPrimitiveTypeChecker('number'),\\n    object: createPrimitiveTypeChecker('object'),\\n    string: createPrimitiveTypeChecker('string'),\\n    symbol: createPrimitiveTypeChecker('symbol'),\\n\\n    any: createAnyTypeChecker(),\\n    arrayOf: createArrayOfTypeChecker,\\n    element: createElementTypeChecker(),\\n    instanceOf: createInstanceTypeChecker,\\n    node: createNodeChecker(),\\n    objectOf: createObjectOfTypeChecker,\\n    oneOf: createEnumTypeChecker,\\n    oneOfType: createUnionTypeChecker,\\n    shape: createShapeTypeChecker,\\n    exact: createStrictShapeTypeChecker,\\n  };\\n\\n  /**\\n   * inlined Object.is polyfill to avoid requiring consumers ship their own\\n   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\\n   */\\n  /*eslint-disable no-self-compare*/\\n  function is(x, y) {\\n    // SameValue algorithm\\n    if (x === y) {\\n      // Steps 1-5, 7-10\\n      // Steps 6.b-6.e: +0 != -0\\n      return x !== 0 || 1 / x === 1 / y;\\n    } else {\\n      // Step 6.a: NaN == NaN\\n      return x !== x && y !== y;\\n    }\\n  }\\n  /*eslint-enable no-self-compare*/\\n\\n  /**\\n   * We use an Error-like object for backward compatibility as people may call\\n   * PropTypes directly and inspect their output. However, we don't use real\\n   * Errors anymore. We don't inspect their stack anyway, and creating them\\n   * is prohibitively expensive if they are created too often, such as what\\n   * happens in oneOfType() for any type before the one that matched.\\n   */\\n  function PropTypeError(message) {\\n    this.message = message;\\n    this.stack = '';\\n  }\\n  // Make `instanceof Error` still work for returned errors.\\n  PropTypeError.prototype = Error.prototype;\\n\\n  function createChainableTypeChecker(validate) {\\n    if (process.env.NODE_ENV !== 'production') {\\n      var manualPropTypeCallCache = {};\\n      var manualPropTypeWarningCount = 0;\\n    }\\n    function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {\\n      componentName = componentName || ANONYMOUS;\\n      propFullName = propFullName || propName;\\n\\n      if (secret !== ReactPropTypesSecret) {\\n        if (throwOnDirectAccess) {\\n          // New behavior only for users of `prop-types` package\\n          invariant(\\n            false,\\n            'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +\\n            'Use `PropTypes.checkPropTypes()` to call them. ' +\\n            'Read more at http://fb.me/use-check-prop-types'\\n          );\\n        } else if (process.env.NODE_ENV !== 'production' && typeof console !== 'undefined') {\\n          // Old behavior for people using React.PropTypes\\n          var cacheKey = componentName + ':' + propName;\\n          if (\\n            !manualPropTypeCallCache[cacheKey] &&\\n            // Avoid spamming the console because they are often not actionable except for lib authors\\n            manualPropTypeWarningCount < 3\\n          ) {\\n            warning(\\n              false,\\n              'You are manually calling a React.PropTypes validation ' +\\n              'function for the `%s` prop on `%s`. This is deprecated ' +\\n              'and will throw in the standalone `prop-types` package. ' +\\n              'You may be seeing this warning due to a third-party PropTypes ' +\\n              'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.',\\n              propFullName,\\n              componentName\\n            );\\n            manualPropTypeCallCache[cacheKey] = true;\\n            manualPropTypeWarningCount++;\\n          }\\n        }\\n      }\\n      if (props[propName] == null) {\\n        if (isRequired) {\\n          if (props[propName] === null) {\\n            return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));\\n          }\\n          return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));\\n        }\\n        return null;\\n      } else {\\n        return validate(props, propName, componentName, location, propFullName);\\n      }\\n    }\\n\\n    var chainedCheckType = checkType.bind(null, false);\\n    chainedCheckType.isRequired = checkType.bind(null, true);\\n\\n    return chainedCheckType;\\n  }\\n\\n  function createPrimitiveTypeChecker(expectedType) {\\n    function validate(props, propName, componentName, location, propFullName, secret) {\\n      var propValue = props[propName];\\n      var propType = getPropType(propValue);\\n      if (propType !== expectedType) {\\n        // `propValue` being instance of, say, date/regexp, pass the 'object'\\n        // check, but we can offer a more precise error message here rather than\\n        // 'of type `object`'.\\n        var preciseType = getPreciseType(propValue);\\n\\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'));\\n      }\\n      return null;\\n    }\\n    return createChainableTypeChecker(validate);\\n  }\\n\\n  function createAnyTypeChecker() {\\n    return createChainableTypeChecker(emptyFunction.thatReturnsNull);\\n  }\\n\\n  function createArrayOfTypeChecker(typeChecker) {\\n    function validate(props, propName, componentName, location, propFullName) {\\n      if (typeof typeChecker !== 'function') {\\n        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');\\n      }\\n      var propValue = props[propName];\\n      if (!Array.isArray(propValue)) {\\n        var propType = getPropType(propValue);\\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));\\n      }\\n      for (var i = 0; i < propValue.length; i++) {\\n        var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret);\\n        if (error instanceof Error) {\\n          return error;\\n        }\\n      }\\n      return null;\\n    }\\n    return createChainableTypeChecker(validate);\\n  }\\n\\n  function createElementTypeChecker() {\\n    function validate(props, propName, componentName, location, propFullName) {\\n      var propValue = props[propName];\\n      if (!isValidElement(propValue)) {\\n        var propType = getPropType(propValue);\\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));\\n      }\\n      return null;\\n    }\\n    return createChainableTypeChecker(validate);\\n  }\\n\\n  function createInstanceTypeChecker(expectedClass) {\\n    function validate(props, propName, componentName, location, propFullName) {\\n      if (!(props[propName] instanceof expectedClass)) {\\n        var expectedClassName = expectedClass.name || ANONYMOUS;\\n        var actualClassName = getClassName(props[propName]);\\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));\\n      }\\n      return null;\\n    }\\n    return createChainableTypeChecker(validate);\\n  }\\n\\n  function createEnumTypeChecker(expectedValues) {\\n    if (!Array.isArray(expectedValues)) {\\n      process.env.NODE_ENV !== 'production' ? warning(false, 'Invalid argument supplied to oneOf, expected an instance of array.') : void 0;\\n      return emptyFunction.thatReturnsNull;\\n    }\\n\\n    function validate(props, propName, componentName, location, propFullName) {\\n      var propValue = props[propName];\\n      for (var i = 0; i < expectedValues.length; i++) {\\n        if (is(propValue, expectedValues[i])) {\\n          return null;\\n        }\\n      }\\n\\n      var valuesString = JSON.stringify(expectedValues);\\n      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of value `' + propValue + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));\\n    }\\n    return createChainableTypeChecker(validate);\\n  }\\n\\n  function createObjectOfTypeChecker(typeChecker) {\\n    function validate(props, propName, componentName, location, propFullName) {\\n      if (typeof typeChecker !== 'function') {\\n        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');\\n      }\\n      var propValue = props[propName];\\n      var propType = getPropType(propValue);\\n      if (propType !== 'object') {\\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));\\n      }\\n      for (var key in propValue) {\\n        if (propValue.hasOwnProperty(key)) {\\n          var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);\\n          if (error instanceof Error) {\\n            return error;\\n          }\\n        }\\n      }\\n      return null;\\n    }\\n    return createChainableTypeChecker(validate);\\n  }\\n\\n  function createUnionTypeChecker(arrayOfTypeCheckers) {\\n    if (!Array.isArray(arrayOfTypeCheckers)) {\\n      process.env.NODE_ENV !== 'production' ? warning(false, 'Invalid argument supplied to oneOfType, expected an instance of array.') : void 0;\\n      return emptyFunction.thatReturnsNull;\\n    }\\n\\n    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {\\n      var checker = arrayOfTypeCheckers[i];\\n      if (typeof checker !== 'function') {\\n        warning(\\n          false,\\n          'Invalid argument supplied to oneOfType. Expected an array of check functions, but ' +\\n          'received %s at index %s.',\\n          getPostfixForTypeWarning(checker),\\n          i\\n        );\\n        return emptyFunction.thatReturnsNull;\\n      }\\n    }\\n\\n    function validate(props, propName, componentName, location, propFullName) {\\n      for (var i = 0; i < arrayOfTypeCheckers.length; i++) {\\n        var checker = arrayOfTypeCheckers[i];\\n        if (checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret) == null) {\\n          return null;\\n        }\\n      }\\n\\n      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`.'));\\n    }\\n    return createChainableTypeChecker(validate);\\n  }\\n\\n  function createNodeChecker() {\\n    function validate(props, propName, componentName, location, propFullName) {\\n      if (!isNode(props[propName])) {\\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));\\n      }\\n      return null;\\n    }\\n    return createChainableTypeChecker(validate);\\n  }\\n\\n  function createShapeTypeChecker(shapeTypes) {\\n    function validate(props, propName, componentName, location, propFullName) {\\n      var propValue = props[propName];\\n      var propType = getPropType(propValue);\\n      if (propType !== 'object') {\\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));\\n      }\\n      for (var key in shapeTypes) {\\n        var checker = shapeTypes[key];\\n        if (!checker) {\\n          continue;\\n        }\\n        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);\\n        if (error) {\\n          return error;\\n        }\\n      }\\n      return null;\\n    }\\n    return createChainableTypeChecker(validate);\\n  }\\n\\n  function createStrictShapeTypeChecker(shapeTypes) {\\n    function validate(props, propName, componentName, location, propFullName) {\\n      var propValue = props[propName];\\n      var propType = getPropType(propValue);\\n      if (propType !== 'object') {\\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));\\n      }\\n      // We need to check all keys in case some are required but missing from\\n      // props.\\n      var allKeys = assign({}, props[propName], shapeTypes);\\n      for (var key in allKeys) {\\n        var checker = shapeTypes[key];\\n        if (!checker) {\\n          return new PropTypeError(\\n            'Invalid ' + location + ' `' + propFullName + '` key `' + key + '` supplied to `' + componentName + '`.' +\\n            '\\\\nBad object: ' + JSON.stringify(props[propName], null, '  ') +\\n            '\\\\nValid keys: ' +  JSON.stringify(Object.keys(shapeTypes), null, '  ')\\n          );\\n        }\\n        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);\\n        if (error) {\\n          return error;\\n        }\\n      }\\n      return null;\\n    }\\n\\n    return createChainableTypeChecker(validate);\\n  }\\n\\n  function isNode(propValue) {\\n    switch (typeof propValue) {\\n      case 'number':\\n      case 'string':\\n      case 'undefined':\\n        return true;\\n      case 'boolean':\\n        return !propValue;\\n      case 'object':\\n        if (Array.isArray(propValue)) {\\n          return propValue.every(isNode);\\n        }\\n        if (propValue === null || isValidElement(propValue)) {\\n          return true;\\n        }\\n\\n        var iteratorFn = getIteratorFn(propValue);\\n        if (iteratorFn) {\\n          var iterator = iteratorFn.call(propValue);\\n          var step;\\n          if (iteratorFn !== propValue.entries) {\\n            while (!(step = iterator.next()).done) {\\n              if (!isNode(step.value)) {\\n                return false;\\n              }\\n            }\\n          } else {\\n            // Iterator will provide entry [k,v] tuples rather than values.\\n            while (!(step = iterator.next()).done) {\\n              var entry = step.value;\\n              if (entry) {\\n                if (!isNode(entry[1])) {\\n                  return false;\\n                }\\n              }\\n            }\\n          }\\n        } else {\\n          return false;\\n        }\\n\\n        return true;\\n      default:\\n        return false;\\n    }\\n  }\\n\\n  function isSymbol(propType, propValue) {\\n    // Native Symbol.\\n    if (propType === 'symbol') {\\n      return true;\\n    }\\n\\n    // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'\\n    if (propValue['@@toStringTag'] === 'Symbol') {\\n      return true;\\n    }\\n\\n    // Fallback for non-spec compliant Symbols which are polyfilled.\\n    if (typeof Symbol === 'function' && propValue instanceof Symbol) {\\n      return true;\\n    }\\n\\n    return false;\\n  }\\n\\n  // Equivalent of `typeof` but with special handling for array and regexp.\\n  function getPropType(propValue) {\\n    var propType = typeof propValue;\\n    if (Array.isArray(propValue)) {\\n      return 'array';\\n    }\\n    if (propValue instanceof RegExp) {\\n      // Old webkits (at least until Android 4.0) return 'function' rather than\\n      // 'object' for typeof a RegExp. We'll normalize this here so that /bla/\\n      // passes PropTypes.object.\\n      return 'object';\\n    }\\n    if (isSymbol(propType, propValue)) {\\n      return 'symbol';\\n    }\\n    return propType;\\n  }\\n\\n  // This handles more types than `getPropType`. Only used for error messages.\\n  // See `createPrimitiveTypeChecker`.\\n  function getPreciseType(propValue) {\\n    if (typeof propValue === 'undefined' || propValue === null) {\\n      return '' + propValue;\\n    }\\n    var propType = getPropType(propValue);\\n    if (propType === 'object') {\\n      if (propValue instanceof Date) {\\n        return 'date';\\n      } else if (propValue instanceof RegExp) {\\n        return 'regexp';\\n      }\\n    }\\n    return propType;\\n  }\\n\\n  // Returns a string that is postfixed to a warning about an invalid type.\\n  // For example, \\\"undefined\\\" or \\\"of type array\\\"\\n  function getPostfixForTypeWarning(value) {\\n    var type = getPreciseType(value);\\n    switch (type) {\\n      case 'array':\\n      case 'object':\\n        return 'an ' + type;\\n      case 'boolean':\\n      case 'date':\\n      case 'regexp':\\n        return 'a ' + type;\\n      default:\\n        return type;\\n    }\\n  }\\n\\n  // Returns class name of the object, if any.\\n  function getClassName(propValue) {\\n    if (!propValue.constructor || !propValue.constructor.name) {\\n      return ANONYMOUS;\\n    }\\n    return propValue.constructor.name;\\n  }\\n\\n  ReactPropTypes.checkPropTypes = checkPropTypes;\\n  ReactPropTypes.PropTypes = ReactPropTypes;\\n\\n  return ReactPropTypes;\\n};\\n\\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))\\n\\n//////////////////\\n// WEBPACK FOOTER\\n// ./~/prop-types/factoryWithTypeCheckers.js\\n// module id = 21\\n// module chunks = 0\\n\\n//# sourceURL=webpack:///./~/prop-types/factoryWithTypeCheckers.js?\");\n\n/***/ }),\n/* 22 */\n/***/ (function(module, exports) {\n\neval(\"\\n/**\\n * When source maps are enabled, `style-loader` uses a link element with a data-uri to\\n * embed the css on the page. This breaks all relative urls because now they are relative to a\\n * bundle instead of the current page.\\n *\\n * One solution is to only use full urls, but that may be impossible.\\n *\\n * Instead, this function \\\"fixes\\\" the relative urls to be absolute according to the current page location.\\n *\\n * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.\\n *\\n */\\n\\nmodule.exports = function (css) {\\n  // get current location\\n  var location = typeof window !== \\\"undefined\\\" && window.location;\\n\\n  if (!location) {\\n    throw new Error(\\\"fixUrls requires window.location\\\");\\n  }\\n\\n\\t// blank or null?\\n\\tif (!css || typeof css !== \\\"string\\\") {\\n\\t  return css;\\n  }\\n\\n  var baseUrl = location.protocol + \\\"//\\\" + location.host;\\n  var currentDir = baseUrl + location.pathname.replace(/\\\\/[^\\\\/]*$/, \\\"/\\\");\\n\\n\\t// convert each url(...)\\n\\t/*\\n\\tThis regular expression is just a way to recursively match brackets within\\n\\ta string.\\n\\n\\t /url\\\\s*\\\\(  = Match on the word \\\"url\\\" with any whitespace after it and then a parens\\n\\t   (  = Start a capturing group\\n\\t     (?:  = Start a non-capturing group\\n\\t         [^)(]  = Match anything that isn't a parentheses\\n\\t         |  = OR\\n\\t         \\\\(  = Match a start parentheses\\n\\t             (?:  = Start another non-capturing groups\\n\\t                 [^)(]+  = Match anything that isn't a parentheses\\n\\t                 |  = OR\\n\\t                 \\\\(  = Match a start parentheses\\n\\t                     [^)(]*  = Match anything that isn't a parentheses\\n\\t                 \\\\)  = Match a end parentheses\\n\\t             )  = End Group\\n              *\\\\) = Match anything and then a close parens\\n          )  = Close non-capturing group\\n          *  = Match anything\\n       )  = Close capturing group\\n\\t \\\\)  = Match a close parens\\n\\n\\t /gi  = Get all matches, not the first.  Be case insensitive.\\n\\t */\\n\\tvar fixedCss = css.replace(/url\\\\s*\\\\(((?:[^)(]|\\\\((?:[^)(]+|\\\\([^)(]*\\\\))*\\\\))*)\\\\)/gi, function(fullMatch, origUrl) {\\n\\t\\t// strip quotes (if they exist)\\n\\t\\tvar unquotedOrigUrl = origUrl\\n\\t\\t\\t.trim()\\n\\t\\t\\t.replace(/^\\\"(.*)\\\"$/, function(o, $1){ return $1; })\\n\\t\\t\\t.replace(/^'(.*)'$/, function(o, $1){ return $1; });\\n\\n\\t\\t// already a full url? no change\\n\\t\\tif (/^(#|data:|http:\\\\/\\\\/|https:\\\\/\\\\/|file:\\\\/\\\\/\\\\/)/i.test(unquotedOrigUrl)) {\\n\\t\\t  return fullMatch;\\n\\t\\t}\\n\\n\\t\\t// convert the url to a full url\\n\\t\\tvar newUrl;\\n\\n\\t\\tif (unquotedOrigUrl.indexOf(\\\"//\\\") === 0) {\\n\\t\\t  \\t//TODO: should we add protocol?\\n\\t\\t\\tnewUrl = unquotedOrigUrl;\\n\\t\\t} else if (unquotedOrigUrl.indexOf(\\\"/\\\") === 0) {\\n\\t\\t\\t// path should be relative to the base url\\n\\t\\t\\tnewUrl = baseUrl + unquotedOrigUrl; // already starts with '/'\\n\\t\\t} else {\\n\\t\\t\\t// path should be relative to current directory\\n\\t\\t\\tnewUrl = currentDir + unquotedOrigUrl.replace(/^\\\\.\\\\//, \\\"\\\"); // Strip leading './'\\n\\t\\t}\\n\\n\\t\\t// send back the fixed url(...)\\n\\t\\treturn \\\"url(\\\" + JSON.stringify(newUrl) + \\\")\\\";\\n\\t});\\n\\n\\t// send back the fixed css\\n\\treturn fixedCss;\\n};\\n\\n\\n//////////////////\\n// WEBPACK FOOTER\\n// ./~/style-loader/fixUrls.js\\n// module id = 22\\n// module chunks = 0\\n\\n//# sourceURL=webpack:///./~/style-loader/fixUrls.js?\");\n\n/***/ })\n/******/ ]);\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0LW93bC1jYXJvdXNlbDMvbGliL093bENhcm91c2VsLmpzPzQ2Y2IiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxJQUFJLElBQXlEO0FBQzdELDJCQUEyQixtQkFBTyxDQUFDLDRDQUFPO0FBQzFDLE1BQU0sRUFLZ0Q7QUFDdEQsQ0FBQztBQUNELG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiw4QkFBbUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRUFBMEUsOEJBQW1CO0FBQzdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSw4QkFBbUI7QUFDN0I7QUFDQTtBQUNBLFVBQVUsOEJBQW1CO0FBQzdCO0FBQ0E7QUFDQSxVQUFVLDhCQUFtQixzQkFBc0IsY0FBYztBQUNqRTtBQUNBO0FBQ0EsVUFBVSw4QkFBbUI7QUFDN0IsZUFBZSw4QkFBbUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLDhCQUFtQjtBQUM3QjtBQUNBLG1DQUFtQywwQkFBMEIsRUFBRTtBQUMvRCx5Q0FBeUMsZUFBZTtBQUN4RCxXQUFXLDhCQUFtQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsOEJBQW1CLGlDQUFpQywrREFBK0Q7QUFDN0g7QUFDQTtBQUNBLFVBQVUsOEJBQW1CO0FBQzdCO0FBQ0E7QUFDQSxpQkFBaUIsOEJBQW1CLENBQUMsOEJBQW1CO0FBQ3hELFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw4RUFBOEUsc1VBQXNVLHlCQUF5QixpQ0FBaUMseURBQXlELEdBQUcsbUNBQW1DLDJEQUEyRCxHQUFHLGdCQUFnQixXQUFXLGlEQUFpRCw0Q0FBNEMs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QXVCLE9BQU8sd0NBQXdDLDROQUE0TixPQUFPLDBDQUEwQyx3QkFBd0IsT0FBTyxzQkFBc0IsS0FBSyxrS0FBa0ssbUVBQW1FLDhCQUE4QixPQUFPLDRDQUE0QyxrQ0FBa0Msd0NBQXdDLHdCQUF3QixTQUFTLHdDQUF3QywwQkFBMEIsU0FBUyxPQUFPLHNCQUFzQixLQUFLLG1MQUFtTCx1Q0FBdUMscUJBQXFCLHlFQUF5RSw4RkFBOEYsc0NBQXNDLE9BQU8sS0FBSyx3RkFBd0Ysa0VBQWtFLHlCQUF5QixPQUFPLHdDQUF3QyxLQUFLLHFEQUFxRCw4Q0FBOEMsNEJBQTRCLElBQUksZ0NBQWdDOztBQUU5OG5CLE9BQU87QUFDUDtBQUNBOztBQUVBLGtrQkFBa2tCLGlHQUFpRyxzQkFBc0IsNERBQTRELEtBQUssbUVBQW1FLGlCQUFpQixLQUFLLCtEQUErRCwrRUFBK0Usb3FDQUFvcUMsc0lBQXNJLFdBQVcsRUFBRSw4Q0FBOEMsV0FBVyxFQUFFLEVBQUUsZ0lBQWdJLHlCQUF5QixPQUFPLHlEQUF5RCxvREFBb0QsMEVBQTBFLE9BQU8saURBQWlELDZGQUE2RixrQ0FBa0MsT0FBTyw4SEFBOEgsNkJBQTZCLDhGQUE4RixLQUFLLEVBQUUsb0RBQW9ELElBQUk7O0FBRWxxRyxPQUFPO0FBQ1A7QUFDQSxDQUFDIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL3JlYWN0LW93bC1jYXJvdXNlbDMvbGliL093bENhcm91c2VsLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKFwicmVhY3RcIikpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoW1wicmVhY3RcIl0sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1wicmVhY3Qtb3dsLWNhcm91c2VsXCJdID0gZmFjdG9yeShyZXF1aXJlKFwicmVhY3RcIikpO1xuXHRlbHNlXG5cdFx0cm9vdFtcInJlYWN0LW93bC1jYXJvdXNlbFwiXSA9IGZhY3Rvcnkocm9vdFtcIlJlYWN0XCJdKTtcbn0pKHRoaXMsIGZ1bmN0aW9uKF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfMTJfXykge1xucmV0dXJuIC8qKioqKiovIChmdW5jdGlvbihtb2R1bGVzKSB7IC8vIHdlYnBhY2tCb290c3RyYXBcbi8qKioqKiovIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbi8qKioqKiovIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbi8qKioqKiovIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuLyoqKioqKi8gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4vKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuLyoqKioqKi8gXHRcdFx0aTogbW9kdWxlSWQsXG4vKioqKioqLyBcdFx0XHRsOiBmYWxzZSxcbi8qKioqKiovIFx0XHRcdGV4cG9ydHM6IHt9XG4vKioqKioqLyBcdFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4vKioqKioqLyBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbi8qKioqKiovIFx0XHRtb2R1bGUubCA9IHRydWU7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4vKioqKioqLyBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHR9XG4vKioqKioqL1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBpZGVudGl0eSBmdW5jdGlvbiBmb3IgY2FsbGluZyBoYXJtb255IGltcG9ydHMgd2l0aCB0aGUgY29ycmVjdCBjb250ZXh0XG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uaSA9IGZ1bmN0aW9uKHZhbHVlKSB7IHJldHVybiB2YWx1ZTsgfTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbi8qKioqKiovIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4vKioqKioqLyBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwge1xuLyoqKioqKi8gXHRcdFx0XHRjb25maWd1cmFibGU6IGZhbHNlLFxuLyoqKioqKi8gXHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuLyoqKioqKi8gXHRcdFx0XHRnZXQ6IGdldHRlclxuLyoqKioqKi8gXHRcdFx0fSk7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4vKioqKioqLyBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4vKioqKioqLyBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuLyoqKioqKi8gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4vKioqKioqLyBcdFx0cmV0dXJuIGdldHRlcjtcbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4vKioqKioqLyBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IDEzKTtcbi8qKioqKiovIH0pXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gKFtcbi8qIDAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuZXZhbChcIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcXG5cXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcXG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXFxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cXG5cXG52YXIgY2FjaGVkU2V0VGltZW91dDtcXG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xcblxcbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XFxuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xcbn1cXG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcXG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcXG59XFxuKGZ1bmN0aW9uICgpIHtcXG4gICAgdHJ5IHtcXG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcXG4gICAgICAgIH1cXG4gICAgfSBjYXRjaCAoZSkge1xcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XFxuICAgIH1cXG4gICAgdHJ5IHtcXG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XFxuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xcbiAgICAgICAgfVxcbiAgICB9IGNhdGNoIChlKSB7XFxuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xcbiAgICB9XFxufSAoKSlcXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXFxuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xcbiAgICB9XFxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XFxuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xcbiAgICB9XFxuICAgIHRyeSB7XFxuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXFxuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xcbiAgICB9IGNhdGNoKGUpe1xcbiAgICAgICAgdHJ5IHtcXG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XFxuICAgICAgICB9IGNhdGNoKGUpe1xcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xcbiAgICAgICAgfVxcbiAgICB9XFxuXFxuXFxufVxcbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcXG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XFxuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcXG4gICAgfVxcbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xcbiAgICB9XFxuICAgIHRyeSB7XFxuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXFxuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XFxuICAgIH0gY2F0Y2ggKGUpe1xcbiAgICAgICAgdHJ5IHtcXG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XFxuICAgICAgICB9IGNhdGNoIChlKXtcXG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XFxuICAgICAgICB9XFxuICAgIH1cXG5cXG5cXG5cXG59XFxudmFyIHF1ZXVlID0gW107XFxudmFyIGRyYWluaW5nID0gZmFsc2U7XFxudmFyIGN1cnJlbnRRdWV1ZTtcXG52YXIgcXVldWVJbmRleCA9IC0xO1xcblxcbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcXG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XFxuICAgICAgICByZXR1cm47XFxuICAgIH1cXG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcXG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcXG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XFxuICAgIH1cXG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xcbiAgICB9XFxufVxcblxcbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XFxuICAgIGlmIChkcmFpbmluZykge1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICB9XFxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xcbiAgICBkcmFpbmluZyA9IHRydWU7XFxuXFxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XFxuICAgIHdoaWxlKGxlbikge1xcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XFxuICAgICAgICBxdWV1ZSA9IFtdO1xcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcXG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcXG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcXG4gICAgfVxcbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XFxufVxcblxcbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XFxuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XFxuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xcbiAgICAgICAgfVxcbiAgICB9XFxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XFxuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XFxuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xcbiAgICB9XFxufTtcXG5cXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXFxuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XFxuICAgIHRoaXMuZnVuID0gZnVuO1xcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XFxufVxcbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcXG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XFxufTtcXG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XFxucHJvY2Vzcy5lbnYgPSB7fTtcXG5wcm9jZXNzLmFyZ3YgPSBbXTtcXG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcXG5wcm9jZXNzLnZlcnNpb25zID0ge307XFxuXFxuZnVuY3Rpb24gbm9vcCgpIHt9XFxuXFxucHJvY2Vzcy5vbiA9IG5vb3A7XFxucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XFxucHJvY2Vzcy5vbmNlID0gbm9vcDtcXG5wcm9jZXNzLm9mZiA9IG5vb3A7XFxucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XFxucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XFxucHJvY2Vzcy5wcmVwZW5kTGlzdGVuZXIgPSBub29wO1xcbnByb2Nlc3MucHJlcGVuZE9uY2VMaXN0ZW5lciA9IG5vb3A7XFxuXFxucHJvY2Vzcy5saXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gW10gfVxcblxcbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XFxuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcXG59O1xcblxcbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XFxucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcXG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcXG59O1xcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XFxuXFxuXFxuLy8vLy8vLy8vLy8vLy8vLy8vXFxuLy8gV0VCUEFDSyBGT09URVJcXG4vLyAuL34vbm9kZS1saWJzLWJyb3dzZXIvfi9wcm9jZXNzL2Jyb3dzZXIuanNcXG4vLyBtb2R1bGUgaWQgPSAwXFxuLy8gbW9kdWxlIGNodW5rcyA9IDBcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9+L25vZGUtbGlicy1icm93c2VyL34vcHJvY2Vzcy9icm93c2VyLmpzP1wiKTtcblxuLyoqKi8gfSksXG4vKiAxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbmV2YWwoXCJ2YXIgX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXywgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX187LyohXFxuICogalF1ZXJ5IEphdmFTY3JpcHQgTGlicmFyeSB2My4zLjFcXG4gKiBodHRwczovL2pxdWVyeS5jb20vXFxuICpcXG4gKiBJbmNsdWRlcyBTaXp6bGUuanNcXG4gKiBodHRwczovL3NpenpsZWpzLmNvbS9cXG4gKlxcbiAqIENvcHlyaWdodCBKUyBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcXG4gKiBodHRwczovL2pxdWVyeS5vcmcvbGljZW5zZVxcbiAqXFxuICogRGF0ZTogMjAxOC0wMS0yMFQxNzoyNFpcXG4gKi9cXG4oIGZ1bmN0aW9uKCBnbG9iYWwsIGZhY3RvcnkgKSB7XFxuXFxuXFx0XFxcInVzZSBzdHJpY3RcXFwiO1xcblxcblxcdGlmICggdHlwZW9mIG1vZHVsZSA9PT0gXFxcIm9iamVjdFxcXCIgJiYgdHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcXFwib2JqZWN0XFxcIiApIHtcXG5cXG5cXHRcXHQvLyBGb3IgQ29tbW9uSlMgYW5kIENvbW1vbkpTLWxpa2UgZW52aXJvbm1lbnRzIHdoZXJlIGEgcHJvcGVyIGB3aW5kb3dgXFxuXFx0XFx0Ly8gaXMgcHJlc2VudCwgZXhlY3V0ZSB0aGUgZmFjdG9yeSBhbmQgZ2V0IGpRdWVyeS5cXG5cXHRcXHQvLyBGb3IgZW52aXJvbm1lbnRzIHRoYXQgZG8gbm90IGhhdmUgYSBgd2luZG93YCB3aXRoIGEgYGRvY3VtZW50YFxcblxcdFxcdC8vIChzdWNoIGFzIE5vZGUuanMpLCBleHBvc2UgYSBmYWN0b3J5IGFzIG1vZHVsZS5leHBvcnRzLlxcblxcdFxcdC8vIFRoaXMgYWNjZW50dWF0ZXMgdGhlIG5lZWQgZm9yIHRoZSBjcmVhdGlvbiBvZiBhIHJlYWwgYHdpbmRvd2AuXFxuXFx0XFx0Ly8gZS5nLiB2YXIgalF1ZXJ5ID0gcmVxdWlyZShcXFwianF1ZXJ5XFxcIikod2luZG93KTtcXG5cXHRcXHQvLyBTZWUgdGlja2V0ICMxNDU0OSBmb3IgbW9yZSBpbmZvLlxcblxcdFxcdG1vZHVsZS5leHBvcnRzID0gZ2xvYmFsLmRvY3VtZW50ID9cXG5cXHRcXHRcXHRmYWN0b3J5KCBnbG9iYWwsIHRydWUgKSA6XFxuXFx0XFx0XFx0ZnVuY3Rpb24oIHcgKSB7XFxuXFx0XFx0XFx0XFx0aWYgKCAhdy5kb2N1bWVudCApIHtcXG5cXHRcXHRcXHRcXHRcXHR0aHJvdyBuZXcgRXJyb3IoIFxcXCJqUXVlcnkgcmVxdWlyZXMgYSB3aW5kb3cgd2l0aCBhIGRvY3VtZW50XFxcIiApO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRyZXR1cm4gZmFjdG9yeSggdyApO1xcblxcdFxcdFxcdH07XFxuXFx0fSBlbHNlIHtcXG5cXHRcXHRmYWN0b3J5KCBnbG9iYWwgKTtcXG5cXHR9XFxuXFxuLy8gUGFzcyB0aGlzIGlmIHdpbmRvdyBpcyBub3QgZGVmaW5lZCB5ZXRcXG59ICkoIHR5cGVvZiB3aW5kb3cgIT09IFxcXCJ1bmRlZmluZWRcXFwiID8gd2luZG93IDogdGhpcywgZnVuY3Rpb24oIHdpbmRvdywgbm9HbG9iYWwgKSB7XFxuXFxuLy8gRWRnZSA8PSAxMiAtIDEzKywgRmlyZWZveCA8PTE4IC0gNDUrLCBJRSAxMCAtIDExLCBTYWZhcmkgNS4xIC0gOSssIGlPUyA2IC0gOS4xXFxuLy8gdGhyb3cgZXhjZXB0aW9ucyB3aGVuIG5vbi1zdHJpY3QgY29kZSAoZS5nLiwgQVNQLk5FVCA0LjUpIGFjY2Vzc2VzIHN0cmljdCBtb2RlXFxuLy8gYXJndW1lbnRzLmNhbGxlZS5jYWxsZXIgKHRyYWMtMTMzMzUpLiBCdXQgYXMgb2YgalF1ZXJ5IDMuMCAoMjAxNiksIHN0cmljdCBtb2RlIHNob3VsZCBiZSBjb21tb25cXG4vLyBlbm91Z2ggdGhhdCBhbGwgc3VjaCBhdHRlbXB0cyBhcmUgZ3VhcmRlZCBpbiBhIHRyeSBibG9jay5cXG5cXFwidXNlIHN0cmljdFxcXCI7XFxuXFxudmFyIGFyciA9IFtdO1xcblxcbnZhciBkb2N1bWVudCA9IHdpbmRvdy5kb2N1bWVudDtcXG5cXG52YXIgZ2V0UHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XFxuXFxudmFyIHNsaWNlID0gYXJyLnNsaWNlO1xcblxcbnZhciBjb25jYXQgPSBhcnIuY29uY2F0O1xcblxcbnZhciBwdXNoID0gYXJyLnB1c2g7XFxuXFxudmFyIGluZGV4T2YgPSBhcnIuaW5kZXhPZjtcXG5cXG52YXIgY2xhc3MydHlwZSA9IHt9O1xcblxcbnZhciB0b1N0cmluZyA9IGNsYXNzMnR5cGUudG9TdHJpbmc7XFxuXFxudmFyIGhhc093biA9IGNsYXNzMnR5cGUuaGFzT3duUHJvcGVydHk7XFxuXFxudmFyIGZuVG9TdHJpbmcgPSBoYXNPd24udG9TdHJpbmc7XFxuXFxudmFyIE9iamVjdEZ1bmN0aW9uU3RyaW5nID0gZm5Ub1N0cmluZy5jYWxsKCBPYmplY3QgKTtcXG5cXG52YXIgc3VwcG9ydCA9IHt9O1xcblxcbnZhciBpc0Z1bmN0aW9uID0gZnVuY3Rpb24gaXNGdW5jdGlvbiggb2JqICkge1xcblxcbiAgICAgIC8vIFN1cHBvcnQ6IENocm9tZSA8PTU3LCBGaXJlZm94IDw9NTJcXG4gICAgICAvLyBJbiBzb21lIGJyb3dzZXJzLCB0eXBlb2YgcmV0dXJucyBcXFwiZnVuY3Rpb25cXFwiIGZvciBIVE1MIDxvYmplY3Q+IGVsZW1lbnRzXFxuICAgICAgLy8gKGkuZS4sIGB0eXBlb2YgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXFxcIm9iamVjdFxcXCIgKSA9PT0gXFxcImZ1bmN0aW9uXFxcImApLlxcbiAgICAgIC8vIFdlIGRvbid0IHdhbnQgdG8gY2xhc3NpZnkgKmFueSogRE9NIG5vZGUgYXMgYSBmdW5jdGlvbi5cXG4gICAgICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gXFxcImZ1bmN0aW9uXFxcIiAmJiB0eXBlb2Ygb2JqLm5vZGVUeXBlICE9PSBcXFwibnVtYmVyXFxcIjtcXG4gIH07XFxuXFxuXFxudmFyIGlzV2luZG93ID0gZnVuY3Rpb24gaXNXaW5kb3coIG9iaiApIHtcXG5cXHRcXHRyZXR1cm4gb2JqICE9IG51bGwgJiYgb2JqID09PSBvYmoud2luZG93O1xcblxcdH07XFxuXFxuXFxuXFxuXFxuXFx0dmFyIHByZXNlcnZlZFNjcmlwdEF0dHJpYnV0ZXMgPSB7XFxuXFx0XFx0dHlwZTogdHJ1ZSxcXG5cXHRcXHRzcmM6IHRydWUsXFxuXFx0XFx0bm9Nb2R1bGU6IHRydWVcXG5cXHR9O1xcblxcblxcdGZ1bmN0aW9uIERPTUV2YWwoIGNvZGUsIGRvYywgbm9kZSApIHtcXG5cXHRcXHRkb2MgPSBkb2MgfHwgZG9jdW1lbnQ7XFxuXFxuXFx0XFx0dmFyIGksXFxuXFx0XFx0XFx0c2NyaXB0ID0gZG9jLmNyZWF0ZUVsZW1lbnQoIFxcXCJzY3JpcHRcXFwiICk7XFxuXFxuXFx0XFx0c2NyaXB0LnRleHQgPSBjb2RlO1xcblxcdFxcdGlmICggbm9kZSApIHtcXG5cXHRcXHRcXHRmb3IgKCBpIGluIHByZXNlcnZlZFNjcmlwdEF0dHJpYnV0ZXMgKSB7XFxuXFx0XFx0XFx0XFx0aWYgKCBub2RlWyBpIF0gKSB7XFxuXFx0XFx0XFx0XFx0XFx0c2NyaXB0WyBpIF0gPSBub2RlWyBpIF07XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFx0XFx0ZG9jLmhlYWQuYXBwZW5kQ2hpbGQoIHNjcmlwdCApLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoIHNjcmlwdCApO1xcblxcdH1cXG5cXG5cXG5mdW5jdGlvbiB0b1R5cGUoIG9iaiApIHtcXG5cXHRpZiAoIG9iaiA9PSBudWxsICkge1xcblxcdFxcdHJldHVybiBvYmogKyBcXFwiXFxcIjtcXG5cXHR9XFxuXFxuXFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTIuMyBvbmx5IChmdW5jdGlvbmlzaCBSZWdFeHApXFxuXFx0cmV0dXJuIHR5cGVvZiBvYmogPT09IFxcXCJvYmplY3RcXFwiIHx8IHR5cGVvZiBvYmogPT09IFxcXCJmdW5jdGlvblxcXCIgP1xcblxcdFxcdGNsYXNzMnR5cGVbIHRvU3RyaW5nLmNhbGwoIG9iaiApIF0gfHwgXFxcIm9iamVjdFxcXCIgOlxcblxcdFxcdHR5cGVvZiBvYmo7XFxufVxcbi8qIGdsb2JhbCBTeW1ib2wgKi9cXG4vLyBEZWZpbmluZyB0aGlzIGdsb2JhbCBpbiAuZXNsaW50cmMuanNvbiB3b3VsZCBjcmVhdGUgYSBkYW5nZXIgb2YgdXNpbmcgdGhlIGdsb2JhbFxcbi8vIHVuZ3VhcmRlZCBpbiBhbm90aGVyIHBsYWNlLCBpdCBzZWVtcyBzYWZlciB0byBkZWZpbmUgZ2xvYmFsIG9ubHkgZm9yIHRoaXMgbW9kdWxlXFxuXFxuXFxuXFxudmFyXFxuXFx0dmVyc2lvbiA9IFxcXCIzLjMuMVxcXCIsXFxuXFxuXFx0Ly8gRGVmaW5lIGEgbG9jYWwgY29weSBvZiBqUXVlcnlcXG5cXHRqUXVlcnkgPSBmdW5jdGlvbiggc2VsZWN0b3IsIGNvbnRleHQgKSB7XFxuXFxuXFx0XFx0Ly8gVGhlIGpRdWVyeSBvYmplY3QgaXMgYWN0dWFsbHkganVzdCB0aGUgaW5pdCBjb25zdHJ1Y3RvciAnZW5oYW5jZWQnXFxuXFx0XFx0Ly8gTmVlZCBpbml0IGlmIGpRdWVyeSBpcyBjYWxsZWQgKGp1c3QgYWxsb3cgZXJyb3IgdG8gYmUgdGhyb3duIGlmIG5vdCBpbmNsdWRlZClcXG5cXHRcXHRyZXR1cm4gbmV3IGpRdWVyeS5mbi5pbml0KCBzZWxlY3RvciwgY29udGV4dCApO1xcblxcdH0sXFxuXFxuXFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5XFxuXFx0Ly8gTWFrZSBzdXJlIHdlIHRyaW0gQk9NIGFuZCBOQlNQXFxuXFx0cnRyaW0gPSAvXltcXFxcc1xcXFx1RkVGRlxcXFx4QTBdK3xbXFxcXHNcXFxcdUZFRkZcXFxceEEwXSskL2c7XFxuXFxualF1ZXJ5LmZuID0galF1ZXJ5LnByb3RvdHlwZSA9IHtcXG5cXG5cXHQvLyBUaGUgY3VycmVudCB2ZXJzaW9uIG9mIGpRdWVyeSBiZWluZyB1c2VkXFxuXFx0anF1ZXJ5OiB2ZXJzaW9uLFxcblxcblxcdGNvbnN0cnVjdG9yOiBqUXVlcnksXFxuXFxuXFx0Ly8gVGhlIGRlZmF1bHQgbGVuZ3RoIG9mIGEgalF1ZXJ5IG9iamVjdCBpcyAwXFxuXFx0bGVuZ3RoOiAwLFxcblxcblxcdHRvQXJyYXk6IGZ1bmN0aW9uKCkge1xcblxcdFxcdHJldHVybiBzbGljZS5jYWxsKCB0aGlzICk7XFxuXFx0fSxcXG5cXG5cXHQvLyBHZXQgdGhlIE50aCBlbGVtZW50IGluIHRoZSBtYXRjaGVkIGVsZW1lbnQgc2V0IE9SXFxuXFx0Ly8gR2V0IHRoZSB3aG9sZSBtYXRjaGVkIGVsZW1lbnQgc2V0IGFzIGEgY2xlYW4gYXJyYXlcXG5cXHRnZXQ6IGZ1bmN0aW9uKCBudW0gKSB7XFxuXFxuXFx0XFx0Ly8gUmV0dXJuIGFsbCB0aGUgZWxlbWVudHMgaW4gYSBjbGVhbiBhcnJheVxcblxcdFxcdGlmICggbnVtID09IG51bGwgKSB7XFxuXFx0XFx0XFx0cmV0dXJuIHNsaWNlLmNhbGwoIHRoaXMgKTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gUmV0dXJuIGp1c3QgdGhlIG9uZSBlbGVtZW50IGZyb20gdGhlIHNldFxcblxcdFxcdHJldHVybiBudW0gPCAwID8gdGhpc1sgbnVtICsgdGhpcy5sZW5ndGggXSA6IHRoaXNbIG51bSBdO1xcblxcdH0sXFxuXFxuXFx0Ly8gVGFrZSBhbiBhcnJheSBvZiBlbGVtZW50cyBhbmQgcHVzaCBpdCBvbnRvIHRoZSBzdGFja1xcblxcdC8vIChyZXR1cm5pbmcgdGhlIG5ldyBtYXRjaGVkIGVsZW1lbnQgc2V0KVxcblxcdHB1c2hTdGFjazogZnVuY3Rpb24oIGVsZW1zICkge1xcblxcblxcdFxcdC8vIEJ1aWxkIGEgbmV3IGpRdWVyeSBtYXRjaGVkIGVsZW1lbnQgc2V0XFxuXFx0XFx0dmFyIHJldCA9IGpRdWVyeS5tZXJnZSggdGhpcy5jb25zdHJ1Y3RvcigpLCBlbGVtcyApO1xcblxcblxcdFxcdC8vIEFkZCB0aGUgb2xkIG9iamVjdCBvbnRvIHRoZSBzdGFjayAoYXMgYSByZWZlcmVuY2UpXFxuXFx0XFx0cmV0LnByZXZPYmplY3QgPSB0aGlzO1xcblxcblxcdFxcdC8vIFJldHVybiB0aGUgbmV3bHktZm9ybWVkIGVsZW1lbnQgc2V0XFxuXFx0XFx0cmV0dXJuIHJldDtcXG5cXHR9LFxcblxcblxcdC8vIEV4ZWN1dGUgYSBjYWxsYmFjayBmb3IgZXZlcnkgZWxlbWVudCBpbiB0aGUgbWF0Y2hlZCBzZXQuXFxuXFx0ZWFjaDogZnVuY3Rpb24oIGNhbGxiYWNrICkge1xcblxcdFxcdHJldHVybiBqUXVlcnkuZWFjaCggdGhpcywgY2FsbGJhY2sgKTtcXG5cXHR9LFxcblxcblxcdG1hcDogZnVuY3Rpb24oIGNhbGxiYWNrICkge1xcblxcdFxcdHJldHVybiB0aGlzLnB1c2hTdGFjayggalF1ZXJ5Lm1hcCggdGhpcywgZnVuY3Rpb24oIGVsZW0sIGkgKSB7XFxuXFx0XFx0XFx0cmV0dXJuIGNhbGxiYWNrLmNhbGwoIGVsZW0sIGksIGVsZW0gKTtcXG5cXHRcXHR9ICkgKTtcXG5cXHR9LFxcblxcblxcdHNsaWNlOiBmdW5jdGlvbigpIHtcXG5cXHRcXHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIHNsaWNlLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKSApO1xcblxcdH0sXFxuXFxuXFx0Zmlyc3Q6IGZ1bmN0aW9uKCkge1xcblxcdFxcdHJldHVybiB0aGlzLmVxKCAwICk7XFxuXFx0fSxcXG5cXG5cXHRsYXN0OiBmdW5jdGlvbigpIHtcXG5cXHRcXHRyZXR1cm4gdGhpcy5lcSggLTEgKTtcXG5cXHR9LFxcblxcblxcdGVxOiBmdW5jdGlvbiggaSApIHtcXG5cXHRcXHR2YXIgbGVuID0gdGhpcy5sZW5ndGgsXFxuXFx0XFx0XFx0aiA9ICtpICsgKCBpIDwgMCA/IGxlbiA6IDAgKTtcXG5cXHRcXHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIGogPj0gMCAmJiBqIDwgbGVuID8gWyB0aGlzWyBqIF0gXSA6IFtdICk7XFxuXFx0fSxcXG5cXG5cXHRlbmQ6IGZ1bmN0aW9uKCkge1xcblxcdFxcdHJldHVybiB0aGlzLnByZXZPYmplY3QgfHwgdGhpcy5jb25zdHJ1Y3RvcigpO1xcblxcdH0sXFxuXFxuXFx0Ly8gRm9yIGludGVybmFsIHVzZSBvbmx5LlxcblxcdC8vIEJlaGF2ZXMgbGlrZSBhbiBBcnJheSdzIG1ldGhvZCwgbm90IGxpa2UgYSBqUXVlcnkgbWV0aG9kLlxcblxcdHB1c2g6IHB1c2gsXFxuXFx0c29ydDogYXJyLnNvcnQsXFxuXFx0c3BsaWNlOiBhcnIuc3BsaWNlXFxufTtcXG5cXG5qUXVlcnkuZXh0ZW5kID0galF1ZXJ5LmZuLmV4dGVuZCA9IGZ1bmN0aW9uKCkge1xcblxcdHZhciBvcHRpb25zLCBuYW1lLCBzcmMsIGNvcHksIGNvcHlJc0FycmF5LCBjbG9uZSxcXG5cXHRcXHR0YXJnZXQgPSBhcmd1bWVudHNbIDAgXSB8fCB7fSxcXG5cXHRcXHRpID0gMSxcXG5cXHRcXHRsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoLFxcblxcdFxcdGRlZXAgPSBmYWxzZTtcXG5cXG5cXHQvLyBIYW5kbGUgYSBkZWVwIGNvcHkgc2l0dWF0aW9uXFxuXFx0aWYgKCB0eXBlb2YgdGFyZ2V0ID09PSBcXFwiYm9vbGVhblxcXCIgKSB7XFxuXFx0XFx0ZGVlcCA9IHRhcmdldDtcXG5cXG5cXHRcXHQvLyBTa2lwIHRoZSBib29sZWFuIGFuZCB0aGUgdGFyZ2V0XFxuXFx0XFx0dGFyZ2V0ID0gYXJndW1lbnRzWyBpIF0gfHwge307XFxuXFx0XFx0aSsrO1xcblxcdH1cXG5cXG5cXHQvLyBIYW5kbGUgY2FzZSB3aGVuIHRhcmdldCBpcyBhIHN0cmluZyBvciBzb21ldGhpbmcgKHBvc3NpYmxlIGluIGRlZXAgY29weSlcXG5cXHRpZiAoIHR5cGVvZiB0YXJnZXQgIT09IFxcXCJvYmplY3RcXFwiICYmICFpc0Z1bmN0aW9uKCB0YXJnZXQgKSApIHtcXG5cXHRcXHR0YXJnZXQgPSB7fTtcXG5cXHR9XFxuXFxuXFx0Ly8gRXh0ZW5kIGpRdWVyeSBpdHNlbGYgaWYgb25seSBvbmUgYXJndW1lbnQgaXMgcGFzc2VkXFxuXFx0aWYgKCBpID09PSBsZW5ndGggKSB7XFxuXFx0XFx0dGFyZ2V0ID0gdGhpcztcXG5cXHRcXHRpLS07XFxuXFx0fVxcblxcblxcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkge1xcblxcblxcdFxcdC8vIE9ubHkgZGVhbCB3aXRoIG5vbi1udWxsL3VuZGVmaW5lZCB2YWx1ZXNcXG5cXHRcXHRpZiAoICggb3B0aW9ucyA9IGFyZ3VtZW50c1sgaSBdICkgIT0gbnVsbCApIHtcXG5cXG5cXHRcXHRcXHQvLyBFeHRlbmQgdGhlIGJhc2Ugb2JqZWN0XFxuXFx0XFx0XFx0Zm9yICggbmFtZSBpbiBvcHRpb25zICkge1xcblxcdFxcdFxcdFxcdHNyYyA9IHRhcmdldFsgbmFtZSBdO1xcblxcdFxcdFxcdFxcdGNvcHkgPSBvcHRpb25zWyBuYW1lIF07XFxuXFxuXFx0XFx0XFx0XFx0Ly8gUHJldmVudCBuZXZlci1lbmRpbmcgbG9vcFxcblxcdFxcdFxcdFxcdGlmICggdGFyZ2V0ID09PSBjb3B5ICkge1xcblxcdFxcdFxcdFxcdFxcdGNvbnRpbnVlO1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHQvLyBSZWN1cnNlIGlmIHdlJ3JlIG1lcmdpbmcgcGxhaW4gb2JqZWN0cyBvciBhcnJheXNcXG5cXHRcXHRcXHRcXHRpZiAoIGRlZXAgJiYgY29weSAmJiAoIGpRdWVyeS5pc1BsYWluT2JqZWN0KCBjb3B5ICkgfHxcXG5cXHRcXHRcXHRcXHRcXHQoIGNvcHlJc0FycmF5ID0gQXJyYXkuaXNBcnJheSggY29weSApICkgKSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRpZiAoIGNvcHlJc0FycmF5ICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGNvcHlJc0FycmF5ID0gZmFsc2U7XFxuXFx0XFx0XFx0XFx0XFx0XFx0Y2xvbmUgPSBzcmMgJiYgQXJyYXkuaXNBcnJheSggc3JjICkgPyBzcmMgOiBbXTtcXG5cXG5cXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdFxcdGNsb25lID0gc3JjICYmIGpRdWVyeS5pc1BsYWluT2JqZWN0KCBzcmMgKSA/IHNyYyA6IHt9O1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBOZXZlciBtb3ZlIG9yaWdpbmFsIG9iamVjdHMsIGNsb25lIHRoZW1cXG5cXHRcXHRcXHRcXHRcXHR0YXJnZXRbIG5hbWUgXSA9IGpRdWVyeS5leHRlbmQoIGRlZXAsIGNsb25lLCBjb3B5ICk7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gRG9uJ3QgYnJpbmcgaW4gdW5kZWZpbmVkIHZhbHVlc1xcblxcdFxcdFxcdFxcdH0gZWxzZSBpZiAoIGNvcHkgIT09IHVuZGVmaW5lZCApIHtcXG5cXHRcXHRcXHRcXHRcXHR0YXJnZXRbIG5hbWUgXSA9IGNvcHk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFx0fVxcblxcblxcdC8vIFJldHVybiB0aGUgbW9kaWZpZWQgb2JqZWN0XFxuXFx0cmV0dXJuIHRhcmdldDtcXG59O1xcblxcbmpRdWVyeS5leHRlbmQoIHtcXG5cXG5cXHQvLyBVbmlxdWUgZm9yIGVhY2ggY29weSBvZiBqUXVlcnkgb24gdGhlIHBhZ2VcXG5cXHRleHBhbmRvOiBcXFwialF1ZXJ5XFxcIiArICggdmVyc2lvbiArIE1hdGgucmFuZG9tKCkgKS5yZXBsYWNlKCAvXFxcXEQvZywgXFxcIlxcXCIgKSxcXG5cXG5cXHQvLyBBc3N1bWUgalF1ZXJ5IGlzIHJlYWR5IHdpdGhvdXQgdGhlIHJlYWR5IG1vZHVsZVxcblxcdGlzUmVhZHk6IHRydWUsXFxuXFxuXFx0ZXJyb3I6IGZ1bmN0aW9uKCBtc2cgKSB7XFxuXFx0XFx0dGhyb3cgbmV3IEVycm9yKCBtc2cgKTtcXG5cXHR9LFxcblxcblxcdG5vb3A6IGZ1bmN0aW9uKCkge30sXFxuXFxuXFx0aXNQbGFpbk9iamVjdDogZnVuY3Rpb24oIG9iaiApIHtcXG5cXHRcXHR2YXIgcHJvdG8sIEN0b3I7XFxuXFxuXFx0XFx0Ly8gRGV0ZWN0IG9idmlvdXMgbmVnYXRpdmVzXFxuXFx0XFx0Ly8gVXNlIHRvU3RyaW5nIGluc3RlYWQgb2YgalF1ZXJ5LnR5cGUgdG8gY2F0Y2ggaG9zdCBvYmplY3RzXFxuXFx0XFx0aWYgKCAhb2JqIHx8IHRvU3RyaW5nLmNhbGwoIG9iaiApICE9PSBcXFwiW29iamVjdCBPYmplY3RdXFxcIiApIHtcXG5cXHRcXHRcXHRyZXR1cm4gZmFsc2U7XFxuXFx0XFx0fVxcblxcblxcdFxcdHByb3RvID0gZ2V0UHJvdG8oIG9iaiApO1xcblxcblxcdFxcdC8vIE9iamVjdHMgd2l0aCBubyBwcm90b3R5cGUgKGUuZy4sIGBPYmplY3QuY3JlYXRlKCBudWxsIClgKSBhcmUgcGxhaW5cXG5cXHRcXHRpZiAoICFwcm90byApIHtcXG5cXHRcXHRcXHRyZXR1cm4gdHJ1ZTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gT2JqZWN0cyB3aXRoIHByb3RvdHlwZSBhcmUgcGxhaW4gaWZmIHRoZXkgd2VyZSBjb25zdHJ1Y3RlZCBieSBhIGdsb2JhbCBPYmplY3QgZnVuY3Rpb25cXG5cXHRcXHRDdG9yID0gaGFzT3duLmNhbGwoIHByb3RvLCBcXFwiY29uc3RydWN0b3JcXFwiICkgJiYgcHJvdG8uY29uc3RydWN0b3I7XFxuXFx0XFx0cmV0dXJuIHR5cGVvZiBDdG9yID09PSBcXFwiZnVuY3Rpb25cXFwiICYmIGZuVG9TdHJpbmcuY2FsbCggQ3RvciApID09PSBPYmplY3RGdW5jdGlvblN0cmluZztcXG5cXHR9LFxcblxcblxcdGlzRW1wdHlPYmplY3Q6IGZ1bmN0aW9uKCBvYmogKSB7XFxuXFxuXFx0XFx0LyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cXG5cXHRcXHQvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2VzbGludC9lc2xpbnQvaXNzdWVzLzYxMjVcXG5cXHRcXHR2YXIgbmFtZTtcXG5cXG5cXHRcXHRmb3IgKCBuYW1lIGluIG9iaiApIHtcXG5cXHRcXHRcXHRyZXR1cm4gZmFsc2U7XFxuXFx0XFx0fVxcblxcdFxcdHJldHVybiB0cnVlO1xcblxcdH0sXFxuXFxuXFx0Ly8gRXZhbHVhdGVzIGEgc2NyaXB0IGluIGEgZ2xvYmFsIGNvbnRleHRcXG5cXHRnbG9iYWxFdmFsOiBmdW5jdGlvbiggY29kZSApIHtcXG5cXHRcXHRET01FdmFsKCBjb2RlICk7XFxuXFx0fSxcXG5cXG5cXHRlYWNoOiBmdW5jdGlvbiggb2JqLCBjYWxsYmFjayApIHtcXG5cXHRcXHR2YXIgbGVuZ3RoLCBpID0gMDtcXG5cXG5cXHRcXHRpZiAoIGlzQXJyYXlMaWtlKCBvYmogKSApIHtcXG5cXHRcXHRcXHRsZW5ndGggPSBvYmoubGVuZ3RoO1xcblxcdFxcdFxcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkge1xcblxcdFxcdFxcdFxcdGlmICggY2FsbGJhY2suY2FsbCggb2JqWyBpIF0sIGksIG9ialsgaSBdICkgPT09IGZhbHNlICkge1xcblxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRmb3IgKCBpIGluIG9iaiApIHtcXG5cXHRcXHRcXHRcXHRpZiAoIGNhbGxiYWNrLmNhbGwoIG9ialsgaSBdLCBpLCBvYmpbIGkgXSApID09PSBmYWxzZSApIHtcXG5cXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXG5cXHRcXHRyZXR1cm4gb2JqO1xcblxcdH0sXFxuXFxuXFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5XFxuXFx0dHJpbTogZnVuY3Rpb24oIHRleHQgKSB7XFxuXFx0XFx0cmV0dXJuIHRleHQgPT0gbnVsbCA/XFxuXFx0XFx0XFx0XFxcIlxcXCIgOlxcblxcdFxcdFxcdCggdGV4dCArIFxcXCJcXFwiICkucmVwbGFjZSggcnRyaW0sIFxcXCJcXFwiICk7XFxuXFx0fSxcXG5cXG5cXHQvLyByZXN1bHRzIGlzIGZvciBpbnRlcm5hbCB1c2FnZSBvbmx5XFxuXFx0bWFrZUFycmF5OiBmdW5jdGlvbiggYXJyLCByZXN1bHRzICkge1xcblxcdFxcdHZhciByZXQgPSByZXN1bHRzIHx8IFtdO1xcblxcblxcdFxcdGlmICggYXJyICE9IG51bGwgKSB7XFxuXFx0XFx0XFx0aWYgKCBpc0FycmF5TGlrZSggT2JqZWN0KCBhcnIgKSApICkge1xcblxcdFxcdFxcdFxcdGpRdWVyeS5tZXJnZSggcmV0LFxcblxcdFxcdFxcdFxcdFxcdHR5cGVvZiBhcnIgPT09IFxcXCJzdHJpbmdcXFwiID9cXG5cXHRcXHRcXHRcXHRcXHRbIGFyciBdIDogYXJyXFxuXFx0XFx0XFx0XFx0KTtcXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdHB1c2guY2FsbCggcmV0LCBhcnIgKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcblxcdFxcdHJldHVybiByZXQ7XFxuXFx0fSxcXG5cXG5cXHRpbkFycmF5OiBmdW5jdGlvbiggZWxlbSwgYXJyLCBpICkge1xcblxcdFxcdHJldHVybiBhcnIgPT0gbnVsbCA/IC0xIDogaW5kZXhPZi5jYWxsKCBhcnIsIGVsZW0sIGkgKTtcXG5cXHR9LFxcblxcblxcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seSwgUGhhbnRvbUpTIDEgb25seVxcblxcdC8vIHB1c2guYXBwbHkoXywgYXJyYXlsaWtlKSB0aHJvd3Mgb24gYW5jaWVudCBXZWJLaXRcXG5cXHRtZXJnZTogZnVuY3Rpb24oIGZpcnN0LCBzZWNvbmQgKSB7XFxuXFx0XFx0dmFyIGxlbiA9ICtzZWNvbmQubGVuZ3RoLFxcblxcdFxcdFxcdGogPSAwLFxcblxcdFxcdFxcdGkgPSBmaXJzdC5sZW5ndGg7XFxuXFxuXFx0XFx0Zm9yICggOyBqIDwgbGVuOyBqKysgKSB7XFxuXFx0XFx0XFx0Zmlyc3RbIGkrKyBdID0gc2Vjb25kWyBqIF07XFxuXFx0XFx0fVxcblxcblxcdFxcdGZpcnN0Lmxlbmd0aCA9IGk7XFxuXFxuXFx0XFx0cmV0dXJuIGZpcnN0O1xcblxcdH0sXFxuXFxuXFx0Z3JlcDogZnVuY3Rpb24oIGVsZW1zLCBjYWxsYmFjaywgaW52ZXJ0ICkge1xcblxcdFxcdHZhciBjYWxsYmFja0ludmVyc2UsXFxuXFx0XFx0XFx0bWF0Y2hlcyA9IFtdLFxcblxcdFxcdFxcdGkgPSAwLFxcblxcdFxcdFxcdGxlbmd0aCA9IGVsZW1zLmxlbmd0aCxcXG5cXHRcXHRcXHRjYWxsYmFja0V4cGVjdCA9ICFpbnZlcnQ7XFxuXFxuXFx0XFx0Ly8gR28gdGhyb3VnaCB0aGUgYXJyYXksIG9ubHkgc2F2aW5nIHRoZSBpdGVtc1xcblxcdFxcdC8vIHRoYXQgcGFzcyB0aGUgdmFsaWRhdG9yIGZ1bmN0aW9uXFxuXFx0XFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XFxuXFx0XFx0XFx0Y2FsbGJhY2tJbnZlcnNlID0gIWNhbGxiYWNrKCBlbGVtc1sgaSBdLCBpICk7XFxuXFx0XFx0XFx0aWYgKCBjYWxsYmFja0ludmVyc2UgIT09IGNhbGxiYWNrRXhwZWN0ICkge1xcblxcdFxcdFxcdFxcdG1hdGNoZXMucHVzaCggZWxlbXNbIGkgXSApO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFxuXFx0XFx0cmV0dXJuIG1hdGNoZXM7XFxuXFx0fSxcXG5cXG5cXHQvLyBhcmcgaXMgZm9yIGludGVybmFsIHVzYWdlIG9ubHlcXG5cXHRtYXA6IGZ1bmN0aW9uKCBlbGVtcywgY2FsbGJhY2ssIGFyZyApIHtcXG5cXHRcXHR2YXIgbGVuZ3RoLCB2YWx1ZSxcXG5cXHRcXHRcXHRpID0gMCxcXG5cXHRcXHRcXHRyZXQgPSBbXTtcXG5cXG5cXHRcXHQvLyBHbyB0aHJvdWdoIHRoZSBhcnJheSwgdHJhbnNsYXRpbmcgZWFjaCBvZiB0aGUgaXRlbXMgdG8gdGhlaXIgbmV3IHZhbHVlc1xcblxcdFxcdGlmICggaXNBcnJheUxpa2UoIGVsZW1zICkgKSB7XFxuXFx0XFx0XFx0bGVuZ3RoID0gZWxlbXMubGVuZ3RoO1xcblxcdFxcdFxcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkge1xcblxcdFxcdFxcdFxcdHZhbHVlID0gY2FsbGJhY2soIGVsZW1zWyBpIF0sIGksIGFyZyApO1xcblxcblxcdFxcdFxcdFxcdGlmICggdmFsdWUgIT0gbnVsbCApIHtcXG5cXHRcXHRcXHRcXHRcXHRyZXQucHVzaCggdmFsdWUgKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdC8vIEdvIHRocm91Z2ggZXZlcnkga2V5IG9uIHRoZSBvYmplY3QsXFxuXFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRmb3IgKCBpIGluIGVsZW1zICkge1xcblxcdFxcdFxcdFxcdHZhbHVlID0gY2FsbGJhY2soIGVsZW1zWyBpIF0sIGksIGFyZyApO1xcblxcblxcdFxcdFxcdFxcdGlmICggdmFsdWUgIT0gbnVsbCApIHtcXG5cXHRcXHRcXHRcXHRcXHRyZXQucHVzaCggdmFsdWUgKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBGbGF0dGVuIGFueSBuZXN0ZWQgYXJyYXlzXFxuXFx0XFx0cmV0dXJuIGNvbmNhdC5hcHBseSggW10sIHJldCApO1xcblxcdH0sXFxuXFxuXFx0Ly8gQSBnbG9iYWwgR1VJRCBjb3VudGVyIGZvciBvYmplY3RzXFxuXFx0Z3VpZDogMSxcXG5cXG5cXHQvLyBqUXVlcnkuc3VwcG9ydCBpcyBub3QgdXNlZCBpbiBDb3JlIGJ1dCBvdGhlciBwcm9qZWN0cyBhdHRhY2ggdGhlaXJcXG5cXHQvLyBwcm9wZXJ0aWVzIHRvIGl0IHNvIGl0IG5lZWRzIHRvIGV4aXN0LlxcblxcdHN1cHBvcnQ6IHN1cHBvcnRcXG59ICk7XFxuXFxuaWYgKCB0eXBlb2YgU3ltYm9sID09PSBcXFwiZnVuY3Rpb25cXFwiICkge1xcblxcdGpRdWVyeS5mblsgU3ltYm9sLml0ZXJhdG9yIF0gPSBhcnJbIFN5bWJvbC5pdGVyYXRvciBdO1xcbn1cXG5cXG4vLyBQb3B1bGF0ZSB0aGUgY2xhc3MydHlwZSBtYXBcXG5qUXVlcnkuZWFjaCggXFxcIkJvb2xlYW4gTnVtYmVyIFN0cmluZyBGdW5jdGlvbiBBcnJheSBEYXRlIFJlZ0V4cCBPYmplY3QgRXJyb3IgU3ltYm9sXFxcIi5zcGxpdCggXFxcIiBcXFwiICksXFxuZnVuY3Rpb24oIGksIG5hbWUgKSB7XFxuXFx0Y2xhc3MydHlwZVsgXFxcIltvYmplY3QgXFxcIiArIG5hbWUgKyBcXFwiXVxcXCIgXSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcXG59ICk7XFxuXFxuZnVuY3Rpb24gaXNBcnJheUxpa2UoIG9iaiApIHtcXG5cXG5cXHQvLyBTdXBwb3J0OiByZWFsIGlPUyA4LjIgb25seSAobm90IHJlcHJvZHVjaWJsZSBpbiBzaW11bGF0b3IpXFxuXFx0Ly8gYGluYCBjaGVjayB1c2VkIHRvIHByZXZlbnQgSklUIGVycm9yIChnaC0yMTQ1KVxcblxcdC8vIGhhc093biBpc24ndCB1c2VkIGhlcmUgZHVlIHRvIGZhbHNlIG5lZ2F0aXZlc1xcblxcdC8vIHJlZ2FyZGluZyBOb2RlbGlzdCBsZW5ndGggaW4gSUVcXG5cXHR2YXIgbGVuZ3RoID0gISFvYmogJiYgXFxcImxlbmd0aFxcXCIgaW4gb2JqICYmIG9iai5sZW5ndGgsXFxuXFx0XFx0dHlwZSA9IHRvVHlwZSggb2JqICk7XFxuXFxuXFx0aWYgKCBpc0Z1bmN0aW9uKCBvYmogKSB8fCBpc1dpbmRvdyggb2JqICkgKSB7XFxuXFx0XFx0cmV0dXJuIGZhbHNlO1xcblxcdH1cXG5cXG5cXHRyZXR1cm4gdHlwZSA9PT0gXFxcImFycmF5XFxcIiB8fCBsZW5ndGggPT09IDAgfHxcXG5cXHRcXHR0eXBlb2YgbGVuZ3RoID09PSBcXFwibnVtYmVyXFxcIiAmJiBsZW5ndGggPiAwICYmICggbGVuZ3RoIC0gMSApIGluIG9iajtcXG59XFxudmFyIFNpenpsZSA9XFxuLyohXFxuICogU2l6emxlIENTUyBTZWxlY3RvciBFbmdpbmUgdjIuMy4zXFxuICogaHR0cHM6Ly9zaXp6bGVqcy5jb20vXFxuICpcXG4gKiBDb3B5cmlnaHQgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxcbiAqIGh0dHA6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcXG4gKlxcbiAqIERhdGU6IDIwMTYtMDgtMDhcXG4gKi9cXG4oZnVuY3Rpb24oIHdpbmRvdyApIHtcXG5cXG52YXIgaSxcXG5cXHRzdXBwb3J0LFxcblxcdEV4cHIsXFxuXFx0Z2V0VGV4dCxcXG5cXHRpc1hNTCxcXG5cXHR0b2tlbml6ZSxcXG5cXHRjb21waWxlLFxcblxcdHNlbGVjdCxcXG5cXHRvdXRlcm1vc3RDb250ZXh0LFxcblxcdHNvcnRJbnB1dCxcXG5cXHRoYXNEdXBsaWNhdGUsXFxuXFxuXFx0Ly8gTG9jYWwgZG9jdW1lbnQgdmFyc1xcblxcdHNldERvY3VtZW50LFxcblxcdGRvY3VtZW50LFxcblxcdGRvY0VsZW0sXFxuXFx0ZG9jdW1lbnRJc0hUTUwsXFxuXFx0cmJ1Z2d5UVNBLFxcblxcdHJidWdneU1hdGNoZXMsXFxuXFx0bWF0Y2hlcyxcXG5cXHRjb250YWlucyxcXG5cXG5cXHQvLyBJbnN0YW5jZS1zcGVjaWZpYyBkYXRhXFxuXFx0ZXhwYW5kbyA9IFxcXCJzaXp6bGVcXFwiICsgMSAqIG5ldyBEYXRlKCksXFxuXFx0cHJlZmVycmVkRG9jID0gd2luZG93LmRvY3VtZW50LFxcblxcdGRpcnJ1bnMgPSAwLFxcblxcdGRvbmUgPSAwLFxcblxcdGNsYXNzQ2FjaGUgPSBjcmVhdGVDYWNoZSgpLFxcblxcdHRva2VuQ2FjaGUgPSBjcmVhdGVDYWNoZSgpLFxcblxcdGNvbXBpbGVyQ2FjaGUgPSBjcmVhdGVDYWNoZSgpLFxcblxcdHNvcnRPcmRlciA9IGZ1bmN0aW9uKCBhLCBiICkge1xcblxcdFxcdGlmICggYSA9PT0gYiApIHtcXG5cXHRcXHRcXHRoYXNEdXBsaWNhdGUgPSB0cnVlO1xcblxcdFxcdH1cXG5cXHRcXHRyZXR1cm4gMDtcXG5cXHR9LFxcblxcblxcdC8vIEluc3RhbmNlIG1ldGhvZHNcXG5cXHRoYXNPd24gPSAoe30pLmhhc093blByb3BlcnR5LFxcblxcdGFyciA9IFtdLFxcblxcdHBvcCA9IGFyci5wb3AsXFxuXFx0cHVzaF9uYXRpdmUgPSBhcnIucHVzaCxcXG5cXHRwdXNoID0gYXJyLnB1c2gsXFxuXFx0c2xpY2UgPSBhcnIuc2xpY2UsXFxuXFx0Ly8gVXNlIGEgc3RyaXBwZWQtZG93biBpbmRleE9mIGFzIGl0J3MgZmFzdGVyIHRoYW4gbmF0aXZlXFxuXFx0Ly8gaHR0cHM6Ly9qc3BlcmYuY29tL3Rob3ItaW5kZXhvZi12cy1mb3IvNVxcblxcdGluZGV4T2YgPSBmdW5jdGlvbiggbGlzdCwgZWxlbSApIHtcXG5cXHRcXHR2YXIgaSA9IDAsXFxuXFx0XFx0XFx0bGVuID0gbGlzdC5sZW5ndGg7XFxuXFx0XFx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XFxuXFx0XFx0XFx0aWYgKCBsaXN0W2ldID09PSBlbGVtICkge1xcblxcdFxcdFxcdFxcdHJldHVybiBpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFx0XFx0cmV0dXJuIC0xO1xcblxcdH0sXFxuXFxuXFx0Ym9vbGVhbnMgPSBcXFwiY2hlY2tlZHxzZWxlY3RlZHxhc3luY3xhdXRvZm9jdXN8YXV0b3BsYXl8Y29udHJvbHN8ZGVmZXJ8ZGlzYWJsZWR8aGlkZGVufGlzbWFwfGxvb3B8bXVsdGlwbGV8b3BlbnxyZWFkb25seXxyZXF1aXJlZHxzY29wZWRcXFwiLFxcblxcblxcdC8vIFJlZ3VsYXIgZXhwcmVzc2lvbnNcXG5cXG5cXHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9jc3MzLXNlbGVjdG9ycy8jd2hpdGVzcGFjZVxcblxcdHdoaXRlc3BhY2UgPSBcXFwiW1xcXFxcXFxceDIwXFxcXFxcXFx0XFxcXFxcXFxyXFxcXFxcXFxuXFxcXFxcXFxmXVxcXCIsXFxuXFxuXFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvQ1NTMjEvc3luZGF0YS5odG1sI3ZhbHVlLWRlZi1pZGVudGlmaWVyXFxuXFx0aWRlbnRpZmllciA9IFxcXCIoPzpcXFxcXFxcXFxcXFxcXFxcLnxbXFxcXFxcXFx3LV18W15cXFxcMC1cXFxcXFxcXHhhMF0pK1xcXCIsXFxuXFxuXFx0Ly8gQXR0cmlidXRlIHNlbGVjdG9yczogaHR0cDovL3d3dy53My5vcmcvVFIvc2VsZWN0b3JzLyNhdHRyaWJ1dGUtc2VsZWN0b3JzXFxuXFx0YXR0cmlidXRlcyA9IFxcXCJcXFxcXFxcXFtcXFwiICsgd2hpdGVzcGFjZSArIFxcXCIqKFxcXCIgKyBpZGVudGlmaWVyICsgXFxcIikoPzpcXFwiICsgd2hpdGVzcGFjZSArXFxuXFx0XFx0Ly8gT3BlcmF0b3IgKGNhcHR1cmUgMilcXG5cXHRcXHRcXFwiKihbKl4kfCF+XT89KVxcXCIgKyB3aGl0ZXNwYWNlICtcXG5cXHRcXHQvLyBcXFwiQXR0cmlidXRlIHZhbHVlcyBtdXN0IGJlIENTUyBpZGVudGlmaWVycyBbY2FwdHVyZSA1XSBvciBzdHJpbmdzIFtjYXB0dXJlIDMgb3IgY2FwdHVyZSA0XVxcXCJcXG5cXHRcXHRcXFwiKig/OicoKD86XFxcXFxcXFxcXFxcXFxcXC58W15cXFxcXFxcXFxcXFxcXFxcJ10pKiknfFxcXFxcXFwiKCg/OlxcXFxcXFxcXFxcXFxcXFwufFteXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFwiXSkqKVxcXFxcXFwifChcXFwiICsgaWRlbnRpZmllciArIFxcXCIpKXwpXFxcIiArIHdoaXRlc3BhY2UgK1xcblxcdFxcdFxcXCIqXFxcXFxcXFxdXFxcIixcXG5cXG5cXHRwc2V1ZG9zID0gXFxcIjooXFxcIiArIGlkZW50aWZpZXIgKyBcXFwiKSg/OlxcXFxcXFxcKChcXFwiICtcXG5cXHRcXHQvLyBUbyByZWR1Y2UgdGhlIG51bWJlciBvZiBzZWxlY3RvcnMgbmVlZGluZyB0b2tlbml6ZSBpbiB0aGUgcHJlRmlsdGVyLCBwcmVmZXIgYXJndW1lbnRzOlxcblxcdFxcdC8vIDEuIHF1b3RlZCAoY2FwdHVyZSAzOyBjYXB0dXJlIDQgb3IgY2FwdHVyZSA1KVxcblxcdFxcdFxcXCIoJygoPzpcXFxcXFxcXFxcXFxcXFxcLnxbXlxcXFxcXFxcXFxcXFxcXFwnXSkqKSd8XFxcXFxcXCIoKD86XFxcXFxcXFxcXFxcXFxcXC58W15cXFxcXFxcXFxcXFxcXFxcXFxcXFxcXCJdKSopXFxcXFxcXCIpfFxcXCIgK1xcblxcdFxcdC8vIDIuIHNpbXBsZSAoY2FwdHVyZSA2KVxcblxcdFxcdFxcXCIoKD86XFxcXFxcXFxcXFxcXFxcXC58W15cXFxcXFxcXFxcXFxcXFxcKClbXFxcXFxcXFxdXXxcXFwiICsgYXR0cmlidXRlcyArIFxcXCIpKil8XFxcIiArXFxuXFx0XFx0Ly8gMy4gYW55dGhpbmcgZWxzZSAoY2FwdHVyZSAyKVxcblxcdFxcdFxcXCIuKlxcXCIgK1xcblxcdFxcdFxcXCIpXFxcXFxcXFwpfClcXFwiLFxcblxcblxcdC8vIExlYWRpbmcgYW5kIG5vbi1lc2NhcGVkIHRyYWlsaW5nIHdoaXRlc3BhY2UsIGNhcHR1cmluZyBzb21lIG5vbi13aGl0ZXNwYWNlIGNoYXJhY3RlcnMgcHJlY2VkaW5nIHRoZSBsYXR0ZXJcXG5cXHRyd2hpdGVzcGFjZSA9IG5ldyBSZWdFeHAoIHdoaXRlc3BhY2UgKyBcXFwiK1xcXCIsIFxcXCJnXFxcIiApLFxcblxcdHJ0cmltID0gbmV3IFJlZ0V4cCggXFxcIl5cXFwiICsgd2hpdGVzcGFjZSArIFxcXCIrfCgoPzpefFteXFxcXFxcXFxcXFxcXFxcXF0pKD86XFxcXFxcXFxcXFxcXFxcXC4pKilcXFwiICsgd2hpdGVzcGFjZSArIFxcXCIrJFxcXCIsIFxcXCJnXFxcIiApLFxcblxcblxcdHJjb21tYSA9IG5ldyBSZWdFeHAoIFxcXCJeXFxcIiArIHdoaXRlc3BhY2UgKyBcXFwiKixcXFwiICsgd2hpdGVzcGFjZSArIFxcXCIqXFxcIiApLFxcblxcdHJjb21iaW5hdG9ycyA9IG5ldyBSZWdFeHAoIFxcXCJeXFxcIiArIHdoaXRlc3BhY2UgKyBcXFwiKihbPit+XXxcXFwiICsgd2hpdGVzcGFjZSArIFxcXCIpXFxcIiArIHdoaXRlc3BhY2UgKyBcXFwiKlxcXCIgKSxcXG5cXG5cXHRyYXR0cmlidXRlUXVvdGVzID0gbmV3IFJlZ0V4cCggXFxcIj1cXFwiICsgd2hpdGVzcGFjZSArIFxcXCIqKFteXFxcXFxcXFxdJ1xcXFxcXFwiXSo/KVxcXCIgKyB3aGl0ZXNwYWNlICsgXFxcIipcXFxcXFxcXF1cXFwiLCBcXFwiZ1xcXCIgKSxcXG5cXG5cXHRycHNldWRvID0gbmV3IFJlZ0V4cCggcHNldWRvcyApLFxcblxcdHJpZGVudGlmaWVyID0gbmV3IFJlZ0V4cCggXFxcIl5cXFwiICsgaWRlbnRpZmllciArIFxcXCIkXFxcIiApLFxcblxcblxcdG1hdGNoRXhwciA9IHtcXG5cXHRcXHRcXFwiSURcXFwiOiBuZXcgUmVnRXhwKCBcXFwiXiMoXFxcIiArIGlkZW50aWZpZXIgKyBcXFwiKVxcXCIgKSxcXG5cXHRcXHRcXFwiQ0xBU1NcXFwiOiBuZXcgUmVnRXhwKCBcXFwiXlxcXFxcXFxcLihcXFwiICsgaWRlbnRpZmllciArIFxcXCIpXFxcIiApLFxcblxcdFxcdFxcXCJUQUdcXFwiOiBuZXcgUmVnRXhwKCBcXFwiXihcXFwiICsgaWRlbnRpZmllciArIFxcXCJ8WypdKVxcXCIgKSxcXG5cXHRcXHRcXFwiQVRUUlxcXCI6IG5ldyBSZWdFeHAoIFxcXCJeXFxcIiArIGF0dHJpYnV0ZXMgKSxcXG5cXHRcXHRcXFwiUFNFVURPXFxcIjogbmV3IFJlZ0V4cCggXFxcIl5cXFwiICsgcHNldWRvcyApLFxcblxcdFxcdFxcXCJDSElMRFxcXCI6IG5ldyBSZWdFeHAoIFxcXCJeOihvbmx5fGZpcnN0fGxhc3R8bnRofG50aC1sYXN0KS0oY2hpbGR8b2YtdHlwZSkoPzpcXFxcXFxcXChcXFwiICsgd2hpdGVzcGFjZSArXFxuXFx0XFx0XFx0XFxcIiooZXZlbnxvZGR8KChbKy1dfCkoXFxcXFxcXFxkKilufClcXFwiICsgd2hpdGVzcGFjZSArIFxcXCIqKD86KFsrLV18KVxcXCIgKyB3aGl0ZXNwYWNlICtcXG5cXHRcXHRcXHRcXFwiKihcXFxcXFxcXGQrKXwpKVxcXCIgKyB3aGl0ZXNwYWNlICsgXFxcIipcXFxcXFxcXCl8KVxcXCIsIFxcXCJpXFxcIiApLFxcblxcdFxcdFxcXCJib29sXFxcIjogbmV3IFJlZ0V4cCggXFxcIl4oPzpcXFwiICsgYm9vbGVhbnMgKyBcXFwiKSRcXFwiLCBcXFwiaVxcXCIgKSxcXG5cXHRcXHQvLyBGb3IgdXNlIGluIGxpYnJhcmllcyBpbXBsZW1lbnRpbmcgLmlzKClcXG5cXHRcXHQvLyBXZSB1c2UgdGhpcyBmb3IgUE9TIG1hdGNoaW5nIGluIGBzZWxlY3RgXFxuXFx0XFx0XFxcIm5lZWRzQ29udGV4dFxcXCI6IG5ldyBSZWdFeHAoIFxcXCJeXFxcIiArIHdoaXRlc3BhY2UgKyBcXFwiKls+K35dfDooZXZlbnxvZGR8ZXF8Z3R8bHR8bnRofGZpcnN0fGxhc3QpKD86XFxcXFxcXFwoXFxcIiArXFxuXFx0XFx0XFx0d2hpdGVzcGFjZSArIFxcXCIqKCg/Oi1cXFxcXFxcXGQpP1xcXFxcXFxcZCopXFxcIiArIHdoaXRlc3BhY2UgKyBcXFwiKlxcXFxcXFxcKXwpKD89W14tXXwkKVxcXCIsIFxcXCJpXFxcIiApXFxuXFx0fSxcXG5cXG5cXHRyaW5wdXRzID0gL14oPzppbnB1dHxzZWxlY3R8dGV4dGFyZWF8YnV0dG9uKSQvaSxcXG5cXHRyaGVhZGVyID0gL15oXFxcXGQkL2ksXFxuXFxuXFx0cm5hdGl2ZSA9IC9eW157XStcXFxce1xcXFxzKlxcXFxbbmF0aXZlIFxcXFx3LyxcXG5cXG5cXHQvLyBFYXNpbHktcGFyc2VhYmxlL3JldHJpZXZhYmxlIElEIG9yIFRBRyBvciBDTEFTUyBzZWxlY3RvcnNcXG5cXHRycXVpY2tFeHByID0gL14oPzojKFtcXFxcdy1dKyl8KFxcXFx3Kyl8XFxcXC4oW1xcXFx3LV0rKSkkLyxcXG5cXG5cXHRyc2libGluZyA9IC9bK35dLyxcXG5cXG5cXHQvLyBDU1MgZXNjYXBlc1xcblxcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL0NTUzIxL3N5bmRhdGEuaHRtbCNlc2NhcGVkLWNoYXJhY3RlcnNcXG5cXHRydW5lc2NhcGUgPSBuZXcgUmVnRXhwKCBcXFwiXFxcXFxcXFxcXFxcXFxcXChbXFxcXFxcXFxkYS1mXXsxLDZ9XFxcIiArIHdoaXRlc3BhY2UgKyBcXFwiP3woXFxcIiArIHdoaXRlc3BhY2UgKyBcXFwiKXwuKVxcXCIsIFxcXCJpZ1xcXCIgKSxcXG5cXHRmdW5lc2NhcGUgPSBmdW5jdGlvbiggXywgZXNjYXBlZCwgZXNjYXBlZFdoaXRlc3BhY2UgKSB7XFxuXFx0XFx0dmFyIGhpZ2ggPSBcXFwiMHhcXFwiICsgZXNjYXBlZCAtIDB4MTAwMDA7XFxuXFx0XFx0Ly8gTmFOIG1lYW5zIG5vbi1jb2RlcG9pbnRcXG5cXHRcXHQvLyBTdXBwb3J0OiBGaXJlZm94PDI0XFxuXFx0XFx0Ly8gV29ya2Fyb3VuZCBlcnJvbmVvdXMgbnVtZXJpYyBpbnRlcnByZXRhdGlvbiBvZiArXFxcIjB4XFxcIlxcblxcdFxcdHJldHVybiBoaWdoICE9PSBoaWdoIHx8IGVzY2FwZWRXaGl0ZXNwYWNlID9cXG5cXHRcXHRcXHRlc2NhcGVkIDpcXG5cXHRcXHRcXHRoaWdoIDwgMCA/XFxuXFx0XFx0XFx0XFx0Ly8gQk1QIGNvZGVwb2ludFxcblxcdFxcdFxcdFxcdFN0cmluZy5mcm9tQ2hhckNvZGUoIGhpZ2ggKyAweDEwMDAwICkgOlxcblxcdFxcdFxcdFxcdC8vIFN1cHBsZW1lbnRhbCBQbGFuZSBjb2RlcG9pbnQgKHN1cnJvZ2F0ZSBwYWlyKVxcblxcdFxcdFxcdFxcdFN0cmluZy5mcm9tQ2hhckNvZGUoIGhpZ2ggPj4gMTAgfCAweEQ4MDAsIGhpZ2ggJiAweDNGRiB8IDB4REMwMCApO1xcblxcdH0sXFxuXFxuXFx0Ly8gQ1NTIHN0cmluZy9pZGVudGlmaWVyIHNlcmlhbGl6YXRpb25cXG5cXHQvLyBodHRwczovL2RyYWZ0cy5jc3N3Zy5vcmcvY3Nzb20vI2NvbW1vbi1zZXJpYWxpemluZy1pZGlvbXNcXG5cXHRyY3NzZXNjYXBlID0gLyhbXFxcXDAtXFxcXHgxZlxcXFx4N2ZdfF4tP1xcXFxkKXxeLSR8W15cXFxcMC1cXFxceDFmXFxcXHg3Zi1cXFxcdUZGRkZcXFxcdy1dL2csXFxuXFx0ZmNzc2VzY2FwZSA9IGZ1bmN0aW9uKCBjaCwgYXNDb2RlUG9pbnQgKSB7XFxuXFx0XFx0aWYgKCBhc0NvZGVQb2ludCApIHtcXG5cXG5cXHRcXHRcXHQvLyBVKzAwMDAgTlVMTCBiZWNvbWVzIFUrRkZGRCBSRVBMQUNFTUVOVCBDSEFSQUNURVJcXG5cXHRcXHRcXHRpZiAoIGNoID09PSBcXFwiXFxcXDBcXFwiICkge1xcblxcdFxcdFxcdFxcdHJldHVybiBcXFwiXFxcXHVGRkZEXFxcIjtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gQ29udHJvbCBjaGFyYWN0ZXJzIGFuZCAoZGVwZW5kZW50IHVwb24gcG9zaXRpb24pIG51bWJlcnMgZ2V0IGVzY2FwZWQgYXMgY29kZSBwb2ludHNcXG5cXHRcXHRcXHRyZXR1cm4gY2guc2xpY2UoIDAsIC0xICkgKyBcXFwiXFxcXFxcXFxcXFwiICsgY2guY2hhckNvZGVBdCggY2gubGVuZ3RoIC0gMSApLnRvU3RyaW5nKCAxNiApICsgXFxcIiBcXFwiO1xcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBPdGhlciBwb3RlbnRpYWxseS1zcGVjaWFsIEFTQ0lJIGNoYXJhY3RlcnMgZ2V0IGJhY2tzbGFzaC1lc2NhcGVkXFxuXFx0XFx0cmV0dXJuIFxcXCJcXFxcXFxcXFxcXCIgKyBjaDtcXG5cXHR9LFxcblxcblxcdC8vIFVzZWQgZm9yIGlmcmFtZXNcXG5cXHQvLyBTZWUgc2V0RG9jdW1lbnQoKVxcblxcdC8vIFJlbW92aW5nIHRoZSBmdW5jdGlvbiB3cmFwcGVyIGNhdXNlcyBhIFxcXCJQZXJtaXNzaW9uIERlbmllZFxcXCJcXG5cXHQvLyBlcnJvciBpbiBJRVxcblxcdHVubG9hZEhhbmRsZXIgPSBmdW5jdGlvbigpIHtcXG5cXHRcXHRzZXREb2N1bWVudCgpO1xcblxcdH0sXFxuXFxuXFx0ZGlzYWJsZWRBbmNlc3RvciA9IGFkZENvbWJpbmF0b3IoXFxuXFx0XFx0ZnVuY3Rpb24oIGVsZW0gKSB7XFxuXFx0XFx0XFx0cmV0dXJuIGVsZW0uZGlzYWJsZWQgPT09IHRydWUgJiYgKFxcXCJmb3JtXFxcIiBpbiBlbGVtIHx8IFxcXCJsYWJlbFxcXCIgaW4gZWxlbSk7XFxuXFx0XFx0fSxcXG5cXHRcXHR7IGRpcjogXFxcInBhcmVudE5vZGVcXFwiLCBuZXh0OiBcXFwibGVnZW5kXFxcIiB9XFxuXFx0KTtcXG5cXG4vLyBPcHRpbWl6ZSBmb3IgcHVzaC5hcHBseSggXywgTm9kZUxpc3QgKVxcbnRyeSB7XFxuXFx0cHVzaC5hcHBseShcXG5cXHRcXHQoYXJyID0gc2xpY2UuY2FsbCggcHJlZmVycmVkRG9jLmNoaWxkTm9kZXMgKSksXFxuXFx0XFx0cHJlZmVycmVkRG9jLmNoaWxkTm9kZXNcXG5cXHQpO1xcblxcdC8vIFN1cHBvcnQ6IEFuZHJvaWQ8NC4wXFxuXFx0Ly8gRGV0ZWN0IHNpbGVudGx5IGZhaWxpbmcgcHVzaC5hcHBseVxcblxcdGFyclsgcHJlZmVycmVkRG9jLmNoaWxkTm9kZXMubGVuZ3RoIF0ubm9kZVR5cGU7XFxufSBjYXRjaCAoIGUgKSB7XFxuXFx0cHVzaCA9IHsgYXBwbHk6IGFyci5sZW5ndGggP1xcblxcblxcdFxcdC8vIExldmVyYWdlIHNsaWNlIGlmIHBvc3NpYmxlXFxuXFx0XFx0ZnVuY3Rpb24oIHRhcmdldCwgZWxzICkge1xcblxcdFxcdFxcdHB1c2hfbmF0aXZlLmFwcGx5KCB0YXJnZXQsIHNsaWNlLmNhbGwoZWxzKSApO1xcblxcdFxcdH0gOlxcblxcblxcdFxcdC8vIFN1cHBvcnQ6IElFPDlcXG5cXHRcXHQvLyBPdGhlcndpc2UgYXBwZW5kIGRpcmVjdGx5XFxuXFx0XFx0ZnVuY3Rpb24oIHRhcmdldCwgZWxzICkge1xcblxcdFxcdFxcdHZhciBqID0gdGFyZ2V0Lmxlbmd0aCxcXG5cXHRcXHRcXHRcXHRpID0gMDtcXG5cXHRcXHRcXHQvLyBDYW4ndCB0cnVzdCBOb2RlTGlzdC5sZW5ndGhcXG5cXHRcXHRcXHR3aGlsZSAoICh0YXJnZXRbaisrXSA9IGVsc1tpKytdKSApIHt9XFxuXFx0XFx0XFx0dGFyZ2V0Lmxlbmd0aCA9IGogLSAxO1xcblxcdFxcdH1cXG5cXHR9O1xcbn1cXG5cXG5mdW5jdGlvbiBTaXp6bGUoIHNlbGVjdG9yLCBjb250ZXh0LCByZXN1bHRzLCBzZWVkICkge1xcblxcdHZhciBtLCBpLCBlbGVtLCBuaWQsIG1hdGNoLCBncm91cHMsIG5ld1NlbGVjdG9yLFxcblxcdFxcdG5ld0NvbnRleHQgPSBjb250ZXh0ICYmIGNvbnRleHQub3duZXJEb2N1bWVudCxcXG5cXG5cXHRcXHQvLyBub2RlVHlwZSBkZWZhdWx0cyB0byA5LCBzaW5jZSBjb250ZXh0IGRlZmF1bHRzIHRvIGRvY3VtZW50XFxuXFx0XFx0bm9kZVR5cGUgPSBjb250ZXh0ID8gY29udGV4dC5ub2RlVHlwZSA6IDk7XFxuXFxuXFx0cmVzdWx0cyA9IHJlc3VsdHMgfHwgW107XFxuXFxuXFx0Ly8gUmV0dXJuIGVhcmx5IGZyb20gY2FsbHMgd2l0aCBpbnZhbGlkIHNlbGVjdG9yIG9yIGNvbnRleHRcXG5cXHRpZiAoIHR5cGVvZiBzZWxlY3RvciAhPT0gXFxcInN0cmluZ1xcXCIgfHwgIXNlbGVjdG9yIHx8XFxuXFx0XFx0bm9kZVR5cGUgIT09IDEgJiYgbm9kZVR5cGUgIT09IDkgJiYgbm9kZVR5cGUgIT09IDExICkge1xcblxcblxcdFxcdHJldHVybiByZXN1bHRzO1xcblxcdH1cXG5cXG5cXHQvLyBUcnkgdG8gc2hvcnRjdXQgZmluZCBvcGVyYXRpb25zIChhcyBvcHBvc2VkIHRvIGZpbHRlcnMpIGluIEhUTUwgZG9jdW1lbnRzXFxuXFx0aWYgKCAhc2VlZCApIHtcXG5cXG5cXHRcXHRpZiAoICggY29udGV4dCA/IGNvbnRleHQub3duZXJEb2N1bWVudCB8fCBjb250ZXh0IDogcHJlZmVycmVkRG9jICkgIT09IGRvY3VtZW50ICkge1xcblxcdFxcdFxcdHNldERvY3VtZW50KCBjb250ZXh0ICk7XFxuXFx0XFx0fVxcblxcdFxcdGNvbnRleHQgPSBjb250ZXh0IHx8IGRvY3VtZW50O1xcblxcblxcdFxcdGlmICggZG9jdW1lbnRJc0hUTUwgKSB7XFxuXFxuXFx0XFx0XFx0Ly8gSWYgdGhlIHNlbGVjdG9yIGlzIHN1ZmZpY2llbnRseSBzaW1wbGUsIHRyeSB1c2luZyBhIFxcXCJnZXQqQnkqXFxcIiBET00gbWV0aG9kXFxuXFx0XFx0XFx0Ly8gKGV4Y2VwdGluZyBEb2N1bWVudEZyYWdtZW50IGNvbnRleHQsIHdoZXJlIHRoZSBtZXRob2RzIGRvbid0IGV4aXN0KVxcblxcdFxcdFxcdGlmICggbm9kZVR5cGUgIT09IDExICYmIChtYXRjaCA9IHJxdWlja0V4cHIuZXhlYyggc2VsZWN0b3IgKSkgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gSUQgc2VsZWN0b3JcXG5cXHRcXHRcXHRcXHRpZiAoIChtID0gbWF0Y2hbMV0pICkge1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIERvY3VtZW50IGNvbnRleHRcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIG5vZGVUeXBlID09PSA5ICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGlmICggKGVsZW0gPSBjb250ZXh0LmdldEVsZW1lbnRCeUlkKCBtICkpICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIFN1cHBvcnQ6IElFLCBPcGVyYSwgV2Via2l0XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gVE9ETzogaWRlbnRpZnkgdmVyc2lvbnNcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBnZXRFbGVtZW50QnlJZCBjYW4gbWF0Y2ggZWxlbWVudHMgYnkgbmFtZSBpbnN0ZWFkIG9mIElEXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBlbGVtLmlkID09PSBtICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHJlc3VsdHMucHVzaCggZWxlbSApO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiByZXN1bHRzO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiByZXN1bHRzO1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBFbGVtZW50IGNvbnRleHRcXG5cXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdC8vIFN1cHBvcnQ6IElFLCBPcGVyYSwgV2Via2l0XFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gVE9ETzogaWRlbnRpZnkgdmVyc2lvbnNcXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBnZXRFbGVtZW50QnlJZCBjYW4gbWF0Y2ggZWxlbWVudHMgYnkgbmFtZSBpbnN0ZWFkIG9mIElEXFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBuZXdDb250ZXh0ICYmIChlbGVtID0gbmV3Q29udGV4dC5nZXRFbGVtZW50QnlJZCggbSApKSAmJlxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGNvbnRhaW5zKCBjb250ZXh0LCBlbGVtICkgJiZcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRlbGVtLmlkID09PSBtICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHJlc3VsdHMucHVzaCggZWxlbSApO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiByZXN1bHRzO1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0Ly8gVHlwZSBzZWxlY3RvclxcblxcdFxcdFxcdFxcdH0gZWxzZSBpZiAoIG1hdGNoWzJdICkge1xcblxcdFxcdFxcdFxcdFxcdHB1c2guYXBwbHkoIHJlc3VsdHMsIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIHNlbGVjdG9yICkgKTtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gcmVzdWx0cztcXG5cXG5cXHRcXHRcXHRcXHQvLyBDbGFzcyBzZWxlY3RvclxcblxcdFxcdFxcdFxcdH0gZWxzZSBpZiAoIChtID0gbWF0Y2hbM10pICYmIHN1cHBvcnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSAmJlxcblxcdFxcdFxcdFxcdFxcdGNvbnRleHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRwdXNoLmFwcGx5KCByZXN1bHRzLCBjb250ZXh0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoIG0gKSApO1xcblxcdFxcdFxcdFxcdFxcdHJldHVybiByZXN1bHRzO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gVGFrZSBhZHZhbnRhZ2Ugb2YgcXVlcnlTZWxlY3RvckFsbFxcblxcdFxcdFxcdGlmICggc3VwcG9ydC5xc2EgJiZcXG5cXHRcXHRcXHRcXHQhY29tcGlsZXJDYWNoZVsgc2VsZWN0b3IgKyBcXFwiIFxcXCIgXSAmJlxcblxcdFxcdFxcdFxcdCghcmJ1Z2d5UVNBIHx8ICFyYnVnZ3lRU0EudGVzdCggc2VsZWN0b3IgKSkgKSB7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBub2RlVHlwZSAhPT0gMSApIHtcXG5cXHRcXHRcXHRcXHRcXHRuZXdDb250ZXh0ID0gY29udGV4dDtcXG5cXHRcXHRcXHRcXHRcXHRuZXdTZWxlY3RvciA9IHNlbGVjdG9yO1xcblxcblxcdFxcdFxcdFxcdC8vIHFTQSBsb29rcyBvdXRzaWRlIEVsZW1lbnQgY29udGV4dCwgd2hpY2ggaXMgbm90IHdoYXQgd2Ugd2FudFxcblxcdFxcdFxcdFxcdC8vIFRoYW5rcyB0byBBbmRyZXcgRHVwb250IGZvciB0aGlzIHdvcmthcm91bmQgdGVjaG5pcXVlXFxuXFx0XFx0XFx0XFx0Ly8gU3VwcG9ydDogSUUgPD04XFxuXFx0XFx0XFx0XFx0Ly8gRXhjbHVkZSBvYmplY3QgZWxlbWVudHNcXG5cXHRcXHRcXHRcXHR9IGVsc2UgaWYgKCBjb250ZXh0Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgIT09IFxcXCJvYmplY3RcXFwiICkge1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIENhcHR1cmUgdGhlIGNvbnRleHQgSUQsIHNldHRpbmcgaXQgZmlyc3QgaWYgbmVjZXNzYXJ5XFxuXFx0XFx0XFx0XFx0XFx0aWYgKCAobmlkID0gY29udGV4dC5nZXRBdHRyaWJ1dGUoIFxcXCJpZFxcXCIgKSkgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0bmlkID0gbmlkLnJlcGxhY2UoIHJjc3Nlc2NhcGUsIGZjc3Nlc2NhcGUgKTtcXG5cXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdFxcdGNvbnRleHQuc2V0QXR0cmlidXRlKCBcXFwiaWRcXFwiLCAobmlkID0gZXhwYW5kbykgKTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gUHJlZml4IGV2ZXJ5IHNlbGVjdG9yIGluIHRoZSBsaXN0XFxuXFx0XFx0XFx0XFx0XFx0Z3JvdXBzID0gdG9rZW5pemUoIHNlbGVjdG9yICk7XFxuXFx0XFx0XFx0XFx0XFx0aSA9IGdyb3Vwcy5sZW5ndGg7XFxuXFx0XFx0XFx0XFx0XFx0d2hpbGUgKCBpLS0gKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0Z3JvdXBzW2ldID0gXFxcIiNcXFwiICsgbmlkICsgXFxcIiBcXFwiICsgdG9TZWxlY3RvciggZ3JvdXBzW2ldICk7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdG5ld1NlbGVjdG9yID0gZ3JvdXBzLmpvaW4oIFxcXCIsXFxcIiApO1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIEV4cGFuZCBjb250ZXh0IGZvciBzaWJsaW5nIHNlbGVjdG9yc1xcblxcdFxcdFxcdFxcdFxcdG5ld0NvbnRleHQgPSByc2libGluZy50ZXN0KCBzZWxlY3RvciApICYmIHRlc3RDb250ZXh0KCBjb250ZXh0LnBhcmVudE5vZGUgKSB8fFxcblxcdFxcdFxcdFxcdFxcdFxcdGNvbnRleHQ7XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdGlmICggbmV3U2VsZWN0b3IgKSB7XFxuXFx0XFx0XFx0XFx0XFx0dHJ5IHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRwdXNoLmFwcGx5KCByZXN1bHRzLFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdG5ld0NvbnRleHQucXVlcnlTZWxlY3RvckFsbCggbmV3U2VsZWN0b3IgKVxcblxcdFxcdFxcdFxcdFxcdFxcdCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIHJlc3VsdHM7XFxuXFx0XFx0XFx0XFx0XFx0fSBjYXRjaCAoIHFzYUVycm9yICkge1xcblxcdFxcdFxcdFxcdFxcdH0gZmluYWxseSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBuaWQgPT09IGV4cGFuZG8gKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Y29udGV4dC5yZW1vdmVBdHRyaWJ1dGUoIFxcXCJpZFxcXCIgKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcdH1cXG5cXG5cXHQvLyBBbGwgb3RoZXJzXFxuXFx0cmV0dXJuIHNlbGVjdCggc2VsZWN0b3IucmVwbGFjZSggcnRyaW0sIFxcXCIkMVxcXCIgKSwgY29udGV4dCwgcmVzdWx0cywgc2VlZCApO1xcbn1cXG5cXG4vKipcXG4gKiBDcmVhdGUga2V5LXZhbHVlIGNhY2hlcyBvZiBsaW1pdGVkIHNpemVcXG4gKiBAcmV0dXJucyB7ZnVuY3Rpb24oc3RyaW5nLCBvYmplY3QpfSBSZXR1cm5zIHRoZSBPYmplY3QgZGF0YSBhZnRlciBzdG9yaW5nIGl0IG9uIGl0c2VsZiB3aXRoXFxuICpcXHRwcm9wZXJ0eSBuYW1lIHRoZSAoc3BhY2Utc3VmZml4ZWQpIHN0cmluZyBhbmQgKGlmIHRoZSBjYWNoZSBpcyBsYXJnZXIgdGhhbiBFeHByLmNhY2hlTGVuZ3RoKVxcbiAqXFx0ZGVsZXRpbmcgdGhlIG9sZGVzdCBlbnRyeVxcbiAqL1xcbmZ1bmN0aW9uIGNyZWF0ZUNhY2hlKCkge1xcblxcdHZhciBrZXlzID0gW107XFxuXFxuXFx0ZnVuY3Rpb24gY2FjaGUoIGtleSwgdmFsdWUgKSB7XFxuXFx0XFx0Ly8gVXNlIChrZXkgKyBcXFwiIFxcXCIpIHRvIGF2b2lkIGNvbGxpc2lvbiB3aXRoIG5hdGl2ZSBwcm90b3R5cGUgcHJvcGVydGllcyAoc2VlIElzc3VlICMxNTcpXFxuXFx0XFx0aWYgKCBrZXlzLnB1c2goIGtleSArIFxcXCIgXFxcIiApID4gRXhwci5jYWNoZUxlbmd0aCApIHtcXG5cXHRcXHRcXHQvLyBPbmx5IGtlZXAgdGhlIG1vc3QgcmVjZW50IGVudHJpZXNcXG5cXHRcXHRcXHRkZWxldGUgY2FjaGVbIGtleXMuc2hpZnQoKSBdO1xcblxcdFxcdH1cXG5cXHRcXHRyZXR1cm4gKGNhY2hlWyBrZXkgKyBcXFwiIFxcXCIgXSA9IHZhbHVlKTtcXG5cXHR9XFxuXFx0cmV0dXJuIGNhY2hlO1xcbn1cXG5cXG4vKipcXG4gKiBNYXJrIGEgZnVuY3Rpb24gZm9yIHNwZWNpYWwgdXNlIGJ5IFNpenpsZVxcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byBtYXJrXFxuICovXFxuZnVuY3Rpb24gbWFya0Z1bmN0aW9uKCBmbiApIHtcXG5cXHRmblsgZXhwYW5kbyBdID0gdHJ1ZTtcXG5cXHRyZXR1cm4gZm47XFxufVxcblxcbi8qKlxcbiAqIFN1cHBvcnQgdGVzdGluZyB1c2luZyBhbiBlbGVtZW50XFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gUGFzc2VkIHRoZSBjcmVhdGVkIGVsZW1lbnQgYW5kIHJldHVybnMgYSBib29sZWFuIHJlc3VsdFxcbiAqL1xcbmZ1bmN0aW9uIGFzc2VydCggZm4gKSB7XFxuXFx0dmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcXFwiZmllbGRzZXRcXFwiKTtcXG5cXG5cXHR0cnkge1xcblxcdFxcdHJldHVybiAhIWZuKCBlbCApO1xcblxcdH0gY2F0Y2ggKGUpIHtcXG5cXHRcXHRyZXR1cm4gZmFsc2U7XFxuXFx0fSBmaW5hbGx5IHtcXG5cXHRcXHQvLyBSZW1vdmUgZnJvbSBpdHMgcGFyZW50IGJ5IGRlZmF1bHRcXG5cXHRcXHRpZiAoIGVsLnBhcmVudE5vZGUgKSB7XFxuXFx0XFx0XFx0ZWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCggZWwgKTtcXG5cXHRcXHR9XFxuXFx0XFx0Ly8gcmVsZWFzZSBtZW1vcnkgaW4gSUVcXG5cXHRcXHRlbCA9IG51bGw7XFxuXFx0fVxcbn1cXG5cXG4vKipcXG4gKiBBZGRzIHRoZSBzYW1lIGhhbmRsZXIgZm9yIGFsbCBvZiB0aGUgc3BlY2lmaWVkIGF0dHJzXFxuICogQHBhcmFtIHtTdHJpbmd9IGF0dHJzIFBpcGUtc2VwYXJhdGVkIGxpc3Qgb2YgYXR0cmlidXRlc1xcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXIgVGhlIG1ldGhvZCB0aGF0IHdpbGwgYmUgYXBwbGllZFxcbiAqL1xcbmZ1bmN0aW9uIGFkZEhhbmRsZSggYXR0cnMsIGhhbmRsZXIgKSB7XFxuXFx0dmFyIGFyciA9IGF0dHJzLnNwbGl0KFxcXCJ8XFxcIiksXFxuXFx0XFx0aSA9IGFyci5sZW5ndGg7XFxuXFxuXFx0d2hpbGUgKCBpLS0gKSB7XFxuXFx0XFx0RXhwci5hdHRySGFuZGxlWyBhcnJbaV0gXSA9IGhhbmRsZXI7XFxuXFx0fVxcbn1cXG5cXG4vKipcXG4gKiBDaGVja3MgZG9jdW1lbnQgb3JkZXIgb2YgdHdvIHNpYmxpbmdzXFxuICogQHBhcmFtIHtFbGVtZW50fSBhXFxuICogQHBhcmFtIHtFbGVtZW50fSBiXFxuICogQHJldHVybnMge051bWJlcn0gUmV0dXJucyBsZXNzIHRoYW4gMCBpZiBhIHByZWNlZGVzIGIsIGdyZWF0ZXIgdGhhbiAwIGlmIGEgZm9sbG93cyBiXFxuICovXFxuZnVuY3Rpb24gc2libGluZ0NoZWNrKCBhLCBiICkge1xcblxcdHZhciBjdXIgPSBiICYmIGEsXFxuXFx0XFx0ZGlmZiA9IGN1ciAmJiBhLm5vZGVUeXBlID09PSAxICYmIGIubm9kZVR5cGUgPT09IDEgJiZcXG5cXHRcXHRcXHRhLnNvdXJjZUluZGV4IC0gYi5zb3VyY2VJbmRleDtcXG5cXG5cXHQvLyBVc2UgSUUgc291cmNlSW5kZXggaWYgYXZhaWxhYmxlIG9uIGJvdGggbm9kZXNcXG5cXHRpZiAoIGRpZmYgKSB7XFxuXFx0XFx0cmV0dXJuIGRpZmY7XFxuXFx0fVxcblxcblxcdC8vIENoZWNrIGlmIGIgZm9sbG93cyBhXFxuXFx0aWYgKCBjdXIgKSB7XFxuXFx0XFx0d2hpbGUgKCAoY3VyID0gY3VyLm5leHRTaWJsaW5nKSApIHtcXG5cXHRcXHRcXHRpZiAoIGN1ciA9PT0gYiApIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gLTE7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXHR9XFxuXFxuXFx0cmV0dXJuIGEgPyAxIDogLTE7XFxufVxcblxcbi8qKlxcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0byB1c2UgaW4gcHNldWRvcyBmb3IgaW5wdXQgdHlwZXNcXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxcbiAqL1xcbmZ1bmN0aW9uIGNyZWF0ZUlucHV0UHNldWRvKCB0eXBlICkge1xcblxcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcXG5cXHRcXHR2YXIgbmFtZSA9IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcXG5cXHRcXHRyZXR1cm4gbmFtZSA9PT0gXFxcImlucHV0XFxcIiAmJiBlbGVtLnR5cGUgPT09IHR5cGU7XFxuXFx0fTtcXG59XFxuXFxuLyoqXFxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRvIHVzZSBpbiBwc2V1ZG9zIGZvciBidXR0b25zXFxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcXG4gKi9cXG5mdW5jdGlvbiBjcmVhdGVCdXR0b25Qc2V1ZG8oIHR5cGUgKSB7XFxuXFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xcblxcdFxcdHZhciBuYW1lID0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xcblxcdFxcdHJldHVybiAobmFtZSA9PT0gXFxcImlucHV0XFxcIiB8fCBuYW1lID09PSBcXFwiYnV0dG9uXFxcIikgJiYgZWxlbS50eXBlID09PSB0eXBlO1xcblxcdH07XFxufVxcblxcbi8qKlxcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0byB1c2UgaW4gcHNldWRvcyBmb3IgOmVuYWJsZWQvOmRpc2FibGVkXFxuICogQHBhcmFtIHtCb29sZWFufSBkaXNhYmxlZCB0cnVlIGZvciA6ZGlzYWJsZWQ7IGZhbHNlIGZvciA6ZW5hYmxlZFxcbiAqL1xcbmZ1bmN0aW9uIGNyZWF0ZURpc2FibGVkUHNldWRvKCBkaXNhYmxlZCApIHtcXG5cXG5cXHQvLyBLbm93biA6ZGlzYWJsZWQgZmFsc2UgcG9zaXRpdmVzOiBmaWVsZHNldFtkaXNhYmxlZF0gPiBsZWdlbmQ6bnRoLW9mLXR5cGUobisyKSA6Y2FuLWRpc2FibGVcXG5cXHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XFxuXFxuXFx0XFx0Ly8gT25seSBjZXJ0YWluIGVsZW1lbnRzIGNhbiBtYXRjaCA6ZW5hYmxlZCBvciA6ZGlzYWJsZWRcXG5cXHRcXHQvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zY3JpcHRpbmcuaHRtbCNzZWxlY3Rvci1lbmFibGVkXFxuXFx0XFx0Ly8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc2NyaXB0aW5nLmh0bWwjc2VsZWN0b3ItZGlzYWJsZWRcXG5cXHRcXHRpZiAoIFxcXCJmb3JtXFxcIiBpbiBlbGVtICkge1xcblxcblxcdFxcdFxcdC8vIENoZWNrIGZvciBpbmhlcml0ZWQgZGlzYWJsZWRuZXNzIG9uIHJlbGV2YW50IG5vbi1kaXNhYmxlZCBlbGVtZW50czpcXG5cXHRcXHRcXHQvLyAqIGxpc3RlZCBmb3JtLWFzc29jaWF0ZWQgZWxlbWVudHMgaW4gYSBkaXNhYmxlZCBmaWVsZHNldFxcblxcdFxcdFxcdC8vICAgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZm9ybXMuaHRtbCNjYXRlZ29yeS1saXN0ZWRcXG5cXHRcXHRcXHQvLyAgIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2Zvcm1zLmh0bWwjY29uY2VwdC1mZS1kaXNhYmxlZFxcblxcdFxcdFxcdC8vICogb3B0aW9uIGVsZW1lbnRzIGluIGEgZGlzYWJsZWQgb3B0Z3JvdXBcXG5cXHRcXHRcXHQvLyAgIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2Zvcm1zLmh0bWwjY29uY2VwdC1vcHRpb24tZGlzYWJsZWRcXG5cXHRcXHRcXHQvLyBBbGwgc3VjaCBlbGVtZW50cyBoYXZlIGEgXFxcImZvcm1cXFwiIHByb3BlcnR5LlxcblxcdFxcdFxcdGlmICggZWxlbS5wYXJlbnROb2RlICYmIGVsZW0uZGlzYWJsZWQgPT09IGZhbHNlICkge1xcblxcblxcdFxcdFxcdFxcdC8vIE9wdGlvbiBlbGVtZW50cyBkZWZlciB0byBhIHBhcmVudCBvcHRncm91cCBpZiBwcmVzZW50XFxuXFx0XFx0XFx0XFx0aWYgKCBcXFwibGFiZWxcXFwiIGluIGVsZW0gKSB7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBcXFwibGFiZWxcXFwiIGluIGVsZW0ucGFyZW50Tm9kZSApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gZWxlbS5wYXJlbnROb2RlLmRpc2FibGVkID09PSBkaXNhYmxlZDtcXG5cXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiBlbGVtLmRpc2FibGVkID09PSBkaXNhYmxlZDtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdC8vIFN1cHBvcnQ6IElFIDYgLSAxMVxcblxcdFxcdFxcdFxcdC8vIFVzZSB0aGUgaXNEaXNhYmxlZCBzaG9ydGN1dCBwcm9wZXJ0eSB0byBjaGVjayBmb3IgZGlzYWJsZWQgZmllbGRzZXQgYW5jZXN0b3JzXFxuXFx0XFx0XFx0XFx0cmV0dXJuIGVsZW0uaXNEaXNhYmxlZCA9PT0gZGlzYWJsZWQgfHxcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBXaGVyZSB0aGVyZSBpcyBubyBpc0Rpc2FibGVkLCBjaGVjayBtYW51YWxseVxcblxcdFxcdFxcdFxcdFxcdC8qIGpzaGludCAtVzAxOCAqL1xcblxcdFxcdFxcdFxcdFxcdGVsZW0uaXNEaXNhYmxlZCAhPT0gIWRpc2FibGVkICYmXFxuXFx0XFx0XFx0XFx0XFx0XFx0ZGlzYWJsZWRBbmNlc3RvciggZWxlbSApID09PSBkaXNhYmxlZDtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cmV0dXJuIGVsZW0uZGlzYWJsZWQgPT09IGRpc2FibGVkO1xcblxcblxcdFxcdC8vIFRyeSB0byB3aW5ub3cgb3V0IGVsZW1lbnRzIHRoYXQgY2FuJ3QgYmUgZGlzYWJsZWQgYmVmb3JlIHRydXN0aW5nIHRoZSBkaXNhYmxlZCBwcm9wZXJ0eS5cXG5cXHRcXHQvLyBTb21lIHZpY3RpbXMgZ2V0IGNhdWdodCBpbiBvdXIgbmV0IChsYWJlbCwgbGVnZW5kLCBtZW51LCB0cmFjayksIGJ1dCBpdCBzaG91bGRuJ3RcXG5cXHRcXHQvLyBldmVuIGV4aXN0IG9uIHRoZW0sIGxldCBhbG9uZSBoYXZlIGEgYm9vbGVhbiB2YWx1ZS5cXG5cXHRcXHR9IGVsc2UgaWYgKCBcXFwibGFiZWxcXFwiIGluIGVsZW0gKSB7XFxuXFx0XFx0XFx0cmV0dXJuIGVsZW0uZGlzYWJsZWQgPT09IGRpc2FibGVkO1xcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBSZW1haW5pbmcgZWxlbWVudHMgYXJlIG5laXRoZXIgOmVuYWJsZWQgbm9yIDpkaXNhYmxlZFxcblxcdFxcdHJldHVybiBmYWxzZTtcXG5cXHR9O1xcbn1cXG5cXG4vKipcXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdG8gdXNlIGluIHBzZXVkb3MgZm9yIHBvc2l0aW9uYWxzXFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cXG4gKi9cXG5mdW5jdGlvbiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKCBmbiApIHtcXG5cXHRyZXR1cm4gbWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBhcmd1bWVudCApIHtcXG5cXHRcXHRhcmd1bWVudCA9ICthcmd1bWVudDtcXG5cXHRcXHRyZXR1cm4gbWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBzZWVkLCBtYXRjaGVzICkge1xcblxcdFxcdFxcdHZhciBqLFxcblxcdFxcdFxcdFxcdG1hdGNoSW5kZXhlcyA9IGZuKCBbXSwgc2VlZC5sZW5ndGgsIGFyZ3VtZW50ICksXFxuXFx0XFx0XFx0XFx0aSA9IG1hdGNoSW5kZXhlcy5sZW5ndGg7XFxuXFxuXFx0XFx0XFx0Ly8gTWF0Y2ggZWxlbWVudHMgZm91bmQgYXQgdGhlIHNwZWNpZmllZCBpbmRleGVzXFxuXFx0XFx0XFx0d2hpbGUgKCBpLS0gKSB7XFxuXFx0XFx0XFx0XFx0aWYgKCBzZWVkWyAoaiA9IG1hdGNoSW5kZXhlc1tpXSkgXSApIHtcXG5cXHRcXHRcXHRcXHRcXHRzZWVkW2pdID0gIShtYXRjaGVzW2pdID0gc2VlZFtqXSk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHR9KTtcXG5cXHR9KTtcXG59XFxuXFxuLyoqXFxuICogQ2hlY2tzIGEgbm9kZSBmb3IgdmFsaWRpdHkgYXMgYSBTaXp6bGUgY29udGV4dFxcbiAqIEBwYXJhbSB7RWxlbWVudHxPYmplY3Q9fSBjb250ZXh0XFxuICogQHJldHVybnMge0VsZW1lbnR8T2JqZWN0fEJvb2xlYW59IFRoZSBpbnB1dCBub2RlIGlmIGFjY2VwdGFibGUsIG90aGVyd2lzZSBhIGZhbHN5IHZhbHVlXFxuICovXFxuZnVuY3Rpb24gdGVzdENvbnRleHQoIGNvbnRleHQgKSB7XFxuXFx0cmV0dXJuIGNvbnRleHQgJiYgdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgIT09IFxcXCJ1bmRlZmluZWRcXFwiICYmIGNvbnRleHQ7XFxufVxcblxcbi8vIEV4cG9zZSBzdXBwb3J0IHZhcnMgZm9yIGNvbnZlbmllbmNlXFxuc3VwcG9ydCA9IFNpenpsZS5zdXBwb3J0ID0ge307XFxuXFxuLyoqXFxuICogRGV0ZWN0cyBYTUwgbm9kZXNcXG4gKiBAcGFyYW0ge0VsZW1lbnR8T2JqZWN0fSBlbGVtIEFuIGVsZW1lbnQgb3IgYSBkb2N1bWVudFxcbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmZiBlbGVtIGlzIGEgbm9uLUhUTUwgWE1MIG5vZGVcXG4gKi9cXG5pc1hNTCA9IFNpenpsZS5pc1hNTCA9IGZ1bmN0aW9uKCBlbGVtICkge1xcblxcdC8vIGRvY3VtZW50RWxlbWVudCBpcyB2ZXJpZmllZCBmb3IgY2FzZXMgd2hlcmUgaXQgZG9lc24ndCB5ZXQgZXhpc3RcXG5cXHQvLyAoc3VjaCBhcyBsb2FkaW5nIGlmcmFtZXMgaW4gSUUgLSAjNDgzMylcXG5cXHR2YXIgZG9jdW1lbnRFbGVtZW50ID0gZWxlbSAmJiAoZWxlbS5vd25lckRvY3VtZW50IHx8IGVsZW0pLmRvY3VtZW50RWxlbWVudDtcXG5cXHRyZXR1cm4gZG9jdW1lbnRFbGVtZW50ID8gZG9jdW1lbnRFbGVtZW50Lm5vZGVOYW1lICE9PSBcXFwiSFRNTFxcXCIgOiBmYWxzZTtcXG59O1xcblxcbi8qKlxcbiAqIFNldHMgZG9jdW1lbnQtcmVsYXRlZCB2YXJpYWJsZXMgb25jZSBiYXNlZCBvbiB0aGUgY3VycmVudCBkb2N1bWVudFxcbiAqIEBwYXJhbSB7RWxlbWVudHxPYmplY3R9IFtkb2NdIEFuIGVsZW1lbnQgb3IgZG9jdW1lbnQgb2JqZWN0IHRvIHVzZSB0byBzZXQgdGhlIGRvY3VtZW50XFxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY3VycmVudCBkb2N1bWVudFxcbiAqL1xcbnNldERvY3VtZW50ID0gU2l6emxlLnNldERvY3VtZW50ID0gZnVuY3Rpb24oIG5vZGUgKSB7XFxuXFx0dmFyIGhhc0NvbXBhcmUsIHN1YldpbmRvdyxcXG5cXHRcXHRkb2MgPSBub2RlID8gbm9kZS5vd25lckRvY3VtZW50IHx8IG5vZGUgOiBwcmVmZXJyZWREb2M7XFxuXFxuXFx0Ly8gUmV0dXJuIGVhcmx5IGlmIGRvYyBpcyBpbnZhbGlkIG9yIGFscmVhZHkgc2VsZWN0ZWRcXG5cXHRpZiAoIGRvYyA9PT0gZG9jdW1lbnQgfHwgZG9jLm5vZGVUeXBlICE9PSA5IHx8ICFkb2MuZG9jdW1lbnRFbGVtZW50ICkge1xcblxcdFxcdHJldHVybiBkb2N1bWVudDtcXG5cXHR9XFxuXFxuXFx0Ly8gVXBkYXRlIGdsb2JhbCB2YXJpYWJsZXNcXG5cXHRkb2N1bWVudCA9IGRvYztcXG5cXHRkb2NFbGVtID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xcblxcdGRvY3VtZW50SXNIVE1MID0gIWlzWE1MKCBkb2N1bWVudCApO1xcblxcblxcdC8vIFN1cHBvcnQ6IElFIDktMTEsIEVkZ2VcXG5cXHQvLyBBY2Nlc3NpbmcgaWZyYW1lIGRvY3VtZW50cyBhZnRlciB1bmxvYWQgdGhyb3dzIFxcXCJwZXJtaXNzaW9uIGRlbmllZFxcXCIgZXJyb3JzIChqUXVlcnkgIzEzOTM2KVxcblxcdGlmICggcHJlZmVycmVkRG9jICE9PSBkb2N1bWVudCAmJlxcblxcdFxcdChzdWJXaW5kb3cgPSBkb2N1bWVudC5kZWZhdWx0VmlldykgJiYgc3ViV2luZG93LnRvcCAhPT0gc3ViV2luZG93ICkge1xcblxcblxcdFxcdC8vIFN1cHBvcnQ6IElFIDExLCBFZGdlXFxuXFx0XFx0aWYgKCBzdWJXaW5kb3cuYWRkRXZlbnRMaXN0ZW5lciApIHtcXG5cXHRcXHRcXHRzdWJXaW5kb3cuYWRkRXZlbnRMaXN0ZW5lciggXFxcInVubG9hZFxcXCIsIHVubG9hZEhhbmRsZXIsIGZhbHNlICk7XFxuXFxuXFx0XFx0Ly8gU3VwcG9ydDogSUUgOSAtIDEwIG9ubHlcXG5cXHRcXHR9IGVsc2UgaWYgKCBzdWJXaW5kb3cuYXR0YWNoRXZlbnQgKSB7XFxuXFx0XFx0XFx0c3ViV2luZG93LmF0dGFjaEV2ZW50KCBcXFwib251bmxvYWRcXFwiLCB1bmxvYWRIYW5kbGVyICk7XFxuXFx0XFx0fVxcblxcdH1cXG5cXG5cXHQvKiBBdHRyaWJ1dGVzXFxuXFx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xcblxcblxcdC8vIFN1cHBvcnQ6IElFPDhcXG5cXHQvLyBWZXJpZnkgdGhhdCBnZXRBdHRyaWJ1dGUgcmVhbGx5IHJldHVybnMgYXR0cmlidXRlcyBhbmQgbm90IHByb3BlcnRpZXNcXG5cXHQvLyAoZXhjZXB0aW5nIElFOCBib29sZWFucylcXG5cXHRzdXBwb3J0LmF0dHJpYnV0ZXMgPSBhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xcblxcdFxcdGVsLmNsYXNzTmFtZSA9IFxcXCJpXFxcIjtcXG5cXHRcXHRyZXR1cm4gIWVsLmdldEF0dHJpYnV0ZShcXFwiY2xhc3NOYW1lXFxcIik7XFxuXFx0fSk7XFxuXFxuXFx0LyogZ2V0RWxlbWVudChzKUJ5KlxcblxcdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cXG5cXG5cXHQvLyBDaGVjayBpZiBnZXRFbGVtZW50c0J5VGFnTmFtZShcXFwiKlxcXCIpIHJldHVybnMgb25seSBlbGVtZW50c1xcblxcdHN1cHBvcnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgPSBhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xcblxcdFxcdGVsLmFwcGVuZENoaWxkKCBkb2N1bWVudC5jcmVhdGVDb21tZW50KFxcXCJcXFwiKSApO1xcblxcdFxcdHJldHVybiAhZWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXFxcIipcXFwiKS5sZW5ndGg7XFxuXFx0fSk7XFxuXFxuXFx0Ly8gU3VwcG9ydDogSUU8OVxcblxcdHN1cHBvcnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSA9IHJuYXRpdmUudGVzdCggZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSApO1xcblxcblxcdC8vIFN1cHBvcnQ6IElFPDEwXFxuXFx0Ly8gQ2hlY2sgaWYgZ2V0RWxlbWVudEJ5SWQgcmV0dXJucyBlbGVtZW50cyBieSBuYW1lXFxuXFx0Ly8gVGhlIGJyb2tlbiBnZXRFbGVtZW50QnlJZCBtZXRob2RzIGRvbid0IHBpY2sgdXAgcHJvZ3JhbW1hdGljYWxseS1zZXQgbmFtZXMsXFxuXFx0Ly8gc28gdXNlIGEgcm91bmRhYm91dCBnZXRFbGVtZW50c0J5TmFtZSB0ZXN0XFxuXFx0c3VwcG9ydC5nZXRCeUlkID0gYXNzZXJ0KGZ1bmN0aW9uKCBlbCApIHtcXG5cXHRcXHRkb2NFbGVtLmFwcGVuZENoaWxkKCBlbCApLmlkID0gZXhwYW5kbztcXG5cXHRcXHRyZXR1cm4gIWRvY3VtZW50LmdldEVsZW1lbnRzQnlOYW1lIHx8ICFkb2N1bWVudC5nZXRFbGVtZW50c0J5TmFtZSggZXhwYW5kbyApLmxlbmd0aDtcXG5cXHR9KTtcXG5cXG5cXHQvLyBJRCBmaWx0ZXIgYW5kIGZpbmRcXG5cXHRpZiAoIHN1cHBvcnQuZ2V0QnlJZCApIHtcXG5cXHRcXHRFeHByLmZpbHRlcltcXFwiSURcXFwiXSA9IGZ1bmN0aW9uKCBpZCApIHtcXG5cXHRcXHRcXHR2YXIgYXR0cklkID0gaWQucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcXG5cXHRcXHRcXHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIGVsZW0uZ2V0QXR0cmlidXRlKFxcXCJpZFxcXCIpID09PSBhdHRySWQ7XFxuXFx0XFx0XFx0fTtcXG5cXHRcXHR9O1xcblxcdFxcdEV4cHIuZmluZFtcXFwiSURcXFwiXSA9IGZ1bmN0aW9uKCBpZCwgY29udGV4dCApIHtcXG5cXHRcXHRcXHRpZiAoIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRCeUlkICE9PSBcXFwidW5kZWZpbmVkXFxcIiAmJiBkb2N1bWVudElzSFRNTCApIHtcXG5cXHRcXHRcXHRcXHR2YXIgZWxlbSA9IGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQoIGlkICk7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIGVsZW0gPyBbIGVsZW0gXSA6IFtdO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9O1xcblxcdH0gZWxzZSB7XFxuXFx0XFx0RXhwci5maWx0ZXJbXFxcIklEXFxcIl0gPSAgZnVuY3Rpb24oIGlkICkge1xcblxcdFxcdFxcdHZhciBhdHRySWQgPSBpZC5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xcblxcdFxcdFxcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcXG5cXHRcXHRcXHRcXHR2YXIgbm9kZSA9IHR5cGVvZiBlbGVtLmdldEF0dHJpYnV0ZU5vZGUgIT09IFxcXCJ1bmRlZmluZWRcXFwiICYmXFxuXFx0XFx0XFx0XFx0XFx0ZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKFxcXCJpZFxcXCIpO1xcblxcdFxcdFxcdFxcdHJldHVybiBub2RlICYmIG5vZGUudmFsdWUgPT09IGF0dHJJZDtcXG5cXHRcXHRcXHR9O1xcblxcdFxcdH07XFxuXFxuXFx0XFx0Ly8gU3VwcG9ydDogSUUgNiAtIDcgb25seVxcblxcdFxcdC8vIGdldEVsZW1lbnRCeUlkIGlzIG5vdCByZWxpYWJsZSBhcyBhIGZpbmQgc2hvcnRjdXRcXG5cXHRcXHRFeHByLmZpbmRbXFxcIklEXFxcIl0gPSBmdW5jdGlvbiggaWQsIGNvbnRleHQgKSB7XFxuXFx0XFx0XFx0aWYgKCB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50QnlJZCAhPT0gXFxcInVuZGVmaW5lZFxcXCIgJiYgZG9jdW1lbnRJc0hUTUwgKSB7XFxuXFx0XFx0XFx0XFx0dmFyIG5vZGUsIGksIGVsZW1zLFxcblxcdFxcdFxcdFxcdFxcdGVsZW0gPSBjb250ZXh0LmdldEVsZW1lbnRCeUlkKCBpZCApO1xcblxcblxcdFxcdFxcdFxcdGlmICggZWxlbSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBWZXJpZnkgdGhlIGlkIGF0dHJpYnV0ZVxcblxcdFxcdFxcdFxcdFxcdG5vZGUgPSBlbGVtLmdldEF0dHJpYnV0ZU5vZGUoXFxcImlkXFxcIik7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBub2RlICYmIG5vZGUudmFsdWUgPT09IGlkICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiBbIGVsZW0gXTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gRmFsbCBiYWNrIG9uIGdldEVsZW1lbnRzQnlOYW1lXFxuXFx0XFx0XFx0XFx0XFx0ZWxlbXMgPSBjb250ZXh0LmdldEVsZW1lbnRzQnlOYW1lKCBpZCApO1xcblxcdFxcdFxcdFxcdFxcdGkgPSAwO1xcblxcdFxcdFxcdFxcdFxcdHdoaWxlICggKGVsZW0gPSBlbGVtc1tpKytdKSApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRub2RlID0gZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKFxcXCJpZFxcXCIpO1xcblxcdFxcdFxcdFxcdFxcdFxcdGlmICggbm9kZSAmJiBub2RlLnZhbHVlID09PSBpZCApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gWyBlbGVtIF07XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0cmV0dXJuIFtdO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9O1xcblxcdH1cXG5cXG5cXHQvLyBUYWdcXG5cXHRFeHByLmZpbmRbXFxcIlRBR1xcXCJdID0gc3VwcG9ydC5nZXRFbGVtZW50c0J5VGFnTmFtZSA/XFxuXFx0XFx0ZnVuY3Rpb24oIHRhZywgY29udGV4dCApIHtcXG5cXHRcXHRcXHRpZiAoIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lICE9PSBcXFwidW5kZWZpbmVkXFxcIiApIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSggdGFnICk7XFxuXFxuXFx0XFx0XFx0Ly8gRG9jdW1lbnRGcmFnbWVudCBub2RlcyBkb24ndCBoYXZlIGdFQlROXFxuXFx0XFx0XFx0fSBlbHNlIGlmICggc3VwcG9ydC5xc2EgKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIGNvbnRleHQucXVlcnlTZWxlY3RvckFsbCggdGFnICk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH0gOlxcblxcblxcdFxcdGZ1bmN0aW9uKCB0YWcsIGNvbnRleHQgKSB7XFxuXFx0XFx0XFx0dmFyIGVsZW0sXFxuXFx0XFx0XFx0XFx0dG1wID0gW10sXFxuXFx0XFx0XFx0XFx0aSA9IDAsXFxuXFx0XFx0XFx0XFx0Ly8gQnkgaGFwcHkgY29pbmNpZGVuY2UsIGEgKGJyb2tlbikgZ0VCVE4gYXBwZWFycyBvbiBEb2N1bWVudEZyYWdtZW50IG5vZGVzIHRvb1xcblxcdFxcdFxcdFxcdHJlc3VsdHMgPSBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCB0YWcgKTtcXG5cXG5cXHRcXHRcXHQvLyBGaWx0ZXIgb3V0IHBvc3NpYmxlIGNvbW1lbnRzXFxuXFx0XFx0XFx0aWYgKCB0YWcgPT09IFxcXCIqXFxcIiApIHtcXG5cXHRcXHRcXHRcXHR3aGlsZSAoIChlbGVtID0gcmVzdWx0c1tpKytdKSApIHtcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dG1wLnB1c2goIGVsZW0gKTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdHJldHVybiB0bXA7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHJldHVybiByZXN1bHRzO1xcblxcdFxcdH07XFxuXFxuXFx0Ly8gQ2xhc3NcXG5cXHRFeHByLmZpbmRbXFxcIkNMQVNTXFxcIl0gPSBzdXBwb3J0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgJiYgZnVuY3Rpb24oIGNsYXNzTmFtZSwgY29udGV4dCApIHtcXG5cXHRcXHRpZiAoIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgIT09IFxcXCJ1bmRlZmluZWRcXFwiICYmIGRvY3VtZW50SXNIVE1MICkge1xcblxcdFxcdFxcdHJldHVybiBjb250ZXh0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoIGNsYXNzTmFtZSApO1xcblxcdFxcdH1cXG5cXHR9O1xcblxcblxcdC8qIFFTQS9tYXRjaGVzU2VsZWN0b3JcXG5cXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXFxuXFxuXFx0Ly8gUVNBIGFuZCBtYXRjaGVzU2VsZWN0b3Igc3VwcG9ydFxcblxcblxcdC8vIG1hdGNoZXNTZWxlY3Rvcig6YWN0aXZlKSByZXBvcnRzIGZhbHNlIHdoZW4gdHJ1ZSAoSUU5L09wZXJhIDExLjUpXFxuXFx0cmJ1Z2d5TWF0Y2hlcyA9IFtdO1xcblxcblxcdC8vIHFTYSg6Zm9jdXMpIHJlcG9ydHMgZmFsc2Ugd2hlbiB0cnVlIChDaHJvbWUgMjEpXFxuXFx0Ly8gV2UgYWxsb3cgdGhpcyBiZWNhdXNlIG9mIGEgYnVnIGluIElFOC85IHRoYXQgdGhyb3dzIGFuIGVycm9yXFxuXFx0Ly8gd2hlbmV2ZXIgYGRvY3VtZW50LmFjdGl2ZUVsZW1lbnRgIGlzIGFjY2Vzc2VkIG9uIGFuIGlmcmFtZVxcblxcdC8vIFNvLCB3ZSBhbGxvdyA6Zm9jdXMgdG8gcGFzcyB0aHJvdWdoIFFTQSBhbGwgdGhlIHRpbWUgdG8gYXZvaWQgdGhlIElFIGVycm9yXFxuXFx0Ly8gU2VlIGh0dHBzOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC8xMzM3OFxcblxcdHJidWdneVFTQSA9IFtdO1xcblxcblxcdGlmICggKHN1cHBvcnQucXNhID0gcm5hdGl2ZS50ZXN0KCBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsICkpICkge1xcblxcdFxcdC8vIEJ1aWxkIFFTQSByZWdleFxcblxcdFxcdC8vIFJlZ2V4IHN0cmF0ZWd5IGFkb3B0ZWQgZnJvbSBEaWVnbyBQZXJpbmlcXG5cXHRcXHRhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xcblxcdFxcdFxcdC8vIFNlbGVjdCBpcyBzZXQgdG8gZW1wdHkgc3RyaW5nIG9uIHB1cnBvc2VcXG5cXHRcXHRcXHQvLyBUaGlzIGlzIHRvIHRlc3QgSUUncyB0cmVhdG1lbnQgb2Ygbm90IGV4cGxpY2l0bHlcXG5cXHRcXHRcXHQvLyBzZXR0aW5nIGEgYm9vbGVhbiBjb250ZW50IGF0dHJpYnV0ZSxcXG5cXHRcXHRcXHQvLyBzaW5jZSBpdHMgcHJlc2VuY2Ugc2hvdWxkIGJlIGVub3VnaFxcblxcdFxcdFxcdC8vIGh0dHBzOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC8xMjM1OVxcblxcdFxcdFxcdGRvY0VsZW0uYXBwZW5kQ2hpbGQoIGVsICkuaW5uZXJIVE1MID0gXFxcIjxhIGlkPSdcXFwiICsgZXhwYW5kbyArIFxcXCInPjwvYT5cXFwiICtcXG5cXHRcXHRcXHRcXHRcXFwiPHNlbGVjdCBpZD0nXFxcIiArIGV4cGFuZG8gKyBcXFwiLVxcXFxyXFxcXFxcXFwnIG1zYWxsb3djYXB0dXJlPScnPlxcXCIgK1xcblxcdFxcdFxcdFxcdFxcXCI8b3B0aW9uIHNlbGVjdGVkPScnPjwvb3B0aW9uPjwvc2VsZWN0PlxcXCI7XFxuXFxuXFx0XFx0XFx0Ly8gU3VwcG9ydDogSUU4LCBPcGVyYSAxMS0xMi4xNlxcblxcdFxcdFxcdC8vIE5vdGhpbmcgc2hvdWxkIGJlIHNlbGVjdGVkIHdoZW4gZW1wdHkgc3RyaW5ncyBmb2xsb3cgXj0gb3IgJD0gb3IgKj1cXG5cXHRcXHRcXHQvLyBUaGUgdGVzdCBhdHRyaWJ1dGUgbXVzdCBiZSB1bmtub3duIGluIE9wZXJhIGJ1dCBcXFwic2FmZVxcXCIgZm9yIFdpblJUXFxuXFx0XFx0XFx0Ly8gaHR0cHM6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9pZS9oaDQ2NTM4OC5hc3B4I2F0dHJpYnV0ZV9zZWN0aW9uXFxuXFx0XFx0XFx0aWYgKCBlbC5xdWVyeVNlbGVjdG9yQWxsKFxcXCJbbXNhbGxvd2NhcHR1cmVePScnXVxcXCIpLmxlbmd0aCApIHtcXG5cXHRcXHRcXHRcXHRyYnVnZ3lRU0EucHVzaCggXFxcIlsqXiRdPVxcXCIgKyB3aGl0ZXNwYWNlICsgXFxcIiooPzonJ3xcXFxcXFxcIlxcXFxcXFwiKVxcXCIgKTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gU3VwcG9ydDogSUU4XFxuXFx0XFx0XFx0Ly8gQm9vbGVhbiBhdHRyaWJ1dGVzIGFuZCBcXFwidmFsdWVcXFwiIGFyZSBub3QgdHJlYXRlZCBjb3JyZWN0bHlcXG5cXHRcXHRcXHRpZiAoICFlbC5xdWVyeVNlbGVjdG9yQWxsKFxcXCJbc2VsZWN0ZWRdXFxcIikubGVuZ3RoICkge1xcblxcdFxcdFxcdFxcdHJidWdneVFTQS5wdXNoKCBcXFwiXFxcXFxcXFxbXFxcIiArIHdoaXRlc3BhY2UgKyBcXFwiKig/OnZhbHVlfFxcXCIgKyBib29sZWFucyArIFxcXCIpXFxcIiApO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBTdXBwb3J0OiBDaHJvbWU8MjksIEFuZHJvaWQ8NC40LCBTYWZhcmk8Ny4wKywgaU9TPDcuMCssIFBoYW50b21KUzwxLjkuOCtcXG5cXHRcXHRcXHRpZiAoICFlbC5xdWVyeVNlbGVjdG9yQWxsKCBcXFwiW2lkfj1cXFwiICsgZXhwYW5kbyArIFxcXCItXVxcXCIgKS5sZW5ndGggKSB7XFxuXFx0XFx0XFx0XFx0cmJ1Z2d5UVNBLnB1c2goXFxcIn49XFxcIik7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIFdlYmtpdC9PcGVyYSAtIDpjaGVja2VkIHNob3VsZCByZXR1cm4gc2VsZWN0ZWQgb3B0aW9uIGVsZW1lbnRzXFxuXFx0XFx0XFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvMjAxMS9SRUMtY3NzMy1zZWxlY3RvcnMtMjAxMTA5MjkvI2NoZWNrZWRcXG5cXHRcXHRcXHQvLyBJRTggdGhyb3dzIGVycm9yIGhlcmUgYW5kIHdpbGwgbm90IHNlZSBsYXRlciB0ZXN0c1xcblxcdFxcdFxcdGlmICggIWVsLnF1ZXJ5U2VsZWN0b3JBbGwoXFxcIjpjaGVja2VkXFxcIikubGVuZ3RoICkge1xcblxcdFxcdFxcdFxcdHJidWdneVFTQS5wdXNoKFxcXCI6Y2hlY2tlZFxcXCIpO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBTdXBwb3J0OiBTYWZhcmkgOCssIGlPUyA4K1xcblxcdFxcdFxcdC8vIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xMzY4NTFcXG5cXHRcXHRcXHQvLyBJbi1wYWdlIGBzZWxlY3RvciNpZCBzaWJsaW5nLWNvbWJpbmF0b3Igc2VsZWN0b3JgIGZhaWxzXFxuXFx0XFx0XFx0aWYgKCAhZWwucXVlcnlTZWxlY3RvckFsbCggXFxcImEjXFxcIiArIGV4cGFuZG8gKyBcXFwiKypcXFwiICkubGVuZ3RoICkge1xcblxcdFxcdFxcdFxcdHJidWdneVFTQS5wdXNoKFxcXCIuIy4rWyt+XVxcXCIpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9KTtcXG5cXG5cXHRcXHRhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xcblxcdFxcdFxcdGVsLmlubmVySFRNTCA9IFxcXCI8YSBocmVmPScnIGRpc2FibGVkPSdkaXNhYmxlZCc+PC9hPlxcXCIgK1xcblxcdFxcdFxcdFxcdFxcXCI8c2VsZWN0IGRpc2FibGVkPSdkaXNhYmxlZCc+PG9wdGlvbi8+PC9zZWxlY3Q+XFxcIjtcXG5cXG5cXHRcXHRcXHQvLyBTdXBwb3J0OiBXaW5kb3dzIDggTmF0aXZlIEFwcHNcXG5cXHRcXHRcXHQvLyBUaGUgdHlwZSBhbmQgbmFtZSBhdHRyaWJ1dGVzIGFyZSByZXN0cmljdGVkIGR1cmluZyAuaW5uZXJIVE1MIGFzc2lnbm1lbnRcXG5cXHRcXHRcXHR2YXIgaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFxcXCJpbnB1dFxcXCIpO1xcblxcdFxcdFxcdGlucHV0LnNldEF0dHJpYnV0ZSggXFxcInR5cGVcXFwiLCBcXFwiaGlkZGVuXFxcIiApO1xcblxcdFxcdFxcdGVsLmFwcGVuZENoaWxkKCBpbnB1dCApLnNldEF0dHJpYnV0ZSggXFxcIm5hbWVcXFwiLCBcXFwiRFxcXCIgKTtcXG5cXG5cXHRcXHRcXHQvLyBTdXBwb3J0OiBJRThcXG5cXHRcXHRcXHQvLyBFbmZvcmNlIGNhc2Utc2Vuc2l0aXZpdHkgb2YgbmFtZSBhdHRyaWJ1dGVcXG5cXHRcXHRcXHRpZiAoIGVsLnF1ZXJ5U2VsZWN0b3JBbGwoXFxcIltuYW1lPWRdXFxcIikubGVuZ3RoICkge1xcblxcdFxcdFxcdFxcdHJidWdneVFTQS5wdXNoKCBcXFwibmFtZVxcXCIgKyB3aGl0ZXNwYWNlICsgXFxcIipbKl4kfCF+XT89XFxcIiApO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBGRiAzLjUgLSA6ZW5hYmxlZC86ZGlzYWJsZWQgYW5kIGhpZGRlbiBlbGVtZW50cyAoaGlkZGVuIGVsZW1lbnRzIGFyZSBzdGlsbCBlbmFibGVkKVxcblxcdFxcdFxcdC8vIElFOCB0aHJvd3MgZXJyb3IgaGVyZSBhbmQgd2lsbCBub3Qgc2VlIGxhdGVyIHRlc3RzXFxuXFx0XFx0XFx0aWYgKCBlbC5xdWVyeVNlbGVjdG9yQWxsKFxcXCI6ZW5hYmxlZFxcXCIpLmxlbmd0aCAhPT0gMiApIHtcXG5cXHRcXHRcXHRcXHRyYnVnZ3lRU0EucHVzaCggXFxcIjplbmFibGVkXFxcIiwgXFxcIjpkaXNhYmxlZFxcXCIgKTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gU3VwcG9ydDogSUU5LTExK1xcblxcdFxcdFxcdC8vIElFJ3MgOmRpc2FibGVkIHNlbGVjdG9yIGRvZXMgbm90IHBpY2sgdXAgdGhlIGNoaWxkcmVuIG9mIGRpc2FibGVkIGZpZWxkc2V0c1xcblxcdFxcdFxcdGRvY0VsZW0uYXBwZW5kQ2hpbGQoIGVsICkuZGlzYWJsZWQgPSB0cnVlO1xcblxcdFxcdFxcdGlmICggZWwucXVlcnlTZWxlY3RvckFsbChcXFwiOmRpc2FibGVkXFxcIikubGVuZ3RoICE9PSAyICkge1xcblxcdFxcdFxcdFxcdHJidWdneVFTQS5wdXNoKCBcXFwiOmVuYWJsZWRcXFwiLCBcXFwiOmRpc2FibGVkXFxcIiApO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBPcGVyYSAxMC0xMSBkb2VzIG5vdCB0aHJvdyBvbiBwb3N0LWNvbW1hIGludmFsaWQgcHNldWRvc1xcblxcdFxcdFxcdGVsLnF1ZXJ5U2VsZWN0b3JBbGwoXFxcIiosOnhcXFwiKTtcXG5cXHRcXHRcXHRyYnVnZ3lRU0EucHVzaChcXFwiLC4qOlxcXCIpO1xcblxcdFxcdH0pO1xcblxcdH1cXG5cXG5cXHRpZiAoIChzdXBwb3J0Lm1hdGNoZXNTZWxlY3RvciA9IHJuYXRpdmUudGVzdCggKG1hdGNoZXMgPSBkb2NFbGVtLm1hdGNoZXMgfHxcXG5cXHRcXHRkb2NFbGVtLndlYmtpdE1hdGNoZXNTZWxlY3RvciB8fFxcblxcdFxcdGRvY0VsZW0ubW96TWF0Y2hlc1NlbGVjdG9yIHx8XFxuXFx0XFx0ZG9jRWxlbS5vTWF0Y2hlc1NlbGVjdG9yIHx8XFxuXFx0XFx0ZG9jRWxlbS5tc01hdGNoZXNTZWxlY3RvcikgKSkgKSB7XFxuXFxuXFx0XFx0YXNzZXJ0KGZ1bmN0aW9uKCBlbCApIHtcXG5cXHRcXHRcXHQvLyBDaGVjayB0byBzZWUgaWYgaXQncyBwb3NzaWJsZSB0byBkbyBtYXRjaGVzU2VsZWN0b3JcXG5cXHRcXHRcXHQvLyBvbiBhIGRpc2Nvbm5lY3RlZCBub2RlIChJRSA5KVxcblxcdFxcdFxcdHN1cHBvcnQuZGlzY29ubmVjdGVkTWF0Y2ggPSBtYXRjaGVzLmNhbGwoIGVsLCBcXFwiKlxcXCIgKTtcXG5cXG5cXHRcXHRcXHQvLyBUaGlzIHNob3VsZCBmYWlsIHdpdGggYW4gZXhjZXB0aW9uXFxuXFx0XFx0XFx0Ly8gR2Vja28gZG9lcyBub3QgZXJyb3IsIHJldHVybnMgZmFsc2UgaW5zdGVhZFxcblxcdFxcdFxcdG1hdGNoZXMuY2FsbCggZWwsIFxcXCJbcyE9JyddOnhcXFwiICk7XFxuXFx0XFx0XFx0cmJ1Z2d5TWF0Y2hlcy5wdXNoKCBcXFwiIT1cXFwiLCBwc2V1ZG9zICk7XFxuXFx0XFx0fSk7XFxuXFx0fVxcblxcblxcdHJidWdneVFTQSA9IHJidWdneVFTQS5sZW5ndGggJiYgbmV3IFJlZ0V4cCggcmJ1Z2d5UVNBLmpvaW4oXFxcInxcXFwiKSApO1xcblxcdHJidWdneU1hdGNoZXMgPSByYnVnZ3lNYXRjaGVzLmxlbmd0aCAmJiBuZXcgUmVnRXhwKCByYnVnZ3lNYXRjaGVzLmpvaW4oXFxcInxcXFwiKSApO1xcblxcblxcdC8qIENvbnRhaW5zXFxuXFx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xcblxcdGhhc0NvbXBhcmUgPSBybmF0aXZlLnRlc3QoIGRvY0VsZW0uY29tcGFyZURvY3VtZW50UG9zaXRpb24gKTtcXG5cXG5cXHQvLyBFbGVtZW50IGNvbnRhaW5zIGFub3RoZXJcXG5cXHQvLyBQdXJwb3NlZnVsbHkgc2VsZi1leGNsdXNpdmVcXG5cXHQvLyBBcyBpbiwgYW4gZWxlbWVudCBkb2VzIG5vdCBjb250YWluIGl0c2VsZlxcblxcdGNvbnRhaW5zID0gaGFzQ29tcGFyZSB8fCBybmF0aXZlLnRlc3QoIGRvY0VsZW0uY29udGFpbnMgKSA/XFxuXFx0XFx0ZnVuY3Rpb24oIGEsIGIgKSB7XFxuXFx0XFx0XFx0dmFyIGFkb3duID0gYS5ub2RlVHlwZSA9PT0gOSA/IGEuZG9jdW1lbnRFbGVtZW50IDogYSxcXG5cXHRcXHRcXHRcXHRidXAgPSBiICYmIGIucGFyZW50Tm9kZTtcXG5cXHRcXHRcXHRyZXR1cm4gYSA9PT0gYnVwIHx8ICEhKCBidXAgJiYgYnVwLm5vZGVUeXBlID09PSAxICYmIChcXG5cXHRcXHRcXHRcXHRhZG93bi5jb250YWlucyA/XFxuXFx0XFx0XFx0XFx0XFx0YWRvd24uY29udGFpbnMoIGJ1cCApIDpcXG5cXHRcXHRcXHRcXHRcXHRhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uICYmIGEuY29tcGFyZURvY3VtZW50UG9zaXRpb24oIGJ1cCApICYgMTZcXG5cXHRcXHRcXHQpKTtcXG5cXHRcXHR9IDpcXG5cXHRcXHRmdW5jdGlvbiggYSwgYiApIHtcXG5cXHRcXHRcXHRpZiAoIGIgKSB7XFxuXFx0XFx0XFx0XFx0d2hpbGUgKCAoYiA9IGIucGFyZW50Tm9kZSkgKSB7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBiID09PSBhICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiB0cnVlO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHJldHVybiBmYWxzZTtcXG5cXHRcXHR9O1xcblxcblxcdC8qIFNvcnRpbmdcXG5cXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXFxuXFxuXFx0Ly8gRG9jdW1lbnQgb3JkZXIgc29ydGluZ1xcblxcdHNvcnRPcmRlciA9IGhhc0NvbXBhcmUgP1xcblxcdGZ1bmN0aW9uKCBhLCBiICkge1xcblxcblxcdFxcdC8vIEZsYWcgZm9yIGR1cGxpY2F0ZSByZW1vdmFsXFxuXFx0XFx0aWYgKCBhID09PSBiICkge1xcblxcdFxcdFxcdGhhc0R1cGxpY2F0ZSA9IHRydWU7XFxuXFx0XFx0XFx0cmV0dXJuIDA7XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIFNvcnQgb24gbWV0aG9kIGV4aXN0ZW5jZSBpZiBvbmx5IG9uZSBpbnB1dCBoYXMgY29tcGFyZURvY3VtZW50UG9zaXRpb25cXG5cXHRcXHR2YXIgY29tcGFyZSA9ICFhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uIC0gIWIuY29tcGFyZURvY3VtZW50UG9zaXRpb247XFxuXFx0XFx0aWYgKCBjb21wYXJlICkge1xcblxcdFxcdFxcdHJldHVybiBjb21wYXJlO1xcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBDYWxjdWxhdGUgcG9zaXRpb24gaWYgYm90aCBpbnB1dHMgYmVsb25nIHRvIHRoZSBzYW1lIGRvY3VtZW50XFxuXFx0XFx0Y29tcGFyZSA9ICggYS5vd25lckRvY3VtZW50IHx8IGEgKSA9PT0gKCBiLm93bmVyRG9jdW1lbnQgfHwgYiApID9cXG5cXHRcXHRcXHRhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKCBiICkgOlxcblxcblxcdFxcdFxcdC8vIE90aGVyd2lzZSB3ZSBrbm93IHRoZXkgYXJlIGRpc2Nvbm5lY3RlZFxcblxcdFxcdFxcdDE7XFxuXFxuXFx0XFx0Ly8gRGlzY29ubmVjdGVkIG5vZGVzXFxuXFx0XFx0aWYgKCBjb21wYXJlICYgMSB8fFxcblxcdFxcdFxcdCghc3VwcG9ydC5zb3J0RGV0YWNoZWQgJiYgYi5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiggYSApID09PSBjb21wYXJlKSApIHtcXG5cXG5cXHRcXHRcXHQvLyBDaG9vc2UgdGhlIGZpcnN0IGVsZW1lbnQgdGhhdCBpcyByZWxhdGVkIHRvIG91ciBwcmVmZXJyZWQgZG9jdW1lbnRcXG5cXHRcXHRcXHRpZiAoIGEgPT09IGRvY3VtZW50IHx8IGEub3duZXJEb2N1bWVudCA9PT0gcHJlZmVycmVkRG9jICYmIGNvbnRhaW5zKHByZWZlcnJlZERvYywgYSkgKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIC0xO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAoIGIgPT09IGRvY3VtZW50IHx8IGIub3duZXJEb2N1bWVudCA9PT0gcHJlZmVycmVkRG9jICYmIGNvbnRhaW5zKHByZWZlcnJlZERvYywgYikgKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIDE7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIE1haW50YWluIG9yaWdpbmFsIG9yZGVyXFxuXFx0XFx0XFx0cmV0dXJuIHNvcnRJbnB1dCA/XFxuXFx0XFx0XFx0XFx0KCBpbmRleE9mKCBzb3J0SW5wdXQsIGEgKSAtIGluZGV4T2YoIHNvcnRJbnB1dCwgYiApICkgOlxcblxcdFxcdFxcdFxcdDA7XFxuXFx0XFx0fVxcblxcblxcdFxcdHJldHVybiBjb21wYXJlICYgNCA/IC0xIDogMTtcXG5cXHR9IDpcXG5cXHRmdW5jdGlvbiggYSwgYiApIHtcXG5cXHRcXHQvLyBFeGl0IGVhcmx5IGlmIHRoZSBub2RlcyBhcmUgaWRlbnRpY2FsXFxuXFx0XFx0aWYgKCBhID09PSBiICkge1xcblxcdFxcdFxcdGhhc0R1cGxpY2F0ZSA9IHRydWU7XFxuXFx0XFx0XFx0cmV0dXJuIDA7XFxuXFx0XFx0fVxcblxcblxcdFxcdHZhciBjdXIsXFxuXFx0XFx0XFx0aSA9IDAsXFxuXFx0XFx0XFx0YXVwID0gYS5wYXJlbnROb2RlLFxcblxcdFxcdFxcdGJ1cCA9IGIucGFyZW50Tm9kZSxcXG5cXHRcXHRcXHRhcCA9IFsgYSBdLFxcblxcdFxcdFxcdGJwID0gWyBiIF07XFxuXFxuXFx0XFx0Ly8gUGFyZW50bGVzcyBub2RlcyBhcmUgZWl0aGVyIGRvY3VtZW50cyBvciBkaXNjb25uZWN0ZWRcXG5cXHRcXHRpZiAoICFhdXAgfHwgIWJ1cCApIHtcXG5cXHRcXHRcXHRyZXR1cm4gYSA9PT0gZG9jdW1lbnQgPyAtMSA6XFxuXFx0XFx0XFx0XFx0YiA9PT0gZG9jdW1lbnQgPyAxIDpcXG5cXHRcXHRcXHRcXHRhdXAgPyAtMSA6XFxuXFx0XFx0XFx0XFx0YnVwID8gMSA6XFxuXFx0XFx0XFx0XFx0c29ydElucHV0ID9cXG5cXHRcXHRcXHRcXHQoIGluZGV4T2YoIHNvcnRJbnB1dCwgYSApIC0gaW5kZXhPZiggc29ydElucHV0LCBiICkgKSA6XFxuXFx0XFx0XFx0XFx0MDtcXG5cXG5cXHRcXHQvLyBJZiB0aGUgbm9kZXMgYXJlIHNpYmxpbmdzLCB3ZSBjYW4gZG8gYSBxdWljayBjaGVja1xcblxcdFxcdH0gZWxzZSBpZiAoIGF1cCA9PT0gYnVwICkge1xcblxcdFxcdFxcdHJldHVybiBzaWJsaW5nQ2hlY2soIGEsIGIgKTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gT3RoZXJ3aXNlIHdlIG5lZWQgZnVsbCBsaXN0cyBvZiB0aGVpciBhbmNlc3RvcnMgZm9yIGNvbXBhcmlzb25cXG5cXHRcXHRjdXIgPSBhO1xcblxcdFxcdHdoaWxlICggKGN1ciA9IGN1ci5wYXJlbnROb2RlKSApIHtcXG5cXHRcXHRcXHRhcC51bnNoaWZ0KCBjdXIgKTtcXG5cXHRcXHR9XFxuXFx0XFx0Y3VyID0gYjtcXG5cXHRcXHR3aGlsZSAoIChjdXIgPSBjdXIucGFyZW50Tm9kZSkgKSB7XFxuXFx0XFx0XFx0YnAudW5zaGlmdCggY3VyICk7XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIFdhbGsgZG93biB0aGUgdHJlZSBsb29raW5nIGZvciBhIGRpc2NyZXBhbmN5XFxuXFx0XFx0d2hpbGUgKCBhcFtpXSA9PT0gYnBbaV0gKSB7XFxuXFx0XFx0XFx0aSsrO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRyZXR1cm4gaSA/XFxuXFx0XFx0XFx0Ly8gRG8gYSBzaWJsaW5nIGNoZWNrIGlmIHRoZSBub2RlcyBoYXZlIGEgY29tbW9uIGFuY2VzdG9yXFxuXFx0XFx0XFx0c2libGluZ0NoZWNrKCBhcFtpXSwgYnBbaV0gKSA6XFxuXFxuXFx0XFx0XFx0Ly8gT3RoZXJ3aXNlIG5vZGVzIGluIG91ciBkb2N1bWVudCBzb3J0IGZpcnN0XFxuXFx0XFx0XFx0YXBbaV0gPT09IHByZWZlcnJlZERvYyA/IC0xIDpcXG5cXHRcXHRcXHRicFtpXSA9PT0gcHJlZmVycmVkRG9jID8gMSA6XFxuXFx0XFx0XFx0MDtcXG5cXHR9O1xcblxcblxcdHJldHVybiBkb2N1bWVudDtcXG59O1xcblxcblNpenpsZS5tYXRjaGVzID0gZnVuY3Rpb24oIGV4cHIsIGVsZW1lbnRzICkge1xcblxcdHJldHVybiBTaXp6bGUoIGV4cHIsIG51bGwsIG51bGwsIGVsZW1lbnRzICk7XFxufTtcXG5cXG5TaXp6bGUubWF0Y2hlc1NlbGVjdG9yID0gZnVuY3Rpb24oIGVsZW0sIGV4cHIgKSB7XFxuXFx0Ly8gU2V0IGRvY3VtZW50IHZhcnMgaWYgbmVlZGVkXFxuXFx0aWYgKCAoIGVsZW0ub3duZXJEb2N1bWVudCB8fCBlbGVtICkgIT09IGRvY3VtZW50ICkge1xcblxcdFxcdHNldERvY3VtZW50KCBlbGVtICk7XFxuXFx0fVxcblxcblxcdC8vIE1ha2Ugc3VyZSB0aGF0IGF0dHJpYnV0ZSBzZWxlY3RvcnMgYXJlIHF1b3RlZFxcblxcdGV4cHIgPSBleHByLnJlcGxhY2UoIHJhdHRyaWJ1dGVRdW90ZXMsIFxcXCI9JyQxJ11cXFwiICk7XFxuXFxuXFx0aWYgKCBzdXBwb3J0Lm1hdGNoZXNTZWxlY3RvciAmJiBkb2N1bWVudElzSFRNTCAmJlxcblxcdFxcdCFjb21waWxlckNhY2hlWyBleHByICsgXFxcIiBcXFwiIF0gJiZcXG5cXHRcXHQoICFyYnVnZ3lNYXRjaGVzIHx8ICFyYnVnZ3lNYXRjaGVzLnRlc3QoIGV4cHIgKSApICYmXFxuXFx0XFx0KCAhcmJ1Z2d5UVNBICAgICB8fCAhcmJ1Z2d5UVNBLnRlc3QoIGV4cHIgKSApICkge1xcblxcblxcdFxcdHRyeSB7XFxuXFx0XFx0XFx0dmFyIHJldCA9IG1hdGNoZXMuY2FsbCggZWxlbSwgZXhwciApO1xcblxcblxcdFxcdFxcdC8vIElFIDkncyBtYXRjaGVzU2VsZWN0b3IgcmV0dXJucyBmYWxzZSBvbiBkaXNjb25uZWN0ZWQgbm9kZXNcXG5cXHRcXHRcXHRpZiAoIHJldCB8fCBzdXBwb3J0LmRpc2Nvbm5lY3RlZE1hdGNoIHx8XFxuXFx0XFx0XFx0XFx0XFx0Ly8gQXMgd2VsbCwgZGlzY29ubmVjdGVkIG5vZGVzIGFyZSBzYWlkIHRvIGJlIGluIGEgZG9jdW1lbnRcXG5cXHRcXHRcXHRcXHRcXHQvLyBmcmFnbWVudCBpbiBJRSA5XFxuXFx0XFx0XFx0XFx0XFx0ZWxlbS5kb2N1bWVudCAmJiBlbGVtLmRvY3VtZW50Lm5vZGVUeXBlICE9PSAxMSApIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gcmV0O1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9IGNhdGNoIChlKSB7fVxcblxcdH1cXG5cXG5cXHRyZXR1cm4gU2l6emxlKCBleHByLCBkb2N1bWVudCwgbnVsbCwgWyBlbGVtIF0gKS5sZW5ndGggPiAwO1xcbn07XFxuXFxuU2l6emxlLmNvbnRhaW5zID0gZnVuY3Rpb24oIGNvbnRleHQsIGVsZW0gKSB7XFxuXFx0Ly8gU2V0IGRvY3VtZW50IHZhcnMgaWYgbmVlZGVkXFxuXFx0aWYgKCAoIGNvbnRleHQub3duZXJEb2N1bWVudCB8fCBjb250ZXh0ICkgIT09IGRvY3VtZW50ICkge1xcblxcdFxcdHNldERvY3VtZW50KCBjb250ZXh0ICk7XFxuXFx0fVxcblxcdHJldHVybiBjb250YWlucyggY29udGV4dCwgZWxlbSApO1xcbn07XFxuXFxuU2l6emxlLmF0dHIgPSBmdW5jdGlvbiggZWxlbSwgbmFtZSApIHtcXG5cXHQvLyBTZXQgZG9jdW1lbnQgdmFycyBpZiBuZWVkZWRcXG5cXHRpZiAoICggZWxlbS5vd25lckRvY3VtZW50IHx8IGVsZW0gKSAhPT0gZG9jdW1lbnQgKSB7XFxuXFx0XFx0c2V0RG9jdW1lbnQoIGVsZW0gKTtcXG5cXHR9XFxuXFxuXFx0dmFyIGZuID0gRXhwci5hdHRySGFuZGxlWyBuYW1lLnRvTG93ZXJDYXNlKCkgXSxcXG5cXHRcXHQvLyBEb24ndCBnZXQgZm9vbGVkIGJ5IE9iamVjdC5wcm90b3R5cGUgcHJvcGVydGllcyAoalF1ZXJ5ICMxMzgwNylcXG5cXHRcXHR2YWwgPSBmbiAmJiBoYXNPd24uY2FsbCggRXhwci5hdHRySGFuZGxlLCBuYW1lLnRvTG93ZXJDYXNlKCkgKSA/XFxuXFx0XFx0XFx0Zm4oIGVsZW0sIG5hbWUsICFkb2N1bWVudElzSFRNTCApIDpcXG5cXHRcXHRcXHR1bmRlZmluZWQ7XFxuXFxuXFx0cmV0dXJuIHZhbCAhPT0gdW5kZWZpbmVkID9cXG5cXHRcXHR2YWwgOlxcblxcdFxcdHN1cHBvcnQuYXR0cmlidXRlcyB8fCAhZG9jdW1lbnRJc0hUTUwgP1xcblxcdFxcdFxcdGVsZW0uZ2V0QXR0cmlidXRlKCBuYW1lICkgOlxcblxcdFxcdFxcdCh2YWwgPSBlbGVtLmdldEF0dHJpYnV0ZU5vZGUobmFtZSkpICYmIHZhbC5zcGVjaWZpZWQgP1xcblxcdFxcdFxcdFxcdHZhbC52YWx1ZSA6XFxuXFx0XFx0XFx0XFx0bnVsbDtcXG59O1xcblxcblNpenpsZS5lc2NhcGUgPSBmdW5jdGlvbiggc2VsICkge1xcblxcdHJldHVybiAoc2VsICsgXFxcIlxcXCIpLnJlcGxhY2UoIHJjc3Nlc2NhcGUsIGZjc3Nlc2NhcGUgKTtcXG59O1xcblxcblNpenpsZS5lcnJvciA9IGZ1bmN0aW9uKCBtc2cgKSB7XFxuXFx0dGhyb3cgbmV3IEVycm9yKCBcXFwiU3ludGF4IGVycm9yLCB1bnJlY29nbml6ZWQgZXhwcmVzc2lvbjogXFxcIiArIG1zZyApO1xcbn07XFxuXFxuLyoqXFxuICogRG9jdW1lbnQgc29ydGluZyBhbmQgcmVtb3ZpbmcgZHVwbGljYXRlc1xcbiAqIEBwYXJhbSB7QXJyYXlMaWtlfSByZXN1bHRzXFxuICovXFxuU2l6emxlLnVuaXF1ZVNvcnQgPSBmdW5jdGlvbiggcmVzdWx0cyApIHtcXG5cXHR2YXIgZWxlbSxcXG5cXHRcXHRkdXBsaWNhdGVzID0gW10sXFxuXFx0XFx0aiA9IDAsXFxuXFx0XFx0aSA9IDA7XFxuXFxuXFx0Ly8gVW5sZXNzIHdlICprbm93KiB3ZSBjYW4gZGV0ZWN0IGR1cGxpY2F0ZXMsIGFzc3VtZSB0aGVpciBwcmVzZW5jZVxcblxcdGhhc0R1cGxpY2F0ZSA9ICFzdXBwb3J0LmRldGVjdER1cGxpY2F0ZXM7XFxuXFx0c29ydElucHV0ID0gIXN1cHBvcnQuc29ydFN0YWJsZSAmJiByZXN1bHRzLnNsaWNlKCAwICk7XFxuXFx0cmVzdWx0cy5zb3J0KCBzb3J0T3JkZXIgKTtcXG5cXG5cXHRpZiAoIGhhc0R1cGxpY2F0ZSApIHtcXG5cXHRcXHR3aGlsZSAoIChlbGVtID0gcmVzdWx0c1tpKytdKSApIHtcXG5cXHRcXHRcXHRpZiAoIGVsZW0gPT09IHJlc3VsdHNbIGkgXSApIHtcXG5cXHRcXHRcXHRcXHRqID0gZHVwbGljYXRlcy5wdXNoKCBpICk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXHRcXHR3aGlsZSAoIGotLSApIHtcXG5cXHRcXHRcXHRyZXN1bHRzLnNwbGljZSggZHVwbGljYXRlc1sgaiBdLCAxICk7XFxuXFx0XFx0fVxcblxcdH1cXG5cXG5cXHQvLyBDbGVhciBpbnB1dCBhZnRlciBzb3J0aW5nIHRvIHJlbGVhc2Ugb2JqZWN0c1xcblxcdC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vanF1ZXJ5L3NpenpsZS9wdWxsLzIyNVxcblxcdHNvcnRJbnB1dCA9IG51bGw7XFxuXFxuXFx0cmV0dXJuIHJlc3VsdHM7XFxufTtcXG5cXG4vKipcXG4gKiBVdGlsaXR5IGZ1bmN0aW9uIGZvciByZXRyaWV2aW5nIHRoZSB0ZXh0IHZhbHVlIG9mIGFuIGFycmF5IG9mIERPTSBub2Rlc1xcbiAqIEBwYXJhbSB7QXJyYXl8RWxlbWVudH0gZWxlbVxcbiAqL1xcbmdldFRleHQgPSBTaXp6bGUuZ2V0VGV4dCA9IGZ1bmN0aW9uKCBlbGVtICkge1xcblxcdHZhciBub2RlLFxcblxcdFxcdHJldCA9IFxcXCJcXFwiLFxcblxcdFxcdGkgPSAwLFxcblxcdFxcdG5vZGVUeXBlID0gZWxlbS5ub2RlVHlwZTtcXG5cXG5cXHRpZiAoICFub2RlVHlwZSApIHtcXG5cXHRcXHQvLyBJZiBubyBub2RlVHlwZSwgdGhpcyBpcyBleHBlY3RlZCB0byBiZSBhbiBhcnJheVxcblxcdFxcdHdoaWxlICggKG5vZGUgPSBlbGVtW2krK10pICkge1xcblxcdFxcdFxcdC8vIERvIG5vdCB0cmF2ZXJzZSBjb21tZW50IG5vZGVzXFxuXFx0XFx0XFx0cmV0ICs9IGdldFRleHQoIG5vZGUgKTtcXG5cXHRcXHR9XFxuXFx0fSBlbHNlIGlmICggbm9kZVR5cGUgPT09IDEgfHwgbm9kZVR5cGUgPT09IDkgfHwgbm9kZVR5cGUgPT09IDExICkge1xcblxcdFxcdC8vIFVzZSB0ZXh0Q29udGVudCBmb3IgZWxlbWVudHNcXG5cXHRcXHQvLyBpbm5lclRleHQgdXNhZ2UgcmVtb3ZlZCBmb3IgY29uc2lzdGVuY3kgb2YgbmV3IGxpbmVzIChqUXVlcnkgIzExMTUzKVxcblxcdFxcdGlmICggdHlwZW9mIGVsZW0udGV4dENvbnRlbnQgPT09IFxcXCJzdHJpbmdcXFwiICkge1xcblxcdFxcdFxcdHJldHVybiBlbGVtLnRleHRDb250ZW50O1xcblxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0Ly8gVHJhdmVyc2UgaXRzIGNoaWxkcmVuXFxuXFx0XFx0XFx0Zm9yICggZWxlbSA9IGVsZW0uZmlyc3RDaGlsZDsgZWxlbTsgZWxlbSA9IGVsZW0ubmV4dFNpYmxpbmcgKSB7XFxuXFx0XFx0XFx0XFx0cmV0ICs9IGdldFRleHQoIGVsZW0gKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcdH0gZWxzZSBpZiAoIG5vZGVUeXBlID09PSAzIHx8IG5vZGVUeXBlID09PSA0ICkge1xcblxcdFxcdHJldHVybiBlbGVtLm5vZGVWYWx1ZTtcXG5cXHR9XFxuXFx0Ly8gRG8gbm90IGluY2x1ZGUgY29tbWVudCBvciBwcm9jZXNzaW5nIGluc3RydWN0aW9uIG5vZGVzXFxuXFxuXFx0cmV0dXJuIHJldDtcXG59O1xcblxcbkV4cHIgPSBTaXp6bGUuc2VsZWN0b3JzID0ge1xcblxcblxcdC8vIENhbiBiZSBhZGp1c3RlZCBieSB0aGUgdXNlclxcblxcdGNhY2hlTGVuZ3RoOiA1MCxcXG5cXG5cXHRjcmVhdGVQc2V1ZG86IG1hcmtGdW5jdGlvbixcXG5cXG5cXHRtYXRjaDogbWF0Y2hFeHByLFxcblxcblxcdGF0dHJIYW5kbGU6IHt9LFxcblxcblxcdGZpbmQ6IHt9LFxcblxcblxcdHJlbGF0aXZlOiB7XFxuXFx0XFx0XFxcIj5cXFwiOiB7IGRpcjogXFxcInBhcmVudE5vZGVcXFwiLCBmaXJzdDogdHJ1ZSB9LFxcblxcdFxcdFxcXCIgXFxcIjogeyBkaXI6IFxcXCJwYXJlbnROb2RlXFxcIiB9LFxcblxcdFxcdFxcXCIrXFxcIjogeyBkaXI6IFxcXCJwcmV2aW91c1NpYmxpbmdcXFwiLCBmaXJzdDogdHJ1ZSB9LFxcblxcdFxcdFxcXCJ+XFxcIjogeyBkaXI6IFxcXCJwcmV2aW91c1NpYmxpbmdcXFwiIH1cXG5cXHR9LFxcblxcblxcdHByZUZpbHRlcjoge1xcblxcdFxcdFxcXCJBVFRSXFxcIjogZnVuY3Rpb24oIG1hdGNoICkge1xcblxcdFxcdFxcdG1hdGNoWzFdID0gbWF0Y2hbMV0ucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcXG5cXG5cXHRcXHRcXHQvLyBNb3ZlIHRoZSBnaXZlbiB2YWx1ZSB0byBtYXRjaFszXSB3aGV0aGVyIHF1b3RlZCBvciB1bnF1b3RlZFxcblxcdFxcdFxcdG1hdGNoWzNdID0gKCBtYXRjaFszXSB8fCBtYXRjaFs0XSB8fCBtYXRjaFs1XSB8fCBcXFwiXFxcIiApLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XFxuXFxuXFx0XFx0XFx0aWYgKCBtYXRjaFsyXSA9PT0gXFxcIn49XFxcIiApIHtcXG5cXHRcXHRcXHRcXHRtYXRjaFszXSA9IFxcXCIgXFxcIiArIG1hdGNoWzNdICsgXFxcIiBcXFwiO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRyZXR1cm4gbWF0Y2guc2xpY2UoIDAsIDQgKTtcXG5cXHRcXHR9LFxcblxcblxcdFxcdFxcXCJDSElMRFxcXCI6IGZ1bmN0aW9uKCBtYXRjaCApIHtcXG5cXHRcXHRcXHQvKiBtYXRjaGVzIGZyb20gbWF0Y2hFeHByW1xcXCJDSElMRFxcXCJdXFxuXFx0XFx0XFx0XFx0MSB0eXBlIChvbmx5fG50aHwuLi4pXFxuXFx0XFx0XFx0XFx0MiB3aGF0IChjaGlsZHxvZi10eXBlKVxcblxcdFxcdFxcdFxcdDMgYXJndW1lbnQgKGV2ZW58b2RkfFxcXFxkKnxcXFxcZCpuKFsrLV1cXFxcZCspP3wuLi4pXFxuXFx0XFx0XFx0XFx0NCB4bi1jb21wb25lbnQgb2YgeG4reSBhcmd1bWVudCAoWystXT9cXFxcZCpufClcXG5cXHRcXHRcXHRcXHQ1IHNpZ24gb2YgeG4tY29tcG9uZW50XFxuXFx0XFx0XFx0XFx0NiB4IG9mIHhuLWNvbXBvbmVudFxcblxcdFxcdFxcdFxcdDcgc2lnbiBvZiB5LWNvbXBvbmVudFxcblxcdFxcdFxcdFxcdDggeSBvZiB5LWNvbXBvbmVudFxcblxcdFxcdFxcdCovXFxuXFx0XFx0XFx0bWF0Y2hbMV0gPSBtYXRjaFsxXS50b0xvd2VyQ2FzZSgpO1xcblxcblxcdFxcdFxcdGlmICggbWF0Y2hbMV0uc2xpY2UoIDAsIDMgKSA9PT0gXFxcIm50aFxcXCIgKSB7XFxuXFx0XFx0XFx0XFx0Ly8gbnRoLSogcmVxdWlyZXMgYXJndW1lbnRcXG5cXHRcXHRcXHRcXHRpZiAoICFtYXRjaFszXSApIHtcXG5cXHRcXHRcXHRcXHRcXHRTaXp6bGUuZXJyb3IoIG1hdGNoWzBdICk7XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdC8vIG51bWVyaWMgeCBhbmQgeSBwYXJhbWV0ZXJzIGZvciBFeHByLmZpbHRlci5DSElMRFxcblxcdFxcdFxcdFxcdC8vIHJlbWVtYmVyIHRoYXQgZmFsc2UvdHJ1ZSBjYXN0IHJlc3BlY3RpdmVseSB0byAwLzFcXG5cXHRcXHRcXHRcXHRtYXRjaFs0XSA9ICsoIG1hdGNoWzRdID8gbWF0Y2hbNV0gKyAobWF0Y2hbNl0gfHwgMSkgOiAyICogKCBtYXRjaFszXSA9PT0gXFxcImV2ZW5cXFwiIHx8IG1hdGNoWzNdID09PSBcXFwib2RkXFxcIiApICk7XFxuXFx0XFx0XFx0XFx0bWF0Y2hbNV0gPSArKCAoIG1hdGNoWzddICsgbWF0Y2hbOF0gKSB8fCBtYXRjaFszXSA9PT0gXFxcIm9kZFxcXCIgKTtcXG5cXG5cXHRcXHRcXHQvLyBvdGhlciB0eXBlcyBwcm9oaWJpdCBhcmd1bWVudHNcXG5cXHRcXHRcXHR9IGVsc2UgaWYgKCBtYXRjaFszXSApIHtcXG5cXHRcXHRcXHRcXHRTaXp6bGUuZXJyb3IoIG1hdGNoWzBdICk7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHJldHVybiBtYXRjaDtcXG5cXHRcXHR9LFxcblxcblxcdFxcdFxcXCJQU0VVRE9cXFwiOiBmdW5jdGlvbiggbWF0Y2ggKSB7XFxuXFx0XFx0XFx0dmFyIGV4Y2VzcyxcXG5cXHRcXHRcXHRcXHR1bnF1b3RlZCA9ICFtYXRjaFs2XSAmJiBtYXRjaFsyXTtcXG5cXG5cXHRcXHRcXHRpZiAoIG1hdGNoRXhwcltcXFwiQ0hJTERcXFwiXS50ZXN0KCBtYXRjaFswXSApICkge1xcblxcdFxcdFxcdFxcdHJldHVybiBudWxsO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBBY2NlcHQgcXVvdGVkIGFyZ3VtZW50cyBhcy1pc1xcblxcdFxcdFxcdGlmICggbWF0Y2hbM10gKSB7XFxuXFx0XFx0XFx0XFx0bWF0Y2hbMl0gPSBtYXRjaFs0XSB8fCBtYXRjaFs1XSB8fCBcXFwiXFxcIjtcXG5cXG5cXHRcXHRcXHQvLyBTdHJpcCBleGNlc3MgY2hhcmFjdGVycyBmcm9tIHVucXVvdGVkIGFyZ3VtZW50c1xcblxcdFxcdFxcdH0gZWxzZSBpZiAoIHVucXVvdGVkICYmIHJwc2V1ZG8udGVzdCggdW5xdW90ZWQgKSAmJlxcblxcdFxcdFxcdFxcdC8vIEdldCBleGNlc3MgZnJvbSB0b2tlbml6ZSAocmVjdXJzaXZlbHkpXFxuXFx0XFx0XFx0XFx0KGV4Y2VzcyA9IHRva2VuaXplKCB1bnF1b3RlZCwgdHJ1ZSApKSAmJlxcblxcdFxcdFxcdFxcdC8vIGFkdmFuY2UgdG8gdGhlIG5leHQgY2xvc2luZyBwYXJlbnRoZXNpc1xcblxcdFxcdFxcdFxcdChleGNlc3MgPSB1bnF1b3RlZC5pbmRleE9mKCBcXFwiKVxcXCIsIHVucXVvdGVkLmxlbmd0aCAtIGV4Y2VzcyApIC0gdW5xdW90ZWQubGVuZ3RoKSApIHtcXG5cXG5cXHRcXHRcXHRcXHQvLyBleGNlc3MgaXMgYSBuZWdhdGl2ZSBpbmRleFxcblxcdFxcdFxcdFxcdG1hdGNoWzBdID0gbWF0Y2hbMF0uc2xpY2UoIDAsIGV4Y2VzcyApO1xcblxcdFxcdFxcdFxcdG1hdGNoWzJdID0gdW5xdW90ZWQuc2xpY2UoIDAsIGV4Y2VzcyApO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBSZXR1cm4gb25seSBjYXB0dXJlcyBuZWVkZWQgYnkgdGhlIHBzZXVkbyBmaWx0ZXIgbWV0aG9kICh0eXBlIGFuZCBhcmd1bWVudClcXG5cXHRcXHRcXHRyZXR1cm4gbWF0Y2guc2xpY2UoIDAsIDMgKTtcXG5cXHRcXHR9XFxuXFx0fSxcXG5cXG5cXHRmaWx0ZXI6IHtcXG5cXG5cXHRcXHRcXFwiVEFHXFxcIjogZnVuY3Rpb24oIG5vZGVOYW1lU2VsZWN0b3IgKSB7XFxuXFx0XFx0XFx0dmFyIG5vZGVOYW1lID0gbm9kZU5hbWVTZWxlY3Rvci5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApLnRvTG93ZXJDYXNlKCk7XFxuXFx0XFx0XFx0cmV0dXJuIG5vZGVOYW1lU2VsZWN0b3IgPT09IFxcXCIqXFxcIiA/XFxuXFx0XFx0XFx0XFx0ZnVuY3Rpb24oKSB7IHJldHVybiB0cnVlOyB9IDpcXG5cXHRcXHRcXHRcXHRmdW5jdGlvbiggZWxlbSApIHtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gZWxlbS5ub2RlTmFtZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IG5vZGVOYW1lO1xcblxcdFxcdFxcdFxcdH07XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRcXFwiQ0xBU1NcXFwiOiBmdW5jdGlvbiggY2xhc3NOYW1lICkge1xcblxcdFxcdFxcdHZhciBwYXR0ZXJuID0gY2xhc3NDYWNoZVsgY2xhc3NOYW1lICsgXFxcIiBcXFwiIF07XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHBhdHRlcm4gfHxcXG5cXHRcXHRcXHRcXHQocGF0dGVybiA9IG5ldyBSZWdFeHAoIFxcXCIoXnxcXFwiICsgd2hpdGVzcGFjZSArIFxcXCIpXFxcIiArIGNsYXNzTmFtZSArIFxcXCIoXFxcIiArIHdoaXRlc3BhY2UgKyBcXFwifCQpXFxcIiApKSAmJlxcblxcdFxcdFxcdFxcdGNsYXNzQ2FjaGUoIGNsYXNzTmFtZSwgZnVuY3Rpb24oIGVsZW0gKSB7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIHBhdHRlcm4udGVzdCggdHlwZW9mIGVsZW0uY2xhc3NOYW1lID09PSBcXFwic3RyaW5nXFxcIiAmJiBlbGVtLmNsYXNzTmFtZSB8fCB0eXBlb2YgZWxlbS5nZXRBdHRyaWJ1dGUgIT09IFxcXCJ1bmRlZmluZWRcXFwiICYmIGVsZW0uZ2V0QXR0cmlidXRlKFxcXCJjbGFzc1xcXCIpIHx8IFxcXCJcXFwiICk7XFxuXFx0XFx0XFx0XFx0fSk7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRcXFwiQVRUUlxcXCI6IGZ1bmN0aW9uKCBuYW1lLCBvcGVyYXRvciwgY2hlY2sgKSB7XFxuXFx0XFx0XFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xcblxcdFxcdFxcdFxcdHZhciByZXN1bHQgPSBTaXp6bGUuYXR0ciggZWxlbSwgbmFtZSApO1xcblxcblxcdFxcdFxcdFxcdGlmICggcmVzdWx0ID09IG51bGwgKSB7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIG9wZXJhdG9yID09PSBcXFwiIT1cXFwiO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRpZiAoICFvcGVyYXRvciApIHtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gdHJ1ZTtcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0cmVzdWx0ICs9IFxcXCJcXFwiO1xcblxcblxcdFxcdFxcdFxcdHJldHVybiBvcGVyYXRvciA9PT0gXFxcIj1cXFwiID8gcmVzdWx0ID09PSBjaGVjayA6XFxuXFx0XFx0XFx0XFx0XFx0b3BlcmF0b3IgPT09IFxcXCIhPVxcXCIgPyByZXN1bHQgIT09IGNoZWNrIDpcXG5cXHRcXHRcXHRcXHRcXHRvcGVyYXRvciA9PT0gXFxcIl49XFxcIiA/IGNoZWNrICYmIHJlc3VsdC5pbmRleE9mKCBjaGVjayApID09PSAwIDpcXG5cXHRcXHRcXHRcXHRcXHRvcGVyYXRvciA9PT0gXFxcIio9XFxcIiA/IGNoZWNrICYmIHJlc3VsdC5pbmRleE9mKCBjaGVjayApID4gLTEgOlxcblxcdFxcdFxcdFxcdFxcdG9wZXJhdG9yID09PSBcXFwiJD1cXFwiID8gY2hlY2sgJiYgcmVzdWx0LnNsaWNlKCAtY2hlY2subGVuZ3RoICkgPT09IGNoZWNrIDpcXG5cXHRcXHRcXHRcXHRcXHRvcGVyYXRvciA9PT0gXFxcIn49XFxcIiA/ICggXFxcIiBcXFwiICsgcmVzdWx0LnJlcGxhY2UoIHJ3aGl0ZXNwYWNlLCBcXFwiIFxcXCIgKSArIFxcXCIgXFxcIiApLmluZGV4T2YoIGNoZWNrICkgPiAtMSA6XFxuXFx0XFx0XFx0XFx0XFx0b3BlcmF0b3IgPT09IFxcXCJ8PVxcXCIgPyByZXN1bHQgPT09IGNoZWNrIHx8IHJlc3VsdC5zbGljZSggMCwgY2hlY2subGVuZ3RoICsgMSApID09PSBjaGVjayArIFxcXCItXFxcIiA6XFxuXFx0XFx0XFx0XFx0XFx0ZmFsc2U7XFxuXFx0XFx0XFx0fTtcXG5cXHRcXHR9LFxcblxcblxcdFxcdFxcXCJDSElMRFxcXCI6IGZ1bmN0aW9uKCB0eXBlLCB3aGF0LCBhcmd1bWVudCwgZmlyc3QsIGxhc3QgKSB7XFxuXFx0XFx0XFx0dmFyIHNpbXBsZSA9IHR5cGUuc2xpY2UoIDAsIDMgKSAhPT0gXFxcIm50aFxcXCIsXFxuXFx0XFx0XFx0XFx0Zm9yd2FyZCA9IHR5cGUuc2xpY2UoIC00ICkgIT09IFxcXCJsYXN0XFxcIixcXG5cXHRcXHRcXHRcXHRvZlR5cGUgPSB3aGF0ID09PSBcXFwib2YtdHlwZVxcXCI7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIGZpcnN0ID09PSAxICYmIGxhc3QgPT09IDAgP1xcblxcblxcdFxcdFxcdFxcdC8vIFNob3J0Y3V0IGZvciA6bnRoLSoobilcXG5cXHRcXHRcXHRcXHRmdW5jdGlvbiggZWxlbSApIHtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gISFlbGVtLnBhcmVudE5vZGU7XFxuXFx0XFx0XFx0XFx0fSA6XFxuXFxuXFx0XFx0XFx0XFx0ZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcXG5cXHRcXHRcXHRcXHRcXHR2YXIgY2FjaGUsIHVuaXF1ZUNhY2hlLCBvdXRlckNhY2hlLCBub2RlLCBub2RlSW5kZXgsIHN0YXJ0LFxcblxcdFxcdFxcdFxcdFxcdFxcdGRpciA9IHNpbXBsZSAhPT0gZm9yd2FyZCA/IFxcXCJuZXh0U2libGluZ1xcXCIgOiBcXFwicHJldmlvdXNTaWJsaW5nXFxcIixcXG5cXHRcXHRcXHRcXHRcXHRcXHRwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGUsXFxuXFx0XFx0XFx0XFx0XFx0XFx0bmFtZSA9IG9mVHlwZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCksXFxuXFx0XFx0XFx0XFx0XFx0XFx0dXNlQ2FjaGUgPSAheG1sICYmICFvZlR5cGUsXFxuXFx0XFx0XFx0XFx0XFx0XFx0ZGlmZiA9IGZhbHNlO1xcblxcblxcdFxcdFxcdFxcdFxcdGlmICggcGFyZW50ICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdC8vIDooZmlyc3R8bGFzdHxvbmx5KS0oY2hpbGR8b2YtdHlwZSlcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoIHNpbXBsZSApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR3aGlsZSAoIGRpciApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRub2RlID0gZWxlbTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR3aGlsZSAoIChub2RlID0gbm9kZVsgZGlyIF0pICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmICggb2ZUeXBlID9cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRub2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IG5hbWUgOlxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdG5vZGUubm9kZVR5cGUgPT09IDEgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIGZhbHNlO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gUmV2ZXJzZSBkaXJlY3Rpb24gZm9yIDpvbmx5LSogKGlmIHdlIGhhdmVuJ3QgeWV0IGRvbmUgc28pXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0c3RhcnQgPSBkaXIgPSB0eXBlID09PSBcXFwib25seVxcXCIgJiYgIXN0YXJ0ICYmIFxcXCJuZXh0U2libGluZ1xcXCI7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiB0cnVlO1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRzdGFydCA9IFsgZm9yd2FyZCA/IHBhcmVudC5maXJzdENoaWxkIDogcGFyZW50Lmxhc3RDaGlsZCBdO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdC8vIG5vbi14bWwgOm50aC1jaGlsZCguLi4pIHN0b3JlcyBjYWNoZSBkYXRhIG9uIGBwYXJlbnRgXFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBmb3J3YXJkICYmIHVzZUNhY2hlICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIFNlZWsgYGVsZW1gIGZyb20gYSBwcmV2aW91c2x5LWNhY2hlZCBpbmRleFxcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIC4uLmluIGEgZ3ppcC1mcmllbmRseSB3YXlcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRub2RlID0gcGFyZW50O1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdG91dGVyQ2FjaGUgPSBub2RlWyBleHBhbmRvIF0gfHwgKG5vZGVbIGV4cGFuZG8gXSA9IHt9KTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBTdXBwb3J0OiBJRSA8OSBvbmx5XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gRGVmZW5kIGFnYWluc3QgY2xvbmVkIGF0dHJvcGVydGllcyAoalF1ZXJ5IGdoLTE3MDkpXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dW5pcXVlQ2FjaGUgPSBvdXRlckNhY2hlWyBub2RlLnVuaXF1ZUlEIF0gfHxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQob3V0ZXJDYWNoZVsgbm9kZS51bmlxdWVJRCBdID0ge30pO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGNhY2hlID0gdW5pcXVlQ2FjaGVbIHR5cGUgXSB8fCBbXTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRub2RlSW5kZXggPSBjYWNoZVsgMCBdID09PSBkaXJydW5zICYmIGNhY2hlWyAxIF07XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0ZGlmZiA9IG5vZGVJbmRleCAmJiBjYWNoZVsgMiBdO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdG5vZGUgPSBub2RlSW5kZXggJiYgcGFyZW50LmNoaWxkTm9kZXNbIG5vZGVJbmRleCBdO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHdoaWxlICggKG5vZGUgPSArK25vZGVJbmRleCAmJiBub2RlICYmIG5vZGVbIGRpciBdIHx8XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gRmFsbGJhY2sgdG8gc2Vla2luZyBgZWxlbWAgZnJvbSB0aGUgc3RhcnRcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQoZGlmZiA9IG5vZGVJbmRleCA9IDApIHx8IHN0YXJ0LnBvcCgpKSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBXaGVuIGZvdW5kLCBjYWNoZSBpbmRleGVzIG9uIGBwYXJlbnRgIGFuZCBicmVha1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmICggbm9kZS5ub2RlVHlwZSA9PT0gMSAmJiArK2RpZmYgJiYgbm9kZSA9PT0gZWxlbSApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR1bmlxdWVDYWNoZVsgdHlwZSBdID0gWyBkaXJydW5zLCBub2RlSW5kZXgsIGRpZmYgXTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gVXNlIHByZXZpb3VzbHktY2FjaGVkIGVsZW1lbnQgaW5kZXggaWYgYXZhaWxhYmxlXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKCB1c2VDYWNoZSApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyAuLi5pbiBhIGd6aXAtZnJpZW5kbHkgd2F5XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0bm9kZSA9IGVsZW07XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0b3V0ZXJDYWNoZSA9IG5vZGVbIGV4cGFuZG8gXSB8fCAobm9kZVsgZXhwYW5kbyBdID0ge30pO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIFN1cHBvcnQ6IElFIDw5IG9ubHlcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBEZWZlbmQgYWdhaW5zdCBjbG9uZWQgYXR0cm9wZXJ0aWVzIChqUXVlcnkgZ2gtMTcwOSlcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR1bmlxdWVDYWNoZSA9IG91dGVyQ2FjaGVbIG5vZGUudW5pcXVlSUQgXSB8fFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdChvdXRlckNhY2hlWyBub2RlLnVuaXF1ZUlEIF0gPSB7fSk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Y2FjaGUgPSB1bmlxdWVDYWNoZVsgdHlwZSBdIHx8IFtdO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdG5vZGVJbmRleCA9IGNhY2hlWyAwIF0gPT09IGRpcnJ1bnMgJiYgY2FjaGVbIDEgXTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRkaWZmID0gbm9kZUluZGV4O1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyB4bWwgOm50aC1jaGlsZCguLi4pXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gb3IgOm50aC1sYXN0LWNoaWxkKC4uLikgb3IgOm50aCgtbGFzdCk/LW9mLXR5cGUoLi4uKVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmICggZGlmZiA9PT0gZmFsc2UgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gVXNlIHRoZSBzYW1lIGxvb3AgYXMgYWJvdmUgdG8gc2VlayBgZWxlbWAgZnJvbSB0aGUgc3RhcnRcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR3aGlsZSAoIChub2RlID0gKytub2RlSW5kZXggJiYgbm9kZSAmJiBub2RlWyBkaXIgXSB8fFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdChkaWZmID0gbm9kZUluZGV4ID0gMCkgfHwgc3RhcnQucG9wKCkpICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmICggKCBvZlR5cGUgP1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdG5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gbmFtZSA6XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0bm9kZS5ub2RlVHlwZSA9PT0gMSApICYmXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0KytkaWZmICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIENhY2hlIHRoZSBpbmRleCBvZiBlYWNoIGVuY291bnRlcmVkIGVsZW1lbnRcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoIHVzZUNhY2hlICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdG91dGVyQ2FjaGUgPSBub2RlWyBleHBhbmRvIF0gfHwgKG5vZGVbIGV4cGFuZG8gXSA9IHt9KTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBTdXBwb3J0OiBJRSA8OSBvbmx5XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gRGVmZW5kIGFnYWluc3QgY2xvbmVkIGF0dHJvcGVydGllcyAoalF1ZXJ5IGdoLTE3MDkpXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0dW5pcXVlQ2FjaGUgPSBvdXRlckNhY2hlWyBub2RlLnVuaXF1ZUlEIF0gfHxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQob3V0ZXJDYWNoZVsgbm9kZS51bmlxdWVJRCBdID0ge30pO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHVuaXF1ZUNhY2hlWyB0eXBlIF0gPSBbIGRpcnJ1bnMsIGRpZmYgXTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBub2RlID09PSBlbGVtICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gSW5jb3Jwb3JhdGUgdGhlIG9mZnNldCwgdGhlbiBjaGVjayBhZ2FpbnN0IGN5Y2xlIHNpemVcXG5cXHRcXHRcXHRcXHRcXHRcXHRkaWZmIC09IGxhc3Q7XFxuXFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIGRpZmYgPT09IGZpcnN0IHx8ICggZGlmZiAlIGZpcnN0ID09PSAwICYmIGRpZmYgLyBmaXJzdCA+PSAwICk7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH07XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRcXFwiUFNFVURPXFxcIjogZnVuY3Rpb24oIHBzZXVkbywgYXJndW1lbnQgKSB7XFxuXFx0XFx0XFx0Ly8gcHNldWRvLWNsYXNzIG5hbWVzIGFyZSBjYXNlLWluc2Vuc2l0aXZlXFxuXFx0XFx0XFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvc2VsZWN0b3JzLyNwc2V1ZG8tY2xhc3Nlc1xcblxcdFxcdFxcdC8vIFByaW9yaXRpemUgYnkgY2FzZSBzZW5zaXRpdml0eSBpbiBjYXNlIGN1c3RvbSBwc2V1ZG9zIGFyZSBhZGRlZCB3aXRoIHVwcGVyY2FzZSBsZXR0ZXJzXFxuXFx0XFx0XFx0Ly8gUmVtZW1iZXIgdGhhdCBzZXRGaWx0ZXJzIGluaGVyaXRzIGZyb20gcHNldWRvc1xcblxcdFxcdFxcdHZhciBhcmdzLFxcblxcdFxcdFxcdFxcdGZuID0gRXhwci5wc2V1ZG9zWyBwc2V1ZG8gXSB8fCBFeHByLnNldEZpbHRlcnNbIHBzZXVkby50b0xvd2VyQ2FzZSgpIF0gfHxcXG5cXHRcXHRcXHRcXHRcXHRTaXp6bGUuZXJyb3IoIFxcXCJ1bnN1cHBvcnRlZCBwc2V1ZG86IFxcXCIgKyBwc2V1ZG8gKTtcXG5cXG5cXHRcXHRcXHQvLyBUaGUgdXNlciBtYXkgdXNlIGNyZWF0ZVBzZXVkbyB0byBpbmRpY2F0ZSB0aGF0XFxuXFx0XFx0XFx0Ly8gYXJndW1lbnRzIGFyZSBuZWVkZWQgdG8gY3JlYXRlIHRoZSBmaWx0ZXIgZnVuY3Rpb25cXG5cXHRcXHRcXHQvLyBqdXN0IGFzIFNpenpsZSBkb2VzXFxuXFx0XFx0XFx0aWYgKCBmblsgZXhwYW5kbyBdICkge1xcblxcdFxcdFxcdFxcdHJldHVybiBmbiggYXJndW1lbnQgKTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gQnV0IG1haW50YWluIHN1cHBvcnQgZm9yIG9sZCBzaWduYXR1cmVzXFxuXFx0XFx0XFx0aWYgKCBmbi5sZW5ndGggPiAxICkge1xcblxcdFxcdFxcdFxcdGFyZ3MgPSBbIHBzZXVkbywgcHNldWRvLCBcXFwiXFxcIiwgYXJndW1lbnQgXTtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gRXhwci5zZXRGaWx0ZXJzLmhhc093blByb3BlcnR5KCBwc2V1ZG8udG9Mb3dlckNhc2UoKSApID9cXG5cXHRcXHRcXHRcXHRcXHRtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlZWQsIG1hdGNoZXMgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dmFyIGlkeCxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRtYXRjaGVkID0gZm4oIHNlZWQsIGFyZ3VtZW50ICksXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aSA9IG1hdGNoZWQubGVuZ3RoO1xcblxcdFxcdFxcdFxcdFxcdFxcdHdoaWxlICggaS0tICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGlkeCA9IGluZGV4T2YoIHNlZWQsIG1hdGNoZWRbaV0gKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRzZWVkWyBpZHggXSA9ICEoIG1hdGNoZXNbIGlkeCBdID0gbWF0Y2hlZFtpXSApO1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHR9KSA6XFxuXFx0XFx0XFx0XFx0XFx0ZnVuY3Rpb24oIGVsZW0gKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIGZuKCBlbGVtLCAwLCBhcmdzICk7XFxuXFx0XFx0XFx0XFx0XFx0fTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cmV0dXJuIGZuO1xcblxcdFxcdH1cXG5cXHR9LFxcblxcblxcdHBzZXVkb3M6IHtcXG5cXHRcXHQvLyBQb3RlbnRpYWxseSBjb21wbGV4IHBzZXVkb3NcXG5cXHRcXHRcXFwibm90XFxcIjogbWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcXG5cXHRcXHRcXHQvLyBUcmltIHRoZSBzZWxlY3RvciBwYXNzZWQgdG8gY29tcGlsZVxcblxcdFxcdFxcdC8vIHRvIGF2b2lkIHRyZWF0aW5nIGxlYWRpbmcgYW5kIHRyYWlsaW5nXFxuXFx0XFx0XFx0Ly8gc3BhY2VzIGFzIGNvbWJpbmF0b3JzXFxuXFx0XFx0XFx0dmFyIGlucHV0ID0gW10sXFxuXFx0XFx0XFx0XFx0cmVzdWx0cyA9IFtdLFxcblxcdFxcdFxcdFxcdG1hdGNoZXIgPSBjb21waWxlKCBzZWxlY3Rvci5yZXBsYWNlKCBydHJpbSwgXFxcIiQxXFxcIiApICk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIG1hdGNoZXJbIGV4cGFuZG8gXSA/XFxuXFx0XFx0XFx0XFx0bWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBzZWVkLCBtYXRjaGVzLCBjb250ZXh0LCB4bWwgKSB7XFxuXFx0XFx0XFx0XFx0XFx0dmFyIGVsZW0sXFxuXFx0XFx0XFx0XFx0XFx0XFx0dW5tYXRjaGVkID0gbWF0Y2hlciggc2VlZCwgbnVsbCwgeG1sLCBbXSApLFxcblxcdFxcdFxcdFxcdFxcdFxcdGkgPSBzZWVkLmxlbmd0aDtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBNYXRjaCBlbGVtZW50cyB1bm1hdGNoZWQgYnkgYG1hdGNoZXJgXFxuXFx0XFx0XFx0XFx0XFx0d2hpbGUgKCBpLS0gKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKCAoZWxlbSA9IHVubWF0Y2hlZFtpXSkgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0c2VlZFtpXSA9ICEobWF0Y2hlc1tpXSA9IGVsZW0pO1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fSkgOlxcblxcdFxcdFxcdFxcdGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XFxuXFx0XFx0XFx0XFx0XFx0aW5wdXRbMF0gPSBlbGVtO1xcblxcdFxcdFxcdFxcdFxcdG1hdGNoZXIoIGlucHV0LCBudWxsLCB4bWwsIHJlc3VsdHMgKTtcXG5cXHRcXHRcXHRcXHRcXHQvLyBEb24ndCBrZWVwIHRoZSBlbGVtZW50IChpc3N1ZSAjMjk5KVxcblxcdFxcdFxcdFxcdFxcdGlucHV0WzBdID0gbnVsbDtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gIXJlc3VsdHMucG9wKCk7XFxuXFx0XFx0XFx0XFx0fTtcXG5cXHRcXHR9KSxcXG5cXG5cXHRcXHRcXFwiaGFzXFxcIjogbWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcXG5cXHRcXHRcXHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIFNpenpsZSggc2VsZWN0b3IsIGVsZW0gKS5sZW5ndGggPiAwO1xcblxcdFxcdFxcdH07XFxuXFx0XFx0fSksXFxuXFxuXFx0XFx0XFxcImNvbnRhaW5zXFxcIjogbWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCB0ZXh0ICkge1xcblxcdFxcdFxcdHRleHQgPSB0ZXh0LnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XFxuXFx0XFx0XFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xcblxcdFxcdFxcdFxcdHJldHVybiAoIGVsZW0udGV4dENvbnRlbnQgfHwgZWxlbS5pbm5lclRleHQgfHwgZ2V0VGV4dCggZWxlbSApICkuaW5kZXhPZiggdGV4dCApID4gLTE7XFxuXFx0XFx0XFx0fTtcXG5cXHRcXHR9KSxcXG5cXG5cXHRcXHQvLyBcXFwiV2hldGhlciBhbiBlbGVtZW50IGlzIHJlcHJlc2VudGVkIGJ5IGEgOmxhbmcoKSBzZWxlY3RvclxcblxcdFxcdC8vIGlzIGJhc2VkIHNvbGVseSBvbiB0aGUgZWxlbWVudCdzIGxhbmd1YWdlIHZhbHVlXFxuXFx0XFx0Ly8gYmVpbmcgZXF1YWwgdG8gdGhlIGlkZW50aWZpZXIgQyxcXG5cXHRcXHQvLyBvciBiZWdpbm5pbmcgd2l0aCB0aGUgaWRlbnRpZmllciBDIGltbWVkaWF0ZWx5IGZvbGxvd2VkIGJ5IFxcXCItXFxcIi5cXG5cXHRcXHQvLyBUaGUgbWF0Y2hpbmcgb2YgQyBhZ2FpbnN0IHRoZSBlbGVtZW50J3MgbGFuZ3VhZ2UgdmFsdWUgaXMgcGVyZm9ybWVkIGNhc2UtaW5zZW5zaXRpdmVseS5cXG5cXHRcXHQvLyBUaGUgaWRlbnRpZmllciBDIGRvZXMgbm90IGhhdmUgdG8gYmUgYSB2YWxpZCBsYW5ndWFnZSBuYW1lLlxcXCJcXG5cXHRcXHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9zZWxlY3RvcnMvI2xhbmctcHNldWRvXFxuXFx0XFx0XFxcImxhbmdcXFwiOiBtYXJrRnVuY3Rpb24oIGZ1bmN0aW9uKCBsYW5nICkge1xcblxcdFxcdFxcdC8vIGxhbmcgdmFsdWUgbXVzdCBiZSBhIHZhbGlkIGlkZW50aWZpZXJcXG5cXHRcXHRcXHRpZiAoICFyaWRlbnRpZmllci50ZXN0KGxhbmcgfHwgXFxcIlxcXCIpICkge1xcblxcdFxcdFxcdFxcdFNpenpsZS5lcnJvciggXFxcInVuc3VwcG9ydGVkIGxhbmc6IFxcXCIgKyBsYW5nICk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGxhbmcgPSBsYW5nLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICkudG9Mb3dlckNhc2UoKTtcXG5cXHRcXHRcXHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XFxuXFx0XFx0XFx0XFx0dmFyIGVsZW1MYW5nO1xcblxcdFxcdFxcdFxcdGRvIHtcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIChlbGVtTGFuZyA9IGRvY3VtZW50SXNIVE1MID9cXG5cXHRcXHRcXHRcXHRcXHRcXHRlbGVtLmxhbmcgOlxcblxcdFxcdFxcdFxcdFxcdFxcdGVsZW0uZ2V0QXR0cmlidXRlKFxcXCJ4bWw6bGFuZ1xcXCIpIHx8IGVsZW0uZ2V0QXR0cmlidXRlKFxcXCJsYW5nXFxcIikpICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGVsZW1MYW5nID0gZWxlbUxhbmcudG9Mb3dlckNhc2UoKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gZWxlbUxhbmcgPT09IGxhbmcgfHwgZWxlbUxhbmcuaW5kZXhPZiggbGFuZyArIFxcXCItXFxcIiApID09PSAwO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9IHdoaWxlICggKGVsZW0gPSBlbGVtLnBhcmVudE5vZGUpICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKTtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gZmFsc2U7XFxuXFx0XFx0XFx0fTtcXG5cXHRcXHR9KSxcXG5cXG5cXHRcXHQvLyBNaXNjZWxsYW5lb3VzXFxuXFx0XFx0XFxcInRhcmdldFxcXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xcblxcdFxcdFxcdHZhciBoYXNoID0gd2luZG93LmxvY2F0aW9uICYmIHdpbmRvdy5sb2NhdGlvbi5oYXNoO1xcblxcdFxcdFxcdHJldHVybiBoYXNoICYmIGhhc2guc2xpY2UoIDEgKSA9PT0gZWxlbS5pZDtcXG5cXHRcXHR9LFxcblxcblxcdFxcdFxcXCJyb290XFxcIjogZnVuY3Rpb24oIGVsZW0gKSB7XFxuXFx0XFx0XFx0cmV0dXJuIGVsZW0gPT09IGRvY0VsZW07XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRcXFwiZm9jdXNcXFwiOiBmdW5jdGlvbiggZWxlbSApIHtcXG5cXHRcXHRcXHRyZXR1cm4gZWxlbSA9PT0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAmJiAoIWRvY3VtZW50Lmhhc0ZvY3VzIHx8IGRvY3VtZW50Lmhhc0ZvY3VzKCkpICYmICEhKGVsZW0udHlwZSB8fCBlbGVtLmhyZWYgfHwgfmVsZW0udGFiSW5kZXgpO1xcblxcdFxcdH0sXFxuXFxuXFx0XFx0Ly8gQm9vbGVhbiBwcm9wZXJ0aWVzXFxuXFx0XFx0XFxcImVuYWJsZWRcXFwiOiBjcmVhdGVEaXNhYmxlZFBzZXVkbyggZmFsc2UgKSxcXG5cXHRcXHRcXFwiZGlzYWJsZWRcXFwiOiBjcmVhdGVEaXNhYmxlZFBzZXVkbyggdHJ1ZSApLFxcblxcblxcdFxcdFxcXCJjaGVja2VkXFxcIjogZnVuY3Rpb24oIGVsZW0gKSB7XFxuXFx0XFx0XFx0Ly8gSW4gQ1NTMywgOmNoZWNrZWQgc2hvdWxkIHJldHVybiBib3RoIGNoZWNrZWQgYW5kIHNlbGVjdGVkIGVsZW1lbnRzXFxuXFx0XFx0XFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvMjAxMS9SRUMtY3NzMy1zZWxlY3RvcnMtMjAxMTA5MjkvI2NoZWNrZWRcXG5cXHRcXHRcXHR2YXIgbm9kZU5hbWUgPSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XFxuXFx0XFx0XFx0cmV0dXJuIChub2RlTmFtZSA9PT0gXFxcImlucHV0XFxcIiAmJiAhIWVsZW0uY2hlY2tlZCkgfHwgKG5vZGVOYW1lID09PSBcXFwib3B0aW9uXFxcIiAmJiAhIWVsZW0uc2VsZWN0ZWQpO1xcblxcdFxcdH0sXFxuXFxuXFx0XFx0XFxcInNlbGVjdGVkXFxcIjogZnVuY3Rpb24oIGVsZW0gKSB7XFxuXFx0XFx0XFx0Ly8gQWNjZXNzaW5nIHRoaXMgcHJvcGVydHkgbWFrZXMgc2VsZWN0ZWQtYnktZGVmYXVsdFxcblxcdFxcdFxcdC8vIG9wdGlvbnMgaW4gU2FmYXJpIHdvcmsgcHJvcGVybHlcXG5cXHRcXHRcXHRpZiAoIGVsZW0ucGFyZW50Tm9kZSApIHtcXG5cXHRcXHRcXHRcXHRlbGVtLnBhcmVudE5vZGUuc2VsZWN0ZWRJbmRleDtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cmV0dXJuIGVsZW0uc2VsZWN0ZWQgPT09IHRydWU7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHQvLyBDb250ZW50c1xcblxcdFxcdFxcXCJlbXB0eVxcXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xcblxcdFxcdFxcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL3NlbGVjdG9ycy8jZW1wdHktcHNldWRvXFxuXFx0XFx0XFx0Ly8gOmVtcHR5IGlzIG5lZ2F0ZWQgYnkgZWxlbWVudCAoMSkgb3IgY29udGVudCBub2RlcyAodGV4dDogMzsgY2RhdGE6IDQ7IGVudGl0eSByZWY6IDUpLFxcblxcdFxcdFxcdC8vICAgYnV0IG5vdCBieSBvdGhlcnMgKGNvbW1lbnQ6IDg7IHByb2Nlc3NpbmcgaW5zdHJ1Y3Rpb246IDc7IGV0Yy4pXFxuXFx0XFx0XFx0Ly8gbm9kZVR5cGUgPCA2IHdvcmtzIGJlY2F1c2UgYXR0cmlidXRlcyAoMikgZG8gbm90IGFwcGVhciBhcyBjaGlsZHJlblxcblxcdFxcdFxcdGZvciAoIGVsZW0gPSBlbGVtLmZpcnN0Q2hpbGQ7IGVsZW07IGVsZW0gPSBlbGVtLm5leHRTaWJsaW5nICkge1xcblxcdFxcdFxcdFxcdGlmICggZWxlbS5ub2RlVHlwZSA8IDYgKSB7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIGZhbHNlO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0cmV0dXJuIHRydWU7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRcXFwicGFyZW50XFxcIjogZnVuY3Rpb24oIGVsZW0gKSB7XFxuXFx0XFx0XFx0cmV0dXJuICFFeHByLnBzZXVkb3NbXFxcImVtcHR5XFxcIl0oIGVsZW0gKTtcXG5cXHRcXHR9LFxcblxcblxcdFxcdC8vIEVsZW1lbnQvaW5wdXQgdHlwZXNcXG5cXHRcXHRcXFwiaGVhZGVyXFxcIjogZnVuY3Rpb24oIGVsZW0gKSB7XFxuXFx0XFx0XFx0cmV0dXJuIHJoZWFkZXIudGVzdCggZWxlbS5ub2RlTmFtZSApO1xcblxcdFxcdH0sXFxuXFxuXFx0XFx0XFxcImlucHV0XFxcIjogZnVuY3Rpb24oIGVsZW0gKSB7XFxuXFx0XFx0XFx0cmV0dXJuIHJpbnB1dHMudGVzdCggZWxlbS5ub2RlTmFtZSApO1xcblxcdFxcdH0sXFxuXFxuXFx0XFx0XFxcImJ1dHRvblxcXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xcblxcdFxcdFxcdHZhciBuYW1lID0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xcblxcdFxcdFxcdHJldHVybiBuYW1lID09PSBcXFwiaW5wdXRcXFwiICYmIGVsZW0udHlwZSA9PT0gXFxcImJ1dHRvblxcXCIgfHwgbmFtZSA9PT0gXFxcImJ1dHRvblxcXCI7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRcXFwidGV4dFxcXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xcblxcdFxcdFxcdHZhciBhdHRyO1xcblxcdFxcdFxcdHJldHVybiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFxcXCJpbnB1dFxcXCIgJiZcXG5cXHRcXHRcXHRcXHRlbGVtLnR5cGUgPT09IFxcXCJ0ZXh0XFxcIiAmJlxcblxcblxcdFxcdFxcdFxcdC8vIFN1cHBvcnQ6IElFPDhcXG5cXHRcXHRcXHRcXHQvLyBOZXcgSFRNTDUgYXR0cmlidXRlIHZhbHVlcyAoZS5nLiwgXFxcInNlYXJjaFxcXCIpIGFwcGVhciB3aXRoIGVsZW0udHlwZSA9PT0gXFxcInRleHRcXFwiXFxuXFx0XFx0XFx0XFx0KCAoYXR0ciA9IGVsZW0uZ2V0QXR0cmlidXRlKFxcXCJ0eXBlXFxcIikpID09IG51bGwgfHwgYXR0ci50b0xvd2VyQ2FzZSgpID09PSBcXFwidGV4dFxcXCIgKTtcXG5cXHRcXHR9LFxcblxcblxcdFxcdC8vIFBvc2l0aW9uLWluLWNvbGxlY3Rpb25cXG5cXHRcXHRcXFwiZmlyc3RcXFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdHJldHVybiBbIDAgXTtcXG5cXHRcXHR9KSxcXG5cXG5cXHRcXHRcXFwibGFzdFxcXCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoICkge1xcblxcdFxcdFxcdHJldHVybiBbIGxlbmd0aCAtIDEgXTtcXG5cXHRcXHR9KSxcXG5cXG5cXHRcXHRcXFwiZXFcXFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCwgYXJndW1lbnQgKSB7XFxuXFx0XFx0XFx0cmV0dXJuIFsgYXJndW1lbnQgPCAwID8gYXJndW1lbnQgKyBsZW5ndGggOiBhcmd1bWVudCBdO1xcblxcdFxcdH0pLFxcblxcblxcdFxcdFxcXCJldmVuXFxcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGggKSB7XFxuXFx0XFx0XFx0dmFyIGkgPSAwO1xcblxcdFxcdFxcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSArPSAyICkge1xcblxcdFxcdFxcdFxcdG1hdGNoSW5kZXhlcy5wdXNoKCBpICk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHJldHVybiBtYXRjaEluZGV4ZXM7XFxuXFx0XFx0fSksXFxuXFxuXFx0XFx0XFxcIm9kZFxcXCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoICkge1xcblxcdFxcdFxcdHZhciBpID0gMTtcXG5cXHRcXHRcXHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkgKz0gMiApIHtcXG5cXHRcXHRcXHRcXHRtYXRjaEluZGV4ZXMucHVzaCggaSApO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRyZXR1cm4gbWF0Y2hJbmRleGVzO1xcblxcdFxcdH0pLFxcblxcblxcdFxcdFxcXCJsdFxcXCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoLCBhcmd1bWVudCApIHtcXG5cXHRcXHRcXHR2YXIgaSA9IGFyZ3VtZW50IDwgMCA/IGFyZ3VtZW50ICsgbGVuZ3RoIDogYXJndW1lbnQ7XFxuXFx0XFx0XFx0Zm9yICggOyAtLWkgPj0gMDsgKSB7XFxuXFx0XFx0XFx0XFx0bWF0Y2hJbmRleGVzLnB1c2goIGkgKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0cmV0dXJuIG1hdGNoSW5kZXhlcztcXG5cXHRcXHR9KSxcXG5cXG5cXHRcXHRcXFwiZ3RcXFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCwgYXJndW1lbnQgKSB7XFxuXFx0XFx0XFx0dmFyIGkgPSBhcmd1bWVudCA8IDAgPyBhcmd1bWVudCArIGxlbmd0aCA6IGFyZ3VtZW50O1xcblxcdFxcdFxcdGZvciAoIDsgKytpIDwgbGVuZ3RoOyApIHtcXG5cXHRcXHRcXHRcXHRtYXRjaEluZGV4ZXMucHVzaCggaSApO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRyZXR1cm4gbWF0Y2hJbmRleGVzO1xcblxcdFxcdH0pXFxuXFx0fVxcbn07XFxuXFxuRXhwci5wc2V1ZG9zW1xcXCJudGhcXFwiXSA9IEV4cHIucHNldWRvc1tcXFwiZXFcXFwiXTtcXG5cXG4vLyBBZGQgYnV0dG9uL2lucHV0IHR5cGUgcHNldWRvc1xcbmZvciAoIGkgaW4geyByYWRpbzogdHJ1ZSwgY2hlY2tib3g6IHRydWUsIGZpbGU6IHRydWUsIHBhc3N3b3JkOiB0cnVlLCBpbWFnZTogdHJ1ZSB9ICkge1xcblxcdEV4cHIucHNldWRvc1sgaSBdID0gY3JlYXRlSW5wdXRQc2V1ZG8oIGkgKTtcXG59XFxuZm9yICggaSBpbiB7IHN1Ym1pdDogdHJ1ZSwgcmVzZXQ6IHRydWUgfSApIHtcXG5cXHRFeHByLnBzZXVkb3NbIGkgXSA9IGNyZWF0ZUJ1dHRvblBzZXVkbyggaSApO1xcbn1cXG5cXG4vLyBFYXN5IEFQSSBmb3IgY3JlYXRpbmcgbmV3IHNldEZpbHRlcnNcXG5mdW5jdGlvbiBzZXRGaWx0ZXJzKCkge31cXG5zZXRGaWx0ZXJzLnByb3RvdHlwZSA9IEV4cHIuZmlsdGVycyA9IEV4cHIucHNldWRvcztcXG5FeHByLnNldEZpbHRlcnMgPSBuZXcgc2V0RmlsdGVycygpO1xcblxcbnRva2VuaXplID0gU2l6emxlLnRva2VuaXplID0gZnVuY3Rpb24oIHNlbGVjdG9yLCBwYXJzZU9ubHkgKSB7XFxuXFx0dmFyIG1hdGNoZWQsIG1hdGNoLCB0b2tlbnMsIHR5cGUsXFxuXFx0XFx0c29GYXIsIGdyb3VwcywgcHJlRmlsdGVycyxcXG5cXHRcXHRjYWNoZWQgPSB0b2tlbkNhY2hlWyBzZWxlY3RvciArIFxcXCIgXFxcIiBdO1xcblxcblxcdGlmICggY2FjaGVkICkge1xcblxcdFxcdHJldHVybiBwYXJzZU9ubHkgPyAwIDogY2FjaGVkLnNsaWNlKCAwICk7XFxuXFx0fVxcblxcblxcdHNvRmFyID0gc2VsZWN0b3I7XFxuXFx0Z3JvdXBzID0gW107XFxuXFx0cHJlRmlsdGVycyA9IEV4cHIucHJlRmlsdGVyO1xcblxcblxcdHdoaWxlICggc29GYXIgKSB7XFxuXFxuXFx0XFx0Ly8gQ29tbWEgYW5kIGZpcnN0IHJ1blxcblxcdFxcdGlmICggIW1hdGNoZWQgfHwgKG1hdGNoID0gcmNvbW1hLmV4ZWMoIHNvRmFyICkpICkge1xcblxcdFxcdFxcdGlmICggbWF0Y2ggKSB7XFxuXFx0XFx0XFx0XFx0Ly8gRG9uJ3QgY29uc3VtZSB0cmFpbGluZyBjb21tYXMgYXMgdmFsaWRcXG5cXHRcXHRcXHRcXHRzb0ZhciA9IHNvRmFyLnNsaWNlKCBtYXRjaFswXS5sZW5ndGggKSB8fCBzb0ZhcjtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0Z3JvdXBzLnB1c2goICh0b2tlbnMgPSBbXSkgKTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0bWF0Y2hlZCA9IGZhbHNlO1xcblxcblxcdFxcdC8vIENvbWJpbmF0b3JzXFxuXFx0XFx0aWYgKCAobWF0Y2ggPSByY29tYmluYXRvcnMuZXhlYyggc29GYXIgKSkgKSB7XFxuXFx0XFx0XFx0bWF0Y2hlZCA9IG1hdGNoLnNoaWZ0KCk7XFxuXFx0XFx0XFx0dG9rZW5zLnB1c2goe1xcblxcdFxcdFxcdFxcdHZhbHVlOiBtYXRjaGVkLFxcblxcdFxcdFxcdFxcdC8vIENhc3QgZGVzY2VuZGFudCBjb21iaW5hdG9ycyB0byBzcGFjZVxcblxcdFxcdFxcdFxcdHR5cGU6IG1hdGNoWzBdLnJlcGxhY2UoIHJ0cmltLCBcXFwiIFxcXCIgKVxcblxcdFxcdFxcdH0pO1xcblxcdFxcdFxcdHNvRmFyID0gc29GYXIuc2xpY2UoIG1hdGNoZWQubGVuZ3RoICk7XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIEZpbHRlcnNcXG5cXHRcXHRmb3IgKCB0eXBlIGluIEV4cHIuZmlsdGVyICkge1xcblxcdFxcdFxcdGlmICggKG1hdGNoID0gbWF0Y2hFeHByWyB0eXBlIF0uZXhlYyggc29GYXIgKSkgJiYgKCFwcmVGaWx0ZXJzWyB0eXBlIF0gfHxcXG5cXHRcXHRcXHRcXHQobWF0Y2ggPSBwcmVGaWx0ZXJzWyB0eXBlIF0oIG1hdGNoICkpKSApIHtcXG5cXHRcXHRcXHRcXHRtYXRjaGVkID0gbWF0Y2guc2hpZnQoKTtcXG5cXHRcXHRcXHRcXHR0b2tlbnMucHVzaCh7XFxuXFx0XFx0XFx0XFx0XFx0dmFsdWU6IG1hdGNoZWQsXFxuXFx0XFx0XFx0XFx0XFx0dHlwZTogdHlwZSxcXG5cXHRcXHRcXHRcXHRcXHRtYXRjaGVzOiBtYXRjaFxcblxcdFxcdFxcdFxcdH0pO1xcblxcdFxcdFxcdFxcdHNvRmFyID0gc29GYXIuc2xpY2UoIG1hdGNoZWQubGVuZ3RoICk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXG5cXHRcXHRpZiAoICFtYXRjaGVkICkge1xcblxcdFxcdFxcdGJyZWFrO1xcblxcdFxcdH1cXG5cXHR9XFxuXFxuXFx0Ly8gUmV0dXJuIHRoZSBsZW5ndGggb2YgdGhlIGludmFsaWQgZXhjZXNzXFxuXFx0Ly8gaWYgd2UncmUganVzdCBwYXJzaW5nXFxuXFx0Ly8gT3RoZXJ3aXNlLCB0aHJvdyBhbiBlcnJvciBvciByZXR1cm4gdG9rZW5zXFxuXFx0cmV0dXJuIHBhcnNlT25seSA/XFxuXFx0XFx0c29GYXIubGVuZ3RoIDpcXG5cXHRcXHRzb0ZhciA/XFxuXFx0XFx0XFx0U2l6emxlLmVycm9yKCBzZWxlY3RvciApIDpcXG5cXHRcXHRcXHQvLyBDYWNoZSB0aGUgdG9rZW5zXFxuXFx0XFx0XFx0dG9rZW5DYWNoZSggc2VsZWN0b3IsIGdyb3VwcyApLnNsaWNlKCAwICk7XFxufTtcXG5cXG5mdW5jdGlvbiB0b1NlbGVjdG9yKCB0b2tlbnMgKSB7XFxuXFx0dmFyIGkgPSAwLFxcblxcdFxcdGxlbiA9IHRva2Vucy5sZW5ndGgsXFxuXFx0XFx0c2VsZWN0b3IgPSBcXFwiXFxcIjtcXG5cXHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcXG5cXHRcXHRzZWxlY3RvciArPSB0b2tlbnNbaV0udmFsdWU7XFxuXFx0fVxcblxcdHJldHVybiBzZWxlY3RvcjtcXG59XFxuXFxuZnVuY3Rpb24gYWRkQ29tYmluYXRvciggbWF0Y2hlciwgY29tYmluYXRvciwgYmFzZSApIHtcXG5cXHR2YXIgZGlyID0gY29tYmluYXRvci5kaXIsXFxuXFx0XFx0c2tpcCA9IGNvbWJpbmF0b3IubmV4dCxcXG5cXHRcXHRrZXkgPSBza2lwIHx8IGRpcixcXG5cXHRcXHRjaGVja05vbkVsZW1lbnRzID0gYmFzZSAmJiBrZXkgPT09IFxcXCJwYXJlbnROb2RlXFxcIixcXG5cXHRcXHRkb25lTmFtZSA9IGRvbmUrKztcXG5cXG5cXHRyZXR1cm4gY29tYmluYXRvci5maXJzdCA/XFxuXFx0XFx0Ly8gQ2hlY2sgYWdhaW5zdCBjbG9zZXN0IGFuY2VzdG9yL3ByZWNlZGluZyBlbGVtZW50XFxuXFx0XFx0ZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcXG5cXHRcXHRcXHR3aGlsZSAoIChlbGVtID0gZWxlbVsgZGlyIF0pICkge1xcblxcdFxcdFxcdFxcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBjaGVja05vbkVsZW1lbnRzICkge1xcblxcdFxcdFxcdFxcdFxcdHJldHVybiBtYXRjaGVyKCBlbGVtLCBjb250ZXh0LCB4bWwgKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHJldHVybiBmYWxzZTtcXG5cXHRcXHR9IDpcXG5cXG5cXHRcXHQvLyBDaGVjayBhZ2FpbnN0IGFsbCBhbmNlc3Rvci9wcmVjZWRpbmcgZWxlbWVudHNcXG5cXHRcXHRmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xcblxcdFxcdFxcdHZhciBvbGRDYWNoZSwgdW5pcXVlQ2FjaGUsIG91dGVyQ2FjaGUsXFxuXFx0XFx0XFx0XFx0bmV3Q2FjaGUgPSBbIGRpcnJ1bnMsIGRvbmVOYW1lIF07XFxuXFxuXFx0XFx0XFx0Ly8gV2UgY2FuJ3Qgc2V0IGFyYml0cmFyeSBkYXRhIG9uIFhNTCBub2Rlcywgc28gdGhleSBkb24ndCBiZW5lZml0IGZyb20gY29tYmluYXRvciBjYWNoaW5nXFxuXFx0XFx0XFx0aWYgKCB4bWwgKSB7XFxuXFx0XFx0XFx0XFx0d2hpbGUgKCAoZWxlbSA9IGVsZW1bIGRpciBdKSApIHtcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgfHwgY2hlY2tOb25FbGVtZW50cyApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoIG1hdGNoZXIoIGVsZW0sIGNvbnRleHQsIHhtbCApICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiB0cnVlO1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0d2hpbGUgKCAoZWxlbSA9IGVsZW1bIGRpciBdKSApIHtcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgfHwgY2hlY2tOb25FbGVtZW50cyApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRvdXRlckNhY2hlID0gZWxlbVsgZXhwYW5kbyBdIHx8IChlbGVtWyBleHBhbmRvIF0gPSB7fSk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gU3VwcG9ydDogSUUgPDkgb25seVxcblxcdFxcdFxcdFxcdFxcdFxcdC8vIERlZmVuZCBhZ2FpbnN0IGNsb25lZCBhdHRyb3BlcnRpZXMgKGpRdWVyeSBnaC0xNzA5KVxcblxcdFxcdFxcdFxcdFxcdFxcdHVuaXF1ZUNhY2hlID0gb3V0ZXJDYWNoZVsgZWxlbS51bmlxdWVJRCBdIHx8IChvdXRlckNhY2hlWyBlbGVtLnVuaXF1ZUlEIF0gPSB7fSk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBza2lwICYmIHNraXAgPT09IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRlbGVtID0gZWxlbVsgZGlyIF0gfHwgZWxlbTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9IGVsc2UgaWYgKCAob2xkQ2FjaGUgPSB1bmlxdWVDYWNoZVsga2V5IF0pICYmXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0b2xkQ2FjaGVbIDAgXSA9PT0gZGlycnVucyAmJiBvbGRDYWNoZVsgMSBdID09PSBkb25lTmFtZSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBBc3NpZ24gdG8gbmV3Q2FjaGUgc28gcmVzdWx0cyBiYWNrLXByb3BhZ2F0ZSB0byBwcmV2aW91cyBlbGVtZW50c1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiAobmV3Q2FjaGVbIDIgXSA9IG9sZENhY2hlWyAyIF0pO1xcblxcdFxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gUmV1c2UgbmV3Y2FjaGUgc28gcmVzdWx0cyBiYWNrLXByb3BhZ2F0ZSB0byBwcmV2aW91cyBlbGVtZW50c1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHVuaXF1ZUNhY2hlWyBrZXkgXSA9IG5ld0NhY2hlO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIEEgbWF0Y2ggbWVhbnMgd2UncmUgZG9uZTsgYSBmYWlsIG1lYW5zIHdlIGhhdmUgdG8ga2VlcCBjaGVja2luZ1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmICggKG5ld0NhY2hlWyAyIF0gPSBtYXRjaGVyKCBlbGVtLCBjb250ZXh0LCB4bWwgKSkgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIHRydWU7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRyZXR1cm4gZmFsc2U7XFxuXFx0XFx0fTtcXG59XFxuXFxuZnVuY3Rpb24gZWxlbWVudE1hdGNoZXIoIG1hdGNoZXJzICkge1xcblxcdHJldHVybiBtYXRjaGVycy5sZW5ndGggPiAxID9cXG5cXHRcXHRmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xcblxcdFxcdFxcdHZhciBpID0gbWF0Y2hlcnMubGVuZ3RoO1xcblxcdFxcdFxcdHdoaWxlICggaS0tICkge1xcblxcdFxcdFxcdFxcdGlmICggIW1hdGNoZXJzW2ldKCBlbGVtLCBjb250ZXh0LCB4bWwgKSApIHtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gZmFsc2U7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRyZXR1cm4gdHJ1ZTtcXG5cXHRcXHR9IDpcXG5cXHRcXHRtYXRjaGVyc1swXTtcXG59XFxuXFxuZnVuY3Rpb24gbXVsdGlwbGVDb250ZXh0cyggc2VsZWN0b3IsIGNvbnRleHRzLCByZXN1bHRzICkge1xcblxcdHZhciBpID0gMCxcXG5cXHRcXHRsZW4gPSBjb250ZXh0cy5sZW5ndGg7XFxuXFx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XFxuXFx0XFx0U2l6emxlKCBzZWxlY3RvciwgY29udGV4dHNbaV0sIHJlc3VsdHMgKTtcXG5cXHR9XFxuXFx0cmV0dXJuIHJlc3VsdHM7XFxufVxcblxcbmZ1bmN0aW9uIGNvbmRlbnNlKCB1bm1hdGNoZWQsIG1hcCwgZmlsdGVyLCBjb250ZXh0LCB4bWwgKSB7XFxuXFx0dmFyIGVsZW0sXFxuXFx0XFx0bmV3VW5tYXRjaGVkID0gW10sXFxuXFx0XFx0aSA9IDAsXFxuXFx0XFx0bGVuID0gdW5tYXRjaGVkLmxlbmd0aCxcXG5cXHRcXHRtYXBwZWQgPSBtYXAgIT0gbnVsbDtcXG5cXG5cXHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcXG5cXHRcXHRpZiAoIChlbGVtID0gdW5tYXRjaGVkW2ldKSApIHtcXG5cXHRcXHRcXHRpZiAoICFmaWx0ZXIgfHwgZmlsdGVyKCBlbGVtLCBjb250ZXh0LCB4bWwgKSApIHtcXG5cXHRcXHRcXHRcXHRuZXdVbm1hdGNoZWQucHVzaCggZWxlbSApO1xcblxcdFxcdFxcdFxcdGlmICggbWFwcGVkICkge1xcblxcdFxcdFxcdFxcdFxcdG1hcC5wdXNoKCBpICk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFx0fVxcblxcblxcdHJldHVybiBuZXdVbm1hdGNoZWQ7XFxufVxcblxcbmZ1bmN0aW9uIHNldE1hdGNoZXIoIHByZUZpbHRlciwgc2VsZWN0b3IsIG1hdGNoZXIsIHBvc3RGaWx0ZXIsIHBvc3RGaW5kZXIsIHBvc3RTZWxlY3RvciApIHtcXG5cXHRpZiAoIHBvc3RGaWx0ZXIgJiYgIXBvc3RGaWx0ZXJbIGV4cGFuZG8gXSApIHtcXG5cXHRcXHRwb3N0RmlsdGVyID0gc2V0TWF0Y2hlciggcG9zdEZpbHRlciApO1xcblxcdH1cXG5cXHRpZiAoIHBvc3RGaW5kZXIgJiYgIXBvc3RGaW5kZXJbIGV4cGFuZG8gXSApIHtcXG5cXHRcXHRwb3N0RmluZGVyID0gc2V0TWF0Y2hlciggcG9zdEZpbmRlciwgcG9zdFNlbGVjdG9yICk7XFxuXFx0fVxcblxcdHJldHVybiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlZWQsIHJlc3VsdHMsIGNvbnRleHQsIHhtbCApIHtcXG5cXHRcXHR2YXIgdGVtcCwgaSwgZWxlbSxcXG5cXHRcXHRcXHRwcmVNYXAgPSBbXSxcXG5cXHRcXHRcXHRwb3N0TWFwID0gW10sXFxuXFx0XFx0XFx0cHJlZXhpc3RpbmcgPSByZXN1bHRzLmxlbmd0aCxcXG5cXG5cXHRcXHRcXHQvLyBHZXQgaW5pdGlhbCBlbGVtZW50cyBmcm9tIHNlZWQgb3IgY29udGV4dFxcblxcdFxcdFxcdGVsZW1zID0gc2VlZCB8fCBtdWx0aXBsZUNvbnRleHRzKCBzZWxlY3RvciB8fCBcXFwiKlxcXCIsIGNvbnRleHQubm9kZVR5cGUgPyBbIGNvbnRleHQgXSA6IGNvbnRleHQsIFtdICksXFxuXFxuXFx0XFx0XFx0Ly8gUHJlZmlsdGVyIHRvIGdldCBtYXRjaGVyIGlucHV0LCBwcmVzZXJ2aW5nIGEgbWFwIGZvciBzZWVkLXJlc3VsdHMgc3luY2hyb25pemF0aW9uXFxuXFx0XFx0XFx0bWF0Y2hlckluID0gcHJlRmlsdGVyICYmICggc2VlZCB8fCAhc2VsZWN0b3IgKSA/XFxuXFx0XFx0XFx0XFx0Y29uZGVuc2UoIGVsZW1zLCBwcmVNYXAsIHByZUZpbHRlciwgY29udGV4dCwgeG1sICkgOlxcblxcdFxcdFxcdFxcdGVsZW1zLFxcblxcblxcdFxcdFxcdG1hdGNoZXJPdXQgPSBtYXRjaGVyID9cXG5cXHRcXHRcXHRcXHQvLyBJZiB3ZSBoYXZlIGEgcG9zdEZpbmRlciwgb3IgZmlsdGVyZWQgc2VlZCwgb3Igbm9uLXNlZWQgcG9zdEZpbHRlciBvciBwcmVleGlzdGluZyByZXN1bHRzLFxcblxcdFxcdFxcdFxcdHBvc3RGaW5kZXIgfHwgKCBzZWVkID8gcHJlRmlsdGVyIDogcHJlZXhpc3RpbmcgfHwgcG9zdEZpbHRlciApID9cXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyAuLi5pbnRlcm1lZGlhdGUgcHJvY2Vzc2luZyBpcyBuZWNlc3NhcnlcXG5cXHRcXHRcXHRcXHRcXHRbXSA6XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gLi4ub3RoZXJ3aXNlIHVzZSByZXN1bHRzIGRpcmVjdGx5XFxuXFx0XFx0XFx0XFx0XFx0cmVzdWx0cyA6XFxuXFx0XFx0XFx0XFx0bWF0Y2hlckluO1xcblxcblxcdFxcdC8vIEZpbmQgcHJpbWFyeSBtYXRjaGVzXFxuXFx0XFx0aWYgKCBtYXRjaGVyICkge1xcblxcdFxcdFxcdG1hdGNoZXIoIG1hdGNoZXJJbiwgbWF0Y2hlck91dCwgY29udGV4dCwgeG1sICk7XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIEFwcGx5IHBvc3RGaWx0ZXJcXG5cXHRcXHRpZiAoIHBvc3RGaWx0ZXIgKSB7XFxuXFx0XFx0XFx0dGVtcCA9IGNvbmRlbnNlKCBtYXRjaGVyT3V0LCBwb3N0TWFwICk7XFxuXFx0XFx0XFx0cG9zdEZpbHRlciggdGVtcCwgW10sIGNvbnRleHQsIHhtbCApO1xcblxcblxcdFxcdFxcdC8vIFVuLW1hdGNoIGZhaWxpbmcgZWxlbWVudHMgYnkgbW92aW5nIHRoZW0gYmFjayB0byBtYXRjaGVySW5cXG5cXHRcXHRcXHRpID0gdGVtcC5sZW5ndGg7XFxuXFx0XFx0XFx0d2hpbGUgKCBpLS0gKSB7XFxuXFx0XFx0XFx0XFx0aWYgKCAoZWxlbSA9IHRlbXBbaV0pICkge1xcblxcdFxcdFxcdFxcdFxcdG1hdGNoZXJPdXRbIHBvc3RNYXBbaV0gXSA9ICEobWF0Y2hlckluWyBwb3N0TWFwW2ldIF0gPSBlbGVtKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXG5cXHRcXHRpZiAoIHNlZWQgKSB7XFxuXFx0XFx0XFx0aWYgKCBwb3N0RmluZGVyIHx8IHByZUZpbHRlciApIHtcXG5cXHRcXHRcXHRcXHRpZiAoIHBvc3RGaW5kZXIgKSB7XFxuXFx0XFx0XFx0XFx0XFx0Ly8gR2V0IHRoZSBmaW5hbCBtYXRjaGVyT3V0IGJ5IGNvbmRlbnNpbmcgdGhpcyBpbnRlcm1lZGlhdGUgaW50byBwb3N0RmluZGVyIGNvbnRleHRzXFxuXFx0XFx0XFx0XFx0XFx0dGVtcCA9IFtdO1xcblxcdFxcdFxcdFxcdFxcdGkgPSBtYXRjaGVyT3V0Lmxlbmd0aDtcXG5cXHRcXHRcXHRcXHRcXHR3aGlsZSAoIGktLSApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoIChlbGVtID0gbWF0Y2hlck91dFtpXSkgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gUmVzdG9yZSBtYXRjaGVySW4gc2luY2UgZWxlbSBpcyBub3QgeWV0IGEgZmluYWwgbWF0Y2hcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR0ZW1wLnB1c2goIChtYXRjaGVySW5baV0gPSBlbGVtKSApO1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0cG9zdEZpbmRlciggbnVsbCwgKG1hdGNoZXJPdXQgPSBbXSksIHRlbXAsIHhtbCApO1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHQvLyBNb3ZlIG1hdGNoZWQgZWxlbWVudHMgZnJvbSBzZWVkIHRvIHJlc3VsdHMgdG8ga2VlcCB0aGVtIHN5bmNocm9uaXplZFxcblxcdFxcdFxcdFxcdGkgPSBtYXRjaGVyT3V0Lmxlbmd0aDtcXG5cXHRcXHRcXHRcXHR3aGlsZSAoIGktLSApIHtcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIChlbGVtID0gbWF0Y2hlck91dFtpXSkgJiZcXG5cXHRcXHRcXHRcXHRcXHRcXHQodGVtcCA9IHBvc3RGaW5kZXIgPyBpbmRleE9mKCBzZWVkLCBlbGVtICkgOiBwcmVNYXBbaV0pID4gLTEgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0c2VlZFt0ZW1wXSA9ICEocmVzdWx0c1t0ZW1wXSA9IGVsZW0pO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdC8vIEFkZCBlbGVtZW50cyB0byByZXN1bHRzLCB0aHJvdWdoIHBvc3RGaW5kZXIgaWYgZGVmaW5lZFxcblxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0bWF0Y2hlck91dCA9IGNvbmRlbnNlKFxcblxcdFxcdFxcdFxcdG1hdGNoZXJPdXQgPT09IHJlc3VsdHMgP1xcblxcdFxcdFxcdFxcdFxcdG1hdGNoZXJPdXQuc3BsaWNlKCBwcmVleGlzdGluZywgbWF0Y2hlck91dC5sZW5ndGggKSA6XFxuXFx0XFx0XFx0XFx0XFx0bWF0Y2hlck91dFxcblxcdFxcdFxcdCk7XFxuXFx0XFx0XFx0aWYgKCBwb3N0RmluZGVyICkge1xcblxcdFxcdFxcdFxcdHBvc3RGaW5kZXIoIG51bGwsIHJlc3VsdHMsIG1hdGNoZXJPdXQsIHhtbCApO1xcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0cHVzaC5hcHBseSggcmVzdWx0cywgbWF0Y2hlck91dCApO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFx0fSk7XFxufVxcblxcbmZ1bmN0aW9uIG1hdGNoZXJGcm9tVG9rZW5zKCB0b2tlbnMgKSB7XFxuXFx0dmFyIGNoZWNrQ29udGV4dCwgbWF0Y2hlciwgaixcXG5cXHRcXHRsZW4gPSB0b2tlbnMubGVuZ3RoLFxcblxcdFxcdGxlYWRpbmdSZWxhdGl2ZSA9IEV4cHIucmVsYXRpdmVbIHRva2Vuc1swXS50eXBlIF0sXFxuXFx0XFx0aW1wbGljaXRSZWxhdGl2ZSA9IGxlYWRpbmdSZWxhdGl2ZSB8fCBFeHByLnJlbGF0aXZlW1xcXCIgXFxcIl0sXFxuXFx0XFx0aSA9IGxlYWRpbmdSZWxhdGl2ZSA/IDEgOiAwLFxcblxcblxcdFxcdC8vIFRoZSBmb3VuZGF0aW9uYWwgbWF0Y2hlciBlbnN1cmVzIHRoYXQgZWxlbWVudHMgYXJlIHJlYWNoYWJsZSBmcm9tIHRvcC1sZXZlbCBjb250ZXh0KHMpXFxuXFx0XFx0bWF0Y2hDb250ZXh0ID0gYWRkQ29tYmluYXRvciggZnVuY3Rpb24oIGVsZW0gKSB7XFxuXFx0XFx0XFx0cmV0dXJuIGVsZW0gPT09IGNoZWNrQ29udGV4dDtcXG5cXHRcXHR9LCBpbXBsaWNpdFJlbGF0aXZlLCB0cnVlICksXFxuXFx0XFx0bWF0Y2hBbnlDb250ZXh0ID0gYWRkQ29tYmluYXRvciggZnVuY3Rpb24oIGVsZW0gKSB7XFxuXFx0XFx0XFx0cmV0dXJuIGluZGV4T2YoIGNoZWNrQ29udGV4dCwgZWxlbSApID4gLTE7XFxuXFx0XFx0fSwgaW1wbGljaXRSZWxhdGl2ZSwgdHJ1ZSApLFxcblxcdFxcdG1hdGNoZXJzID0gWyBmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xcblxcdFxcdFxcdHZhciByZXQgPSAoICFsZWFkaW5nUmVsYXRpdmUgJiYgKCB4bWwgfHwgY29udGV4dCAhPT0gb3V0ZXJtb3N0Q29udGV4dCApICkgfHwgKFxcblxcdFxcdFxcdFxcdChjaGVja0NvbnRleHQgPSBjb250ZXh0KS5ub2RlVHlwZSA/XFxuXFx0XFx0XFx0XFx0XFx0bWF0Y2hDb250ZXh0KCBlbGVtLCBjb250ZXh0LCB4bWwgKSA6XFxuXFx0XFx0XFx0XFx0XFx0bWF0Y2hBbnlDb250ZXh0KCBlbGVtLCBjb250ZXh0LCB4bWwgKSApO1xcblxcdFxcdFxcdC8vIEF2b2lkIGhhbmdpbmcgb250byBlbGVtZW50IChpc3N1ZSAjMjk5KVxcblxcdFxcdFxcdGNoZWNrQ29udGV4dCA9IG51bGw7XFxuXFx0XFx0XFx0cmV0dXJuIHJldDtcXG5cXHRcXHR9IF07XFxuXFxuXFx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XFxuXFx0XFx0aWYgKCAobWF0Y2hlciA9IEV4cHIucmVsYXRpdmVbIHRva2Vuc1tpXS50eXBlIF0pICkge1xcblxcdFxcdFxcdG1hdGNoZXJzID0gWyBhZGRDb21iaW5hdG9yKGVsZW1lbnRNYXRjaGVyKCBtYXRjaGVycyApLCBtYXRjaGVyKSBdO1xcblxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0bWF0Y2hlciA9IEV4cHIuZmlsdGVyWyB0b2tlbnNbaV0udHlwZSBdLmFwcGx5KCBudWxsLCB0b2tlbnNbaV0ubWF0Y2hlcyApO1xcblxcblxcdFxcdFxcdC8vIFJldHVybiBzcGVjaWFsIHVwb24gc2VlaW5nIGEgcG9zaXRpb25hbCBtYXRjaGVyXFxuXFx0XFx0XFx0aWYgKCBtYXRjaGVyWyBleHBhbmRvIF0gKSB7XFxuXFx0XFx0XFx0XFx0Ly8gRmluZCB0aGUgbmV4dCByZWxhdGl2ZSBvcGVyYXRvciAoaWYgYW55KSBmb3IgcHJvcGVyIGhhbmRsaW5nXFxuXFx0XFx0XFx0XFx0aiA9ICsraTtcXG5cXHRcXHRcXHRcXHRmb3IgKCA7IGogPCBsZW47IGorKyApIHtcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIEV4cHIucmVsYXRpdmVbIHRva2Vuc1tqXS50eXBlIF0gKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRyZXR1cm4gc2V0TWF0Y2hlcihcXG5cXHRcXHRcXHRcXHRcXHRpID4gMSAmJiBlbGVtZW50TWF0Y2hlciggbWF0Y2hlcnMgKSxcXG5cXHRcXHRcXHRcXHRcXHRpID4gMSAmJiB0b1NlbGVjdG9yKFxcblxcdFxcdFxcdFxcdFxcdFxcdC8vIElmIHRoZSBwcmVjZWRpbmcgdG9rZW4gd2FzIGEgZGVzY2VuZGFudCBjb21iaW5hdG9yLCBpbnNlcnQgYW4gaW1wbGljaXQgYW55LWVsZW1lbnQgYCpgXFxuXFx0XFx0XFx0XFx0XFx0XFx0dG9rZW5zLnNsaWNlKCAwLCBpIC0gMSApLmNvbmNhdCh7IHZhbHVlOiB0b2tlbnNbIGkgLSAyIF0udHlwZSA9PT0gXFxcIiBcXFwiID8gXFxcIipcXFwiIDogXFxcIlxcXCIgfSlcXG5cXHRcXHRcXHRcXHRcXHQpLnJlcGxhY2UoIHJ0cmltLCBcXFwiJDFcXFwiICksXFxuXFx0XFx0XFx0XFx0XFx0bWF0Y2hlcixcXG5cXHRcXHRcXHRcXHRcXHRpIDwgaiAmJiBtYXRjaGVyRnJvbVRva2VucyggdG9rZW5zLnNsaWNlKCBpLCBqICkgKSxcXG5cXHRcXHRcXHRcXHRcXHRqIDwgbGVuICYmIG1hdGNoZXJGcm9tVG9rZW5zKCAodG9rZW5zID0gdG9rZW5zLnNsaWNlKCBqICkpICksXFxuXFx0XFx0XFx0XFx0XFx0aiA8IGxlbiAmJiB0b1NlbGVjdG9yKCB0b2tlbnMgKVxcblxcdFxcdFxcdFxcdCk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdG1hdGNoZXJzLnB1c2goIG1hdGNoZXIgKTtcXG5cXHRcXHR9XFxuXFx0fVxcblxcblxcdHJldHVybiBlbGVtZW50TWF0Y2hlciggbWF0Y2hlcnMgKTtcXG59XFxuXFxuZnVuY3Rpb24gbWF0Y2hlckZyb21Hcm91cE1hdGNoZXJzKCBlbGVtZW50TWF0Y2hlcnMsIHNldE1hdGNoZXJzICkge1xcblxcdHZhciBieVNldCA9IHNldE1hdGNoZXJzLmxlbmd0aCA+IDAsXFxuXFx0XFx0YnlFbGVtZW50ID0gZWxlbWVudE1hdGNoZXJzLmxlbmd0aCA+IDAsXFxuXFx0XFx0c3VwZXJNYXRjaGVyID0gZnVuY3Rpb24oIHNlZWQsIGNvbnRleHQsIHhtbCwgcmVzdWx0cywgb3V0ZXJtb3N0ICkge1xcblxcdFxcdFxcdHZhciBlbGVtLCBqLCBtYXRjaGVyLFxcblxcdFxcdFxcdFxcdG1hdGNoZWRDb3VudCA9IDAsXFxuXFx0XFx0XFx0XFx0aSA9IFxcXCIwXFxcIixcXG5cXHRcXHRcXHRcXHR1bm1hdGNoZWQgPSBzZWVkICYmIFtdLFxcblxcdFxcdFxcdFxcdHNldE1hdGNoZWQgPSBbXSxcXG5cXHRcXHRcXHRcXHRjb250ZXh0QmFja3VwID0gb3V0ZXJtb3N0Q29udGV4dCxcXG5cXHRcXHRcXHRcXHQvLyBXZSBtdXN0IGFsd2F5cyBoYXZlIGVpdGhlciBzZWVkIGVsZW1lbnRzIG9yIG91dGVybW9zdCBjb250ZXh0XFxuXFx0XFx0XFx0XFx0ZWxlbXMgPSBzZWVkIHx8IGJ5RWxlbWVudCAmJiBFeHByLmZpbmRbXFxcIlRBR1xcXCJdKCBcXFwiKlxcXCIsIG91dGVybW9zdCApLFxcblxcdFxcdFxcdFxcdC8vIFVzZSBpbnRlZ2VyIGRpcnJ1bnMgaWZmIHRoaXMgaXMgdGhlIG91dGVybW9zdCBtYXRjaGVyXFxuXFx0XFx0XFx0XFx0ZGlycnVuc1VuaXF1ZSA9IChkaXJydW5zICs9IGNvbnRleHRCYWNrdXAgPT0gbnVsbCA/IDEgOiBNYXRoLnJhbmRvbSgpIHx8IDAuMSksXFxuXFx0XFx0XFx0XFx0bGVuID0gZWxlbXMubGVuZ3RoO1xcblxcblxcdFxcdFxcdGlmICggb3V0ZXJtb3N0ICkge1xcblxcdFxcdFxcdFxcdG91dGVybW9zdENvbnRleHQgPSBjb250ZXh0ID09PSBkb2N1bWVudCB8fCBjb250ZXh0IHx8IG91dGVybW9zdDtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gQWRkIGVsZW1lbnRzIHBhc3NpbmcgZWxlbWVudE1hdGNoZXJzIGRpcmVjdGx5IHRvIHJlc3VsdHNcXG5cXHRcXHRcXHQvLyBTdXBwb3J0OiBJRTw5LCBTYWZhcmlcXG5cXHRcXHRcXHQvLyBUb2xlcmF0ZSBOb2RlTGlzdCBwcm9wZXJ0aWVzIChJRTogXFxcImxlbmd0aFxcXCI7IFNhZmFyaTogPG51bWJlcj4pIG1hdGNoaW5nIGVsZW1lbnRzIGJ5IGlkXFxuXFx0XFx0XFx0Zm9yICggOyBpICE9PSBsZW4gJiYgKGVsZW0gPSBlbGVtc1tpXSkgIT0gbnVsbDsgaSsrICkge1xcblxcdFxcdFxcdFxcdGlmICggYnlFbGVtZW50ICYmIGVsZW0gKSB7XFxuXFx0XFx0XFx0XFx0XFx0aiA9IDA7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKCAhY29udGV4dCAmJiBlbGVtLm93bmVyRG9jdW1lbnQgIT09IGRvY3VtZW50ICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHNldERvY3VtZW50KCBlbGVtICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0eG1sID0gIWRvY3VtZW50SXNIVE1MO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHR3aGlsZSAoIChtYXRjaGVyID0gZWxlbWVudE1hdGNoZXJzW2orK10pICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGlmICggbWF0Y2hlciggZWxlbSwgY29udGV4dCB8fCBkb2N1bWVudCwgeG1sKSApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRyZXN1bHRzLnB1c2goIGVsZW0gKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdGlmICggb3V0ZXJtb3N0ICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGRpcnJ1bnMgPSBkaXJydW5zVW5pcXVlO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0Ly8gVHJhY2sgdW5tYXRjaGVkIGVsZW1lbnRzIGZvciBzZXQgZmlsdGVyc1xcblxcdFxcdFxcdFxcdGlmICggYnlTZXQgKSB7XFxuXFx0XFx0XFx0XFx0XFx0Ly8gVGhleSB3aWxsIGhhdmUgZ29uZSB0aHJvdWdoIGFsbCBwb3NzaWJsZSBtYXRjaGVyc1xcblxcdFxcdFxcdFxcdFxcdGlmICggKGVsZW0gPSAhbWF0Y2hlciAmJiBlbGVtKSApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRtYXRjaGVkQ291bnQtLTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gTGVuZ3RoZW4gdGhlIGFycmF5IGZvciBldmVyeSBlbGVtZW50LCBtYXRjaGVkIG9yIG5vdFxcblxcdFxcdFxcdFxcdFxcdGlmICggc2VlZCApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHR1bm1hdGNoZWQucHVzaCggZWxlbSApO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIGBpYCBpcyBub3cgdGhlIGNvdW50IG9mIGVsZW1lbnRzIHZpc2l0ZWQgYWJvdmUsIGFuZCBhZGRpbmcgaXQgdG8gYG1hdGNoZWRDb3VudGBcXG5cXHRcXHRcXHQvLyBtYWtlcyB0aGUgbGF0dGVyIG5vbm5lZ2F0aXZlLlxcblxcdFxcdFxcdG1hdGNoZWRDb3VudCArPSBpO1xcblxcblxcdFxcdFxcdC8vIEFwcGx5IHNldCBmaWx0ZXJzIHRvIHVubWF0Y2hlZCBlbGVtZW50c1xcblxcdFxcdFxcdC8vIE5PVEU6IFRoaXMgY2FuIGJlIHNraXBwZWQgaWYgdGhlcmUgYXJlIG5vIHVubWF0Y2hlZCBlbGVtZW50cyAoaS5lLiwgYG1hdGNoZWRDb3VudGBcXG5cXHRcXHRcXHQvLyBlcXVhbHMgYGlgKSwgdW5sZXNzIHdlIGRpZG4ndCB2aXNpdCBfYW55XyBlbGVtZW50cyBpbiB0aGUgYWJvdmUgbG9vcCBiZWNhdXNlIHdlIGhhdmVcXG5cXHRcXHRcXHQvLyBubyBlbGVtZW50IG1hdGNoZXJzIGFuZCBubyBzZWVkLlxcblxcdFxcdFxcdC8vIEluY3JlbWVudGluZyBhbiBpbml0aWFsbHktc3RyaW5nIFxcXCIwXFxcIiBgaWAgYWxsb3dzIGBpYCB0byByZW1haW4gYSBzdHJpbmcgb25seSBpbiB0aGF0XFxuXFx0XFx0XFx0Ly8gY2FzZSwgd2hpY2ggd2lsbCByZXN1bHQgaW4gYSBcXFwiMDBcXFwiIGBtYXRjaGVkQ291bnRgIHRoYXQgZGlmZmVycyBmcm9tIGBpYCBidXQgaXMgYWxzb1xcblxcdFxcdFxcdC8vIG51bWVyaWNhbGx5IHplcm8uXFxuXFx0XFx0XFx0aWYgKCBieVNldCAmJiBpICE9PSBtYXRjaGVkQ291bnQgKSB7XFxuXFx0XFx0XFx0XFx0aiA9IDA7XFxuXFx0XFx0XFx0XFx0d2hpbGUgKCAobWF0Y2hlciA9IHNldE1hdGNoZXJzW2orK10pICkge1xcblxcdFxcdFxcdFxcdFxcdG1hdGNoZXIoIHVubWF0Y2hlZCwgc2V0TWF0Y2hlZCwgY29udGV4dCwgeG1sICk7XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdGlmICggc2VlZCApIHtcXG5cXHRcXHRcXHRcXHRcXHQvLyBSZWludGVncmF0ZSBlbGVtZW50IG1hdGNoZXMgdG8gZWxpbWluYXRlIHRoZSBuZWVkIGZvciBzb3J0aW5nXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBtYXRjaGVkQ291bnQgPiAwICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHdoaWxlICggaS0tICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmICggISh1bm1hdGNoZWRbaV0gfHwgc2V0TWF0Y2hlZFtpXSkgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0c2V0TWF0Y2hlZFtpXSA9IHBvcC5jYWxsKCByZXN1bHRzICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gRGlzY2FyZCBpbmRleCBwbGFjZWhvbGRlciB2YWx1ZXMgdG8gZ2V0IG9ubHkgYWN0dWFsIG1hdGNoZXNcXG5cXHRcXHRcXHRcXHRcXHRzZXRNYXRjaGVkID0gY29uZGVuc2UoIHNldE1hdGNoZWQgKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0Ly8gQWRkIG1hdGNoZXMgdG8gcmVzdWx0c1xcblxcdFxcdFxcdFxcdHB1c2guYXBwbHkoIHJlc3VsdHMsIHNldE1hdGNoZWQgKTtcXG5cXG5cXHRcXHRcXHRcXHQvLyBTZWVkbGVzcyBzZXQgbWF0Y2hlcyBzdWNjZWVkaW5nIG11bHRpcGxlIHN1Y2Nlc3NmdWwgbWF0Y2hlcnMgc3RpcHVsYXRlIHNvcnRpbmdcXG5cXHRcXHRcXHRcXHRpZiAoIG91dGVybW9zdCAmJiAhc2VlZCAmJiBzZXRNYXRjaGVkLmxlbmd0aCA+IDAgJiZcXG5cXHRcXHRcXHRcXHRcXHQoIG1hdGNoZWRDb3VudCArIHNldE1hdGNoZXJzLmxlbmd0aCApID4gMSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRTaXp6bGUudW5pcXVlU29ydCggcmVzdWx0cyApO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gT3ZlcnJpZGUgbWFuaXB1bGF0aW9uIG9mIGdsb2JhbHMgYnkgbmVzdGVkIG1hdGNoZXJzXFxuXFx0XFx0XFx0aWYgKCBvdXRlcm1vc3QgKSB7XFxuXFx0XFx0XFx0XFx0ZGlycnVucyA9IGRpcnJ1bnNVbmlxdWU7XFxuXFx0XFx0XFx0XFx0b3V0ZXJtb3N0Q29udGV4dCA9IGNvbnRleHRCYWNrdXA7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHJldHVybiB1bm1hdGNoZWQ7XFxuXFx0XFx0fTtcXG5cXG5cXHRyZXR1cm4gYnlTZXQgP1xcblxcdFxcdG1hcmtGdW5jdGlvbiggc3VwZXJNYXRjaGVyICkgOlxcblxcdFxcdHN1cGVyTWF0Y2hlcjtcXG59XFxuXFxuY29tcGlsZSA9IFNpenpsZS5jb21waWxlID0gZnVuY3Rpb24oIHNlbGVjdG9yLCBtYXRjaCAvKiBJbnRlcm5hbCBVc2UgT25seSAqLyApIHtcXG5cXHR2YXIgaSxcXG5cXHRcXHRzZXRNYXRjaGVycyA9IFtdLFxcblxcdFxcdGVsZW1lbnRNYXRjaGVycyA9IFtdLFxcblxcdFxcdGNhY2hlZCA9IGNvbXBpbGVyQ2FjaGVbIHNlbGVjdG9yICsgXFxcIiBcXFwiIF07XFxuXFxuXFx0aWYgKCAhY2FjaGVkICkge1xcblxcdFxcdC8vIEdlbmVyYXRlIGEgZnVuY3Rpb24gb2YgcmVjdXJzaXZlIGZ1bmN0aW9ucyB0aGF0IGNhbiBiZSB1c2VkIHRvIGNoZWNrIGVhY2ggZWxlbWVudFxcblxcdFxcdGlmICggIW1hdGNoICkge1xcblxcdFxcdFxcdG1hdGNoID0gdG9rZW5pemUoIHNlbGVjdG9yICk7XFxuXFx0XFx0fVxcblxcdFxcdGkgPSBtYXRjaC5sZW5ndGg7XFxuXFx0XFx0d2hpbGUgKCBpLS0gKSB7XFxuXFx0XFx0XFx0Y2FjaGVkID0gbWF0Y2hlckZyb21Ub2tlbnMoIG1hdGNoW2ldICk7XFxuXFx0XFx0XFx0aWYgKCBjYWNoZWRbIGV4cGFuZG8gXSApIHtcXG5cXHRcXHRcXHRcXHRzZXRNYXRjaGVycy5wdXNoKCBjYWNoZWQgKTtcXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdGVsZW1lbnRNYXRjaGVycy5wdXNoKCBjYWNoZWQgKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIENhY2hlIHRoZSBjb21waWxlZCBmdW5jdGlvblxcblxcdFxcdGNhY2hlZCA9IGNvbXBpbGVyQ2FjaGUoIHNlbGVjdG9yLCBtYXRjaGVyRnJvbUdyb3VwTWF0Y2hlcnMoIGVsZW1lbnRNYXRjaGVycywgc2V0TWF0Y2hlcnMgKSApO1xcblxcblxcdFxcdC8vIFNhdmUgc2VsZWN0b3IgYW5kIHRva2VuaXphdGlvblxcblxcdFxcdGNhY2hlZC5zZWxlY3RvciA9IHNlbGVjdG9yO1xcblxcdH1cXG5cXHRyZXR1cm4gY2FjaGVkO1xcbn07XFxuXFxuLyoqXFxuICogQSBsb3ctbGV2ZWwgc2VsZWN0aW9uIGZ1bmN0aW9uIHRoYXQgd29ya3Mgd2l0aCBTaXp6bGUncyBjb21waWxlZFxcbiAqICBzZWxlY3RvciBmdW5jdGlvbnNcXG4gKiBAcGFyYW0ge1N0cmluZ3xGdW5jdGlvbn0gc2VsZWN0b3IgQSBzZWxlY3RvciBvciBhIHByZS1jb21waWxlZFxcbiAqICBzZWxlY3RvciBmdW5jdGlvbiBidWlsdCB3aXRoIFNpenpsZS5jb21waWxlXFxuICogQHBhcmFtIHtFbGVtZW50fSBjb250ZXh0XFxuICogQHBhcmFtIHtBcnJheX0gW3Jlc3VsdHNdXFxuICogQHBhcmFtIHtBcnJheX0gW3NlZWRdIEEgc2V0IG9mIGVsZW1lbnRzIHRvIG1hdGNoIGFnYWluc3RcXG4gKi9cXG5zZWxlY3QgPSBTaXp6bGUuc2VsZWN0ID0gZnVuY3Rpb24oIHNlbGVjdG9yLCBjb250ZXh0LCByZXN1bHRzLCBzZWVkICkge1xcblxcdHZhciBpLCB0b2tlbnMsIHRva2VuLCB0eXBlLCBmaW5kLFxcblxcdFxcdGNvbXBpbGVkID0gdHlwZW9mIHNlbGVjdG9yID09PSBcXFwiZnVuY3Rpb25cXFwiICYmIHNlbGVjdG9yLFxcblxcdFxcdG1hdGNoID0gIXNlZWQgJiYgdG9rZW5pemUoIChzZWxlY3RvciA9IGNvbXBpbGVkLnNlbGVjdG9yIHx8IHNlbGVjdG9yKSApO1xcblxcblxcdHJlc3VsdHMgPSByZXN1bHRzIHx8IFtdO1xcblxcblxcdC8vIFRyeSB0byBtaW5pbWl6ZSBvcGVyYXRpb25zIGlmIHRoZXJlIGlzIG9ubHkgb25lIHNlbGVjdG9yIGluIHRoZSBsaXN0IGFuZCBubyBzZWVkXFxuXFx0Ly8gKHRoZSBsYXR0ZXIgb2Ygd2hpY2ggZ3VhcmFudGVlcyB1cyBjb250ZXh0KVxcblxcdGlmICggbWF0Y2gubGVuZ3RoID09PSAxICkge1xcblxcblxcdFxcdC8vIFJlZHVjZSBjb250ZXh0IGlmIHRoZSBsZWFkaW5nIGNvbXBvdW5kIHNlbGVjdG9yIGlzIGFuIElEXFxuXFx0XFx0dG9rZW5zID0gbWF0Y2hbMF0gPSBtYXRjaFswXS5zbGljZSggMCApO1xcblxcdFxcdGlmICggdG9rZW5zLmxlbmd0aCA+IDIgJiYgKHRva2VuID0gdG9rZW5zWzBdKS50eXBlID09PSBcXFwiSURcXFwiICYmXFxuXFx0XFx0XFx0XFx0Y29udGV4dC5ub2RlVHlwZSA9PT0gOSAmJiBkb2N1bWVudElzSFRNTCAmJiBFeHByLnJlbGF0aXZlWyB0b2tlbnNbMV0udHlwZSBdICkge1xcblxcblxcdFxcdFxcdGNvbnRleHQgPSAoIEV4cHIuZmluZFtcXFwiSURcXFwiXSggdG9rZW4ubWF0Y2hlc1swXS5yZXBsYWNlKHJ1bmVzY2FwZSwgZnVuZXNjYXBlKSwgY29udGV4dCApIHx8IFtdIClbMF07XFxuXFx0XFx0XFx0aWYgKCAhY29udGV4dCApIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gcmVzdWx0cztcXG5cXG5cXHRcXHRcXHQvLyBQcmVjb21waWxlZCBtYXRjaGVycyB3aWxsIHN0aWxsIHZlcmlmeSBhbmNlc3RyeSwgc28gc3RlcCB1cCBhIGxldmVsXFxuXFx0XFx0XFx0fSBlbHNlIGlmICggY29tcGlsZWQgKSB7XFxuXFx0XFx0XFx0XFx0Y29udGV4dCA9IGNvbnRleHQucGFyZW50Tm9kZTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0c2VsZWN0b3IgPSBzZWxlY3Rvci5zbGljZSggdG9rZW5zLnNoaWZ0KCkudmFsdWUubGVuZ3RoICk7XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIEZldGNoIGEgc2VlZCBzZXQgZm9yIHJpZ2h0LXRvLWxlZnQgbWF0Y2hpbmdcXG5cXHRcXHRpID0gbWF0Y2hFeHByW1xcXCJuZWVkc0NvbnRleHRcXFwiXS50ZXN0KCBzZWxlY3RvciApID8gMCA6IHRva2Vucy5sZW5ndGg7XFxuXFx0XFx0d2hpbGUgKCBpLS0gKSB7XFxuXFx0XFx0XFx0dG9rZW4gPSB0b2tlbnNbaV07XFxuXFxuXFx0XFx0XFx0Ly8gQWJvcnQgaWYgd2UgaGl0IGEgY29tYmluYXRvclxcblxcdFxcdFxcdGlmICggRXhwci5yZWxhdGl2ZVsgKHR5cGUgPSB0b2tlbi50eXBlKSBdICkge1xcblxcdFxcdFxcdFxcdGJyZWFrO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAoIChmaW5kID0gRXhwci5maW5kWyB0eXBlIF0pICkge1xcblxcdFxcdFxcdFxcdC8vIFNlYXJjaCwgZXhwYW5kaW5nIGNvbnRleHQgZm9yIGxlYWRpbmcgc2libGluZyBjb21iaW5hdG9yc1xcblxcdFxcdFxcdFxcdGlmICggKHNlZWQgPSBmaW5kKFxcblxcdFxcdFxcdFxcdFxcdHRva2VuLm1hdGNoZXNbMF0ucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKSxcXG5cXHRcXHRcXHRcXHRcXHRyc2libGluZy50ZXN0KCB0b2tlbnNbMF0udHlwZSApICYmIHRlc3RDb250ZXh0KCBjb250ZXh0LnBhcmVudE5vZGUgKSB8fCBjb250ZXh0XFxuXFx0XFx0XFx0XFx0KSkgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gSWYgc2VlZCBpcyBlbXB0eSBvciBubyB0b2tlbnMgcmVtYWluLCB3ZSBjYW4gcmV0dXJuIGVhcmx5XFxuXFx0XFx0XFx0XFx0XFx0dG9rZW5zLnNwbGljZSggaSwgMSApO1xcblxcdFxcdFxcdFxcdFxcdHNlbGVjdG9yID0gc2VlZC5sZW5ndGggJiYgdG9TZWxlY3RvciggdG9rZW5zICk7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKCAhc2VsZWN0b3IgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0cHVzaC5hcHBseSggcmVzdWx0cywgc2VlZCApO1xcblxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiByZXN1bHRzO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXHR9XFxuXFxuXFx0Ly8gQ29tcGlsZSBhbmQgZXhlY3V0ZSBhIGZpbHRlcmluZyBmdW5jdGlvbiBpZiBvbmUgaXMgbm90IHByb3ZpZGVkXFxuXFx0Ly8gUHJvdmlkZSBgbWF0Y2hgIHRvIGF2b2lkIHJldG9rZW5pemF0aW9uIGlmIHdlIG1vZGlmaWVkIHRoZSBzZWxlY3RvciBhYm92ZVxcblxcdCggY29tcGlsZWQgfHwgY29tcGlsZSggc2VsZWN0b3IsIG1hdGNoICkgKShcXG5cXHRcXHRzZWVkLFxcblxcdFxcdGNvbnRleHQsXFxuXFx0XFx0IWRvY3VtZW50SXNIVE1MLFxcblxcdFxcdHJlc3VsdHMsXFxuXFx0XFx0IWNvbnRleHQgfHwgcnNpYmxpbmcudGVzdCggc2VsZWN0b3IgKSAmJiB0ZXN0Q29udGV4dCggY29udGV4dC5wYXJlbnROb2RlICkgfHwgY29udGV4dFxcblxcdCk7XFxuXFx0cmV0dXJuIHJlc3VsdHM7XFxufTtcXG5cXG4vLyBPbmUtdGltZSBhc3NpZ25tZW50c1xcblxcbi8vIFNvcnQgc3RhYmlsaXR5XFxuc3VwcG9ydC5zb3J0U3RhYmxlID0gZXhwYW5kby5zcGxpdChcXFwiXFxcIikuc29ydCggc29ydE9yZGVyICkuam9pbihcXFwiXFxcIikgPT09IGV4cGFuZG87XFxuXFxuLy8gU3VwcG9ydDogQ2hyb21lIDE0LTM1K1xcbi8vIEFsd2F5cyBhc3N1bWUgZHVwbGljYXRlcyBpZiB0aGV5IGFyZW4ndCBwYXNzZWQgdG8gdGhlIGNvbXBhcmlzb24gZnVuY3Rpb25cXG5zdXBwb3J0LmRldGVjdER1cGxpY2F0ZXMgPSAhIWhhc0R1cGxpY2F0ZTtcXG5cXG4vLyBJbml0aWFsaXplIGFnYWluc3QgdGhlIGRlZmF1bHQgZG9jdW1lbnRcXG5zZXREb2N1bWVudCgpO1xcblxcbi8vIFN1cHBvcnQ6IFdlYmtpdDw1MzcuMzIgLSBTYWZhcmkgNi4wLjMvQ2hyb21lIDI1IChmaXhlZCBpbiBDaHJvbWUgMjcpXFxuLy8gRGV0YWNoZWQgbm9kZXMgY29uZm91bmRpbmdseSBmb2xsb3cgKmVhY2ggb3RoZXIqXFxuc3VwcG9ydC5zb3J0RGV0YWNoZWQgPSBhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xcblxcdC8vIFNob3VsZCByZXR1cm4gMSwgYnV0IHJldHVybnMgNCAoZm9sbG93aW5nKVxcblxcdHJldHVybiBlbC5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiggZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcXFwiZmllbGRzZXRcXFwiKSApICYgMTtcXG59KTtcXG5cXG4vLyBTdXBwb3J0OiBJRTw4XFxuLy8gUHJldmVudCBhdHRyaWJ1dGUvcHJvcGVydHkgXFxcImludGVycG9sYXRpb25cXFwiXFxuLy8gaHR0cHM6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9tczUzNjQyOSUyOFZTLjg1JTI5LmFzcHhcXG5pZiAoICFhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xcblxcdGVsLmlubmVySFRNTCA9IFxcXCI8YSBocmVmPScjJz48L2E+XFxcIjtcXG5cXHRyZXR1cm4gZWwuZmlyc3RDaGlsZC5nZXRBdHRyaWJ1dGUoXFxcImhyZWZcXFwiKSA9PT0gXFxcIiNcXFwiIDtcXG59KSApIHtcXG5cXHRhZGRIYW5kbGUoIFxcXCJ0eXBlfGhyZWZ8aGVpZ2h0fHdpZHRoXFxcIiwgZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGlzWE1MICkge1xcblxcdFxcdGlmICggIWlzWE1MICkge1xcblxcdFxcdFxcdHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZSggbmFtZSwgbmFtZS50b0xvd2VyQ2FzZSgpID09PSBcXFwidHlwZVxcXCIgPyAxIDogMiApO1xcblxcdFxcdH1cXG5cXHR9KTtcXG59XFxuXFxuLy8gU3VwcG9ydDogSUU8OVxcbi8vIFVzZSBkZWZhdWx0VmFsdWUgaW4gcGxhY2Ugb2YgZ2V0QXR0cmlidXRlKFxcXCJ2YWx1ZVxcXCIpXFxuaWYgKCAhc3VwcG9ydC5hdHRyaWJ1dGVzIHx8ICFhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xcblxcdGVsLmlubmVySFRNTCA9IFxcXCI8aW5wdXQvPlxcXCI7XFxuXFx0ZWwuZmlyc3RDaGlsZC5zZXRBdHRyaWJ1dGUoIFxcXCJ2YWx1ZVxcXCIsIFxcXCJcXFwiICk7XFxuXFx0cmV0dXJuIGVsLmZpcnN0Q2hpbGQuZ2V0QXR0cmlidXRlKCBcXFwidmFsdWVcXFwiICkgPT09IFxcXCJcXFwiO1xcbn0pICkge1xcblxcdGFkZEhhbmRsZSggXFxcInZhbHVlXFxcIiwgZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGlzWE1MICkge1xcblxcdFxcdGlmICggIWlzWE1MICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gXFxcImlucHV0XFxcIiApIHtcXG5cXHRcXHRcXHRyZXR1cm4gZWxlbS5kZWZhdWx0VmFsdWU7XFxuXFx0XFx0fVxcblxcdH0pO1xcbn1cXG5cXG4vLyBTdXBwb3J0OiBJRTw5XFxuLy8gVXNlIGdldEF0dHJpYnV0ZU5vZGUgdG8gZmV0Y2ggYm9vbGVhbnMgd2hlbiBnZXRBdHRyaWJ1dGUgbGllc1xcbmlmICggIWFzc2VydChmdW5jdGlvbiggZWwgKSB7XFxuXFx0cmV0dXJuIGVsLmdldEF0dHJpYnV0ZShcXFwiZGlzYWJsZWRcXFwiKSA9PSBudWxsO1xcbn0pICkge1xcblxcdGFkZEhhbmRsZSggYm9vbGVhbnMsIGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBpc1hNTCApIHtcXG5cXHRcXHR2YXIgdmFsO1xcblxcdFxcdGlmICggIWlzWE1MICkge1xcblxcdFxcdFxcdHJldHVybiBlbGVtWyBuYW1lIF0gPT09IHRydWUgPyBuYW1lLnRvTG93ZXJDYXNlKCkgOlxcblxcdFxcdFxcdFxcdFxcdCh2YWwgPSBlbGVtLmdldEF0dHJpYnV0ZU5vZGUoIG5hbWUgKSkgJiYgdmFsLnNwZWNpZmllZCA/XFxuXFx0XFx0XFx0XFx0XFx0dmFsLnZhbHVlIDpcXG5cXHRcXHRcXHRcXHRudWxsO1xcblxcdFxcdH1cXG5cXHR9KTtcXG59XFxuXFxucmV0dXJuIFNpenpsZTtcXG5cXG59KSggd2luZG93ICk7XFxuXFxuXFxuXFxualF1ZXJ5LmZpbmQgPSBTaXp6bGU7XFxualF1ZXJ5LmV4cHIgPSBTaXp6bGUuc2VsZWN0b3JzO1xcblxcbi8vIERlcHJlY2F0ZWRcXG5qUXVlcnkuZXhwclsgXFxcIjpcXFwiIF0gPSBqUXVlcnkuZXhwci5wc2V1ZG9zO1xcbmpRdWVyeS51bmlxdWVTb3J0ID0galF1ZXJ5LnVuaXF1ZSA9IFNpenpsZS51bmlxdWVTb3J0O1xcbmpRdWVyeS50ZXh0ID0gU2l6emxlLmdldFRleHQ7XFxualF1ZXJ5LmlzWE1MRG9jID0gU2l6emxlLmlzWE1MO1xcbmpRdWVyeS5jb250YWlucyA9IFNpenpsZS5jb250YWlucztcXG5qUXVlcnkuZXNjYXBlU2VsZWN0b3IgPSBTaXp6bGUuZXNjYXBlO1xcblxcblxcblxcblxcbnZhciBkaXIgPSBmdW5jdGlvbiggZWxlbSwgZGlyLCB1bnRpbCApIHtcXG5cXHR2YXIgbWF0Y2hlZCA9IFtdLFxcblxcdFxcdHRydW5jYXRlID0gdW50aWwgIT09IHVuZGVmaW5lZDtcXG5cXG5cXHR3aGlsZSAoICggZWxlbSA9IGVsZW1bIGRpciBdICkgJiYgZWxlbS5ub2RlVHlwZSAhPT0gOSApIHtcXG5cXHRcXHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XFxuXFx0XFx0XFx0aWYgKCB0cnVuY2F0ZSAmJiBqUXVlcnkoIGVsZW0gKS5pcyggdW50aWwgKSApIHtcXG5cXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0bWF0Y2hlZC5wdXNoKCBlbGVtICk7XFxuXFx0XFx0fVxcblxcdH1cXG5cXHRyZXR1cm4gbWF0Y2hlZDtcXG59O1xcblxcblxcbnZhciBzaWJsaW5ncyA9IGZ1bmN0aW9uKCBuLCBlbGVtICkge1xcblxcdHZhciBtYXRjaGVkID0gW107XFxuXFxuXFx0Zm9yICggOyBuOyBuID0gbi5uZXh0U2libGluZyApIHtcXG5cXHRcXHRpZiAoIG4ubm9kZVR5cGUgPT09IDEgJiYgbiAhPT0gZWxlbSApIHtcXG5cXHRcXHRcXHRtYXRjaGVkLnB1c2goIG4gKTtcXG5cXHRcXHR9XFxuXFx0fVxcblxcblxcdHJldHVybiBtYXRjaGVkO1xcbn07XFxuXFxuXFxudmFyIHJuZWVkc0NvbnRleHQgPSBqUXVlcnkuZXhwci5tYXRjaC5uZWVkc0NvbnRleHQ7XFxuXFxuXFxuXFxuZnVuY3Rpb24gbm9kZU5hbWUoIGVsZW0sIG5hbWUgKSB7XFxuXFxuICByZXR1cm4gZWxlbS5ub2RlTmFtZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IG5hbWUudG9Mb3dlckNhc2UoKTtcXG5cXG59O1xcbnZhciByc2luZ2xlVGFnID0gKCAvXjwoW2Etel1bXlxcXFwvXFxcXDA+OlxcXFx4MjBcXFxcdFxcXFxyXFxcXG5cXFxcZl0qKVtcXFxceDIwXFxcXHRcXFxcclxcXFxuXFxcXGZdKlxcXFwvPz4oPzo8XFxcXC9cXFxcMT58KSQvaSApO1xcblxcblxcblxcbi8vIEltcGxlbWVudCB0aGUgaWRlbnRpY2FsIGZ1bmN0aW9uYWxpdHkgZm9yIGZpbHRlciBhbmQgbm90XFxuZnVuY3Rpb24gd2lubm93KCBlbGVtZW50cywgcXVhbGlmaWVyLCBub3QgKSB7XFxuXFx0aWYgKCBpc0Z1bmN0aW9uKCBxdWFsaWZpZXIgKSApIHtcXG5cXHRcXHRyZXR1cm4galF1ZXJ5LmdyZXAoIGVsZW1lbnRzLCBmdW5jdGlvbiggZWxlbSwgaSApIHtcXG5cXHRcXHRcXHRyZXR1cm4gISFxdWFsaWZpZXIuY2FsbCggZWxlbSwgaSwgZWxlbSApICE9PSBub3Q7XFxuXFx0XFx0fSApO1xcblxcdH1cXG5cXG5cXHQvLyBTaW5nbGUgZWxlbWVudFxcblxcdGlmICggcXVhbGlmaWVyLm5vZGVUeXBlICkge1xcblxcdFxcdHJldHVybiBqUXVlcnkuZ3JlcCggZWxlbWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xcblxcdFxcdFxcdHJldHVybiAoIGVsZW0gPT09IHF1YWxpZmllciApICE9PSBub3Q7XFxuXFx0XFx0fSApO1xcblxcdH1cXG5cXG5cXHQvLyBBcnJheWxpa2Ugb2YgZWxlbWVudHMgKGpRdWVyeSwgYXJndW1lbnRzLCBBcnJheSlcXG5cXHRpZiAoIHR5cGVvZiBxdWFsaWZpZXIgIT09IFxcXCJzdHJpbmdcXFwiICkge1xcblxcdFxcdHJldHVybiBqUXVlcnkuZ3JlcCggZWxlbWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xcblxcdFxcdFxcdHJldHVybiAoIGluZGV4T2YuY2FsbCggcXVhbGlmaWVyLCBlbGVtICkgPiAtMSApICE9PSBub3Q7XFxuXFx0XFx0fSApO1xcblxcdH1cXG5cXG5cXHQvLyBGaWx0ZXJlZCBkaXJlY3RseSBmb3IgYm90aCBzaW1wbGUgYW5kIGNvbXBsZXggc2VsZWN0b3JzXFxuXFx0cmV0dXJuIGpRdWVyeS5maWx0ZXIoIHF1YWxpZmllciwgZWxlbWVudHMsIG5vdCApO1xcbn1cXG5cXG5qUXVlcnkuZmlsdGVyID0gZnVuY3Rpb24oIGV4cHIsIGVsZW1zLCBub3QgKSB7XFxuXFx0dmFyIGVsZW0gPSBlbGVtc1sgMCBdO1xcblxcblxcdGlmICggbm90ICkge1xcblxcdFxcdGV4cHIgPSBcXFwiOm5vdChcXFwiICsgZXhwciArIFxcXCIpXFxcIjtcXG5cXHR9XFxuXFxuXFx0aWYgKCBlbGVtcy5sZW5ndGggPT09IDEgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcXG5cXHRcXHRyZXR1cm4galF1ZXJ5LmZpbmQubWF0Y2hlc1NlbGVjdG9yKCBlbGVtLCBleHByICkgPyBbIGVsZW0gXSA6IFtdO1xcblxcdH1cXG5cXG5cXHRyZXR1cm4galF1ZXJ5LmZpbmQubWF0Y2hlcyggZXhwciwgalF1ZXJ5LmdyZXAoIGVsZW1zLCBmdW5jdGlvbiggZWxlbSApIHtcXG5cXHRcXHRyZXR1cm4gZWxlbS5ub2RlVHlwZSA9PT0gMTtcXG5cXHR9ICkgKTtcXG59O1xcblxcbmpRdWVyeS5mbi5leHRlbmQoIHtcXG5cXHRmaW5kOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XFxuXFx0XFx0dmFyIGksIHJldCxcXG5cXHRcXHRcXHRsZW4gPSB0aGlzLmxlbmd0aCxcXG5cXHRcXHRcXHRzZWxmID0gdGhpcztcXG5cXG5cXHRcXHRpZiAoIHR5cGVvZiBzZWxlY3RvciAhPT0gXFxcInN0cmluZ1xcXCIgKSB7XFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBqUXVlcnkoIHNlbGVjdG9yICkuZmlsdGVyKCBmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHRcXHRmb3IgKCBpID0gMDsgaSA8IGxlbjsgaSsrICkge1xcblxcdFxcdFxcdFxcdFxcdGlmICggalF1ZXJ5LmNvbnRhaW5zKCBzZWxmWyBpIF0sIHRoaXMgKSApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gdHJ1ZTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH0gKSApO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRyZXQgPSB0aGlzLnB1c2hTdGFjayggW10gKTtcXG5cXG5cXHRcXHRmb3IgKCBpID0gMDsgaSA8IGxlbjsgaSsrICkge1xcblxcdFxcdFxcdGpRdWVyeS5maW5kKCBzZWxlY3Rvciwgc2VsZlsgaSBdLCByZXQgKTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0cmV0dXJuIGxlbiA+IDEgPyBqUXVlcnkudW5pcXVlU29ydCggcmV0ICkgOiByZXQ7XFxuXFx0fSxcXG5cXHRmaWx0ZXI6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcXG5cXHRcXHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIHdpbm5vdyggdGhpcywgc2VsZWN0b3IgfHwgW10sIGZhbHNlICkgKTtcXG5cXHR9LFxcblxcdG5vdDogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xcblxcdFxcdHJldHVybiB0aGlzLnB1c2hTdGFjayggd2lubm93KCB0aGlzLCBzZWxlY3RvciB8fCBbXSwgdHJ1ZSApICk7XFxuXFx0fSxcXG5cXHRpczogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xcblxcdFxcdHJldHVybiAhIXdpbm5vdyhcXG5cXHRcXHRcXHR0aGlzLFxcblxcblxcdFxcdFxcdC8vIElmIHRoaXMgaXMgYSBwb3NpdGlvbmFsL3JlbGF0aXZlIHNlbGVjdG9yLCBjaGVjayBtZW1iZXJzaGlwIGluIHRoZSByZXR1cm5lZCBzZXRcXG5cXHRcXHRcXHQvLyBzbyAkKFxcXCJwOmZpcnN0XFxcIikuaXMoXFxcInA6bGFzdFxcXCIpIHdvbid0IHJldHVybiB0cnVlIGZvciBhIGRvYyB3aXRoIHR3byBcXFwicFxcXCIuXFxuXFx0XFx0XFx0dHlwZW9mIHNlbGVjdG9yID09PSBcXFwic3RyaW5nXFxcIiAmJiBybmVlZHNDb250ZXh0LnRlc3QoIHNlbGVjdG9yICkgP1xcblxcdFxcdFxcdFxcdGpRdWVyeSggc2VsZWN0b3IgKSA6XFxuXFx0XFx0XFx0XFx0c2VsZWN0b3IgfHwgW10sXFxuXFx0XFx0XFx0ZmFsc2VcXG5cXHRcXHQpLmxlbmd0aDtcXG5cXHR9XFxufSApO1xcblxcblxcbi8vIEluaXRpYWxpemUgYSBqUXVlcnkgb2JqZWN0XFxuXFxuXFxuLy8gQSBjZW50cmFsIHJlZmVyZW5jZSB0byB0aGUgcm9vdCBqUXVlcnkoZG9jdW1lbnQpXFxudmFyIHJvb3RqUXVlcnksXFxuXFxuXFx0Ly8gQSBzaW1wbGUgd2F5IHRvIGNoZWNrIGZvciBIVE1MIHN0cmluZ3NcXG5cXHQvLyBQcmlvcml0aXplICNpZCBvdmVyIDx0YWc+IHRvIGF2b2lkIFhTUyB2aWEgbG9jYXRpb24uaGFzaCAoIzk1MjEpXFxuXFx0Ly8gU3RyaWN0IEhUTUwgcmVjb2duaXRpb24gKCMxMTI5MDogbXVzdCBzdGFydCB3aXRoIDwpXFxuXFx0Ly8gU2hvcnRjdXQgc2ltcGxlICNpZCBjYXNlIGZvciBzcGVlZFxcblxcdHJxdWlja0V4cHIgPSAvXig/OlxcXFxzKig8W1xcXFx3XFxcXFddKz4pW14+XSp8IyhbXFxcXHctXSspKSQvLFxcblxcblxcdGluaXQgPSBqUXVlcnkuZm4uaW5pdCA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgY29udGV4dCwgcm9vdCApIHtcXG5cXHRcXHR2YXIgbWF0Y2gsIGVsZW07XFxuXFxuXFx0XFx0Ly8gSEFORExFOiAkKFxcXCJcXFwiKSwgJChudWxsKSwgJCh1bmRlZmluZWQpLCAkKGZhbHNlKVxcblxcdFxcdGlmICggIXNlbGVjdG9yICkge1xcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBNZXRob2QgaW5pdCgpIGFjY2VwdHMgYW4gYWx0ZXJuYXRlIHJvb3RqUXVlcnlcXG5cXHRcXHQvLyBzbyBtaWdyYXRlIGNhbiBzdXBwb3J0IGpRdWVyeS5zdWIgKGdoLTIxMDEpXFxuXFx0XFx0cm9vdCA9IHJvb3QgfHwgcm9vdGpRdWVyeTtcXG5cXG5cXHRcXHQvLyBIYW5kbGUgSFRNTCBzdHJpbmdzXFxuXFx0XFx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgPT09IFxcXCJzdHJpbmdcXFwiICkge1xcblxcdFxcdFxcdGlmICggc2VsZWN0b3JbIDAgXSA9PT0gXFxcIjxcXFwiICYmXFxuXFx0XFx0XFx0XFx0c2VsZWN0b3JbIHNlbGVjdG9yLmxlbmd0aCAtIDEgXSA9PT0gXFxcIj5cXFwiICYmXFxuXFx0XFx0XFx0XFx0c2VsZWN0b3IubGVuZ3RoID49IDMgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gQXNzdW1lIHRoYXQgc3RyaW5ncyB0aGF0IHN0YXJ0IGFuZCBlbmQgd2l0aCA8PiBhcmUgSFRNTCBhbmQgc2tpcCB0aGUgcmVnZXggY2hlY2tcXG5cXHRcXHRcXHRcXHRtYXRjaCA9IFsgbnVsbCwgc2VsZWN0b3IsIG51bGwgXTtcXG5cXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdG1hdGNoID0gcnF1aWNrRXhwci5leGVjKCBzZWxlY3RvciApO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBNYXRjaCBodG1sIG9yIG1ha2Ugc3VyZSBubyBjb250ZXh0IGlzIHNwZWNpZmllZCBmb3IgI2lkXFxuXFx0XFx0XFx0aWYgKCBtYXRjaCAmJiAoIG1hdGNoWyAxIF0gfHwgIWNvbnRleHQgKSApIHtcXG5cXG5cXHRcXHRcXHRcXHQvLyBIQU5ETEU6ICQoaHRtbCkgLT4gJChhcnJheSlcXG5cXHRcXHRcXHRcXHRpZiAoIG1hdGNoWyAxIF0gKSB7XFxuXFx0XFx0XFx0XFx0XFx0Y29udGV4dCA9IGNvbnRleHQgaW5zdGFuY2VvZiBqUXVlcnkgPyBjb250ZXh0WyAwIF0gOiBjb250ZXh0O1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIE9wdGlvbiB0byBydW4gc2NyaXB0cyBpcyB0cnVlIGZvciBiYWNrLWNvbXBhdFxcblxcdFxcdFxcdFxcdFxcdC8vIEludGVudGlvbmFsbHkgbGV0IHRoZSBlcnJvciBiZSB0aHJvd24gaWYgcGFyc2VIVE1MIGlzIG5vdCBwcmVzZW50XFxuXFx0XFx0XFx0XFx0XFx0alF1ZXJ5Lm1lcmdlKCB0aGlzLCBqUXVlcnkucGFyc2VIVE1MKFxcblxcdFxcdFxcdFxcdFxcdFxcdG1hdGNoWyAxIF0sXFxuXFx0XFx0XFx0XFx0XFx0XFx0Y29udGV4dCAmJiBjb250ZXh0Lm5vZGVUeXBlID8gY29udGV4dC5vd25lckRvY3VtZW50IHx8IGNvbnRleHQgOiBkb2N1bWVudCxcXG5cXHRcXHRcXHRcXHRcXHRcXHR0cnVlXFxuXFx0XFx0XFx0XFx0XFx0KSApO1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIEhBTkRMRTogJChodG1sLCBwcm9wcylcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIHJzaW5nbGVUYWcudGVzdCggbWF0Y2hbIDEgXSApICYmIGpRdWVyeS5pc1BsYWluT2JqZWN0KCBjb250ZXh0ICkgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0Zm9yICggbWF0Y2ggaW4gY29udGV4dCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBQcm9wZXJ0aWVzIG9mIGNvbnRleHQgYXJlIGNhbGxlZCBhcyBtZXRob2RzIGlmIHBvc3NpYmxlXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBpc0Z1bmN0aW9uKCB0aGlzWyBtYXRjaCBdICkgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0dGhpc1sgbWF0Y2ggXSggY29udGV4dFsgbWF0Y2ggXSApO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIC4uLmFuZCBvdGhlcndpc2Ugc2V0IGFzIGF0dHJpYnV0ZXNcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHRoaXMuYXR0ciggbWF0Y2gsIGNvbnRleHRbIG1hdGNoIF0gKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHRcXHRcXHQvLyBIQU5ETEU6ICQoI2lkKVxcblxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0ZWxlbSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCBtYXRjaFsgMiBdICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBlbGVtICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdC8vIEluamVjdCB0aGUgZWxlbWVudCBkaXJlY3RseSBpbnRvIHRoZSBqUXVlcnkgb2JqZWN0XFxuXFx0XFx0XFx0XFx0XFx0XFx0dGhpc1sgMCBdID0gZWxlbTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR0aGlzLmxlbmd0aCA9IDE7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBIQU5ETEU6ICQoZXhwciwgJCguLi4pKVxcblxcdFxcdFxcdH0gZWxzZSBpZiAoICFjb250ZXh0IHx8IGNvbnRleHQuanF1ZXJ5ICkge1xcblxcdFxcdFxcdFxcdHJldHVybiAoIGNvbnRleHQgfHwgcm9vdCApLmZpbmQoIHNlbGVjdG9yICk7XFxuXFxuXFx0XFx0XFx0Ly8gSEFORExFOiAkKGV4cHIsIGNvbnRleHQpXFxuXFx0XFx0XFx0Ly8gKHdoaWNoIGlzIGp1c3QgZXF1aXZhbGVudCB0bzogJChjb250ZXh0KS5maW5kKGV4cHIpXFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gdGhpcy5jb25zdHJ1Y3RvciggY29udGV4dCApLmZpbmQoIHNlbGVjdG9yICk7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdC8vIEhBTkRMRTogJChET01FbGVtZW50KVxcblxcdFxcdH0gZWxzZSBpZiAoIHNlbGVjdG9yLm5vZGVUeXBlICkge1xcblxcdFxcdFxcdHRoaXNbIDAgXSA9IHNlbGVjdG9yO1xcblxcdFxcdFxcdHRoaXMubGVuZ3RoID0gMTtcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHQvLyBIQU5ETEU6ICQoZnVuY3Rpb24pXFxuXFx0XFx0Ly8gU2hvcnRjdXQgZm9yIGRvY3VtZW50IHJlYWR5XFxuXFx0XFx0fSBlbHNlIGlmICggaXNGdW5jdGlvbiggc2VsZWN0b3IgKSApIHtcXG5cXHRcXHRcXHRyZXR1cm4gcm9vdC5yZWFkeSAhPT0gdW5kZWZpbmVkID9cXG5cXHRcXHRcXHRcXHRyb290LnJlYWR5KCBzZWxlY3RvciApIDpcXG5cXG5cXHRcXHRcXHRcXHQvLyBFeGVjdXRlIGltbWVkaWF0ZWx5IGlmIHJlYWR5IGlzIG5vdCBwcmVzZW50XFxuXFx0XFx0XFx0XFx0c2VsZWN0b3IoIGpRdWVyeSApO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRyZXR1cm4galF1ZXJ5Lm1ha2VBcnJheSggc2VsZWN0b3IsIHRoaXMgKTtcXG5cXHR9O1xcblxcbi8vIEdpdmUgdGhlIGluaXQgZnVuY3Rpb24gdGhlIGpRdWVyeSBwcm90b3R5cGUgZm9yIGxhdGVyIGluc3RhbnRpYXRpb25cXG5pbml0LnByb3RvdHlwZSA9IGpRdWVyeS5mbjtcXG5cXG4vLyBJbml0aWFsaXplIGNlbnRyYWwgcmVmZXJlbmNlXFxucm9vdGpRdWVyeSA9IGpRdWVyeSggZG9jdW1lbnQgKTtcXG5cXG5cXG52YXIgcnBhcmVudHNwcmV2ID0gL14oPzpwYXJlbnRzfHByZXYoPzpVbnRpbHxBbGwpKS8sXFxuXFxuXFx0Ly8gTWV0aG9kcyBndWFyYW50ZWVkIHRvIHByb2R1Y2UgYSB1bmlxdWUgc2V0IHdoZW4gc3RhcnRpbmcgZnJvbSBhIHVuaXF1ZSBzZXRcXG5cXHRndWFyYW50ZWVkVW5pcXVlID0ge1xcblxcdFxcdGNoaWxkcmVuOiB0cnVlLFxcblxcdFxcdGNvbnRlbnRzOiB0cnVlLFxcblxcdFxcdG5leHQ6IHRydWUsXFxuXFx0XFx0cHJldjogdHJ1ZVxcblxcdH07XFxuXFxualF1ZXJ5LmZuLmV4dGVuZCgge1xcblxcdGhhczogZnVuY3Rpb24oIHRhcmdldCApIHtcXG5cXHRcXHR2YXIgdGFyZ2V0cyA9IGpRdWVyeSggdGFyZ2V0LCB0aGlzICksXFxuXFx0XFx0XFx0bCA9IHRhcmdldHMubGVuZ3RoO1xcblxcblxcdFxcdHJldHVybiB0aGlzLmZpbHRlciggZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0dmFyIGkgPSAwO1xcblxcdFxcdFxcdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcXG5cXHRcXHRcXHRcXHRpZiAoIGpRdWVyeS5jb250YWlucyggdGhpcywgdGFyZ2V0c1sgaSBdICkgKSB7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIHRydWU7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHR9ICk7XFxuXFx0fSxcXG5cXG5cXHRjbG9zZXN0OiBmdW5jdGlvbiggc2VsZWN0b3JzLCBjb250ZXh0ICkge1xcblxcdFxcdHZhciBjdXIsXFxuXFx0XFx0XFx0aSA9IDAsXFxuXFx0XFx0XFx0bCA9IHRoaXMubGVuZ3RoLFxcblxcdFxcdFxcdG1hdGNoZWQgPSBbXSxcXG5cXHRcXHRcXHR0YXJnZXRzID0gdHlwZW9mIHNlbGVjdG9ycyAhPT0gXFxcInN0cmluZ1xcXCIgJiYgalF1ZXJ5KCBzZWxlY3RvcnMgKTtcXG5cXG5cXHRcXHQvLyBQb3NpdGlvbmFsIHNlbGVjdG9ycyBuZXZlciBtYXRjaCwgc2luY2UgdGhlcmUncyBubyBfc2VsZWN0aW9uXyBjb250ZXh0XFxuXFx0XFx0aWYgKCAhcm5lZWRzQ29udGV4dC50ZXN0KCBzZWxlY3RvcnMgKSApIHtcXG5cXHRcXHRcXHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XFxuXFx0XFx0XFx0XFx0Zm9yICggY3VyID0gdGhpc1sgaSBdOyBjdXIgJiYgY3VyICE9PSBjb250ZXh0OyBjdXIgPSBjdXIucGFyZW50Tm9kZSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBBbHdheXMgc2tpcCBkb2N1bWVudCBmcmFnbWVudHNcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIGN1ci5ub2RlVHlwZSA8IDExICYmICggdGFyZ2V0cyA/XFxuXFx0XFx0XFx0XFx0XFx0XFx0dGFyZ2V0cy5pbmRleCggY3VyICkgPiAtMSA6XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gRG9uJ3QgcGFzcyBub24tZWxlbWVudHMgdG8gU2l6emxlXFxuXFx0XFx0XFx0XFx0XFx0XFx0Y3VyLm5vZGVUeXBlID09PSAxICYmXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0alF1ZXJ5LmZpbmQubWF0Y2hlc1NlbGVjdG9yKCBjdXIsIHNlbGVjdG9ycyApICkgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0bWF0Y2hlZC5wdXNoKCBjdXIgKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFxuXFx0XFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBtYXRjaGVkLmxlbmd0aCA+IDEgPyBqUXVlcnkudW5pcXVlU29ydCggbWF0Y2hlZCApIDogbWF0Y2hlZCApO1xcblxcdH0sXFxuXFxuXFx0Ly8gRGV0ZXJtaW5lIHRoZSBwb3NpdGlvbiBvZiBhbiBlbGVtZW50IHdpdGhpbiB0aGUgc2V0XFxuXFx0aW5kZXg6IGZ1bmN0aW9uKCBlbGVtICkge1xcblxcblxcdFxcdC8vIE5vIGFyZ3VtZW50LCByZXR1cm4gaW5kZXggaW4gcGFyZW50XFxuXFx0XFx0aWYgKCAhZWxlbSApIHtcXG5cXHRcXHRcXHRyZXR1cm4gKCB0aGlzWyAwIF0gJiYgdGhpc1sgMCBdLnBhcmVudE5vZGUgKSA/IHRoaXMuZmlyc3QoKS5wcmV2QWxsKCkubGVuZ3RoIDogLTE7XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIEluZGV4IGluIHNlbGVjdG9yXFxuXFx0XFx0aWYgKCB0eXBlb2YgZWxlbSA9PT0gXFxcInN0cmluZ1xcXCIgKSB7XFxuXFx0XFx0XFx0cmV0dXJuIGluZGV4T2YuY2FsbCggalF1ZXJ5KCBlbGVtICksIHRoaXNbIDAgXSApO1xcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBMb2NhdGUgdGhlIHBvc2l0aW9uIG9mIHRoZSBkZXNpcmVkIGVsZW1lbnRcXG5cXHRcXHRyZXR1cm4gaW5kZXhPZi5jYWxsKCB0aGlzLFxcblxcblxcdFxcdFxcdC8vIElmIGl0IHJlY2VpdmVzIGEgalF1ZXJ5IG9iamVjdCwgdGhlIGZpcnN0IGVsZW1lbnQgaXMgdXNlZFxcblxcdFxcdFxcdGVsZW0uanF1ZXJ5ID8gZWxlbVsgMCBdIDogZWxlbVxcblxcdFxcdCk7XFxuXFx0fSxcXG5cXG5cXHRhZGQ6IGZ1bmN0aW9uKCBzZWxlY3RvciwgY29udGV4dCApIHtcXG5cXHRcXHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soXFxuXFx0XFx0XFx0alF1ZXJ5LnVuaXF1ZVNvcnQoXFxuXFx0XFx0XFx0XFx0alF1ZXJ5Lm1lcmdlKCB0aGlzLmdldCgpLCBqUXVlcnkoIHNlbGVjdG9yLCBjb250ZXh0ICkgKVxcblxcdFxcdFxcdClcXG5cXHRcXHQpO1xcblxcdH0sXFxuXFxuXFx0YWRkQmFjazogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xcblxcdFxcdHJldHVybiB0aGlzLmFkZCggc2VsZWN0b3IgPT0gbnVsbCA/XFxuXFx0XFx0XFx0dGhpcy5wcmV2T2JqZWN0IDogdGhpcy5wcmV2T2JqZWN0LmZpbHRlciggc2VsZWN0b3IgKVxcblxcdFxcdCk7XFxuXFx0fVxcbn0gKTtcXG5cXG5mdW5jdGlvbiBzaWJsaW5nKCBjdXIsIGRpciApIHtcXG5cXHR3aGlsZSAoICggY3VyID0gY3VyWyBkaXIgXSApICYmIGN1ci5ub2RlVHlwZSAhPT0gMSApIHt9XFxuXFx0cmV0dXJuIGN1cjtcXG59XFxuXFxualF1ZXJ5LmVhY2goIHtcXG5cXHRwYXJlbnQ6IGZ1bmN0aW9uKCBlbGVtICkge1xcblxcdFxcdHZhciBwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGU7XFxuXFx0XFx0cmV0dXJuIHBhcmVudCAmJiBwYXJlbnQubm9kZVR5cGUgIT09IDExID8gcGFyZW50IDogbnVsbDtcXG5cXHR9LFxcblxcdHBhcmVudHM6IGZ1bmN0aW9uKCBlbGVtICkge1xcblxcdFxcdHJldHVybiBkaXIoIGVsZW0sIFxcXCJwYXJlbnROb2RlXFxcIiApO1xcblxcdH0sXFxuXFx0cGFyZW50c1VudGlsOiBmdW5jdGlvbiggZWxlbSwgaSwgdW50aWwgKSB7XFxuXFx0XFx0cmV0dXJuIGRpciggZWxlbSwgXFxcInBhcmVudE5vZGVcXFwiLCB1bnRpbCApO1xcblxcdH0sXFxuXFx0bmV4dDogZnVuY3Rpb24oIGVsZW0gKSB7XFxuXFx0XFx0cmV0dXJuIHNpYmxpbmcoIGVsZW0sIFxcXCJuZXh0U2libGluZ1xcXCIgKTtcXG5cXHR9LFxcblxcdHByZXY6IGZ1bmN0aW9uKCBlbGVtICkge1xcblxcdFxcdHJldHVybiBzaWJsaW5nKCBlbGVtLCBcXFwicHJldmlvdXNTaWJsaW5nXFxcIiApO1xcblxcdH0sXFxuXFx0bmV4dEFsbDogZnVuY3Rpb24oIGVsZW0gKSB7XFxuXFx0XFx0cmV0dXJuIGRpciggZWxlbSwgXFxcIm5leHRTaWJsaW5nXFxcIiApO1xcblxcdH0sXFxuXFx0cHJldkFsbDogZnVuY3Rpb24oIGVsZW0gKSB7XFxuXFx0XFx0cmV0dXJuIGRpciggZWxlbSwgXFxcInByZXZpb3VzU2libGluZ1xcXCIgKTtcXG5cXHR9LFxcblxcdG5leHRVbnRpbDogZnVuY3Rpb24oIGVsZW0sIGksIHVudGlsICkge1xcblxcdFxcdHJldHVybiBkaXIoIGVsZW0sIFxcXCJuZXh0U2libGluZ1xcXCIsIHVudGlsICk7XFxuXFx0fSxcXG5cXHRwcmV2VW50aWw6IGZ1bmN0aW9uKCBlbGVtLCBpLCB1bnRpbCApIHtcXG5cXHRcXHRyZXR1cm4gZGlyKCBlbGVtLCBcXFwicHJldmlvdXNTaWJsaW5nXFxcIiwgdW50aWwgKTtcXG5cXHR9LFxcblxcdHNpYmxpbmdzOiBmdW5jdGlvbiggZWxlbSApIHtcXG5cXHRcXHRyZXR1cm4gc2libGluZ3MoICggZWxlbS5wYXJlbnROb2RlIHx8IHt9ICkuZmlyc3RDaGlsZCwgZWxlbSApO1xcblxcdH0sXFxuXFx0Y2hpbGRyZW46IGZ1bmN0aW9uKCBlbGVtICkge1xcblxcdFxcdHJldHVybiBzaWJsaW5ncyggZWxlbS5maXJzdENoaWxkICk7XFxuXFx0fSxcXG5cXHRjb250ZW50czogZnVuY3Rpb24oIGVsZW0gKSB7XFxuICAgICAgICBpZiAoIG5vZGVOYW1lKCBlbGVtLCBcXFwiaWZyYW1lXFxcIiApICkge1xcbiAgICAgICAgICAgIHJldHVybiBlbGVtLmNvbnRlbnREb2N1bWVudDtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIC8vIFN1cHBvcnQ6IElFIDkgLSAxMSBvbmx5LCBpT1MgNyBvbmx5LCBBbmRyb2lkIEJyb3dzZXIgPD00LjMgb25seVxcbiAgICAgICAgLy8gVHJlYXQgdGhlIHRlbXBsYXRlIGVsZW1lbnQgYXMgYSByZWd1bGFyIG9uZSBpbiBicm93c2VycyB0aGF0XFxuICAgICAgICAvLyBkb24ndCBzdXBwb3J0IGl0LlxcbiAgICAgICAgaWYgKCBub2RlTmFtZSggZWxlbSwgXFxcInRlbXBsYXRlXFxcIiApICkge1xcbiAgICAgICAgICAgIGVsZW0gPSBlbGVtLmNvbnRlbnQgfHwgZWxlbTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHJldHVybiBqUXVlcnkubWVyZ2UoIFtdLCBlbGVtLmNoaWxkTm9kZXMgKTtcXG5cXHR9XFxufSwgZnVuY3Rpb24oIG5hbWUsIGZuICkge1xcblxcdGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIHVudGlsLCBzZWxlY3RvciApIHtcXG5cXHRcXHR2YXIgbWF0Y2hlZCA9IGpRdWVyeS5tYXAoIHRoaXMsIGZuLCB1bnRpbCApO1xcblxcblxcdFxcdGlmICggbmFtZS5zbGljZSggLTUgKSAhPT0gXFxcIlVudGlsXFxcIiApIHtcXG5cXHRcXHRcXHRzZWxlY3RvciA9IHVudGlsO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRpZiAoIHNlbGVjdG9yICYmIHR5cGVvZiBzZWxlY3RvciA9PT0gXFxcInN0cmluZ1xcXCIgKSB7XFxuXFx0XFx0XFx0bWF0Y2hlZCA9IGpRdWVyeS5maWx0ZXIoIHNlbGVjdG9yLCBtYXRjaGVkICk7XFxuXFx0XFx0fVxcblxcblxcdFxcdGlmICggdGhpcy5sZW5ndGggPiAxICkge1xcblxcblxcdFxcdFxcdC8vIFJlbW92ZSBkdXBsaWNhdGVzXFxuXFx0XFx0XFx0aWYgKCAhZ3VhcmFudGVlZFVuaXF1ZVsgbmFtZSBdICkge1xcblxcdFxcdFxcdFxcdGpRdWVyeS51bmlxdWVTb3J0KCBtYXRjaGVkICk7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIFJldmVyc2Ugb3JkZXIgZm9yIHBhcmVudHMqIGFuZCBwcmV2LWRlcml2YXRpdmVzXFxuXFx0XFx0XFx0aWYgKCBycGFyZW50c3ByZXYudGVzdCggbmFtZSApICkge1xcblxcdFxcdFxcdFxcdG1hdGNoZWQucmV2ZXJzZSgpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFxuXFx0XFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBtYXRjaGVkICk7XFxuXFx0fTtcXG59ICk7XFxudmFyIHJub3RodG1sd2hpdGUgPSAoIC9bXlxcXFx4MjBcXFxcdFxcXFxyXFxcXG5cXFxcZl0rL2cgKTtcXG5cXG5cXG5cXG4vLyBDb252ZXJ0IFN0cmluZy1mb3JtYXR0ZWQgb3B0aW9ucyBpbnRvIE9iamVjdC1mb3JtYXR0ZWQgb25lc1xcbmZ1bmN0aW9uIGNyZWF0ZU9wdGlvbnMoIG9wdGlvbnMgKSB7XFxuXFx0dmFyIG9iamVjdCA9IHt9O1xcblxcdGpRdWVyeS5lYWNoKCBvcHRpb25zLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgW10sIGZ1bmN0aW9uKCBfLCBmbGFnICkge1xcblxcdFxcdG9iamVjdFsgZmxhZyBdID0gdHJ1ZTtcXG5cXHR9ICk7XFxuXFx0cmV0dXJuIG9iamVjdDtcXG59XFxuXFxuLypcXG4gKiBDcmVhdGUgYSBjYWxsYmFjayBsaXN0IHVzaW5nIHRoZSBmb2xsb3dpbmcgcGFyYW1ldGVyczpcXG4gKlxcbiAqXFx0b3B0aW9uczogYW4gb3B0aW9uYWwgbGlzdCBvZiBzcGFjZS1zZXBhcmF0ZWQgb3B0aW9ucyB0aGF0IHdpbGwgY2hhbmdlIGhvd1xcbiAqXFx0XFx0XFx0dGhlIGNhbGxiYWNrIGxpc3QgYmVoYXZlcyBvciBhIG1vcmUgdHJhZGl0aW9uYWwgb3B0aW9uIG9iamVjdFxcbiAqXFxuICogQnkgZGVmYXVsdCBhIGNhbGxiYWNrIGxpc3Qgd2lsbCBhY3QgbGlrZSBhbiBldmVudCBjYWxsYmFjayBsaXN0IGFuZCBjYW4gYmVcXG4gKiBcXFwiZmlyZWRcXFwiIG11bHRpcGxlIHRpbWVzLlxcbiAqXFxuICogUG9zc2libGUgb3B0aW9uczpcXG4gKlxcbiAqXFx0b25jZTpcXHRcXHRcXHR3aWxsIGVuc3VyZSB0aGUgY2FsbGJhY2sgbGlzdCBjYW4gb25seSBiZSBmaXJlZCBvbmNlIChsaWtlIGEgRGVmZXJyZWQpXFxuICpcXG4gKlxcdG1lbW9yeTpcXHRcXHRcXHR3aWxsIGtlZXAgdHJhY2sgb2YgcHJldmlvdXMgdmFsdWVzIGFuZCB3aWxsIGNhbGwgYW55IGNhbGxiYWNrIGFkZGVkXFxuICpcXHRcXHRcXHRcXHRcXHRhZnRlciB0aGUgbGlzdCBoYXMgYmVlbiBmaXJlZCByaWdodCBhd2F5IHdpdGggdGhlIGxhdGVzdCBcXFwibWVtb3JpemVkXFxcIlxcbiAqXFx0XFx0XFx0XFx0XFx0dmFsdWVzIChsaWtlIGEgRGVmZXJyZWQpXFxuICpcXG4gKlxcdHVuaXF1ZTpcXHRcXHRcXHR3aWxsIGVuc3VyZSBhIGNhbGxiYWNrIGNhbiBvbmx5IGJlIGFkZGVkIG9uY2UgKG5vIGR1cGxpY2F0ZSBpbiB0aGUgbGlzdClcXG4gKlxcbiAqXFx0c3RvcE9uRmFsc2U6XFx0aW50ZXJydXB0IGNhbGxpbmdzIHdoZW4gYSBjYWxsYmFjayByZXR1cm5zIGZhbHNlXFxuICpcXG4gKi9cXG5qUXVlcnkuQ2FsbGJhY2tzID0gZnVuY3Rpb24oIG9wdGlvbnMgKSB7XFxuXFxuXFx0Ly8gQ29udmVydCBvcHRpb25zIGZyb20gU3RyaW5nLWZvcm1hdHRlZCB0byBPYmplY3QtZm9ybWF0dGVkIGlmIG5lZWRlZFxcblxcdC8vICh3ZSBjaGVjayBpbiBjYWNoZSBmaXJzdClcXG5cXHRvcHRpb25zID0gdHlwZW9mIG9wdGlvbnMgPT09IFxcXCJzdHJpbmdcXFwiID9cXG5cXHRcXHRjcmVhdGVPcHRpb25zKCBvcHRpb25zICkgOlxcblxcdFxcdGpRdWVyeS5leHRlbmQoIHt9LCBvcHRpb25zICk7XFxuXFxuXFx0dmFyIC8vIEZsYWcgdG8ga25vdyBpZiBsaXN0IGlzIGN1cnJlbnRseSBmaXJpbmdcXG5cXHRcXHRmaXJpbmcsXFxuXFxuXFx0XFx0Ly8gTGFzdCBmaXJlIHZhbHVlIGZvciBub24tZm9yZ2V0dGFibGUgbGlzdHNcXG5cXHRcXHRtZW1vcnksXFxuXFxuXFx0XFx0Ly8gRmxhZyB0byBrbm93IGlmIGxpc3Qgd2FzIGFscmVhZHkgZmlyZWRcXG5cXHRcXHRmaXJlZCxcXG5cXG5cXHRcXHQvLyBGbGFnIHRvIHByZXZlbnQgZmlyaW5nXFxuXFx0XFx0bG9ja2VkLFxcblxcblxcdFxcdC8vIEFjdHVhbCBjYWxsYmFjayBsaXN0XFxuXFx0XFx0bGlzdCA9IFtdLFxcblxcblxcdFxcdC8vIFF1ZXVlIG9mIGV4ZWN1dGlvbiBkYXRhIGZvciByZXBlYXRhYmxlIGxpc3RzXFxuXFx0XFx0cXVldWUgPSBbXSxcXG5cXG5cXHRcXHQvLyBJbmRleCBvZiBjdXJyZW50bHkgZmlyaW5nIGNhbGxiYWNrIChtb2RpZmllZCBieSBhZGQvcmVtb3ZlIGFzIG5lZWRlZClcXG5cXHRcXHRmaXJpbmdJbmRleCA9IC0xLFxcblxcblxcdFxcdC8vIEZpcmUgY2FsbGJhY2tzXFxuXFx0XFx0ZmlyZSA9IGZ1bmN0aW9uKCkge1xcblxcblxcdFxcdFxcdC8vIEVuZm9yY2Ugc2luZ2xlLWZpcmluZ1xcblxcdFxcdFxcdGxvY2tlZCA9IGxvY2tlZCB8fCBvcHRpb25zLm9uY2U7XFxuXFxuXFx0XFx0XFx0Ly8gRXhlY3V0ZSBjYWxsYmFja3MgZm9yIGFsbCBwZW5kaW5nIGV4ZWN1dGlvbnMsXFxuXFx0XFx0XFx0Ly8gcmVzcGVjdGluZyBmaXJpbmdJbmRleCBvdmVycmlkZXMgYW5kIHJ1bnRpbWUgY2hhbmdlc1xcblxcdFxcdFxcdGZpcmVkID0gZmlyaW5nID0gdHJ1ZTtcXG5cXHRcXHRcXHRmb3IgKCA7IHF1ZXVlLmxlbmd0aDsgZmlyaW5nSW5kZXggPSAtMSApIHtcXG5cXHRcXHRcXHRcXHRtZW1vcnkgPSBxdWV1ZS5zaGlmdCgpO1xcblxcdFxcdFxcdFxcdHdoaWxlICggKytmaXJpbmdJbmRleCA8IGxpc3QubGVuZ3RoICkge1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIFJ1biBjYWxsYmFjayBhbmQgY2hlY2sgZm9yIGVhcmx5IHRlcm1pbmF0aW9uXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBsaXN0WyBmaXJpbmdJbmRleCBdLmFwcGx5KCBtZW1vcnlbIDAgXSwgbWVtb3J5WyAxIF0gKSA9PT0gZmFsc2UgJiZcXG5cXHRcXHRcXHRcXHRcXHRcXHRvcHRpb25zLnN0b3BPbkZhbHNlICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdC8vIEp1bXAgdG8gZW5kIGFuZCBmb3JnZXQgdGhlIGRhdGEgc28gLmFkZCBkb2Vzbid0IHJlLWZpcmVcXG5cXHRcXHRcXHRcXHRcXHRcXHRmaXJpbmdJbmRleCA9IGxpc3QubGVuZ3RoO1xcblxcdFxcdFxcdFxcdFxcdFxcdG1lbW9yeSA9IGZhbHNlO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIEZvcmdldCB0aGUgZGF0YSBpZiB3ZSdyZSBkb25lIHdpdGggaXRcXG5cXHRcXHRcXHRpZiAoICFvcHRpb25zLm1lbW9yeSApIHtcXG5cXHRcXHRcXHRcXHRtZW1vcnkgPSBmYWxzZTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0ZmlyaW5nID0gZmFsc2U7XFxuXFxuXFx0XFx0XFx0Ly8gQ2xlYW4gdXAgaWYgd2UncmUgZG9uZSBmaXJpbmcgZm9yIGdvb2RcXG5cXHRcXHRcXHRpZiAoIGxvY2tlZCApIHtcXG5cXG5cXHRcXHRcXHRcXHQvLyBLZWVwIGFuIGVtcHR5IGxpc3QgaWYgd2UgaGF2ZSBkYXRhIGZvciBmdXR1cmUgYWRkIGNhbGxzXFxuXFx0XFx0XFx0XFx0aWYgKCBtZW1vcnkgKSB7XFxuXFx0XFx0XFx0XFx0XFx0bGlzdCA9IFtdO1xcblxcblxcdFxcdFxcdFxcdC8vIE90aGVyd2lzZSwgdGhpcyBvYmplY3QgaXMgc3BlbnRcXG5cXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdGxpc3QgPSBcXFwiXFxcIjtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Ly8gQWN0dWFsIENhbGxiYWNrcyBvYmplY3RcXG5cXHRcXHRzZWxmID0ge1xcblxcblxcdFxcdFxcdC8vIEFkZCBhIGNhbGxiYWNrIG9yIGEgY29sbGVjdGlvbiBvZiBjYWxsYmFja3MgdG8gdGhlIGxpc3RcXG5cXHRcXHRcXHRhZGQ6IGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdFxcdGlmICggbGlzdCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBJZiB3ZSBoYXZlIG1lbW9yeSBmcm9tIGEgcGFzdCBydW4sIHdlIHNob3VsZCBmaXJlIGFmdGVyIGFkZGluZ1xcblxcdFxcdFxcdFxcdFxcdGlmICggbWVtb3J5ICYmICFmaXJpbmcgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0ZmlyaW5nSW5kZXggPSBsaXN0Lmxlbmd0aCAtIDE7XFxuXFx0XFx0XFx0XFx0XFx0XFx0cXVldWUucHVzaCggbWVtb3J5ICk7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdCggZnVuY3Rpb24gYWRkKCBhcmdzICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGpRdWVyeS5lYWNoKCBhcmdzLCBmdW5jdGlvbiggXywgYXJnICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmICggaXNGdW5jdGlvbiggYXJnICkgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKCAhb3B0aW9ucy51bmlxdWUgfHwgIXNlbGYuaGFzKCBhcmcgKSApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRsaXN0LnB1c2goIGFyZyApO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9IGVsc2UgaWYgKCBhcmcgJiYgYXJnLmxlbmd0aCAmJiB0b1R5cGUoIGFyZyApICE9PSBcXFwic3RyaW5nXFxcIiApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBJbnNwZWN0IHJlY3Vyc2l2ZWx5XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0YWRkKCBhcmcgKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0fSApO1xcblxcdFxcdFxcdFxcdFxcdH0gKSggYXJndW1lbnRzICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBtZW1vcnkgJiYgIWZpcmluZyApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRmaXJlKCk7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXHRcXHRcXHR9LFxcblxcblxcdFxcdFxcdC8vIFJlbW92ZSBhIGNhbGxiYWNrIGZyb20gdGhlIGxpc3RcXG5cXHRcXHRcXHRyZW1vdmU6IGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdFxcdGpRdWVyeS5lYWNoKCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBfLCBhcmcgKSB7XFxuXFx0XFx0XFx0XFx0XFx0dmFyIGluZGV4O1xcblxcdFxcdFxcdFxcdFxcdHdoaWxlICggKCBpbmRleCA9IGpRdWVyeS5pbkFycmF5KCBhcmcsIGxpc3QsIGluZGV4ICkgKSA+IC0xICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGxpc3Quc3BsaWNlKCBpbmRleCwgMSApO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdC8vIEhhbmRsZSBmaXJpbmcgaW5kZXhlc1xcblxcdFxcdFxcdFxcdFxcdFxcdGlmICggaW5kZXggPD0gZmlyaW5nSW5kZXggKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0ZmlyaW5nSW5kZXgtLTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH0gKTtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXHRcXHRcXHR9LFxcblxcblxcdFxcdFxcdC8vIENoZWNrIGlmIGEgZ2l2ZW4gY2FsbGJhY2sgaXMgaW4gdGhlIGxpc3QuXFxuXFx0XFx0XFx0Ly8gSWYgbm8gYXJndW1lbnQgaXMgZ2l2ZW4sIHJldHVybiB3aGV0aGVyIG9yIG5vdCBsaXN0IGhhcyBjYWxsYmFja3MgYXR0YWNoZWQuXFxuXFx0XFx0XFx0aGFzOiBmdW5jdGlvbiggZm4gKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIGZuID9cXG5cXHRcXHRcXHRcXHRcXHRqUXVlcnkuaW5BcnJheSggZm4sIGxpc3QgKSA+IC0xIDpcXG5cXHRcXHRcXHRcXHRcXHRsaXN0Lmxlbmd0aCA+IDA7XFxuXFx0XFx0XFx0fSxcXG5cXG5cXHRcXHRcXHQvLyBSZW1vdmUgYWxsIGNhbGxiYWNrcyBmcm9tIHRoZSBsaXN0XFxuXFx0XFx0XFx0ZW1wdHk6IGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdFxcdGlmICggbGlzdCApIHtcXG5cXHRcXHRcXHRcXHRcXHRsaXN0ID0gW107XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcdFxcdFxcdH0sXFxuXFxuXFx0XFx0XFx0Ly8gRGlzYWJsZSAuZmlyZSBhbmQgLmFkZFxcblxcdFxcdFxcdC8vIEFib3J0IGFueSBjdXJyZW50L3BlbmRpbmcgZXhlY3V0aW9uc1xcblxcdFxcdFxcdC8vIENsZWFyIGFsbCBjYWxsYmFja3MgYW5kIHZhbHVlc1xcblxcdFxcdFxcdGRpc2FibGU6IGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdFxcdGxvY2tlZCA9IHF1ZXVlID0gW107XFxuXFx0XFx0XFx0XFx0bGlzdCA9IG1lbW9yeSA9IFxcXCJcXFwiO1xcblxcdFxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcdFxcdFxcdH0sXFxuXFx0XFx0XFx0ZGlzYWJsZWQ6IGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdFxcdHJldHVybiAhbGlzdDtcXG5cXHRcXHRcXHR9LFxcblxcblxcdFxcdFxcdC8vIERpc2FibGUgLmZpcmVcXG5cXHRcXHRcXHQvLyBBbHNvIGRpc2FibGUgLmFkZCB1bmxlc3Mgd2UgaGF2ZSBtZW1vcnkgKHNpbmNlIGl0IHdvdWxkIGhhdmUgbm8gZWZmZWN0KVxcblxcdFxcdFxcdC8vIEFib3J0IGFueSBwZW5kaW5nIGV4ZWN1dGlvbnNcXG5cXHRcXHRcXHRsb2NrOiBmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHRcXHRsb2NrZWQgPSBxdWV1ZSA9IFtdO1xcblxcdFxcdFxcdFxcdGlmICggIW1lbW9yeSAmJiAhZmlyaW5nICkge1xcblxcdFxcdFxcdFxcdFxcdGxpc3QgPSBtZW1vcnkgPSBcXFwiXFxcIjtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFx0XFx0XFx0fSxcXG5cXHRcXHRcXHRsb2NrZWQ6IGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdFxcdHJldHVybiAhIWxvY2tlZDtcXG5cXHRcXHRcXHR9LFxcblxcblxcdFxcdFxcdC8vIENhbGwgYWxsIGNhbGxiYWNrcyB3aXRoIHRoZSBnaXZlbiBjb250ZXh0IGFuZCBhcmd1bWVudHNcXG5cXHRcXHRcXHRmaXJlV2l0aDogZnVuY3Rpb24oIGNvbnRleHQsIGFyZ3MgKSB7XFxuXFx0XFx0XFx0XFx0aWYgKCAhbG9ja2VkICkge1xcblxcdFxcdFxcdFxcdFxcdGFyZ3MgPSBhcmdzIHx8IFtdO1xcblxcdFxcdFxcdFxcdFxcdGFyZ3MgPSBbIGNvbnRleHQsIGFyZ3Muc2xpY2UgPyBhcmdzLnNsaWNlKCkgOiBhcmdzIF07XFxuXFx0XFx0XFx0XFx0XFx0cXVldWUucHVzaCggYXJncyApO1xcblxcdFxcdFxcdFxcdFxcdGlmICggIWZpcmluZyApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRmaXJlKCk7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXHRcXHRcXHR9LFxcblxcblxcdFxcdFxcdC8vIENhbGwgYWxsIHRoZSBjYWxsYmFja3Mgd2l0aCB0aGUgZ2l2ZW4gYXJndW1lbnRzXFxuXFx0XFx0XFx0ZmlyZTogZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0XFx0c2VsZi5maXJlV2l0aCggdGhpcywgYXJndW1lbnRzICk7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFx0XFx0XFx0fSxcXG5cXG5cXHRcXHRcXHQvLyBUbyBrbm93IGlmIHRoZSBjYWxsYmFja3MgaGF2ZSBhbHJlYWR5IGJlZW4gY2FsbGVkIGF0IGxlYXN0IG9uY2VcXG5cXHRcXHRcXHRmaXJlZDogZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuICEhZmlyZWQ7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH07XFxuXFxuXFx0cmV0dXJuIHNlbGY7XFxufTtcXG5cXG5cXG5mdW5jdGlvbiBJZGVudGl0eSggdiApIHtcXG5cXHRyZXR1cm4gdjtcXG59XFxuZnVuY3Rpb24gVGhyb3dlciggZXggKSB7XFxuXFx0dGhyb3cgZXg7XFxufVxcblxcbmZ1bmN0aW9uIGFkb3B0VmFsdWUoIHZhbHVlLCByZXNvbHZlLCByZWplY3QsIG5vVmFsdWUgKSB7XFxuXFx0dmFyIG1ldGhvZDtcXG5cXG5cXHR0cnkge1xcblxcblxcdFxcdC8vIENoZWNrIGZvciBwcm9taXNlIGFzcGVjdCBmaXJzdCB0byBwcml2aWxlZ2Ugc3luY2hyb25vdXMgYmVoYXZpb3JcXG5cXHRcXHRpZiAoIHZhbHVlICYmIGlzRnVuY3Rpb24oICggbWV0aG9kID0gdmFsdWUucHJvbWlzZSApICkgKSB7XFxuXFx0XFx0XFx0bWV0aG9kLmNhbGwoIHZhbHVlICkuZG9uZSggcmVzb2x2ZSApLmZhaWwoIHJlamVjdCApO1xcblxcblxcdFxcdC8vIE90aGVyIHRoZW5hYmxlc1xcblxcdFxcdH0gZWxzZSBpZiAoIHZhbHVlICYmIGlzRnVuY3Rpb24oICggbWV0aG9kID0gdmFsdWUudGhlbiApICkgKSB7XFxuXFx0XFx0XFx0bWV0aG9kLmNhbGwoIHZhbHVlLCByZXNvbHZlLCByZWplY3QgKTtcXG5cXG5cXHRcXHQvLyBPdGhlciBub24tdGhlbmFibGVzXFxuXFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHQvLyBDb250cm9sIGByZXNvbHZlYCBhcmd1bWVudHMgYnkgbGV0dGluZyBBcnJheSNzbGljZSBjYXN0IGJvb2xlYW4gYG5vVmFsdWVgIHRvIGludGVnZXI6XFxuXFx0XFx0XFx0Ly8gKiBmYWxzZTogWyB2YWx1ZSBdLnNsaWNlKCAwICkgPT4gcmVzb2x2ZSggdmFsdWUgKVxcblxcdFxcdFxcdC8vICogdHJ1ZTogWyB2YWx1ZSBdLnNsaWNlKCAxICkgPT4gcmVzb2x2ZSgpXFxuXFx0XFx0XFx0cmVzb2x2ZS5hcHBseSggdW5kZWZpbmVkLCBbIHZhbHVlIF0uc2xpY2UoIG5vVmFsdWUgKSApO1xcblxcdFxcdH1cXG5cXG5cXHQvLyBGb3IgUHJvbWlzZXMvQSssIGNvbnZlcnQgZXhjZXB0aW9ucyBpbnRvIHJlamVjdGlvbnNcXG5cXHQvLyBTaW5jZSBqUXVlcnkud2hlbiBkb2Vzbid0IHVud3JhcCB0aGVuYWJsZXMsIHdlIGNhbiBza2lwIHRoZSBleHRyYSBjaGVja3MgYXBwZWFyaW5nIGluXFxuXFx0Ly8gRGVmZXJyZWQjdGhlbiB0byBjb25kaXRpb25hbGx5IHN1cHByZXNzIHJlamVjdGlvbi5cXG5cXHR9IGNhdGNoICggdmFsdWUgKSB7XFxuXFxuXFx0XFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA0LjAgb25seVxcblxcdFxcdC8vIFN0cmljdCBtb2RlIGZ1bmN0aW9ucyBpbnZva2VkIHdpdGhvdXQgLmNhbGwvLmFwcGx5IGdldCBnbG9iYWwtb2JqZWN0IGNvbnRleHRcXG5cXHRcXHRyZWplY3QuYXBwbHkoIHVuZGVmaW5lZCwgWyB2YWx1ZSBdICk7XFxuXFx0fVxcbn1cXG5cXG5qUXVlcnkuZXh0ZW5kKCB7XFxuXFxuXFx0RGVmZXJyZWQ6IGZ1bmN0aW9uKCBmdW5jICkge1xcblxcdFxcdHZhciB0dXBsZXMgPSBbXFxuXFxuXFx0XFx0XFx0XFx0Ly8gYWN0aW9uLCBhZGQgbGlzdGVuZXIsIGNhbGxiYWNrcyxcXG5cXHRcXHRcXHRcXHQvLyAuLi4gLnRoZW4gaGFuZGxlcnMsIGFyZ3VtZW50IGluZGV4LCBbZmluYWwgc3RhdGVdXFxuXFx0XFx0XFx0XFx0WyBcXFwibm90aWZ5XFxcIiwgXFxcInByb2dyZXNzXFxcIiwgalF1ZXJ5LkNhbGxiYWNrcyggXFxcIm1lbW9yeVxcXCIgKSxcXG5cXHRcXHRcXHRcXHRcXHRqUXVlcnkuQ2FsbGJhY2tzKCBcXFwibWVtb3J5XFxcIiApLCAyIF0sXFxuXFx0XFx0XFx0XFx0WyBcXFwicmVzb2x2ZVxcXCIsIFxcXCJkb25lXFxcIiwgalF1ZXJ5LkNhbGxiYWNrcyggXFxcIm9uY2UgbWVtb3J5XFxcIiApLFxcblxcdFxcdFxcdFxcdFxcdGpRdWVyeS5DYWxsYmFja3MoIFxcXCJvbmNlIG1lbW9yeVxcXCIgKSwgMCwgXFxcInJlc29sdmVkXFxcIiBdLFxcblxcdFxcdFxcdFxcdFsgXFxcInJlamVjdFxcXCIsIFxcXCJmYWlsXFxcIiwgalF1ZXJ5LkNhbGxiYWNrcyggXFxcIm9uY2UgbWVtb3J5XFxcIiApLFxcblxcdFxcdFxcdFxcdFxcdGpRdWVyeS5DYWxsYmFja3MoIFxcXCJvbmNlIG1lbW9yeVxcXCIgKSwgMSwgXFxcInJlamVjdGVkXFxcIiBdXFxuXFx0XFx0XFx0XSxcXG5cXHRcXHRcXHRzdGF0ZSA9IFxcXCJwZW5kaW5nXFxcIixcXG5cXHRcXHRcXHRwcm9taXNlID0ge1xcblxcdFxcdFxcdFxcdHN0YXRlOiBmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gc3RhdGU7XFxuXFx0XFx0XFx0XFx0fSxcXG5cXHRcXHRcXHRcXHRhbHdheXM6IGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdFxcdFxcdGRlZmVycmVkLmRvbmUoIGFyZ3VtZW50cyApLmZhaWwoIGFyZ3VtZW50cyApO1xcblxcdFxcdFxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcdFxcdFxcdFxcdH0sXFxuXFx0XFx0XFx0XFx0XFxcImNhdGNoXFxcIjogZnVuY3Rpb24oIGZuICkge1xcblxcdFxcdFxcdFxcdFxcdHJldHVybiBwcm9taXNlLnRoZW4oIG51bGwsIGZuICk7XFxuXFx0XFx0XFx0XFx0fSxcXG5cXG5cXHRcXHRcXHRcXHQvLyBLZWVwIHBpcGUgZm9yIGJhY2stY29tcGF0XFxuXFx0XFx0XFx0XFx0cGlwZTogZnVuY3Rpb24oIC8qIGZuRG9uZSwgZm5GYWlsLCBmblByb2dyZXNzICovICkge1xcblxcdFxcdFxcdFxcdFxcdHZhciBmbnMgPSBhcmd1bWVudHM7XFxuXFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIGpRdWVyeS5EZWZlcnJlZCggZnVuY3Rpb24oIG5ld0RlZmVyICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGpRdWVyeS5lYWNoKCB0dXBsZXMsIGZ1bmN0aW9uKCBpLCB0dXBsZSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBNYXAgdHVwbGVzIChwcm9ncmVzcywgZG9uZSwgZmFpbCkgdG8gYXJndW1lbnRzIChkb25lLCBmYWlsLCBwcm9ncmVzcylcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR2YXIgZm4gPSBpc0Z1bmN0aW9uKCBmbnNbIHR1cGxlWyA0IF0gXSApICYmIGZuc1sgdHVwbGVbIDQgXSBdO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIGRlZmVycmVkLnByb2dyZXNzKGZ1bmN0aW9uKCkgeyBiaW5kIHRvIG5ld0RlZmVyIG9yIG5ld0RlZmVyLm5vdGlmeSB9KVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIGRlZmVycmVkLmRvbmUoZnVuY3Rpb24oKSB7IGJpbmQgdG8gbmV3RGVmZXIgb3IgbmV3RGVmZXIucmVzb2x2ZSB9KVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIGRlZmVycmVkLmZhaWwoZnVuY3Rpb24oKSB7IGJpbmQgdG8gbmV3RGVmZXIgb3IgbmV3RGVmZXIucmVqZWN0IH0pXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0ZGVmZXJyZWRbIHR1cGxlWyAxIF0gXSggZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0dmFyIHJldHVybmVkID0gZm4gJiYgZm4uYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmICggcmV0dXJuZWQgJiYgaXNGdW5jdGlvbiggcmV0dXJuZWQucHJvbWlzZSApICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHJldHVybmVkLnByb21pc2UoKVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdC5wcm9ncmVzcyggbmV3RGVmZXIubm90aWZ5IClcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQuZG9uZSggbmV3RGVmZXIucmVzb2x2ZSApXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0LmZhaWwoIG5ld0RlZmVyLnJlamVjdCApO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0bmV3RGVmZXJbIHR1cGxlWyAwIF0gKyBcXFwiV2l0aFxcXCIgXShcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR0aGlzLFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGZuID8gWyByZXR1cm5lZCBdIDogYXJndW1lbnRzXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0KTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fSApO1xcblxcdFxcdFxcdFxcdFxcdFxcdH0gKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRmbnMgPSBudWxsO1xcblxcdFxcdFxcdFxcdFxcdH0gKS5wcm9taXNlKCk7XFxuXFx0XFx0XFx0XFx0fSxcXG5cXHRcXHRcXHRcXHR0aGVuOiBmdW5jdGlvbiggb25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQsIG9uUHJvZ3Jlc3MgKSB7XFxuXFx0XFx0XFx0XFx0XFx0dmFyIG1heERlcHRoID0gMDtcXG5cXHRcXHRcXHRcXHRcXHRmdW5jdGlvbiByZXNvbHZlKCBkZXB0aCwgZGVmZXJyZWQsIGhhbmRsZXIsIHNwZWNpYWwgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHZhciB0aGF0ID0gdGhpcyxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRhcmdzID0gYXJndW1lbnRzLFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdG1pZ2h0VGhyb3cgPSBmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR2YXIgcmV0dXJuZWQsIHRoZW47XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gU3VwcG9ydDogUHJvbWlzZXMvQSsgc2VjdGlvbiAyLjMuMy4zLjNcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC01OVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIElnbm9yZSBkb3VibGUtcmVzb2x1dGlvbiBhdHRlbXB0c1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmICggZGVwdGggPCBtYXhEZXB0aCApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm47XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHJldHVybmVkID0gaGFuZGxlci5hcHBseSggdGhhdCwgYXJncyApO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb24gMi4zLjFcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC00OFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmICggcmV0dXJuZWQgPT09IGRlZmVycmVkLnByb21pc2UoKSApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR0aHJvdyBuZXcgVHlwZUVycm9yKCBcXFwiVGhlbmFibGUgc2VsZi1yZXNvbHV0aW9uXFxcIiApO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBTdXBwb3J0OiBQcm9taXNlcy9BKyBzZWN0aW9ucyAyLjMuMy4xLCAzLjVcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC01NFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTc1XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gUmV0cmlldmUgYHRoZW5gIG9ubHkgb25jZVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHRoZW4gPSByZXR1cm5lZCAmJlxcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb24gMi4zLjRcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC02NFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIE9ubHkgY2hlY2sgb2JqZWN0cyBhbmQgZnVuY3Rpb25zIGZvciB0aGVuYWJpbGl0eVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdCggdHlwZW9mIHJldHVybmVkID09PSBcXFwib2JqZWN0XFxcIiB8fFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHR5cGVvZiByZXR1cm5lZCA9PT0gXFxcImZ1bmN0aW9uXFxcIiApICYmXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuZWQudGhlbjtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBIYW5kbGUgYSByZXR1cm5lZCB0aGVuYWJsZVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmICggaXNGdW5jdGlvbiggdGhlbiApICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIFNwZWNpYWwgcHJvY2Vzc29ycyAobm90aWZ5KSBqdXN0IHdhaXQgZm9yIHJlc29sdXRpb25cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoIHNwZWNpYWwgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0dGhlbi5jYWxsKFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHJldHVybmVkLFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHJlc29sdmUoIG1heERlcHRoLCBkZWZlcnJlZCwgSWRlbnRpdHksIHNwZWNpYWwgKSxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRyZXNvbHZlKCBtYXhEZXB0aCwgZGVmZXJyZWQsIFRocm93ZXIsIHNwZWNpYWwgKVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdCk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gTm9ybWFsIHByb2Nlc3NvcnMgKHJlc29sdmUpIGFsc28gaG9vayBpbnRvIHByb2dyZXNzXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyAuLi5hbmQgZGlzcmVnYXJkIG9sZGVyIHJlc29sdXRpb24gdmFsdWVzXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0bWF4RGVwdGgrKztcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR0aGVuLmNhbGwoXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuZWQsXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0cmVzb2x2ZSggbWF4RGVwdGgsIGRlZmVycmVkLCBJZGVudGl0eSwgc3BlY2lhbCApLFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHJlc29sdmUoIG1heERlcHRoLCBkZWZlcnJlZCwgVGhyb3dlciwgc3BlY2lhbCApLFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHJlc29sdmUoIG1heERlcHRoLCBkZWZlcnJlZCwgSWRlbnRpdHksXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ZGVmZXJyZWQubm90aWZ5V2l0aCApXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0KTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gSGFuZGxlIGFsbCBvdGhlciByZXR1cm5lZCB2YWx1ZXNcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIE9ubHkgc3Vic3RpdHV0ZSBoYW5kbGVycyBwYXNzIG9uIGNvbnRleHRcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBhbmQgbXVsdGlwbGUgdmFsdWVzIChub24tc3BlYyBiZWhhdmlvcilcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoIGhhbmRsZXIgIT09IElkZW50aXR5ICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHRoYXQgPSB1bmRlZmluZWQ7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0YXJncyA9IFsgcmV0dXJuZWQgXTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gUHJvY2VzcyB0aGUgdmFsdWUocylcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBEZWZhdWx0IHByb2Nlc3MgaXMgcmVzb2x2ZVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdCggc3BlY2lhbCB8fCBkZWZlcnJlZC5yZXNvbHZlV2l0aCApKCB0aGF0LCBhcmdzICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdH0sXFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gT25seSBub3JtYWwgcHJvY2Vzc29ycyAocmVzb2x2ZSkgY2F0Y2ggYW5kIHJlamVjdCBleGNlcHRpb25zXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0cHJvY2VzcyA9IHNwZWNpYWwgP1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdG1pZ2h0VGhyb3cgOlxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHRyeSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0bWlnaHRUaHJvdygpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdH0gY2F0Y2ggKCBlICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmICggalF1ZXJ5LkRlZmVycmVkLmV4Y2VwdGlvbkhvb2sgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0alF1ZXJ5LkRlZmVycmVkLmV4Y2VwdGlvbkhvb2soIGUsXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0cHJvY2Vzcy5zdGFja1RyYWNlICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb24gMi4zLjMuMy40LjFcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC02MVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIElnbm9yZSBwb3N0LXJlc29sdXRpb24gZXhjZXB0aW9uc1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmICggZGVwdGggKyAxID49IG1heERlcHRoICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIE9ubHkgc3Vic3RpdHV0ZSBoYW5kbGVycyBwYXNzIG9uIGNvbnRleHRcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBhbmQgbXVsdGlwbGUgdmFsdWVzIChub24tc3BlYyBiZWhhdmlvcilcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoIGhhbmRsZXIgIT09IFRocm93ZXIgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0dGhhdCA9IHVuZGVmaW5lZDtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRhcmdzID0gWyBlIF07XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGRlZmVycmVkLnJlamVjdFdpdGgoIHRoYXQsIGFyZ3MgKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdH07XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gU3VwcG9ydDogUHJvbWlzZXMvQSsgc2VjdGlvbiAyLjMuMy4zLjFcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC01N1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIFJlLXJlc29sdmUgcHJvbWlzZXMgaW1tZWRpYXRlbHkgdG8gZG9kZ2UgZmFsc2UgcmVqZWN0aW9uIGZyb21cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBzdWJzZXF1ZW50IGVycm9yc1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmICggZGVwdGggKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0cHJvY2VzcygpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gQ2FsbCBhbiBvcHRpb25hbCBob29rIHRvIHJlY29yZCB0aGUgc3RhY2ssIGluIGNhc2Ugb2YgZXhjZXB0aW9uXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gc2luY2UgaXQncyBvdGhlcndpc2UgbG9zdCB3aGVuIGV4ZWN1dGlvbiBnb2VzIGFzeW5jXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBqUXVlcnkuRGVmZXJyZWQuZ2V0U3RhY2tIb29rICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHByb2Nlc3Muc3RhY2tUcmFjZSA9IGpRdWVyeS5EZWZlcnJlZC5nZXRTdGFja0hvb2soKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0d2luZG93LnNldFRpbWVvdXQoIHByb2Nlc3MgKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0fTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIGpRdWVyeS5EZWZlcnJlZCggZnVuY3Rpb24oIG5ld0RlZmVyICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdC8vIHByb2dyZXNzX2hhbmRsZXJzLmFkZCggLi4uIClcXG5cXHRcXHRcXHRcXHRcXHRcXHR0dXBsZXNbIDAgXVsgMyBdLmFkZChcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRyZXNvbHZlKFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdDAsXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0bmV3RGVmZXIsXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0aXNGdW5jdGlvbiggb25Qcm9ncmVzcyApID9cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRvblByb2dyZXNzIDpcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRJZGVudGl0eSxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRuZXdEZWZlci5ub3RpZnlXaXRoXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0KVxcblxcdFxcdFxcdFxcdFxcdFxcdCk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gZnVsZmlsbGVkX2hhbmRsZXJzLmFkZCggLi4uIClcXG5cXHRcXHRcXHRcXHRcXHRcXHR0dXBsZXNbIDEgXVsgMyBdLmFkZChcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRyZXNvbHZlKFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdDAsXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0bmV3RGVmZXIsXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0aXNGdW5jdGlvbiggb25GdWxmaWxsZWQgKSA/XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0b25GdWxmaWxsZWQgOlxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdElkZW50aXR5XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0KVxcblxcdFxcdFxcdFxcdFxcdFxcdCk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gcmVqZWN0ZWRfaGFuZGxlcnMuYWRkKCAuLi4gKVxcblxcdFxcdFxcdFxcdFxcdFxcdHR1cGxlc1sgMiBdWyAzIF0uYWRkKFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHJlc29sdmUoXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0MCxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRuZXdEZWZlcixcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRpc0Z1bmN0aW9uKCBvblJlamVjdGVkICkgP1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdG9uUmVqZWN0ZWQgOlxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFRocm93ZXJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQpXFxuXFx0XFx0XFx0XFx0XFx0XFx0KTtcXG5cXHRcXHRcXHRcXHRcXHR9ICkucHJvbWlzZSgpO1xcblxcdFxcdFxcdFxcdH0sXFxuXFxuXFx0XFx0XFx0XFx0Ly8gR2V0IGEgcHJvbWlzZSBmb3IgdGhpcyBkZWZlcnJlZFxcblxcdFxcdFxcdFxcdC8vIElmIG9iaiBpcyBwcm92aWRlZCwgdGhlIHByb21pc2UgYXNwZWN0IGlzIGFkZGVkIHRvIHRoZSBvYmplY3RcXG5cXHRcXHRcXHRcXHRwcm9taXNlOiBmdW5jdGlvbiggb2JqICkge1xcblxcdFxcdFxcdFxcdFxcdHJldHVybiBvYmogIT0gbnVsbCA/IGpRdWVyeS5leHRlbmQoIG9iaiwgcHJvbWlzZSApIDogcHJvbWlzZTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fSxcXG5cXHRcXHRcXHRkZWZlcnJlZCA9IHt9O1xcblxcblxcdFxcdC8vIEFkZCBsaXN0LXNwZWNpZmljIG1ldGhvZHNcXG5cXHRcXHRqUXVlcnkuZWFjaCggdHVwbGVzLCBmdW5jdGlvbiggaSwgdHVwbGUgKSB7XFxuXFx0XFx0XFx0dmFyIGxpc3QgPSB0dXBsZVsgMiBdLFxcblxcdFxcdFxcdFxcdHN0YXRlU3RyaW5nID0gdHVwbGVbIDUgXTtcXG5cXG5cXHRcXHRcXHQvLyBwcm9taXNlLnByb2dyZXNzID0gbGlzdC5hZGRcXG5cXHRcXHRcXHQvLyBwcm9taXNlLmRvbmUgPSBsaXN0LmFkZFxcblxcdFxcdFxcdC8vIHByb21pc2UuZmFpbCA9IGxpc3QuYWRkXFxuXFx0XFx0XFx0cHJvbWlzZVsgdHVwbGVbIDEgXSBdID0gbGlzdC5hZGQ7XFxuXFxuXFx0XFx0XFx0Ly8gSGFuZGxlIHN0YXRlXFxuXFx0XFx0XFx0aWYgKCBzdGF0ZVN0cmluZyApIHtcXG5cXHRcXHRcXHRcXHRsaXN0LmFkZChcXG5cXHRcXHRcXHRcXHRcXHRmdW5jdGlvbigpIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBzdGF0ZSA9IFxcXCJyZXNvbHZlZFxcXCIgKGkuZS4sIGZ1bGZpbGxlZClcXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBzdGF0ZSA9IFxcXCJyZWplY3RlZFxcXCJcXG5cXHRcXHRcXHRcXHRcXHRcXHRzdGF0ZSA9IHN0YXRlU3RyaW5nO1xcblxcdFxcdFxcdFxcdFxcdH0sXFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gcmVqZWN0ZWRfY2FsbGJhY2tzLmRpc2FibGVcXG5cXHRcXHRcXHRcXHRcXHQvLyBmdWxmaWxsZWRfY2FsbGJhY2tzLmRpc2FibGVcXG5cXHRcXHRcXHRcXHRcXHR0dXBsZXNbIDMgLSBpIF1bIDIgXS5kaXNhYmxlLFxcblxcblxcdFxcdFxcdFxcdFxcdC8vIHJlamVjdGVkX2hhbmRsZXJzLmRpc2FibGVcXG5cXHRcXHRcXHRcXHRcXHQvLyBmdWxmaWxsZWRfaGFuZGxlcnMuZGlzYWJsZVxcblxcdFxcdFxcdFxcdFxcdHR1cGxlc1sgMyAtIGkgXVsgMyBdLmRpc2FibGUsXFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gcHJvZ3Jlc3NfY2FsbGJhY2tzLmxvY2tcXG5cXHRcXHRcXHRcXHRcXHR0dXBsZXNbIDAgXVsgMiBdLmxvY2ssXFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gcHJvZ3Jlc3NfaGFuZGxlcnMubG9ja1xcblxcdFxcdFxcdFxcdFxcdHR1cGxlc1sgMCBdWyAzIF0ubG9ja1xcblxcdFxcdFxcdFxcdCk7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIHByb2dyZXNzX2hhbmRsZXJzLmZpcmVcXG5cXHRcXHRcXHQvLyBmdWxmaWxsZWRfaGFuZGxlcnMuZmlyZVxcblxcdFxcdFxcdC8vIHJlamVjdGVkX2hhbmRsZXJzLmZpcmVcXG5cXHRcXHRcXHRsaXN0LmFkZCggdHVwbGVbIDMgXS5maXJlICk7XFxuXFxuXFx0XFx0XFx0Ly8gZGVmZXJyZWQubm90aWZ5ID0gZnVuY3Rpb24oKSB7IGRlZmVycmVkLm5vdGlmeVdpdGgoLi4uKSB9XFxuXFx0XFx0XFx0Ly8gZGVmZXJyZWQucmVzb2x2ZSA9IGZ1bmN0aW9uKCkgeyBkZWZlcnJlZC5yZXNvbHZlV2l0aCguLi4pIH1cXG5cXHRcXHRcXHQvLyBkZWZlcnJlZC5yZWplY3QgPSBmdW5jdGlvbigpIHsgZGVmZXJyZWQucmVqZWN0V2l0aCguLi4pIH1cXG5cXHRcXHRcXHRkZWZlcnJlZFsgdHVwbGVbIDAgXSBdID0gZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0XFx0ZGVmZXJyZWRbIHR1cGxlWyAwIF0gKyBcXFwiV2l0aFxcXCIgXSggdGhpcyA9PT0gZGVmZXJyZWQgPyB1bmRlZmluZWQgOiB0aGlzLCBhcmd1bWVudHMgKTtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXHRcXHRcXHR9O1xcblxcblxcdFxcdFxcdC8vIGRlZmVycmVkLm5vdGlmeVdpdGggPSBsaXN0LmZpcmVXaXRoXFxuXFx0XFx0XFx0Ly8gZGVmZXJyZWQucmVzb2x2ZVdpdGggPSBsaXN0LmZpcmVXaXRoXFxuXFx0XFx0XFx0Ly8gZGVmZXJyZWQucmVqZWN0V2l0aCA9IGxpc3QuZmlyZVdpdGhcXG5cXHRcXHRcXHRkZWZlcnJlZFsgdHVwbGVbIDAgXSArIFxcXCJXaXRoXFxcIiBdID0gbGlzdC5maXJlV2l0aDtcXG5cXHRcXHR9ICk7XFxuXFxuXFx0XFx0Ly8gTWFrZSB0aGUgZGVmZXJyZWQgYSBwcm9taXNlXFxuXFx0XFx0cHJvbWlzZS5wcm9taXNlKCBkZWZlcnJlZCApO1xcblxcblxcdFxcdC8vIENhbGwgZ2l2ZW4gZnVuYyBpZiBhbnlcXG5cXHRcXHRpZiAoIGZ1bmMgKSB7XFxuXFx0XFx0XFx0ZnVuYy5jYWxsKCBkZWZlcnJlZCwgZGVmZXJyZWQgKTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gQWxsIGRvbmUhXFxuXFx0XFx0cmV0dXJuIGRlZmVycmVkO1xcblxcdH0sXFxuXFxuXFx0Ly8gRGVmZXJyZWQgaGVscGVyXFxuXFx0d2hlbjogZnVuY3Rpb24oIHNpbmdsZVZhbHVlICkge1xcblxcdFxcdHZhclxcblxcblxcdFxcdFxcdC8vIGNvdW50IG9mIHVuY29tcGxldGVkIHN1Ym9yZGluYXRlc1xcblxcdFxcdFxcdHJlbWFpbmluZyA9IGFyZ3VtZW50cy5sZW5ndGgsXFxuXFxuXFx0XFx0XFx0Ly8gY291bnQgb2YgdW5wcm9jZXNzZWQgYXJndW1lbnRzXFxuXFx0XFx0XFx0aSA9IHJlbWFpbmluZyxcXG5cXG5cXHRcXHRcXHQvLyBzdWJvcmRpbmF0ZSBmdWxmaWxsbWVudCBkYXRhXFxuXFx0XFx0XFx0cmVzb2x2ZUNvbnRleHRzID0gQXJyYXkoIGkgKSxcXG5cXHRcXHRcXHRyZXNvbHZlVmFsdWVzID0gc2xpY2UuY2FsbCggYXJndW1lbnRzICksXFxuXFxuXFx0XFx0XFx0Ly8gdGhlIG1hc3RlciBEZWZlcnJlZFxcblxcdFxcdFxcdG1hc3RlciA9IGpRdWVyeS5EZWZlcnJlZCgpLFxcblxcblxcdFxcdFxcdC8vIHN1Ym9yZGluYXRlIGNhbGxiYWNrIGZhY3RvcnlcXG5cXHRcXHRcXHR1cGRhdGVGdW5jID0gZnVuY3Rpb24oIGkgKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIGZ1bmN0aW9uKCB2YWx1ZSApIHtcXG5cXHRcXHRcXHRcXHRcXHRyZXNvbHZlQ29udGV4dHNbIGkgXSA9IHRoaXM7XFxuXFx0XFx0XFx0XFx0XFx0cmVzb2x2ZVZhbHVlc1sgaSBdID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBzbGljZS5jYWxsKCBhcmd1bWVudHMgKSA6IHZhbHVlO1xcblxcdFxcdFxcdFxcdFxcdGlmICggISggLS1yZW1haW5pbmcgKSApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRtYXN0ZXIucmVzb2x2ZVdpdGgoIHJlc29sdmVDb250ZXh0cywgcmVzb2x2ZVZhbHVlcyApO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9O1xcblxcdFxcdFxcdH07XFxuXFxuXFx0XFx0Ly8gU2luZ2xlLSBhbmQgZW1wdHkgYXJndW1lbnRzIGFyZSBhZG9wdGVkIGxpa2UgUHJvbWlzZS5yZXNvbHZlXFxuXFx0XFx0aWYgKCByZW1haW5pbmcgPD0gMSApIHtcXG5cXHRcXHRcXHRhZG9wdFZhbHVlKCBzaW5nbGVWYWx1ZSwgbWFzdGVyLmRvbmUoIHVwZGF0ZUZ1bmMoIGkgKSApLnJlc29sdmUsIG1hc3Rlci5yZWplY3QsXFxuXFx0XFx0XFx0XFx0IXJlbWFpbmluZyApO1xcblxcblxcdFxcdFxcdC8vIFVzZSAudGhlbigpIHRvIHVud3JhcCBzZWNvbmRhcnkgdGhlbmFibGVzIChjZi4gZ2gtMzAwMClcXG5cXHRcXHRcXHRpZiAoIG1hc3Rlci5zdGF0ZSgpID09PSBcXFwicGVuZGluZ1xcXCIgfHxcXG5cXHRcXHRcXHRcXHRpc0Z1bmN0aW9uKCByZXNvbHZlVmFsdWVzWyBpIF0gJiYgcmVzb2x2ZVZhbHVlc1sgaSBdLnRoZW4gKSApIHtcXG5cXG5cXHRcXHRcXHRcXHRyZXR1cm4gbWFzdGVyLnRoZW4oKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIE11bHRpcGxlIGFyZ3VtZW50cyBhcmUgYWdncmVnYXRlZCBsaWtlIFByb21pc2UuYWxsIGFycmF5IGVsZW1lbnRzXFxuXFx0XFx0d2hpbGUgKCBpLS0gKSB7XFxuXFx0XFx0XFx0YWRvcHRWYWx1ZSggcmVzb2x2ZVZhbHVlc1sgaSBdLCB1cGRhdGVGdW5jKCBpICksIG1hc3Rlci5yZWplY3QgKTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0cmV0dXJuIG1hc3Rlci5wcm9taXNlKCk7XFxuXFx0fVxcbn0gKTtcXG5cXG5cXG4vLyBUaGVzZSB1c3VhbGx5IGluZGljYXRlIGEgcHJvZ3JhbW1lciBtaXN0YWtlIGR1cmluZyBkZXZlbG9wbWVudCxcXG4vLyB3YXJuIGFib3V0IHRoZW0gQVNBUCByYXRoZXIgdGhhbiBzd2FsbG93aW5nIHRoZW0gYnkgZGVmYXVsdC5cXG52YXIgcmVycm9yTmFtZXMgPSAvXihFdmFsfEludGVybmFsfFJhbmdlfFJlZmVyZW5jZXxTeW50YXh8VHlwZXxVUkkpRXJyb3IkLztcXG5cXG5qUXVlcnkuRGVmZXJyZWQuZXhjZXB0aW9uSG9vayA9IGZ1bmN0aW9uKCBlcnJvciwgc3RhY2sgKSB7XFxuXFxuXFx0Ly8gU3VwcG9ydDogSUUgOCAtIDkgb25seVxcblxcdC8vIENvbnNvbGUgZXhpc3RzIHdoZW4gZGV2IHRvb2xzIGFyZSBvcGVuLCB3aGljaCBjYW4gaGFwcGVuIGF0IGFueSB0aW1lXFxuXFx0aWYgKCB3aW5kb3cuY29uc29sZSAmJiB3aW5kb3cuY29uc29sZS53YXJuICYmIGVycm9yICYmIHJlcnJvck5hbWVzLnRlc3QoIGVycm9yLm5hbWUgKSApIHtcXG5cXHRcXHR3aW5kb3cuY29uc29sZS53YXJuKCBcXFwialF1ZXJ5LkRlZmVycmVkIGV4Y2VwdGlvbjogXFxcIiArIGVycm9yLm1lc3NhZ2UsIGVycm9yLnN0YWNrLCBzdGFjayApO1xcblxcdH1cXG59O1xcblxcblxcblxcblxcbmpRdWVyeS5yZWFkeUV4Y2VwdGlvbiA9IGZ1bmN0aW9uKCBlcnJvciApIHtcXG5cXHR3aW5kb3cuc2V0VGltZW91dCggZnVuY3Rpb24oKSB7XFxuXFx0XFx0dGhyb3cgZXJyb3I7XFxuXFx0fSApO1xcbn07XFxuXFxuXFxuXFxuXFxuLy8gVGhlIGRlZmVycmVkIHVzZWQgb24gRE9NIHJlYWR5XFxudmFyIHJlYWR5TGlzdCA9IGpRdWVyeS5EZWZlcnJlZCgpO1xcblxcbmpRdWVyeS5mbi5yZWFkeSA9IGZ1bmN0aW9uKCBmbiApIHtcXG5cXG5cXHRyZWFkeUxpc3RcXG5cXHRcXHQudGhlbiggZm4gKVxcblxcblxcdFxcdC8vIFdyYXAgalF1ZXJ5LnJlYWR5RXhjZXB0aW9uIGluIGEgZnVuY3Rpb24gc28gdGhhdCB0aGUgbG9va3VwXFxuXFx0XFx0Ly8gaGFwcGVucyBhdCB0aGUgdGltZSBvZiBlcnJvciBoYW5kbGluZyBpbnN0ZWFkIG9mIGNhbGxiYWNrXFxuXFx0XFx0Ly8gcmVnaXN0cmF0aW9uLlxcblxcdFxcdC5jYXRjaCggZnVuY3Rpb24oIGVycm9yICkge1xcblxcdFxcdFxcdGpRdWVyeS5yZWFkeUV4Y2VwdGlvbiggZXJyb3IgKTtcXG5cXHRcXHR9ICk7XFxuXFxuXFx0cmV0dXJuIHRoaXM7XFxufTtcXG5cXG5qUXVlcnkuZXh0ZW5kKCB7XFxuXFxuXFx0Ly8gSXMgdGhlIERPTSByZWFkeSB0byBiZSB1c2VkPyBTZXQgdG8gdHJ1ZSBvbmNlIGl0IG9jY3Vycy5cXG5cXHRpc1JlYWR5OiBmYWxzZSxcXG5cXG5cXHQvLyBBIGNvdW50ZXIgdG8gdHJhY2sgaG93IG1hbnkgaXRlbXMgdG8gd2FpdCBmb3IgYmVmb3JlXFxuXFx0Ly8gdGhlIHJlYWR5IGV2ZW50IGZpcmVzLiBTZWUgIzY3ODFcXG5cXHRyZWFkeVdhaXQ6IDEsXFxuXFxuXFx0Ly8gSGFuZGxlIHdoZW4gdGhlIERPTSBpcyByZWFkeVxcblxcdHJlYWR5OiBmdW5jdGlvbiggd2FpdCApIHtcXG5cXG5cXHRcXHQvLyBBYm9ydCBpZiB0aGVyZSBhcmUgcGVuZGluZyBob2xkcyBvciB3ZSdyZSBhbHJlYWR5IHJlYWR5XFxuXFx0XFx0aWYgKCB3YWl0ID09PSB0cnVlID8gLS1qUXVlcnkucmVhZHlXYWl0IDogalF1ZXJ5LmlzUmVhZHkgKSB7XFxuXFx0XFx0XFx0cmV0dXJuO1xcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBSZW1lbWJlciB0aGF0IHRoZSBET00gaXMgcmVhZHlcXG5cXHRcXHRqUXVlcnkuaXNSZWFkeSA9IHRydWU7XFxuXFxuXFx0XFx0Ly8gSWYgYSBub3JtYWwgRE9NIFJlYWR5IGV2ZW50IGZpcmVkLCBkZWNyZW1lbnQsIGFuZCB3YWl0IGlmIG5lZWQgYmVcXG5cXHRcXHRpZiAoIHdhaXQgIT09IHRydWUgJiYgLS1qUXVlcnkucmVhZHlXYWl0ID4gMCApIHtcXG5cXHRcXHRcXHRyZXR1cm47XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIElmIHRoZXJlIGFyZSBmdW5jdGlvbnMgYm91bmQsIHRvIGV4ZWN1dGVcXG5cXHRcXHRyZWFkeUxpc3QucmVzb2x2ZVdpdGgoIGRvY3VtZW50LCBbIGpRdWVyeSBdICk7XFxuXFx0fVxcbn0gKTtcXG5cXG5qUXVlcnkucmVhZHkudGhlbiA9IHJlYWR5TGlzdC50aGVuO1xcblxcbi8vIFRoZSByZWFkeSBldmVudCBoYW5kbGVyIGFuZCBzZWxmIGNsZWFudXAgbWV0aG9kXFxuZnVuY3Rpb24gY29tcGxldGVkKCkge1xcblxcdGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoIFxcXCJET01Db250ZW50TG9hZGVkXFxcIiwgY29tcGxldGVkICk7XFxuXFx0d2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoIFxcXCJsb2FkXFxcIiwgY29tcGxldGVkICk7XFxuXFx0alF1ZXJ5LnJlYWR5KCk7XFxufVxcblxcbi8vIENhdGNoIGNhc2VzIHdoZXJlICQoZG9jdW1lbnQpLnJlYWR5KCkgaXMgY2FsbGVkXFxuLy8gYWZ0ZXIgdGhlIGJyb3dzZXIgZXZlbnQgaGFzIGFscmVhZHkgb2NjdXJyZWQuXFxuLy8gU3VwcG9ydDogSUUgPD05IC0gMTAgb25seVxcbi8vIE9sZGVyIElFIHNvbWV0aW1lcyBzaWduYWxzIFxcXCJpbnRlcmFjdGl2ZVxcXCIgdG9vIHNvb25cXG5pZiAoIGRvY3VtZW50LnJlYWR5U3RhdGUgPT09IFxcXCJjb21wbGV0ZVxcXCIgfHxcXG5cXHQoIGRvY3VtZW50LnJlYWR5U3RhdGUgIT09IFxcXCJsb2FkaW5nXFxcIiAmJiAhZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmRvU2Nyb2xsICkgKSB7XFxuXFxuXFx0Ly8gSGFuZGxlIGl0IGFzeW5jaHJvbm91c2x5IHRvIGFsbG93IHNjcmlwdHMgdGhlIG9wcG9ydHVuaXR5IHRvIGRlbGF5IHJlYWR5XFxuXFx0d2luZG93LnNldFRpbWVvdXQoIGpRdWVyeS5yZWFkeSApO1xcblxcbn0gZWxzZSB7XFxuXFxuXFx0Ly8gVXNlIHRoZSBoYW5keSBldmVudCBjYWxsYmFja1xcblxcdGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoIFxcXCJET01Db250ZW50TG9hZGVkXFxcIiwgY29tcGxldGVkICk7XFxuXFxuXFx0Ly8gQSBmYWxsYmFjayB0byB3aW5kb3cub25sb2FkLCB0aGF0IHdpbGwgYWx3YXlzIHdvcmtcXG5cXHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciggXFxcImxvYWRcXFwiLCBjb21wbGV0ZWQgKTtcXG59XFxuXFxuXFxuXFxuXFxuLy8gTXVsdGlmdW5jdGlvbmFsIG1ldGhvZCB0byBnZXQgYW5kIHNldCB2YWx1ZXMgb2YgYSBjb2xsZWN0aW9uXFxuLy8gVGhlIHZhbHVlL3MgY2FuIG9wdGlvbmFsbHkgYmUgZXhlY3V0ZWQgaWYgaXQncyBhIGZ1bmN0aW9uXFxudmFyIGFjY2VzcyA9IGZ1bmN0aW9uKCBlbGVtcywgZm4sIGtleSwgdmFsdWUsIGNoYWluYWJsZSwgZW1wdHlHZXQsIHJhdyApIHtcXG5cXHR2YXIgaSA9IDAsXFxuXFx0XFx0bGVuID0gZWxlbXMubGVuZ3RoLFxcblxcdFxcdGJ1bGsgPSBrZXkgPT0gbnVsbDtcXG5cXG5cXHQvLyBTZXRzIG1hbnkgdmFsdWVzXFxuXFx0aWYgKCB0b1R5cGUoIGtleSApID09PSBcXFwib2JqZWN0XFxcIiApIHtcXG5cXHRcXHRjaGFpbmFibGUgPSB0cnVlO1xcblxcdFxcdGZvciAoIGkgaW4ga2V5ICkge1xcblxcdFxcdFxcdGFjY2VzcyggZWxlbXMsIGZuLCBpLCBrZXlbIGkgXSwgdHJ1ZSwgZW1wdHlHZXQsIHJhdyApO1xcblxcdFxcdH1cXG5cXG5cXHQvLyBTZXRzIG9uZSB2YWx1ZVxcblxcdH0gZWxzZSBpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XFxuXFx0XFx0Y2hhaW5hYmxlID0gdHJ1ZTtcXG5cXG5cXHRcXHRpZiAoICFpc0Z1bmN0aW9uKCB2YWx1ZSApICkge1xcblxcdFxcdFxcdHJhdyA9IHRydWU7XFxuXFx0XFx0fVxcblxcblxcdFxcdGlmICggYnVsayApIHtcXG5cXG5cXHRcXHRcXHQvLyBCdWxrIG9wZXJhdGlvbnMgcnVuIGFnYWluc3QgdGhlIGVudGlyZSBzZXRcXG5cXHRcXHRcXHRpZiAoIHJhdyApIHtcXG5cXHRcXHRcXHRcXHRmbi5jYWxsKCBlbGVtcywgdmFsdWUgKTtcXG5cXHRcXHRcXHRcXHRmbiA9IG51bGw7XFxuXFxuXFx0XFx0XFx0Ly8gLi4uZXhjZXB0IHdoZW4gZXhlY3V0aW5nIGZ1bmN0aW9uIHZhbHVlc1xcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0YnVsayA9IGZuO1xcblxcdFxcdFxcdFxcdGZuID0gZnVuY3Rpb24oIGVsZW0sIGtleSwgdmFsdWUgKSB7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIGJ1bGsuY2FsbCggalF1ZXJ5KCBlbGVtICksIHZhbHVlICk7XFxuXFx0XFx0XFx0XFx0fTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcblxcdFxcdGlmICggZm4gKSB7XFxuXFx0XFx0XFx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XFxuXFx0XFx0XFx0XFx0Zm4oXFxuXFx0XFx0XFx0XFx0XFx0ZWxlbXNbIGkgXSwga2V5LCByYXcgP1xcblxcdFxcdFxcdFxcdFxcdHZhbHVlIDpcXG5cXHRcXHRcXHRcXHRcXHR2YWx1ZS5jYWxsKCBlbGVtc1sgaSBdLCBpLCBmbiggZWxlbXNbIGkgXSwga2V5ICkgKVxcblxcdFxcdFxcdFxcdCk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXHR9XFxuXFxuXFx0aWYgKCBjaGFpbmFibGUgKSB7XFxuXFx0XFx0cmV0dXJuIGVsZW1zO1xcblxcdH1cXG5cXG5cXHQvLyBHZXRzXFxuXFx0aWYgKCBidWxrICkge1xcblxcdFxcdHJldHVybiBmbi5jYWxsKCBlbGVtcyApO1xcblxcdH1cXG5cXG5cXHRyZXR1cm4gbGVuID8gZm4oIGVsZW1zWyAwIF0sIGtleSApIDogZW1wdHlHZXQ7XFxufTtcXG5cXG5cXG4vLyBNYXRjaGVzIGRhc2hlZCBzdHJpbmcgZm9yIGNhbWVsaXppbmdcXG52YXIgcm1zUHJlZml4ID0gL14tbXMtLyxcXG5cXHRyZGFzaEFscGhhID0gLy0oW2Etel0pL2c7XFxuXFxuLy8gVXNlZCBieSBjYW1lbENhc2UgYXMgY2FsbGJhY2sgdG8gcmVwbGFjZSgpXFxuZnVuY3Rpb24gZmNhbWVsQ2FzZSggYWxsLCBsZXR0ZXIgKSB7XFxuXFx0cmV0dXJuIGxldHRlci50b1VwcGVyQ2FzZSgpO1xcbn1cXG5cXG4vLyBDb252ZXJ0IGRhc2hlZCB0byBjYW1lbENhc2U7IHVzZWQgYnkgdGhlIGNzcyBhbmQgZGF0YSBtb2R1bGVzXFxuLy8gU3VwcG9ydDogSUUgPD05IC0gMTEsIEVkZ2UgMTIgLSAxNVxcbi8vIE1pY3Jvc29mdCBmb3Jnb3QgdG8gaHVtcCB0aGVpciB2ZW5kb3IgcHJlZml4ICgjOTU3MilcXG5mdW5jdGlvbiBjYW1lbENhc2UoIHN0cmluZyApIHtcXG5cXHRyZXR1cm4gc3RyaW5nLnJlcGxhY2UoIHJtc1ByZWZpeCwgXFxcIm1zLVxcXCIgKS5yZXBsYWNlKCByZGFzaEFscGhhLCBmY2FtZWxDYXNlICk7XFxufVxcbnZhciBhY2NlcHREYXRhID0gZnVuY3Rpb24oIG93bmVyICkge1xcblxcblxcdC8vIEFjY2VwdHMgb25seTpcXG5cXHQvLyAgLSBOb2RlXFxuXFx0Ly8gICAgLSBOb2RlLkVMRU1FTlRfTk9ERVxcblxcdC8vICAgIC0gTm9kZS5ET0NVTUVOVF9OT0RFXFxuXFx0Ly8gIC0gT2JqZWN0XFxuXFx0Ly8gICAgLSBBbnlcXG5cXHRyZXR1cm4gb3duZXIubm9kZVR5cGUgPT09IDEgfHwgb3duZXIubm9kZVR5cGUgPT09IDkgfHwgISggK293bmVyLm5vZGVUeXBlICk7XFxufTtcXG5cXG5cXG5cXG5cXG5mdW5jdGlvbiBEYXRhKCkge1xcblxcdHRoaXMuZXhwYW5kbyA9IGpRdWVyeS5leHBhbmRvICsgRGF0YS51aWQrKztcXG59XFxuXFxuRGF0YS51aWQgPSAxO1xcblxcbkRhdGEucHJvdG90eXBlID0ge1xcblxcblxcdGNhY2hlOiBmdW5jdGlvbiggb3duZXIgKSB7XFxuXFxuXFx0XFx0Ly8gQ2hlY2sgaWYgdGhlIG93bmVyIG9iamVjdCBhbHJlYWR5IGhhcyBhIGNhY2hlXFxuXFx0XFx0dmFyIHZhbHVlID0gb3duZXJbIHRoaXMuZXhwYW5kbyBdO1xcblxcblxcdFxcdC8vIElmIG5vdCwgY3JlYXRlIG9uZVxcblxcdFxcdGlmICggIXZhbHVlICkge1xcblxcdFxcdFxcdHZhbHVlID0ge307XFxuXFxuXFx0XFx0XFx0Ly8gV2UgY2FuIGFjY2VwdCBkYXRhIGZvciBub24tZWxlbWVudCBub2RlcyBpbiBtb2Rlcm4gYnJvd3NlcnMsXFxuXFx0XFx0XFx0Ly8gYnV0IHdlIHNob3VsZCBub3QsIHNlZSAjODMzNS5cXG5cXHRcXHRcXHQvLyBBbHdheXMgcmV0dXJuIGFuIGVtcHR5IG9iamVjdC5cXG5cXHRcXHRcXHRpZiAoIGFjY2VwdERhdGEoIG93bmVyICkgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gSWYgaXQgaXMgYSBub2RlIHVubGlrZWx5IHRvIGJlIHN0cmluZ2lmeS1lZCBvciBsb29wZWQgb3ZlclxcblxcdFxcdFxcdFxcdC8vIHVzZSBwbGFpbiBhc3NpZ25tZW50XFxuXFx0XFx0XFx0XFx0aWYgKCBvd25lci5ub2RlVHlwZSApIHtcXG5cXHRcXHRcXHRcXHRcXHRvd25lclsgdGhpcy5leHBhbmRvIF0gPSB2YWx1ZTtcXG5cXG5cXHRcXHRcXHRcXHQvLyBPdGhlcndpc2Ugc2VjdXJlIGl0IGluIGEgbm9uLWVudW1lcmFibGUgcHJvcGVydHlcXG5cXHRcXHRcXHRcXHQvLyBjb25maWd1cmFibGUgbXVzdCBiZSB0cnVlIHRvIGFsbG93IHRoZSBwcm9wZXJ0eSB0byBiZVxcblxcdFxcdFxcdFxcdC8vIGRlbGV0ZWQgd2hlbiBkYXRhIGlzIHJlbW92ZWRcXG5cXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggb3duZXIsIHRoaXMuZXhwYW5kbywge1xcblxcdFxcdFxcdFxcdFxcdFxcdHZhbHVlOiB2YWx1ZSxcXG5cXHRcXHRcXHRcXHRcXHRcXHRjb25maWd1cmFibGU6IHRydWVcXG5cXHRcXHRcXHRcXHRcXHR9ICk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFxuXFx0XFx0cmV0dXJuIHZhbHVlO1xcblxcdH0sXFxuXFx0c2V0OiBmdW5jdGlvbiggb3duZXIsIGRhdGEsIHZhbHVlICkge1xcblxcdFxcdHZhciBwcm9wLFxcblxcdFxcdFxcdGNhY2hlID0gdGhpcy5jYWNoZSggb3duZXIgKTtcXG5cXG5cXHRcXHQvLyBIYW5kbGU6IFsgb3duZXIsIGtleSwgdmFsdWUgXSBhcmdzXFxuXFx0XFx0Ly8gQWx3YXlzIHVzZSBjYW1lbENhc2Uga2V5IChnaC0yMjU3KVxcblxcdFxcdGlmICggdHlwZW9mIGRhdGEgPT09IFxcXCJzdHJpbmdcXFwiICkge1xcblxcdFxcdFxcdGNhY2hlWyBjYW1lbENhc2UoIGRhdGEgKSBdID0gdmFsdWU7XFxuXFxuXFx0XFx0Ly8gSGFuZGxlOiBbIG93bmVyLCB7IHByb3BlcnRpZXMgfSBdIGFyZ3NcXG5cXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdC8vIENvcHkgdGhlIHByb3BlcnRpZXMgb25lLWJ5LW9uZSB0byB0aGUgY2FjaGUgb2JqZWN0XFxuXFx0XFx0XFx0Zm9yICggcHJvcCBpbiBkYXRhICkge1xcblxcdFxcdFxcdFxcdGNhY2hlWyBjYW1lbENhc2UoIHByb3AgKSBdID0gZGF0YVsgcHJvcCBdO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFx0XFx0cmV0dXJuIGNhY2hlO1xcblxcdH0sXFxuXFx0Z2V0OiBmdW5jdGlvbiggb3duZXIsIGtleSApIHtcXG5cXHRcXHRyZXR1cm4ga2V5ID09PSB1bmRlZmluZWQgP1xcblxcdFxcdFxcdHRoaXMuY2FjaGUoIG93bmVyICkgOlxcblxcblxcdFxcdFxcdC8vIEFsd2F5cyB1c2UgY2FtZWxDYXNlIGtleSAoZ2gtMjI1NylcXG5cXHRcXHRcXHRvd25lclsgdGhpcy5leHBhbmRvIF0gJiYgb3duZXJbIHRoaXMuZXhwYW5kbyBdWyBjYW1lbENhc2UoIGtleSApIF07XFxuXFx0fSxcXG5cXHRhY2Nlc3M6IGZ1bmN0aW9uKCBvd25lciwga2V5LCB2YWx1ZSApIHtcXG5cXG5cXHRcXHQvLyBJbiBjYXNlcyB3aGVyZSBlaXRoZXI6XFxuXFx0XFx0Ly9cXG5cXHRcXHQvLyAgIDEuIE5vIGtleSB3YXMgc3BlY2lmaWVkXFxuXFx0XFx0Ly8gICAyLiBBIHN0cmluZyBrZXkgd2FzIHNwZWNpZmllZCwgYnV0IG5vIHZhbHVlIHByb3ZpZGVkXFxuXFx0XFx0Ly9cXG5cXHRcXHQvLyBUYWtlIHRoZSBcXFwicmVhZFxcXCIgcGF0aCBhbmQgYWxsb3cgdGhlIGdldCBtZXRob2QgdG8gZGV0ZXJtaW5lXFxuXFx0XFx0Ly8gd2hpY2ggdmFsdWUgdG8gcmV0dXJuLCByZXNwZWN0aXZlbHkgZWl0aGVyOlxcblxcdFxcdC8vXFxuXFx0XFx0Ly8gICAxLiBUaGUgZW50aXJlIGNhY2hlIG9iamVjdFxcblxcdFxcdC8vICAgMi4gVGhlIGRhdGEgc3RvcmVkIGF0IHRoZSBrZXlcXG5cXHRcXHQvL1xcblxcdFxcdGlmICgga2V5ID09PSB1bmRlZmluZWQgfHxcXG5cXHRcXHRcXHRcXHQoICgga2V5ICYmIHR5cGVvZiBrZXkgPT09IFxcXCJzdHJpbmdcXFwiICkgJiYgdmFsdWUgPT09IHVuZGVmaW5lZCApICkge1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzLmdldCggb3duZXIsIGtleSApO1xcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBXaGVuIHRoZSBrZXkgaXMgbm90IGEgc3RyaW5nLCBvciBib3RoIGEga2V5IGFuZCB2YWx1ZVxcblxcdFxcdC8vIGFyZSBzcGVjaWZpZWQsIHNldCBvciBleHRlbmQgKGV4aXN0aW5nIG9iamVjdHMpIHdpdGggZWl0aGVyOlxcblxcdFxcdC8vXFxuXFx0XFx0Ly8gICAxLiBBbiBvYmplY3Qgb2YgcHJvcGVydGllc1xcblxcdFxcdC8vICAgMi4gQSBrZXkgYW5kIHZhbHVlXFxuXFx0XFx0Ly9cXG5cXHRcXHR0aGlzLnNldCggb3duZXIsIGtleSwgdmFsdWUgKTtcXG5cXG5cXHRcXHQvLyBTaW5jZSB0aGUgXFxcInNldFxcXCIgcGF0aCBjYW4gaGF2ZSB0d28gcG9zc2libGUgZW50cnkgcG9pbnRzXFxuXFx0XFx0Ly8gcmV0dXJuIHRoZSBleHBlY3RlZCBkYXRhIGJhc2VkIG9uIHdoaWNoIHBhdGggd2FzIHRha2VuWypdXFxuXFx0XFx0cmV0dXJuIHZhbHVlICE9PSB1bmRlZmluZWQgPyB2YWx1ZSA6IGtleTtcXG5cXHR9LFxcblxcdHJlbW92ZTogZnVuY3Rpb24oIG93bmVyLCBrZXkgKSB7XFxuXFx0XFx0dmFyIGksXFxuXFx0XFx0XFx0Y2FjaGUgPSBvd25lclsgdGhpcy5leHBhbmRvIF07XFxuXFxuXFx0XFx0aWYgKCBjYWNoZSA9PT0gdW5kZWZpbmVkICkge1xcblxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0aWYgKCBrZXkgIT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHRcXHQvLyBTdXBwb3J0IGFycmF5IG9yIHNwYWNlIHNlcGFyYXRlZCBzdHJpbmcgb2Yga2V5c1xcblxcdFxcdFxcdGlmICggQXJyYXkuaXNBcnJheSgga2V5ICkgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gSWYga2V5IGlzIGFuIGFycmF5IG9mIGtleXMuLi5cXG5cXHRcXHRcXHRcXHQvLyBXZSBhbHdheXMgc2V0IGNhbWVsQ2FzZSBrZXlzLCBzbyByZW1vdmUgdGhhdC5cXG5cXHRcXHRcXHRcXHRrZXkgPSBrZXkubWFwKCBjYW1lbENhc2UgKTtcXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdGtleSA9IGNhbWVsQ2FzZSgga2V5ICk7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gSWYgYSBrZXkgd2l0aCB0aGUgc3BhY2VzIGV4aXN0cywgdXNlIGl0LlxcblxcdFxcdFxcdFxcdC8vIE90aGVyd2lzZSwgY3JlYXRlIGFuIGFycmF5IGJ5IG1hdGNoaW5nIG5vbi13aGl0ZXNwYWNlXFxuXFx0XFx0XFx0XFx0a2V5ID0ga2V5IGluIGNhY2hlID9cXG5cXHRcXHRcXHRcXHRcXHRbIGtleSBdIDpcXG5cXHRcXHRcXHRcXHRcXHQoIGtleS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFtdICk7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGkgPSBrZXkubGVuZ3RoO1xcblxcblxcdFxcdFxcdHdoaWxlICggaS0tICkge1xcblxcdFxcdFxcdFxcdGRlbGV0ZSBjYWNoZVsga2V5WyBpIF0gXTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIFJlbW92ZSB0aGUgZXhwYW5kbyBpZiB0aGVyZSdzIG5vIG1vcmUgZGF0YVxcblxcdFxcdGlmICgga2V5ID09PSB1bmRlZmluZWQgfHwgalF1ZXJ5LmlzRW1wdHlPYmplY3QoIGNhY2hlICkgKSB7XFxuXFxuXFx0XFx0XFx0Ly8gU3VwcG9ydDogQ2hyb21lIDw9MzUgLSA0NVxcblxcdFxcdFxcdC8vIFdlYmtpdCAmIEJsaW5rIHBlcmZvcm1hbmNlIHN1ZmZlcnMgd2hlbiBkZWxldGluZyBwcm9wZXJ0aWVzXFxuXFx0XFx0XFx0Ly8gZnJvbSBET00gbm9kZXMsIHNvIHNldCB0byB1bmRlZmluZWQgaW5zdGVhZFxcblxcdFxcdFxcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTM3ODYwNyAoYnVnIHJlc3RyaWN0ZWQpXFxuXFx0XFx0XFx0aWYgKCBvd25lci5ub2RlVHlwZSApIHtcXG5cXHRcXHRcXHRcXHRvd25lclsgdGhpcy5leHBhbmRvIF0gPSB1bmRlZmluZWQ7XFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRkZWxldGUgb3duZXJbIHRoaXMuZXhwYW5kbyBdO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFx0fSxcXG5cXHRoYXNEYXRhOiBmdW5jdGlvbiggb3duZXIgKSB7XFxuXFx0XFx0dmFyIGNhY2hlID0gb3duZXJbIHRoaXMuZXhwYW5kbyBdO1xcblxcdFxcdHJldHVybiBjYWNoZSAhPT0gdW5kZWZpbmVkICYmICFqUXVlcnkuaXNFbXB0eU9iamVjdCggY2FjaGUgKTtcXG5cXHR9XFxufTtcXG52YXIgZGF0YVByaXYgPSBuZXcgRGF0YSgpO1xcblxcbnZhciBkYXRhVXNlciA9IG5ldyBEYXRhKCk7XFxuXFxuXFxuXFxuLy9cXHRJbXBsZW1lbnRhdGlvbiBTdW1tYXJ5XFxuLy9cXG4vL1xcdDEuIEVuZm9yY2UgQVBJIHN1cmZhY2UgYW5kIHNlbWFudGljIGNvbXBhdGliaWxpdHkgd2l0aCAxLjkueCBicmFuY2hcXG4vL1xcdDIuIEltcHJvdmUgdGhlIG1vZHVsZSdzIG1haW50YWluYWJpbGl0eSBieSByZWR1Y2luZyB0aGUgc3RvcmFnZVxcbi8vXFx0XFx0cGF0aHMgdG8gYSBzaW5nbGUgbWVjaGFuaXNtLlxcbi8vXFx0My4gVXNlIHRoZSBzYW1lIHNpbmdsZSBtZWNoYW5pc20gdG8gc3VwcG9ydCBcXFwicHJpdmF0ZVxcXCIgYW5kIFxcXCJ1c2VyXFxcIiBkYXRhLlxcbi8vXFx0NC4gX05ldmVyXyBleHBvc2UgXFxcInByaXZhdGVcXFwiIGRhdGEgdG8gdXNlciBjb2RlIChUT0RPOiBEcm9wIF9kYXRhLCBfcmVtb3ZlRGF0YSlcXG4vL1xcdDUuIEF2b2lkIGV4cG9zaW5nIGltcGxlbWVudGF0aW9uIGRldGFpbHMgb24gdXNlciBvYmplY3RzIChlZy4gZXhwYW5kbyBwcm9wZXJ0aWVzKVxcbi8vXFx0Ni4gUHJvdmlkZSBhIGNsZWFyIHBhdGggZm9yIGltcGxlbWVudGF0aW9uIHVwZ3JhZGUgdG8gV2Vha01hcCBpbiAyMDE0XFxuXFxudmFyIHJicmFjZSA9IC9eKD86XFxcXHtbXFxcXHdcXFxcV10qXFxcXH18XFxcXFtbXFxcXHdcXFxcV10qXFxcXF0pJC8sXFxuXFx0cm11bHRpRGFzaCA9IC9bQS1aXS9nO1xcblxcbmZ1bmN0aW9uIGdldERhdGEoIGRhdGEgKSB7XFxuXFx0aWYgKCBkYXRhID09PSBcXFwidHJ1ZVxcXCIgKSB7XFxuXFx0XFx0cmV0dXJuIHRydWU7XFxuXFx0fVxcblxcblxcdGlmICggZGF0YSA9PT0gXFxcImZhbHNlXFxcIiApIHtcXG5cXHRcXHRyZXR1cm4gZmFsc2U7XFxuXFx0fVxcblxcblxcdGlmICggZGF0YSA9PT0gXFxcIm51bGxcXFwiICkge1xcblxcdFxcdHJldHVybiBudWxsO1xcblxcdH1cXG5cXG5cXHQvLyBPbmx5IGNvbnZlcnQgdG8gYSBudW1iZXIgaWYgaXQgZG9lc24ndCBjaGFuZ2UgdGhlIHN0cmluZ1xcblxcdGlmICggZGF0YSA9PT0gK2RhdGEgKyBcXFwiXFxcIiApIHtcXG5cXHRcXHRyZXR1cm4gK2RhdGE7XFxuXFx0fVxcblxcblxcdGlmICggcmJyYWNlLnRlc3QoIGRhdGEgKSApIHtcXG5cXHRcXHRyZXR1cm4gSlNPTi5wYXJzZSggZGF0YSApO1xcblxcdH1cXG5cXG5cXHRyZXR1cm4gZGF0YTtcXG59XFxuXFxuZnVuY3Rpb24gZGF0YUF0dHIoIGVsZW0sIGtleSwgZGF0YSApIHtcXG5cXHR2YXIgbmFtZTtcXG5cXG5cXHQvLyBJZiBub3RoaW5nIHdhcyBmb3VuZCBpbnRlcm5hbGx5LCB0cnkgdG8gZmV0Y2ggYW55XFxuXFx0Ly8gZGF0YSBmcm9tIHRoZSBIVE1MNSBkYXRhLSogYXR0cmlidXRlXFxuXFx0aWYgKCBkYXRhID09PSB1bmRlZmluZWQgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcXG5cXHRcXHRuYW1lID0gXFxcImRhdGEtXFxcIiArIGtleS5yZXBsYWNlKCBybXVsdGlEYXNoLCBcXFwiLSQmXFxcIiApLnRvTG93ZXJDYXNlKCk7XFxuXFx0XFx0ZGF0YSA9IGVsZW0uZ2V0QXR0cmlidXRlKCBuYW1lICk7XFxuXFxuXFx0XFx0aWYgKCB0eXBlb2YgZGF0YSA9PT0gXFxcInN0cmluZ1xcXCIgKSB7XFxuXFx0XFx0XFx0dHJ5IHtcXG5cXHRcXHRcXHRcXHRkYXRhID0gZ2V0RGF0YSggZGF0YSApO1xcblxcdFxcdFxcdH0gY2F0Y2ggKCBlICkge31cXG5cXG5cXHRcXHRcXHQvLyBNYWtlIHN1cmUgd2Ugc2V0IHRoZSBkYXRhIHNvIGl0IGlzbid0IGNoYW5nZWQgbGF0ZXJcXG5cXHRcXHRcXHRkYXRhVXNlci5zZXQoIGVsZW0sIGtleSwgZGF0YSApO1xcblxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0ZGF0YSA9IHVuZGVmaW5lZDtcXG5cXHRcXHR9XFxuXFx0fVxcblxcdHJldHVybiBkYXRhO1xcbn1cXG5cXG5qUXVlcnkuZXh0ZW5kKCB7XFxuXFx0aGFzRGF0YTogZnVuY3Rpb24oIGVsZW0gKSB7XFxuXFx0XFx0cmV0dXJuIGRhdGFVc2VyLmhhc0RhdGEoIGVsZW0gKSB8fCBkYXRhUHJpdi5oYXNEYXRhKCBlbGVtICk7XFxuXFx0fSxcXG5cXG5cXHRkYXRhOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgZGF0YSApIHtcXG5cXHRcXHRyZXR1cm4gZGF0YVVzZXIuYWNjZXNzKCBlbGVtLCBuYW1lLCBkYXRhICk7XFxuXFx0fSxcXG5cXG5cXHRyZW1vdmVEYXRhOiBmdW5jdGlvbiggZWxlbSwgbmFtZSApIHtcXG5cXHRcXHRkYXRhVXNlci5yZW1vdmUoIGVsZW0sIG5hbWUgKTtcXG5cXHR9LFxcblxcblxcdC8vIFRPRE86IE5vdyB0aGF0IGFsbCBjYWxscyB0byBfZGF0YSBhbmQgX3JlbW92ZURhdGEgaGF2ZSBiZWVuIHJlcGxhY2VkXFxuXFx0Ly8gd2l0aCBkaXJlY3QgY2FsbHMgdG8gZGF0YVByaXYgbWV0aG9kcywgdGhlc2UgY2FuIGJlIGRlcHJlY2F0ZWQuXFxuXFx0X2RhdGE6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBkYXRhICkge1xcblxcdFxcdHJldHVybiBkYXRhUHJpdi5hY2Nlc3MoIGVsZW0sIG5hbWUsIGRhdGEgKTtcXG5cXHR9LFxcblxcblxcdF9yZW1vdmVEYXRhOiBmdW5jdGlvbiggZWxlbSwgbmFtZSApIHtcXG5cXHRcXHRkYXRhUHJpdi5yZW1vdmUoIGVsZW0sIG5hbWUgKTtcXG5cXHR9XFxufSApO1xcblxcbmpRdWVyeS5mbi5leHRlbmQoIHtcXG5cXHRkYXRhOiBmdW5jdGlvbigga2V5LCB2YWx1ZSApIHtcXG5cXHRcXHR2YXIgaSwgbmFtZSwgZGF0YSxcXG5cXHRcXHRcXHRlbGVtID0gdGhpc1sgMCBdLFxcblxcdFxcdFxcdGF0dHJzID0gZWxlbSAmJiBlbGVtLmF0dHJpYnV0ZXM7XFxuXFxuXFx0XFx0Ly8gR2V0cyBhbGwgdmFsdWVzXFxuXFx0XFx0aWYgKCBrZXkgPT09IHVuZGVmaW5lZCApIHtcXG5cXHRcXHRcXHRpZiAoIHRoaXMubGVuZ3RoICkge1xcblxcdFxcdFxcdFxcdGRhdGEgPSBkYXRhVXNlci5nZXQoIGVsZW0gKTtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgJiYgIWRhdGFQcml2LmdldCggZWxlbSwgXFxcImhhc0RhdGFBdHRyc1xcXCIgKSApIHtcXG5cXHRcXHRcXHRcXHRcXHRpID0gYXR0cnMubGVuZ3RoO1xcblxcdFxcdFxcdFxcdFxcdHdoaWxlICggaS0tICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdC8vIFN1cHBvcnQ6IElFIDExIG9ubHlcXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBUaGUgYXR0cnMgZWxlbWVudHMgY2FuIGJlIG51bGwgKCMxNDg5NClcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoIGF0dHJzWyBpIF0gKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0bmFtZSA9IGF0dHJzWyBpIF0ubmFtZTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoIG5hbWUuaW5kZXhPZiggXFxcImRhdGEtXFxcIiApID09PSAwICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdG5hbWUgPSBjYW1lbENhc2UoIG5hbWUuc2xpY2UoIDUgKSApO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGRhdGFBdHRyKCBlbGVtLCBuYW1lLCBkYXRhWyBuYW1lIF0gKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRkYXRhUHJpdi5zZXQoIGVsZW0sIFxcXCJoYXNEYXRhQXR0cnNcXFwiLCB0cnVlICk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRyZXR1cm4gZGF0YTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gU2V0cyBtdWx0aXBsZSB2YWx1ZXNcXG5cXHRcXHRpZiAoIHR5cGVvZiBrZXkgPT09IFxcXCJvYmplY3RcXFwiICkge1xcblxcdFxcdFxcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdFxcdGRhdGFVc2VyLnNldCggdGhpcywga2V5ICk7XFxuXFx0XFx0XFx0fSApO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggdmFsdWUgKSB7XFxuXFx0XFx0XFx0dmFyIGRhdGE7XFxuXFxuXFx0XFx0XFx0Ly8gVGhlIGNhbGxpbmcgalF1ZXJ5IG9iamVjdCAoZWxlbWVudCBtYXRjaGVzKSBpcyBub3QgZW1wdHlcXG5cXHRcXHRcXHQvLyAoYW5kIHRoZXJlZm9yZSBoYXMgYW4gZWxlbWVudCBhcHBlYXJzIGF0IHRoaXNbIDAgXSkgYW5kIHRoZVxcblxcdFxcdFxcdC8vIGB2YWx1ZWAgcGFyYW1ldGVyIHdhcyBub3QgdW5kZWZpbmVkLiBBbiBlbXB0eSBqUXVlcnkgb2JqZWN0XFxuXFx0XFx0XFx0Ly8gd2lsbCByZXN1bHQgaW4gYHVuZGVmaW5lZGAgZm9yIGVsZW0gPSB0aGlzWyAwIF0gd2hpY2ggd2lsbFxcblxcdFxcdFxcdC8vIHRocm93IGFuIGV4Y2VwdGlvbiBpZiBhbiBhdHRlbXB0IHRvIHJlYWQgYSBkYXRhIGNhY2hlIGlzIG1hZGUuXFxuXFx0XFx0XFx0aWYgKCBlbGVtICYmIHZhbHVlID09PSB1bmRlZmluZWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gQXR0ZW1wdCB0byBnZXQgZGF0YSBmcm9tIHRoZSBjYWNoZVxcblxcdFxcdFxcdFxcdC8vIFRoZSBrZXkgd2lsbCBhbHdheXMgYmUgY2FtZWxDYXNlZCBpbiBEYXRhXFxuXFx0XFx0XFx0XFx0ZGF0YSA9IGRhdGFVc2VyLmdldCggZWxlbSwga2V5ICk7XFxuXFx0XFx0XFx0XFx0aWYgKCBkYXRhICE9PSB1bmRlZmluZWQgKSB7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIGRhdGE7XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdC8vIEF0dGVtcHQgdG8gXFxcImRpc2NvdmVyXFxcIiB0aGUgZGF0YSBpblxcblxcdFxcdFxcdFxcdC8vIEhUTUw1IGN1c3RvbSBkYXRhLSogYXR0cnNcXG5cXHRcXHRcXHRcXHRkYXRhID0gZGF0YUF0dHIoIGVsZW0sIGtleSApO1xcblxcdFxcdFxcdFxcdGlmICggZGF0YSAhPT0gdW5kZWZpbmVkICkge1xcblxcdFxcdFxcdFxcdFxcdHJldHVybiBkYXRhO1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHQvLyBXZSB0cmllZCByZWFsbHkgaGFyZCwgYnV0IHRoZSBkYXRhIGRvZXNuJ3QgZXhpc3QuXFxuXFx0XFx0XFx0XFx0cmV0dXJuO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBTZXQgdGhlIGRhdGEuLi5cXG5cXHRcXHRcXHR0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xcblxcblxcdFxcdFxcdFxcdC8vIFdlIGFsd2F5cyBzdG9yZSB0aGUgY2FtZWxDYXNlZCBrZXlcXG5cXHRcXHRcXHRcXHRkYXRhVXNlci5zZXQoIHRoaXMsIGtleSwgdmFsdWUgKTtcXG5cXHRcXHRcXHR9ICk7XFxuXFx0XFx0fSwgbnVsbCwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggPiAxLCBudWxsLCB0cnVlICk7XFxuXFx0fSxcXG5cXG5cXHRyZW1vdmVEYXRhOiBmdW5jdGlvbigga2V5ICkge1xcblxcdFxcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdGRhdGFVc2VyLnJlbW92ZSggdGhpcywga2V5ICk7XFxuXFx0XFx0fSApO1xcblxcdH1cXG59ICk7XFxuXFxuXFxualF1ZXJ5LmV4dGVuZCgge1xcblxcdHF1ZXVlOiBmdW5jdGlvbiggZWxlbSwgdHlwZSwgZGF0YSApIHtcXG5cXHRcXHR2YXIgcXVldWU7XFxuXFxuXFx0XFx0aWYgKCBlbGVtICkge1xcblxcdFxcdFxcdHR5cGUgPSAoIHR5cGUgfHwgXFxcImZ4XFxcIiApICsgXFxcInF1ZXVlXFxcIjtcXG5cXHRcXHRcXHRxdWV1ZSA9IGRhdGFQcml2LmdldCggZWxlbSwgdHlwZSApO1xcblxcblxcdFxcdFxcdC8vIFNwZWVkIHVwIGRlcXVldWUgYnkgZ2V0dGluZyBvdXQgcXVpY2tseSBpZiB0aGlzIGlzIGp1c3QgYSBsb29rdXBcXG5cXHRcXHRcXHRpZiAoIGRhdGEgKSB7XFxuXFx0XFx0XFx0XFx0aWYgKCAhcXVldWUgfHwgQXJyYXkuaXNBcnJheSggZGF0YSApICkge1xcblxcdFxcdFxcdFxcdFxcdHF1ZXVlID0gZGF0YVByaXYuYWNjZXNzKCBlbGVtLCB0eXBlLCBqUXVlcnkubWFrZUFycmF5KCBkYXRhICkgKTtcXG5cXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdHF1ZXVlLnB1c2goIGRhdGEgKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHJldHVybiBxdWV1ZSB8fCBbXTtcXG5cXHRcXHR9XFxuXFx0fSxcXG5cXG5cXHRkZXF1ZXVlOiBmdW5jdGlvbiggZWxlbSwgdHlwZSApIHtcXG5cXHRcXHR0eXBlID0gdHlwZSB8fCBcXFwiZnhcXFwiO1xcblxcblxcdFxcdHZhciBxdWV1ZSA9IGpRdWVyeS5xdWV1ZSggZWxlbSwgdHlwZSApLFxcblxcdFxcdFxcdHN0YXJ0TGVuZ3RoID0gcXVldWUubGVuZ3RoLFxcblxcdFxcdFxcdGZuID0gcXVldWUuc2hpZnQoKSxcXG5cXHRcXHRcXHRob29rcyA9IGpRdWVyeS5fcXVldWVIb29rcyggZWxlbSwgdHlwZSApLFxcblxcdFxcdFxcdG5leHQgPSBmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHRcXHRqUXVlcnkuZGVxdWV1ZSggZWxlbSwgdHlwZSApO1xcblxcdFxcdFxcdH07XFxuXFxuXFx0XFx0Ly8gSWYgdGhlIGZ4IHF1ZXVlIGlzIGRlcXVldWVkLCBhbHdheXMgcmVtb3ZlIHRoZSBwcm9ncmVzcyBzZW50aW5lbFxcblxcdFxcdGlmICggZm4gPT09IFxcXCJpbnByb2dyZXNzXFxcIiApIHtcXG5cXHRcXHRcXHRmbiA9IHF1ZXVlLnNoaWZ0KCk7XFxuXFx0XFx0XFx0c3RhcnRMZW5ndGgtLTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0aWYgKCBmbiApIHtcXG5cXG5cXHRcXHRcXHQvLyBBZGQgYSBwcm9ncmVzcyBzZW50aW5lbCB0byBwcmV2ZW50IHRoZSBmeCBxdWV1ZSBmcm9tIGJlaW5nXFxuXFx0XFx0XFx0Ly8gYXV0b21hdGljYWxseSBkZXF1ZXVlZFxcblxcdFxcdFxcdGlmICggdHlwZSA9PT0gXFxcImZ4XFxcIiApIHtcXG5cXHRcXHRcXHRcXHRxdWV1ZS51bnNoaWZ0KCBcXFwiaW5wcm9ncmVzc1xcXCIgKTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gQ2xlYXIgdXAgdGhlIGxhc3QgcXVldWUgc3RvcCBmdW5jdGlvblxcblxcdFxcdFxcdGRlbGV0ZSBob29rcy5zdG9wO1xcblxcdFxcdFxcdGZuLmNhbGwoIGVsZW0sIG5leHQsIGhvb2tzICk7XFxuXFx0XFx0fVxcblxcblxcdFxcdGlmICggIXN0YXJ0TGVuZ3RoICYmIGhvb2tzICkge1xcblxcdFxcdFxcdGhvb2tzLmVtcHR5LmZpcmUoKTtcXG5cXHRcXHR9XFxuXFx0fSxcXG5cXG5cXHQvLyBOb3QgcHVibGljIC0gZ2VuZXJhdGUgYSBxdWV1ZUhvb2tzIG9iamVjdCwgb3IgcmV0dXJuIHRoZSBjdXJyZW50IG9uZVxcblxcdF9xdWV1ZUhvb2tzOiBmdW5jdGlvbiggZWxlbSwgdHlwZSApIHtcXG5cXHRcXHR2YXIga2V5ID0gdHlwZSArIFxcXCJxdWV1ZUhvb2tzXFxcIjtcXG5cXHRcXHRyZXR1cm4gZGF0YVByaXYuZ2V0KCBlbGVtLCBrZXkgKSB8fCBkYXRhUHJpdi5hY2Nlc3MoIGVsZW0sIGtleSwge1xcblxcdFxcdFxcdGVtcHR5OiBqUXVlcnkuQ2FsbGJhY2tzKCBcXFwib25jZSBtZW1vcnlcXFwiICkuYWRkKCBmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHRcXHRkYXRhUHJpdi5yZW1vdmUoIGVsZW0sIFsgdHlwZSArIFxcXCJxdWV1ZVxcXCIsIGtleSBdICk7XFxuXFx0XFx0XFx0fSApXFxuXFx0XFx0fSApO1xcblxcdH1cXG59ICk7XFxuXFxualF1ZXJ5LmZuLmV4dGVuZCgge1xcblxcdHF1ZXVlOiBmdW5jdGlvbiggdHlwZSwgZGF0YSApIHtcXG5cXHRcXHR2YXIgc2V0dGVyID0gMjtcXG5cXG5cXHRcXHRpZiAoIHR5cGVvZiB0eXBlICE9PSBcXFwic3RyaW5nXFxcIiApIHtcXG5cXHRcXHRcXHRkYXRhID0gdHlwZTtcXG5cXHRcXHRcXHR0eXBlID0gXFxcImZ4XFxcIjtcXG5cXHRcXHRcXHRzZXR0ZXItLTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0aWYgKCBhcmd1bWVudHMubGVuZ3RoIDwgc2V0dGVyICkge1xcblxcdFxcdFxcdHJldHVybiBqUXVlcnkucXVldWUoIHRoaXNbIDAgXSwgdHlwZSApO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRyZXR1cm4gZGF0YSA9PT0gdW5kZWZpbmVkID9cXG5cXHRcXHRcXHR0aGlzIDpcXG5cXHRcXHRcXHR0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdFxcdHZhciBxdWV1ZSA9IGpRdWVyeS5xdWV1ZSggdGhpcywgdHlwZSwgZGF0YSApO1xcblxcblxcdFxcdFxcdFxcdC8vIEVuc3VyZSBhIGhvb2tzIGZvciB0aGlzIHF1ZXVlXFxuXFx0XFx0XFx0XFx0alF1ZXJ5Ll9xdWV1ZUhvb2tzKCB0aGlzLCB0eXBlICk7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCB0eXBlID09PSBcXFwiZnhcXFwiICYmIHF1ZXVlWyAwIF0gIT09IFxcXCJpbnByb2dyZXNzXFxcIiApIHtcXG5cXHRcXHRcXHRcXHRcXHRqUXVlcnkuZGVxdWV1ZSggdGhpcywgdHlwZSApO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9ICk7XFxuXFx0fSxcXG5cXHRkZXF1ZXVlOiBmdW5jdGlvbiggdHlwZSApIHtcXG5cXHRcXHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHRqUXVlcnkuZGVxdWV1ZSggdGhpcywgdHlwZSApO1xcblxcdFxcdH0gKTtcXG5cXHR9LFxcblxcdGNsZWFyUXVldWU6IGZ1bmN0aW9uKCB0eXBlICkge1xcblxcdFxcdHJldHVybiB0aGlzLnF1ZXVlKCB0eXBlIHx8IFxcXCJmeFxcXCIsIFtdICk7XFxuXFx0fSxcXG5cXG5cXHQvLyBHZXQgYSBwcm9taXNlIHJlc29sdmVkIHdoZW4gcXVldWVzIG9mIGEgY2VydGFpbiB0eXBlXFxuXFx0Ly8gYXJlIGVtcHRpZWQgKGZ4IGlzIHRoZSB0eXBlIGJ5IGRlZmF1bHQpXFxuXFx0cHJvbWlzZTogZnVuY3Rpb24oIHR5cGUsIG9iaiApIHtcXG5cXHRcXHR2YXIgdG1wLFxcblxcdFxcdFxcdGNvdW50ID0gMSxcXG5cXHRcXHRcXHRkZWZlciA9IGpRdWVyeS5EZWZlcnJlZCgpLFxcblxcdFxcdFxcdGVsZW1lbnRzID0gdGhpcyxcXG5cXHRcXHRcXHRpID0gdGhpcy5sZW5ndGgsXFxuXFx0XFx0XFx0cmVzb2x2ZSA9IGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdFxcdGlmICggISggLS1jb3VudCApICkge1xcblxcdFxcdFxcdFxcdFxcdGRlZmVyLnJlc29sdmVXaXRoKCBlbGVtZW50cywgWyBlbGVtZW50cyBdICk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH07XFxuXFxuXFx0XFx0aWYgKCB0eXBlb2YgdHlwZSAhPT0gXFxcInN0cmluZ1xcXCIgKSB7XFxuXFx0XFx0XFx0b2JqID0gdHlwZTtcXG5cXHRcXHRcXHR0eXBlID0gdW5kZWZpbmVkO1xcblxcdFxcdH1cXG5cXHRcXHR0eXBlID0gdHlwZSB8fCBcXFwiZnhcXFwiO1xcblxcblxcdFxcdHdoaWxlICggaS0tICkge1xcblxcdFxcdFxcdHRtcCA9IGRhdGFQcml2LmdldCggZWxlbWVudHNbIGkgXSwgdHlwZSArIFxcXCJxdWV1ZUhvb2tzXFxcIiApO1xcblxcdFxcdFxcdGlmICggdG1wICYmIHRtcC5lbXB0eSApIHtcXG5cXHRcXHRcXHRcXHRjb3VudCsrO1xcblxcdFxcdFxcdFxcdHRtcC5lbXB0eS5hZGQoIHJlc29sdmUgKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcdFxcdHJlc29sdmUoKTtcXG5cXHRcXHRyZXR1cm4gZGVmZXIucHJvbWlzZSggb2JqICk7XFxuXFx0fVxcbn0gKTtcXG52YXIgcG51bSA9ICggL1srLV0/KD86XFxcXGQqXFxcXC58KVxcXFxkKyg/OltlRV1bKy1dP1xcXFxkK3wpLyApLnNvdXJjZTtcXG5cXG52YXIgcmNzc051bSA9IG5ldyBSZWdFeHAoIFxcXCJeKD86KFsrLV0pPXwpKFxcXCIgKyBwbnVtICsgXFxcIikoW2EteiVdKikkXFxcIiwgXFxcImlcXFwiICk7XFxuXFxuXFxudmFyIGNzc0V4cGFuZCA9IFsgXFxcIlRvcFxcXCIsIFxcXCJSaWdodFxcXCIsIFxcXCJCb3R0b21cXFwiLCBcXFwiTGVmdFxcXCIgXTtcXG5cXG52YXIgaXNIaWRkZW5XaXRoaW5UcmVlID0gZnVuY3Rpb24oIGVsZW0sIGVsICkge1xcblxcblxcdFxcdC8vIGlzSGlkZGVuV2l0aGluVHJlZSBtaWdodCBiZSBjYWxsZWQgZnJvbSBqUXVlcnkjZmlsdGVyIGZ1bmN0aW9uO1xcblxcdFxcdC8vIGluIHRoYXQgY2FzZSwgZWxlbWVudCB3aWxsIGJlIHNlY29uZCBhcmd1bWVudFxcblxcdFxcdGVsZW0gPSBlbCB8fCBlbGVtO1xcblxcblxcdFxcdC8vIElubGluZSBzdHlsZSB0cnVtcHMgYWxsXFxuXFx0XFx0cmV0dXJuIGVsZW0uc3R5bGUuZGlzcGxheSA9PT0gXFxcIm5vbmVcXFwiIHx8XFxuXFx0XFx0XFx0ZWxlbS5zdHlsZS5kaXNwbGF5ID09PSBcXFwiXFxcIiAmJlxcblxcblxcdFxcdFxcdC8vIE90aGVyd2lzZSwgY2hlY2sgY29tcHV0ZWQgc3R5bGVcXG5cXHRcXHRcXHQvLyBTdXBwb3J0OiBGaXJlZm94IDw9NDMgLSA0NVxcblxcdFxcdFxcdC8vIERpc2Nvbm5lY3RlZCBlbGVtZW50cyBjYW4gaGF2ZSBjb21wdXRlZCBkaXNwbGF5OiBub25lLCBzbyBmaXJzdCBjb25maXJtIHRoYXQgZWxlbSBpc1xcblxcdFxcdFxcdC8vIGluIHRoZSBkb2N1bWVudC5cXG5cXHRcXHRcXHRqUXVlcnkuY29udGFpbnMoIGVsZW0ub3duZXJEb2N1bWVudCwgZWxlbSApICYmXFxuXFxuXFx0XFx0XFx0alF1ZXJ5LmNzcyggZWxlbSwgXFxcImRpc3BsYXlcXFwiICkgPT09IFxcXCJub25lXFxcIjtcXG5cXHR9O1xcblxcbnZhciBzd2FwID0gZnVuY3Rpb24oIGVsZW0sIG9wdGlvbnMsIGNhbGxiYWNrLCBhcmdzICkge1xcblxcdHZhciByZXQsIG5hbWUsXFxuXFx0XFx0b2xkID0ge307XFxuXFxuXFx0Ly8gUmVtZW1iZXIgdGhlIG9sZCB2YWx1ZXMsIGFuZCBpbnNlcnQgdGhlIG5ldyBvbmVzXFxuXFx0Zm9yICggbmFtZSBpbiBvcHRpb25zICkge1xcblxcdFxcdG9sZFsgbmFtZSBdID0gZWxlbS5zdHlsZVsgbmFtZSBdO1xcblxcdFxcdGVsZW0uc3R5bGVbIG5hbWUgXSA9IG9wdGlvbnNbIG5hbWUgXTtcXG5cXHR9XFxuXFxuXFx0cmV0ID0gY2FsbGJhY2suYXBwbHkoIGVsZW0sIGFyZ3MgfHwgW10gKTtcXG5cXG5cXHQvLyBSZXZlcnQgdGhlIG9sZCB2YWx1ZXNcXG5cXHRmb3IgKCBuYW1lIGluIG9wdGlvbnMgKSB7XFxuXFx0XFx0ZWxlbS5zdHlsZVsgbmFtZSBdID0gb2xkWyBuYW1lIF07XFxuXFx0fVxcblxcblxcdHJldHVybiByZXQ7XFxufTtcXG5cXG5cXG5cXG5cXG5mdW5jdGlvbiBhZGp1c3RDU1MoIGVsZW0sIHByb3AsIHZhbHVlUGFydHMsIHR3ZWVuICkge1xcblxcdHZhciBhZGp1c3RlZCwgc2NhbGUsXFxuXFx0XFx0bWF4SXRlcmF0aW9ucyA9IDIwLFxcblxcdFxcdGN1cnJlbnRWYWx1ZSA9IHR3ZWVuID9cXG5cXHRcXHRcXHRmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gdHdlZW4uY3VyKCk7XFxuXFx0XFx0XFx0fSA6XFxuXFx0XFx0XFx0ZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIGpRdWVyeS5jc3MoIGVsZW0sIHByb3AsIFxcXCJcXFwiICk7XFxuXFx0XFx0XFx0fSxcXG5cXHRcXHRpbml0aWFsID0gY3VycmVudFZhbHVlKCksXFxuXFx0XFx0dW5pdCA9IHZhbHVlUGFydHMgJiYgdmFsdWVQYXJ0c1sgMyBdIHx8ICggalF1ZXJ5LmNzc051bWJlclsgcHJvcCBdID8gXFxcIlxcXCIgOiBcXFwicHhcXFwiICksXFxuXFxuXFx0XFx0Ly8gU3RhcnRpbmcgdmFsdWUgY29tcHV0YXRpb24gaXMgcmVxdWlyZWQgZm9yIHBvdGVudGlhbCB1bml0IG1pc21hdGNoZXNcXG5cXHRcXHRpbml0aWFsSW5Vbml0ID0gKCBqUXVlcnkuY3NzTnVtYmVyWyBwcm9wIF0gfHwgdW5pdCAhPT0gXFxcInB4XFxcIiAmJiAraW5pdGlhbCApICYmXFxuXFx0XFx0XFx0cmNzc051bS5leGVjKCBqUXVlcnkuY3NzKCBlbGVtLCBwcm9wICkgKTtcXG5cXG5cXHRpZiAoIGluaXRpYWxJblVuaXQgJiYgaW5pdGlhbEluVW5pdFsgMyBdICE9PSB1bml0ICkge1xcblxcblxcdFxcdC8vIFN1cHBvcnQ6IEZpcmVmb3ggPD01NFxcblxcdFxcdC8vIEhhbHZlIHRoZSBpdGVyYXRpb24gdGFyZ2V0IHZhbHVlIHRvIHByZXZlbnQgaW50ZXJmZXJlbmNlIGZyb20gQ1NTIHVwcGVyIGJvdW5kcyAoZ2gtMjE0NClcXG5cXHRcXHRpbml0aWFsID0gaW5pdGlhbCAvIDI7XFxuXFxuXFx0XFx0Ly8gVHJ1c3QgdW5pdHMgcmVwb3J0ZWQgYnkgalF1ZXJ5LmNzc1xcblxcdFxcdHVuaXQgPSB1bml0IHx8IGluaXRpYWxJblVuaXRbIDMgXTtcXG5cXG5cXHRcXHQvLyBJdGVyYXRpdmVseSBhcHByb3hpbWF0ZSBmcm9tIGEgbm9uemVybyBzdGFydGluZyBwb2ludFxcblxcdFxcdGluaXRpYWxJblVuaXQgPSAraW5pdGlhbCB8fCAxO1xcblxcblxcdFxcdHdoaWxlICggbWF4SXRlcmF0aW9ucy0tICkge1xcblxcblxcdFxcdFxcdC8vIEV2YWx1YXRlIGFuZCB1cGRhdGUgb3VyIGJlc3QgZ3Vlc3MgKGRvdWJsaW5nIGd1ZXNzZXMgdGhhdCB6ZXJvIG91dCkuXFxuXFx0XFx0XFx0Ly8gRmluaXNoIGlmIHRoZSBzY2FsZSBlcXVhbHMgb3IgY3Jvc3NlcyAxIChtYWtpbmcgdGhlIG9sZCpuZXcgcHJvZHVjdCBub24tcG9zaXRpdmUpLlxcblxcdFxcdFxcdGpRdWVyeS5zdHlsZSggZWxlbSwgcHJvcCwgaW5pdGlhbEluVW5pdCArIHVuaXQgKTtcXG5cXHRcXHRcXHRpZiAoICggMSAtIHNjYWxlICkgKiAoIDEgLSAoIHNjYWxlID0gY3VycmVudFZhbHVlKCkgLyBpbml0aWFsIHx8IDAuNSApICkgPD0gMCApIHtcXG5cXHRcXHRcXHRcXHRtYXhJdGVyYXRpb25zID0gMDtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0aW5pdGlhbEluVW5pdCA9IGluaXRpYWxJblVuaXQgLyBzY2FsZTtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0aW5pdGlhbEluVW5pdCA9IGluaXRpYWxJblVuaXQgKiAyO1xcblxcdFxcdGpRdWVyeS5zdHlsZSggZWxlbSwgcHJvcCwgaW5pdGlhbEluVW5pdCArIHVuaXQgKTtcXG5cXG5cXHRcXHQvLyBNYWtlIHN1cmUgd2UgdXBkYXRlIHRoZSB0d2VlbiBwcm9wZXJ0aWVzIGxhdGVyIG9uXFxuXFx0XFx0dmFsdWVQYXJ0cyA9IHZhbHVlUGFydHMgfHwgW107XFxuXFx0fVxcblxcblxcdGlmICggdmFsdWVQYXJ0cyApIHtcXG5cXHRcXHRpbml0aWFsSW5Vbml0ID0gK2luaXRpYWxJblVuaXQgfHwgK2luaXRpYWwgfHwgMDtcXG5cXG5cXHRcXHQvLyBBcHBseSByZWxhdGl2ZSBvZmZzZXQgKCs9Ly09KSBpZiBzcGVjaWZpZWRcXG5cXHRcXHRhZGp1c3RlZCA9IHZhbHVlUGFydHNbIDEgXSA/XFxuXFx0XFx0XFx0aW5pdGlhbEluVW5pdCArICggdmFsdWVQYXJ0c1sgMSBdICsgMSApICogdmFsdWVQYXJ0c1sgMiBdIDpcXG5cXHRcXHRcXHQrdmFsdWVQYXJ0c1sgMiBdO1xcblxcdFxcdGlmICggdHdlZW4gKSB7XFxuXFx0XFx0XFx0dHdlZW4udW5pdCA9IHVuaXQ7XFxuXFx0XFx0XFx0dHdlZW4uc3RhcnQgPSBpbml0aWFsSW5Vbml0O1xcblxcdFxcdFxcdHR3ZWVuLmVuZCA9IGFkanVzdGVkO1xcblxcdFxcdH1cXG5cXHR9XFxuXFx0cmV0dXJuIGFkanVzdGVkO1xcbn1cXG5cXG5cXG52YXIgZGVmYXVsdERpc3BsYXlNYXAgPSB7fTtcXG5cXG5mdW5jdGlvbiBnZXREZWZhdWx0RGlzcGxheSggZWxlbSApIHtcXG5cXHR2YXIgdGVtcCxcXG5cXHRcXHRkb2MgPSBlbGVtLm93bmVyRG9jdW1lbnQsXFxuXFx0XFx0bm9kZU5hbWUgPSBlbGVtLm5vZGVOYW1lLFxcblxcdFxcdGRpc3BsYXkgPSBkZWZhdWx0RGlzcGxheU1hcFsgbm9kZU5hbWUgXTtcXG5cXG5cXHRpZiAoIGRpc3BsYXkgKSB7XFxuXFx0XFx0cmV0dXJuIGRpc3BsYXk7XFxuXFx0fVxcblxcblxcdHRlbXAgPSBkb2MuYm9keS5hcHBlbmRDaGlsZCggZG9jLmNyZWF0ZUVsZW1lbnQoIG5vZGVOYW1lICkgKTtcXG5cXHRkaXNwbGF5ID0galF1ZXJ5LmNzcyggdGVtcCwgXFxcImRpc3BsYXlcXFwiICk7XFxuXFxuXFx0dGVtcC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKCB0ZW1wICk7XFxuXFxuXFx0aWYgKCBkaXNwbGF5ID09PSBcXFwibm9uZVxcXCIgKSB7XFxuXFx0XFx0ZGlzcGxheSA9IFxcXCJibG9ja1xcXCI7XFxuXFx0fVxcblxcdGRlZmF1bHREaXNwbGF5TWFwWyBub2RlTmFtZSBdID0gZGlzcGxheTtcXG5cXG5cXHRyZXR1cm4gZGlzcGxheTtcXG59XFxuXFxuZnVuY3Rpb24gc2hvd0hpZGUoIGVsZW1lbnRzLCBzaG93ICkge1xcblxcdHZhciBkaXNwbGF5LCBlbGVtLFxcblxcdFxcdHZhbHVlcyA9IFtdLFxcblxcdFxcdGluZGV4ID0gMCxcXG5cXHRcXHRsZW5ndGggPSBlbGVtZW50cy5sZW5ndGg7XFxuXFxuXFx0Ly8gRGV0ZXJtaW5lIG5ldyBkaXNwbGF5IHZhbHVlIGZvciBlbGVtZW50cyB0aGF0IG5lZWQgdG8gY2hhbmdlXFxuXFx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcXG5cXHRcXHRlbGVtID0gZWxlbWVudHNbIGluZGV4IF07XFxuXFx0XFx0aWYgKCAhZWxlbS5zdHlsZSApIHtcXG5cXHRcXHRcXHRjb250aW51ZTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0ZGlzcGxheSA9IGVsZW0uc3R5bGUuZGlzcGxheTtcXG5cXHRcXHRpZiAoIHNob3cgKSB7XFxuXFxuXFx0XFx0XFx0Ly8gU2luY2Ugd2UgZm9yY2UgdmlzaWJpbGl0eSB1cG9uIGNhc2NhZGUtaGlkZGVuIGVsZW1lbnRzLCBhbiBpbW1lZGlhdGUgKGFuZCBzbG93KVxcblxcdFxcdFxcdC8vIGNoZWNrIGlzIHJlcXVpcmVkIGluIHRoaXMgZmlyc3QgbG9vcCB1bmxlc3Mgd2UgaGF2ZSBhIG5vbmVtcHR5IGRpc3BsYXkgdmFsdWUgKGVpdGhlclxcblxcdFxcdFxcdC8vIGlubGluZSBvciBhYm91dC10by1iZS1yZXN0b3JlZClcXG5cXHRcXHRcXHRpZiAoIGRpc3BsYXkgPT09IFxcXCJub25lXFxcIiApIHtcXG5cXHRcXHRcXHRcXHR2YWx1ZXNbIGluZGV4IF0gPSBkYXRhUHJpdi5nZXQoIGVsZW0sIFxcXCJkaXNwbGF5XFxcIiApIHx8IG51bGw7XFxuXFx0XFx0XFx0XFx0aWYgKCAhdmFsdWVzWyBpbmRleCBdICkge1xcblxcdFxcdFxcdFxcdFxcdGVsZW0uc3R5bGUuZGlzcGxheSA9IFxcXCJcXFwiO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0aWYgKCBlbGVtLnN0eWxlLmRpc3BsYXkgPT09IFxcXCJcXFwiICYmIGlzSGlkZGVuV2l0aGluVHJlZSggZWxlbSApICkge1xcblxcdFxcdFxcdFxcdHZhbHVlc1sgaW5kZXggXSA9IGdldERlZmF1bHREaXNwbGF5KCBlbGVtICk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0aWYgKCBkaXNwbGF5ICE9PSBcXFwibm9uZVxcXCIgKSB7XFxuXFx0XFx0XFx0XFx0dmFsdWVzWyBpbmRleCBdID0gXFxcIm5vbmVcXFwiO1xcblxcblxcdFxcdFxcdFxcdC8vIFJlbWVtYmVyIHdoYXQgd2UncmUgb3ZlcndyaXRpbmdcXG5cXHRcXHRcXHRcXHRkYXRhUHJpdi5zZXQoIGVsZW0sIFxcXCJkaXNwbGF5XFxcIiwgZGlzcGxheSApO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFx0fVxcblxcblxcdC8vIFNldCB0aGUgZGlzcGxheSBvZiB0aGUgZWxlbWVudHMgaW4gYSBzZWNvbmQgbG9vcCB0byBhdm9pZCBjb25zdGFudCByZWZsb3dcXG5cXHRmb3IgKCBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xcblxcdFxcdGlmICggdmFsdWVzWyBpbmRleCBdICE9IG51bGwgKSB7XFxuXFx0XFx0XFx0ZWxlbWVudHNbIGluZGV4IF0uc3R5bGUuZGlzcGxheSA9IHZhbHVlc1sgaW5kZXggXTtcXG5cXHRcXHR9XFxuXFx0fVxcblxcblxcdHJldHVybiBlbGVtZW50cztcXG59XFxuXFxualF1ZXJ5LmZuLmV4dGVuZCgge1xcblxcdHNob3c6IGZ1bmN0aW9uKCkge1xcblxcdFxcdHJldHVybiBzaG93SGlkZSggdGhpcywgdHJ1ZSApO1xcblxcdH0sXFxuXFx0aGlkZTogZnVuY3Rpb24oKSB7XFxuXFx0XFx0cmV0dXJuIHNob3dIaWRlKCB0aGlzICk7XFxuXFx0fSxcXG5cXHR0b2dnbGU6IGZ1bmN0aW9uKCBzdGF0ZSApIHtcXG5cXHRcXHRpZiAoIHR5cGVvZiBzdGF0ZSA9PT0gXFxcImJvb2xlYW5cXFwiICkge1xcblxcdFxcdFxcdHJldHVybiBzdGF0ZSA/IHRoaXMuc2hvdygpIDogdGhpcy5oaWRlKCk7XFxuXFx0XFx0fVxcblxcblxcdFxcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdGlmICggaXNIaWRkZW5XaXRoaW5UcmVlKCB0aGlzICkgKSB7XFxuXFx0XFx0XFx0XFx0alF1ZXJ5KCB0aGlzICkuc2hvdygpO1xcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0alF1ZXJ5KCB0aGlzICkuaGlkZSgpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9ICk7XFxuXFx0fVxcbn0gKTtcXG52YXIgcmNoZWNrYWJsZVR5cGUgPSAoIC9eKD86Y2hlY2tib3h8cmFkaW8pJC9pICk7XFxuXFxudmFyIHJ0YWdOYW1lID0gKCAvPChbYS16XVteXFxcXC9cXFxcMD5cXFxceDIwXFxcXHRcXFxcclxcXFxuXFxcXGZdKykvaSApO1xcblxcbnZhciByc2NyaXB0VHlwZSA9ICggL14kfF5tb2R1bGUkfFxcXFwvKD86amF2YXxlY21hKXNjcmlwdC9pICk7XFxuXFxuXFxuXFxuLy8gV2UgaGF2ZSB0byBjbG9zZSB0aGVzZSB0YWdzIHRvIHN1cHBvcnQgWEhUTUwgKCMxMzIwMClcXG52YXIgd3JhcE1hcCA9IHtcXG5cXG5cXHQvLyBTdXBwb3J0OiBJRSA8PTkgb25seVxcblxcdG9wdGlvbjogWyAxLCBcXFwiPHNlbGVjdCBtdWx0aXBsZT0nbXVsdGlwbGUnPlxcXCIsIFxcXCI8L3NlbGVjdD5cXFwiIF0sXFxuXFxuXFx0Ly8gWEhUTUwgcGFyc2VycyBkbyBub3QgbWFnaWNhbGx5IGluc2VydCBlbGVtZW50cyBpbiB0aGVcXG5cXHQvLyBzYW1lIHdheSB0aGF0IHRhZyBzb3VwIHBhcnNlcnMgZG8uIFNvIHdlIGNhbm5vdCBzaG9ydGVuXFxuXFx0Ly8gdGhpcyBieSBvbWl0dGluZyA8dGJvZHk+IG9yIG90aGVyIHJlcXVpcmVkIGVsZW1lbnRzLlxcblxcdHRoZWFkOiBbIDEsIFxcXCI8dGFibGU+XFxcIiwgXFxcIjwvdGFibGU+XFxcIiBdLFxcblxcdGNvbDogWyAyLCBcXFwiPHRhYmxlPjxjb2xncm91cD5cXFwiLCBcXFwiPC9jb2xncm91cD48L3RhYmxlPlxcXCIgXSxcXG5cXHR0cjogWyAyLCBcXFwiPHRhYmxlPjx0Ym9keT5cXFwiLCBcXFwiPC90Ym9keT48L3RhYmxlPlxcXCIgXSxcXG5cXHR0ZDogWyAzLCBcXFwiPHRhYmxlPjx0Ym9keT48dHI+XFxcIiwgXFxcIjwvdHI+PC90Ym9keT48L3RhYmxlPlxcXCIgXSxcXG5cXG5cXHRfZGVmYXVsdDogWyAwLCBcXFwiXFxcIiwgXFxcIlxcXCIgXVxcbn07XFxuXFxuLy8gU3VwcG9ydDogSUUgPD05IG9ubHlcXG53cmFwTWFwLm9wdGdyb3VwID0gd3JhcE1hcC5vcHRpb247XFxuXFxud3JhcE1hcC50Ym9keSA9IHdyYXBNYXAudGZvb3QgPSB3cmFwTWFwLmNvbGdyb3VwID0gd3JhcE1hcC5jYXB0aW9uID0gd3JhcE1hcC50aGVhZDtcXG53cmFwTWFwLnRoID0gd3JhcE1hcC50ZDtcXG5cXG5cXG5mdW5jdGlvbiBnZXRBbGwoIGNvbnRleHQsIHRhZyApIHtcXG5cXG5cXHQvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSBvbmx5XFxuXFx0Ly8gVXNlIHR5cGVvZiB0byBhdm9pZCB6ZXJvLWFyZ3VtZW50IG1ldGhvZCBpbnZvY2F0aW9uIG9uIGhvc3Qgb2JqZWN0cyAoIzE1MTUxKVxcblxcdHZhciByZXQ7XFxuXFxuXFx0aWYgKCB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSAhPT0gXFxcInVuZGVmaW5lZFxcXCIgKSB7XFxuXFx0XFx0cmV0ID0gY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSggdGFnIHx8IFxcXCIqXFxcIiApO1xcblxcblxcdH0gZWxzZSBpZiAoIHR5cGVvZiBjb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwgIT09IFxcXCJ1bmRlZmluZWRcXFwiICkge1xcblxcdFxcdHJldCA9IGNvbnRleHQucXVlcnlTZWxlY3RvckFsbCggdGFnIHx8IFxcXCIqXFxcIiApO1xcblxcblxcdH0gZWxzZSB7XFxuXFx0XFx0cmV0ID0gW107XFxuXFx0fVxcblxcblxcdGlmICggdGFnID09PSB1bmRlZmluZWQgfHwgdGFnICYmIG5vZGVOYW1lKCBjb250ZXh0LCB0YWcgKSApIHtcXG5cXHRcXHRyZXR1cm4galF1ZXJ5Lm1lcmdlKCBbIGNvbnRleHQgXSwgcmV0ICk7XFxuXFx0fVxcblxcblxcdHJldHVybiByZXQ7XFxufVxcblxcblxcbi8vIE1hcmsgc2NyaXB0cyBhcyBoYXZpbmcgYWxyZWFkeSBiZWVuIGV2YWx1YXRlZFxcbmZ1bmN0aW9uIHNldEdsb2JhbEV2YWwoIGVsZW1zLCByZWZFbGVtZW50cyApIHtcXG5cXHR2YXIgaSA9IDAsXFxuXFx0XFx0bCA9IGVsZW1zLmxlbmd0aDtcXG5cXG5cXHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XFxuXFx0XFx0ZGF0YVByaXYuc2V0KFxcblxcdFxcdFxcdGVsZW1zWyBpIF0sXFxuXFx0XFx0XFx0XFxcImdsb2JhbEV2YWxcXFwiLFxcblxcdFxcdFxcdCFyZWZFbGVtZW50cyB8fCBkYXRhUHJpdi5nZXQoIHJlZkVsZW1lbnRzWyBpIF0sIFxcXCJnbG9iYWxFdmFsXFxcIiApXFxuXFx0XFx0KTtcXG5cXHR9XFxufVxcblxcblxcbnZhciByaHRtbCA9IC88fCYjP1xcXFx3KzsvO1xcblxcbmZ1bmN0aW9uIGJ1aWxkRnJhZ21lbnQoIGVsZW1zLCBjb250ZXh0LCBzY3JpcHRzLCBzZWxlY3Rpb24sIGlnbm9yZWQgKSB7XFxuXFx0dmFyIGVsZW0sIHRtcCwgdGFnLCB3cmFwLCBjb250YWlucywgaixcXG5cXHRcXHRmcmFnbWVudCA9IGNvbnRleHQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLFxcblxcdFxcdG5vZGVzID0gW10sXFxuXFx0XFx0aSA9IDAsXFxuXFx0XFx0bCA9IGVsZW1zLmxlbmd0aDtcXG5cXG5cXHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XFxuXFx0XFx0ZWxlbSA9IGVsZW1zWyBpIF07XFxuXFxuXFx0XFx0aWYgKCBlbGVtIHx8IGVsZW0gPT09IDAgKSB7XFxuXFxuXFx0XFx0XFx0Ly8gQWRkIG5vZGVzIGRpcmVjdGx5XFxuXFx0XFx0XFx0aWYgKCB0b1R5cGUoIGVsZW0gKSA9PT0gXFxcIm9iamVjdFxcXCIgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5LCBQaGFudG9tSlMgMSBvbmx5XFxuXFx0XFx0XFx0XFx0Ly8gcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93cyBvbiBhbmNpZW50IFdlYktpdFxcblxcdFxcdFxcdFxcdGpRdWVyeS5tZXJnZSggbm9kZXMsIGVsZW0ubm9kZVR5cGUgPyBbIGVsZW0gXSA6IGVsZW0gKTtcXG5cXG5cXHRcXHRcXHQvLyBDb252ZXJ0IG5vbi1odG1sIGludG8gYSB0ZXh0IG5vZGVcXG5cXHRcXHRcXHR9IGVsc2UgaWYgKCAhcmh0bWwudGVzdCggZWxlbSApICkge1xcblxcdFxcdFxcdFxcdG5vZGVzLnB1c2goIGNvbnRleHQuY3JlYXRlVGV4dE5vZGUoIGVsZW0gKSApO1xcblxcblxcdFxcdFxcdC8vIENvbnZlcnQgaHRtbCBpbnRvIERPTSBub2Rlc1xcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0dG1wID0gdG1wIHx8IGZyYWdtZW50LmFwcGVuZENoaWxkKCBjb250ZXh0LmNyZWF0ZUVsZW1lbnQoIFxcXCJkaXZcXFwiICkgKTtcXG5cXG5cXHRcXHRcXHRcXHQvLyBEZXNlcmlhbGl6ZSBhIHN0YW5kYXJkIHJlcHJlc2VudGF0aW9uXFxuXFx0XFx0XFx0XFx0dGFnID0gKCBydGFnTmFtZS5leGVjKCBlbGVtICkgfHwgWyBcXFwiXFxcIiwgXFxcIlxcXCIgXSApWyAxIF0udG9Mb3dlckNhc2UoKTtcXG5cXHRcXHRcXHRcXHR3cmFwID0gd3JhcE1hcFsgdGFnIF0gfHwgd3JhcE1hcC5fZGVmYXVsdDtcXG5cXHRcXHRcXHRcXHR0bXAuaW5uZXJIVE1MID0gd3JhcFsgMSBdICsgalF1ZXJ5Lmh0bWxQcmVmaWx0ZXIoIGVsZW0gKSArIHdyYXBbIDIgXTtcXG5cXG5cXHRcXHRcXHRcXHQvLyBEZXNjZW5kIHRocm91Z2ggd3JhcHBlcnMgdG8gdGhlIHJpZ2h0IGNvbnRlbnRcXG5cXHRcXHRcXHRcXHRqID0gd3JhcFsgMCBdO1xcblxcdFxcdFxcdFxcdHdoaWxlICggai0tICkge1xcblxcdFxcdFxcdFxcdFxcdHRtcCA9IHRtcC5sYXN0Q2hpbGQ7XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seSwgUGhhbnRvbUpTIDEgb25seVxcblxcdFxcdFxcdFxcdC8vIHB1c2guYXBwbHkoXywgYXJyYXlsaWtlKSB0aHJvd3Mgb24gYW5jaWVudCBXZWJLaXRcXG5cXHRcXHRcXHRcXHRqUXVlcnkubWVyZ2UoIG5vZGVzLCB0bXAuY2hpbGROb2RlcyApO1xcblxcblxcdFxcdFxcdFxcdC8vIFJlbWVtYmVyIHRoZSB0b3AtbGV2ZWwgY29udGFpbmVyXFxuXFx0XFx0XFx0XFx0dG1wID0gZnJhZ21lbnQuZmlyc3RDaGlsZDtcXG5cXG5cXHRcXHRcXHRcXHQvLyBFbnN1cmUgdGhlIGNyZWF0ZWQgbm9kZXMgYXJlIG9ycGhhbmVkICgjMTIzOTIpXFxuXFx0XFx0XFx0XFx0dG1wLnRleHRDb250ZW50ID0gXFxcIlxcXCI7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXHR9XFxuXFxuXFx0Ly8gUmVtb3ZlIHdyYXBwZXIgZnJvbSBmcmFnbWVudFxcblxcdGZyYWdtZW50LnRleHRDb250ZW50ID0gXFxcIlxcXCI7XFxuXFxuXFx0aSA9IDA7XFxuXFx0d2hpbGUgKCAoIGVsZW0gPSBub2Rlc1sgaSsrIF0gKSApIHtcXG5cXG5cXHRcXHQvLyBTa2lwIGVsZW1lbnRzIGFscmVhZHkgaW4gdGhlIGNvbnRleHQgY29sbGVjdGlvbiAodHJhYy00MDg3KVxcblxcdFxcdGlmICggc2VsZWN0aW9uICYmIGpRdWVyeS5pbkFycmF5KCBlbGVtLCBzZWxlY3Rpb24gKSA+IC0xICkge1xcblxcdFxcdFxcdGlmICggaWdub3JlZCApIHtcXG5cXHRcXHRcXHRcXHRpZ25vcmVkLnB1c2goIGVsZW0gKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0Y29udGludWU7XFxuXFx0XFx0fVxcblxcblxcdFxcdGNvbnRhaW5zID0galF1ZXJ5LmNvbnRhaW5zKCBlbGVtLm93bmVyRG9jdW1lbnQsIGVsZW0gKTtcXG5cXG5cXHRcXHQvLyBBcHBlbmQgdG8gZnJhZ21lbnRcXG5cXHRcXHR0bXAgPSBnZXRBbGwoIGZyYWdtZW50LmFwcGVuZENoaWxkKCBlbGVtICksIFxcXCJzY3JpcHRcXFwiICk7XFxuXFxuXFx0XFx0Ly8gUHJlc2VydmUgc2NyaXB0IGV2YWx1YXRpb24gaGlzdG9yeVxcblxcdFxcdGlmICggY29udGFpbnMgKSB7XFxuXFx0XFx0XFx0c2V0R2xvYmFsRXZhbCggdG1wICk7XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIENhcHR1cmUgZXhlY3V0YWJsZXNcXG5cXHRcXHRpZiAoIHNjcmlwdHMgKSB7XFxuXFx0XFx0XFx0aiA9IDA7XFxuXFx0XFx0XFx0d2hpbGUgKCAoIGVsZW0gPSB0bXBbIGorKyBdICkgKSB7XFxuXFx0XFx0XFx0XFx0aWYgKCByc2NyaXB0VHlwZS50ZXN0KCBlbGVtLnR5cGUgfHwgXFxcIlxcXCIgKSApIHtcXG5cXHRcXHRcXHRcXHRcXHRzY3JpcHRzLnB1c2goIGVsZW0gKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXHR9XFxuXFxuXFx0cmV0dXJuIGZyYWdtZW50O1xcbn1cXG5cXG5cXG4oIGZ1bmN0aW9uKCkge1xcblxcdHZhciBmcmFnbWVudCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSxcXG5cXHRcXHRkaXYgPSBmcmFnbWVudC5hcHBlbmRDaGlsZCggZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXFxcImRpdlxcXCIgKSApLFxcblxcdFxcdGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXFxcImlucHV0XFxcIiApO1xcblxcblxcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgNC4wIC0gNC4zIG9ubHlcXG5cXHQvLyBDaGVjayBzdGF0ZSBsb3N0IGlmIHRoZSBuYW1lIGlzIHNldCAoIzExMjE3KVxcblxcdC8vIFN1cHBvcnQ6IFdpbmRvd3MgV2ViIEFwcHMgKFdXQSlcXG5cXHQvLyBgbmFtZWAgYW5kIGB0eXBlYCBtdXN0IHVzZSAuc2V0QXR0cmlidXRlIGZvciBXV0EgKCMxNDkwMSlcXG5cXHRpbnB1dC5zZXRBdHRyaWJ1dGUoIFxcXCJ0eXBlXFxcIiwgXFxcInJhZGlvXFxcIiApO1xcblxcdGlucHV0LnNldEF0dHJpYnV0ZSggXFxcImNoZWNrZWRcXFwiLCBcXFwiY2hlY2tlZFxcXCIgKTtcXG5cXHRpbnB1dC5zZXRBdHRyaWJ1dGUoIFxcXCJuYW1lXFxcIiwgXFxcInRcXFwiICk7XFxuXFxuXFx0ZGl2LmFwcGVuZENoaWxkKCBpbnB1dCApO1xcblxcblxcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjEgb25seVxcblxcdC8vIE9sZGVyIFdlYktpdCBkb2Vzbid0IGNsb25lIGNoZWNrZWQgc3RhdGUgY29ycmVjdGx5IGluIGZyYWdtZW50c1xcblxcdHN1cHBvcnQuY2hlY2tDbG9uZSA9IGRpdi5jbG9uZU5vZGUoIHRydWUgKS5jbG9uZU5vZGUoIHRydWUgKS5sYXN0Q2hpbGQuY2hlY2tlZDtcXG5cXG5cXHQvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcXG5cXHQvLyBNYWtlIHN1cmUgdGV4dGFyZWEgKGFuZCBjaGVja2JveCkgZGVmYXVsdFZhbHVlIGlzIHByb3Blcmx5IGNsb25lZFxcblxcdGRpdi5pbm5lckhUTUwgPSBcXFwiPHRleHRhcmVhPng8L3RleHRhcmVhPlxcXCI7XFxuXFx0c3VwcG9ydC5ub0Nsb25lQ2hlY2tlZCA9ICEhZGl2LmNsb25lTm9kZSggdHJ1ZSApLmxhc3RDaGlsZC5kZWZhdWx0VmFsdWU7XFxufSApKCk7XFxudmFyIGRvY3VtZW50RWxlbWVudCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcXG5cXG5cXG5cXG52YXJcXG5cXHRya2V5RXZlbnQgPSAvXmtleS8sXFxuXFx0cm1vdXNlRXZlbnQgPSAvXig/Om1vdXNlfHBvaW50ZXJ8Y29udGV4dG1lbnV8ZHJhZ3xkcm9wKXxjbGljay8sXFxuXFx0cnR5cGVuYW1lc3BhY2UgPSAvXihbXi5dKikoPzpcXFxcLiguKyl8KS87XFxuXFxuZnVuY3Rpb24gcmV0dXJuVHJ1ZSgpIHtcXG5cXHRyZXR1cm4gdHJ1ZTtcXG59XFxuXFxuZnVuY3Rpb24gcmV0dXJuRmFsc2UoKSB7XFxuXFx0cmV0dXJuIGZhbHNlO1xcbn1cXG5cXG4vLyBTdXBwb3J0OiBJRSA8PTkgb25seVxcbi8vIFNlZSAjMTMzOTMgZm9yIG1vcmUgaW5mb1xcbmZ1bmN0aW9uIHNhZmVBY3RpdmVFbGVtZW50KCkge1xcblxcdHRyeSB7XFxuXFx0XFx0cmV0dXJuIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XFxuXFx0fSBjYXRjaCAoIGVyciApIHsgfVxcbn1cXG5cXG5mdW5jdGlvbiBvbiggZWxlbSwgdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiwgb25lICkge1xcblxcdHZhciBvcmlnRm4sIHR5cGU7XFxuXFxuXFx0Ly8gVHlwZXMgY2FuIGJlIGEgbWFwIG9mIHR5cGVzL2hhbmRsZXJzXFxuXFx0aWYgKCB0eXBlb2YgdHlwZXMgPT09IFxcXCJvYmplY3RcXFwiICkge1xcblxcblxcdFxcdC8vICggdHlwZXMtT2JqZWN0LCBzZWxlY3RvciwgZGF0YSApXFxuXFx0XFx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgIT09IFxcXCJzdHJpbmdcXFwiICkge1xcblxcblxcdFxcdFxcdC8vICggdHlwZXMtT2JqZWN0LCBkYXRhIClcXG5cXHRcXHRcXHRkYXRhID0gZGF0YSB8fCBzZWxlY3RvcjtcXG5cXHRcXHRcXHRzZWxlY3RvciA9IHVuZGVmaW5lZDtcXG5cXHRcXHR9XFxuXFx0XFx0Zm9yICggdHlwZSBpbiB0eXBlcyApIHtcXG5cXHRcXHRcXHRvbiggZWxlbSwgdHlwZSwgc2VsZWN0b3IsIGRhdGEsIHR5cGVzWyB0eXBlIF0sIG9uZSApO1xcblxcdFxcdH1cXG5cXHRcXHRyZXR1cm4gZWxlbTtcXG5cXHR9XFxuXFxuXFx0aWYgKCBkYXRhID09IG51bGwgJiYgZm4gPT0gbnVsbCApIHtcXG5cXG5cXHRcXHQvLyAoIHR5cGVzLCBmbiApXFxuXFx0XFx0Zm4gPSBzZWxlY3RvcjtcXG5cXHRcXHRkYXRhID0gc2VsZWN0b3IgPSB1bmRlZmluZWQ7XFxuXFx0fSBlbHNlIGlmICggZm4gPT0gbnVsbCApIHtcXG5cXHRcXHRpZiAoIHR5cGVvZiBzZWxlY3RvciA9PT0gXFxcInN0cmluZ1xcXCIgKSB7XFxuXFxuXFx0XFx0XFx0Ly8gKCB0eXBlcywgc2VsZWN0b3IsIGZuIClcXG5cXHRcXHRcXHRmbiA9IGRhdGE7XFxuXFx0XFx0XFx0ZGF0YSA9IHVuZGVmaW5lZDtcXG5cXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdC8vICggdHlwZXMsIGRhdGEsIGZuIClcXG5cXHRcXHRcXHRmbiA9IGRhdGE7XFxuXFx0XFx0XFx0ZGF0YSA9IHNlbGVjdG9yO1xcblxcdFxcdFxcdHNlbGVjdG9yID0gdW5kZWZpbmVkO1xcblxcdFxcdH1cXG5cXHR9XFxuXFx0aWYgKCBmbiA9PT0gZmFsc2UgKSB7XFxuXFx0XFx0Zm4gPSByZXR1cm5GYWxzZTtcXG5cXHR9IGVsc2UgaWYgKCAhZm4gKSB7XFxuXFx0XFx0cmV0dXJuIGVsZW07XFxuXFx0fVxcblxcblxcdGlmICggb25lID09PSAxICkge1xcblxcdFxcdG9yaWdGbiA9IGZuO1xcblxcdFxcdGZuID0gZnVuY3Rpb24oIGV2ZW50ICkge1xcblxcblxcdFxcdFxcdC8vIENhbiB1c2UgYW4gZW1wdHkgc2V0LCBzaW5jZSBldmVudCBjb250YWlucyB0aGUgaW5mb1xcblxcdFxcdFxcdGpRdWVyeSgpLm9mZiggZXZlbnQgKTtcXG5cXHRcXHRcXHRyZXR1cm4gb3JpZ0ZuLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcXG5cXHRcXHR9O1xcblxcblxcdFxcdC8vIFVzZSBzYW1lIGd1aWQgc28gY2FsbGVyIGNhbiByZW1vdmUgdXNpbmcgb3JpZ0ZuXFxuXFx0XFx0Zm4uZ3VpZCA9IG9yaWdGbi5ndWlkIHx8ICggb3JpZ0ZuLmd1aWQgPSBqUXVlcnkuZ3VpZCsrICk7XFxuXFx0fVxcblxcdHJldHVybiBlbGVtLmVhY2goIGZ1bmN0aW9uKCkge1xcblxcdFxcdGpRdWVyeS5ldmVudC5hZGQoIHRoaXMsIHR5cGVzLCBmbiwgZGF0YSwgc2VsZWN0b3IgKTtcXG5cXHR9ICk7XFxufVxcblxcbi8qXFxuICogSGVscGVyIGZ1bmN0aW9ucyBmb3IgbWFuYWdpbmcgZXZlbnRzIC0tIG5vdCBwYXJ0IG9mIHRoZSBwdWJsaWMgaW50ZXJmYWNlLlxcbiAqIFByb3BzIHRvIERlYW4gRWR3YXJkcycgYWRkRXZlbnQgbGlicmFyeSBmb3IgbWFueSBvZiB0aGUgaWRlYXMuXFxuICovXFxualF1ZXJ5LmV2ZW50ID0ge1xcblxcblxcdGdsb2JhbDoge30sXFxuXFxuXFx0YWRkOiBmdW5jdGlvbiggZWxlbSwgdHlwZXMsIGhhbmRsZXIsIGRhdGEsIHNlbGVjdG9yICkge1xcblxcblxcdFxcdHZhciBoYW5kbGVPYmpJbiwgZXZlbnRIYW5kbGUsIHRtcCxcXG5cXHRcXHRcXHRldmVudHMsIHQsIGhhbmRsZU9iaixcXG5cXHRcXHRcXHRzcGVjaWFsLCBoYW5kbGVycywgdHlwZSwgbmFtZXNwYWNlcywgb3JpZ1R5cGUsXFxuXFx0XFx0XFx0ZWxlbURhdGEgPSBkYXRhUHJpdi5nZXQoIGVsZW0gKTtcXG5cXG5cXHRcXHQvLyBEb24ndCBhdHRhY2ggZXZlbnRzIHRvIG5vRGF0YSBvciB0ZXh0L2NvbW1lbnQgbm9kZXMgKGJ1dCBhbGxvdyBwbGFpbiBvYmplY3RzKVxcblxcdFxcdGlmICggIWVsZW1EYXRhICkge1xcblxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gQ2FsbGVyIGNhbiBwYXNzIGluIGFuIG9iamVjdCBvZiBjdXN0b20gZGF0YSBpbiBsaWV1IG9mIHRoZSBoYW5kbGVyXFxuXFx0XFx0aWYgKCBoYW5kbGVyLmhhbmRsZXIgKSB7XFxuXFx0XFx0XFx0aGFuZGxlT2JqSW4gPSBoYW5kbGVyO1xcblxcdFxcdFxcdGhhbmRsZXIgPSBoYW5kbGVPYmpJbi5oYW5kbGVyO1xcblxcdFxcdFxcdHNlbGVjdG9yID0gaGFuZGxlT2JqSW4uc2VsZWN0b3I7XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIEVuc3VyZSB0aGF0IGludmFsaWQgc2VsZWN0b3JzIHRocm93IGV4Y2VwdGlvbnMgYXQgYXR0YWNoIHRpbWVcXG5cXHRcXHQvLyBFdmFsdWF0ZSBhZ2FpbnN0IGRvY3VtZW50RWxlbWVudCBpbiBjYXNlIGVsZW0gaXMgYSBub24tZWxlbWVudCBub2RlIChlLmcuLCBkb2N1bWVudClcXG5cXHRcXHRpZiAoIHNlbGVjdG9yICkge1xcblxcdFxcdFxcdGpRdWVyeS5maW5kLm1hdGNoZXNTZWxlY3RvciggZG9jdW1lbnRFbGVtZW50LCBzZWxlY3RvciApO1xcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBNYWtlIHN1cmUgdGhhdCB0aGUgaGFuZGxlciBoYXMgYSB1bmlxdWUgSUQsIHVzZWQgdG8gZmluZC9yZW1vdmUgaXQgbGF0ZXJcXG5cXHRcXHRpZiAoICFoYW5kbGVyLmd1aWQgKSB7XFxuXFx0XFx0XFx0aGFuZGxlci5ndWlkID0galF1ZXJ5Lmd1aWQrKztcXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gSW5pdCB0aGUgZWxlbWVudCdzIGV2ZW50IHN0cnVjdHVyZSBhbmQgbWFpbiBoYW5kbGVyLCBpZiB0aGlzIGlzIHRoZSBmaXJzdFxcblxcdFxcdGlmICggISggZXZlbnRzID0gZWxlbURhdGEuZXZlbnRzICkgKSB7XFxuXFx0XFx0XFx0ZXZlbnRzID0gZWxlbURhdGEuZXZlbnRzID0ge307XFxuXFx0XFx0fVxcblxcdFxcdGlmICggISggZXZlbnRIYW5kbGUgPSBlbGVtRGF0YS5oYW5kbGUgKSApIHtcXG5cXHRcXHRcXHRldmVudEhhbmRsZSA9IGVsZW1EYXRhLmhhbmRsZSA9IGZ1bmN0aW9uKCBlICkge1xcblxcblxcdFxcdFxcdFxcdC8vIERpc2NhcmQgdGhlIHNlY29uZCBldmVudCBvZiBhIGpRdWVyeS5ldmVudC50cmlnZ2VyKCkgYW5kXFxuXFx0XFx0XFx0XFx0Ly8gd2hlbiBhbiBldmVudCBpcyBjYWxsZWQgYWZ0ZXIgYSBwYWdlIGhhcyB1bmxvYWRlZFxcblxcdFxcdFxcdFxcdHJldHVybiB0eXBlb2YgalF1ZXJ5ICE9PSBcXFwidW5kZWZpbmVkXFxcIiAmJiBqUXVlcnkuZXZlbnQudHJpZ2dlcmVkICE9PSBlLnR5cGUgP1xcblxcdFxcdFxcdFxcdFxcdGpRdWVyeS5ldmVudC5kaXNwYXRjaC5hcHBseSggZWxlbSwgYXJndW1lbnRzICkgOiB1bmRlZmluZWQ7XFxuXFx0XFx0XFx0fTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gSGFuZGxlIG11bHRpcGxlIGV2ZW50cyBzZXBhcmF0ZWQgYnkgYSBzcGFjZVxcblxcdFxcdHR5cGVzID0gKCB0eXBlcyB8fCBcXFwiXFxcIiApLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgWyBcXFwiXFxcIiBdO1xcblxcdFxcdHQgPSB0eXBlcy5sZW5ndGg7XFxuXFx0XFx0d2hpbGUgKCB0LS0gKSB7XFxuXFx0XFx0XFx0dG1wID0gcnR5cGVuYW1lc3BhY2UuZXhlYyggdHlwZXNbIHQgXSApIHx8IFtdO1xcblxcdFxcdFxcdHR5cGUgPSBvcmlnVHlwZSA9IHRtcFsgMSBdO1xcblxcdFxcdFxcdG5hbWVzcGFjZXMgPSAoIHRtcFsgMiBdIHx8IFxcXCJcXFwiICkuc3BsaXQoIFxcXCIuXFxcIiApLnNvcnQoKTtcXG5cXG5cXHRcXHRcXHQvLyBUaGVyZSAqbXVzdCogYmUgYSB0eXBlLCBubyBhdHRhY2hpbmcgbmFtZXNwYWNlLW9ubHkgaGFuZGxlcnNcXG5cXHRcXHRcXHRpZiAoICF0eXBlICkge1xcblxcdFxcdFxcdFxcdGNvbnRpbnVlO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBJZiBldmVudCBjaGFuZ2VzIGl0cyB0eXBlLCB1c2UgdGhlIHNwZWNpYWwgZXZlbnQgaGFuZGxlcnMgZm9yIHRoZSBjaGFuZ2VkIHR5cGVcXG5cXHRcXHRcXHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIHR5cGUgXSB8fCB7fTtcXG5cXG5cXHRcXHRcXHQvLyBJZiBzZWxlY3RvciBkZWZpbmVkLCBkZXRlcm1pbmUgc3BlY2lhbCBldmVudCBhcGkgdHlwZSwgb3RoZXJ3aXNlIGdpdmVuIHR5cGVcXG5cXHRcXHRcXHR0eXBlID0gKCBzZWxlY3RvciA/IHNwZWNpYWwuZGVsZWdhdGVUeXBlIDogc3BlY2lhbC5iaW5kVHlwZSApIHx8IHR5cGU7XFxuXFxuXFx0XFx0XFx0Ly8gVXBkYXRlIHNwZWNpYWwgYmFzZWQgb24gbmV3bHkgcmVzZXQgdHlwZVxcblxcdFxcdFxcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9O1xcblxcblxcdFxcdFxcdC8vIGhhbmRsZU9iaiBpcyBwYXNzZWQgdG8gYWxsIGV2ZW50IGhhbmRsZXJzXFxuXFx0XFx0XFx0aGFuZGxlT2JqID0galF1ZXJ5LmV4dGVuZCgge1xcblxcdFxcdFxcdFxcdHR5cGU6IHR5cGUsXFxuXFx0XFx0XFx0XFx0b3JpZ1R5cGU6IG9yaWdUeXBlLFxcblxcdFxcdFxcdFxcdGRhdGE6IGRhdGEsXFxuXFx0XFx0XFx0XFx0aGFuZGxlcjogaGFuZGxlcixcXG5cXHRcXHRcXHRcXHRndWlkOiBoYW5kbGVyLmd1aWQsXFxuXFx0XFx0XFx0XFx0c2VsZWN0b3I6IHNlbGVjdG9yLFxcblxcdFxcdFxcdFxcdG5lZWRzQ29udGV4dDogc2VsZWN0b3IgJiYgalF1ZXJ5LmV4cHIubWF0Y2gubmVlZHNDb250ZXh0LnRlc3QoIHNlbGVjdG9yICksXFxuXFx0XFx0XFx0XFx0bmFtZXNwYWNlOiBuYW1lc3BhY2VzLmpvaW4oIFxcXCIuXFxcIiApXFxuXFx0XFx0XFx0fSwgaGFuZGxlT2JqSW4gKTtcXG5cXG5cXHRcXHRcXHQvLyBJbml0IHRoZSBldmVudCBoYW5kbGVyIHF1ZXVlIGlmIHdlJ3JlIHRoZSBmaXJzdFxcblxcdFxcdFxcdGlmICggISggaGFuZGxlcnMgPSBldmVudHNbIHR5cGUgXSApICkge1xcblxcdFxcdFxcdFxcdGhhbmRsZXJzID0gZXZlbnRzWyB0eXBlIF0gPSBbXTtcXG5cXHRcXHRcXHRcXHRoYW5kbGVycy5kZWxlZ2F0ZUNvdW50ID0gMDtcXG5cXG5cXHRcXHRcXHRcXHQvLyBPbmx5IHVzZSBhZGRFdmVudExpc3RlbmVyIGlmIHRoZSBzcGVjaWFsIGV2ZW50cyBoYW5kbGVyIHJldHVybnMgZmFsc2VcXG5cXHRcXHRcXHRcXHRpZiAoICFzcGVjaWFsLnNldHVwIHx8XFxuXFx0XFx0XFx0XFx0XFx0c3BlY2lhbC5zZXR1cC5jYWxsKCBlbGVtLCBkYXRhLCBuYW1lc3BhY2VzLCBldmVudEhhbmRsZSApID09PSBmYWxzZSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRpZiAoIGVsZW0uYWRkRXZlbnRMaXN0ZW5lciApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRlbGVtLmFkZEV2ZW50TGlzdGVuZXIoIHR5cGUsIGV2ZW50SGFuZGxlICk7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKCBzcGVjaWFsLmFkZCApIHtcXG5cXHRcXHRcXHRcXHRzcGVjaWFsLmFkZC5jYWxsKCBlbGVtLCBoYW5kbGVPYmogKTtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoICFoYW5kbGVPYmouaGFuZGxlci5ndWlkICkge1xcblxcdFxcdFxcdFxcdFxcdGhhbmRsZU9iai5oYW5kbGVyLmd1aWQgPSBoYW5kbGVyLmd1aWQ7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBBZGQgdG8gdGhlIGVsZW1lbnQncyBoYW5kbGVyIGxpc3QsIGRlbGVnYXRlcyBpbiBmcm9udFxcblxcdFxcdFxcdGlmICggc2VsZWN0b3IgKSB7XFxuXFx0XFx0XFx0XFx0aGFuZGxlcnMuc3BsaWNlKCBoYW5kbGVycy5kZWxlZ2F0ZUNvdW50KyssIDAsIGhhbmRsZU9iaiApO1xcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0aGFuZGxlcnMucHVzaCggaGFuZGxlT2JqICk7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIEtlZXAgdHJhY2sgb2Ygd2hpY2ggZXZlbnRzIGhhdmUgZXZlciBiZWVuIHVzZWQsIGZvciBldmVudCBvcHRpbWl6YXRpb25cXG5cXHRcXHRcXHRqUXVlcnkuZXZlbnQuZ2xvYmFsWyB0eXBlIF0gPSB0cnVlO1xcblxcdFxcdH1cXG5cXG5cXHR9LFxcblxcblxcdC8vIERldGFjaCBhbiBldmVudCBvciBzZXQgb2YgZXZlbnRzIGZyb20gYW4gZWxlbWVudFxcblxcdHJlbW92ZTogZnVuY3Rpb24oIGVsZW0sIHR5cGVzLCBoYW5kbGVyLCBzZWxlY3RvciwgbWFwcGVkVHlwZXMgKSB7XFxuXFxuXFx0XFx0dmFyIGosIG9yaWdDb3VudCwgdG1wLFxcblxcdFxcdFxcdGV2ZW50cywgdCwgaGFuZGxlT2JqLFxcblxcdFxcdFxcdHNwZWNpYWwsIGhhbmRsZXJzLCB0eXBlLCBuYW1lc3BhY2VzLCBvcmlnVHlwZSxcXG5cXHRcXHRcXHRlbGVtRGF0YSA9IGRhdGFQcml2Lmhhc0RhdGEoIGVsZW0gKSAmJiBkYXRhUHJpdi5nZXQoIGVsZW0gKTtcXG5cXG5cXHRcXHRpZiAoICFlbGVtRGF0YSB8fCAhKCBldmVudHMgPSBlbGVtRGF0YS5ldmVudHMgKSApIHtcXG5cXHRcXHRcXHRyZXR1cm47XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIE9uY2UgZm9yIGVhY2ggdHlwZS5uYW1lc3BhY2UgaW4gdHlwZXM7IHR5cGUgbWF5IGJlIG9taXR0ZWRcXG5cXHRcXHR0eXBlcyA9ICggdHlwZXMgfHwgXFxcIlxcXCIgKS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFsgXFxcIlxcXCIgXTtcXG5cXHRcXHR0ID0gdHlwZXMubGVuZ3RoO1xcblxcdFxcdHdoaWxlICggdC0tICkge1xcblxcdFxcdFxcdHRtcCA9IHJ0eXBlbmFtZXNwYWNlLmV4ZWMoIHR5cGVzWyB0IF0gKSB8fCBbXTtcXG5cXHRcXHRcXHR0eXBlID0gb3JpZ1R5cGUgPSB0bXBbIDEgXTtcXG5cXHRcXHRcXHRuYW1lc3BhY2VzID0gKCB0bXBbIDIgXSB8fCBcXFwiXFxcIiApLnNwbGl0KCBcXFwiLlxcXCIgKS5zb3J0KCk7XFxuXFxuXFx0XFx0XFx0Ly8gVW5iaW5kIGFsbCBldmVudHMgKG9uIHRoaXMgbmFtZXNwYWNlLCBpZiBwcm92aWRlZCkgZm9yIHRoZSBlbGVtZW50XFxuXFx0XFx0XFx0aWYgKCAhdHlwZSApIHtcXG5cXHRcXHRcXHRcXHRmb3IgKCB0eXBlIGluIGV2ZW50cyApIHtcXG5cXHRcXHRcXHRcXHRcXHRqUXVlcnkuZXZlbnQucmVtb3ZlKCBlbGVtLCB0eXBlICsgdHlwZXNbIHQgXSwgaGFuZGxlciwgc2VsZWN0b3IsIHRydWUgKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0Y29udGludWU7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9O1xcblxcdFxcdFxcdHR5cGUgPSAoIHNlbGVjdG9yID8gc3BlY2lhbC5kZWxlZ2F0ZVR5cGUgOiBzcGVjaWFsLmJpbmRUeXBlICkgfHwgdHlwZTtcXG5cXHRcXHRcXHRoYW5kbGVycyA9IGV2ZW50c1sgdHlwZSBdIHx8IFtdO1xcblxcdFxcdFxcdHRtcCA9IHRtcFsgMiBdICYmXFxuXFx0XFx0XFx0XFx0bmV3IFJlZ0V4cCggXFxcIihefFxcXFxcXFxcLilcXFwiICsgbmFtZXNwYWNlcy5qb2luKCBcXFwiXFxcXFxcXFwuKD86LipcXFxcXFxcXC58KVxcXCIgKSArIFxcXCIoXFxcXFxcXFwufCQpXFxcIiApO1xcblxcblxcdFxcdFxcdC8vIFJlbW92ZSBtYXRjaGluZyBldmVudHNcXG5cXHRcXHRcXHRvcmlnQ291bnQgPSBqID0gaGFuZGxlcnMubGVuZ3RoO1xcblxcdFxcdFxcdHdoaWxlICggai0tICkge1xcblxcdFxcdFxcdFxcdGhhbmRsZU9iaiA9IGhhbmRsZXJzWyBqIF07XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCAoIG1hcHBlZFR5cGVzIHx8IG9yaWdUeXBlID09PSBoYW5kbGVPYmoub3JpZ1R5cGUgKSAmJlxcblxcdFxcdFxcdFxcdFxcdCggIWhhbmRsZXIgfHwgaGFuZGxlci5ndWlkID09PSBoYW5kbGVPYmouZ3VpZCApICYmXFxuXFx0XFx0XFx0XFx0XFx0KCAhdG1wIHx8IHRtcC50ZXN0KCBoYW5kbGVPYmoubmFtZXNwYWNlICkgKSAmJlxcblxcdFxcdFxcdFxcdFxcdCggIXNlbGVjdG9yIHx8IHNlbGVjdG9yID09PSBoYW5kbGVPYmouc2VsZWN0b3IgfHxcXG5cXHRcXHRcXHRcXHRcXHRcXHRzZWxlY3RvciA9PT0gXFxcIioqXFxcIiAmJiBoYW5kbGVPYmouc2VsZWN0b3IgKSApIHtcXG5cXHRcXHRcXHRcXHRcXHRoYW5kbGVycy5zcGxpY2UoIGosIDEgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRpZiAoIGhhbmRsZU9iai5zZWxlY3RvciApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRoYW5kbGVycy5kZWxlZ2F0ZUNvdW50LS07XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdGlmICggc3BlY2lhbC5yZW1vdmUgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0c3BlY2lhbC5yZW1vdmUuY2FsbCggZWxlbSwgaGFuZGxlT2JqICk7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gUmVtb3ZlIGdlbmVyaWMgZXZlbnQgaGFuZGxlciBpZiB3ZSByZW1vdmVkIHNvbWV0aGluZyBhbmQgbm8gbW9yZSBoYW5kbGVycyBleGlzdFxcblxcdFxcdFxcdC8vIChhdm9pZHMgcG90ZW50aWFsIGZvciBlbmRsZXNzIHJlY3Vyc2lvbiBkdXJpbmcgcmVtb3ZhbCBvZiBzcGVjaWFsIGV2ZW50IGhhbmRsZXJzKVxcblxcdFxcdFxcdGlmICggb3JpZ0NvdW50ICYmICFoYW5kbGVycy5sZW5ndGggKSB7XFxuXFx0XFx0XFx0XFx0aWYgKCAhc3BlY2lhbC50ZWFyZG93biB8fFxcblxcdFxcdFxcdFxcdFxcdHNwZWNpYWwudGVhcmRvd24uY2FsbCggZWxlbSwgbmFtZXNwYWNlcywgZWxlbURhdGEuaGFuZGxlICkgPT09IGZhbHNlICkge1xcblxcblxcdFxcdFxcdFxcdFxcdGpRdWVyeS5yZW1vdmVFdmVudCggZWxlbSwgdHlwZSwgZWxlbURhdGEuaGFuZGxlICk7XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdGRlbGV0ZSBldmVudHNbIHR5cGUgXTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIFJlbW92ZSBkYXRhIGFuZCB0aGUgZXhwYW5kbyBpZiBpdCdzIG5vIGxvbmdlciB1c2VkXFxuXFx0XFx0aWYgKCBqUXVlcnkuaXNFbXB0eU9iamVjdCggZXZlbnRzICkgKSB7XFxuXFx0XFx0XFx0ZGF0YVByaXYucmVtb3ZlKCBlbGVtLCBcXFwiaGFuZGxlIGV2ZW50c1xcXCIgKTtcXG5cXHRcXHR9XFxuXFx0fSxcXG5cXG5cXHRkaXNwYXRjaDogZnVuY3Rpb24oIG5hdGl2ZUV2ZW50ICkge1xcblxcblxcdFxcdC8vIE1ha2UgYSB3cml0YWJsZSBqUXVlcnkuRXZlbnQgZnJvbSB0aGUgbmF0aXZlIGV2ZW50IG9iamVjdFxcblxcdFxcdHZhciBldmVudCA9IGpRdWVyeS5ldmVudC5maXgoIG5hdGl2ZUV2ZW50ICk7XFxuXFxuXFx0XFx0dmFyIGksIGosIHJldCwgbWF0Y2hlZCwgaGFuZGxlT2JqLCBoYW5kbGVyUXVldWUsXFxuXFx0XFx0XFx0YXJncyA9IG5ldyBBcnJheSggYXJndW1lbnRzLmxlbmd0aCApLFxcblxcdFxcdFxcdGhhbmRsZXJzID0gKCBkYXRhUHJpdi5nZXQoIHRoaXMsIFxcXCJldmVudHNcXFwiICkgfHwge30gKVsgZXZlbnQudHlwZSBdIHx8IFtdLFxcblxcdFxcdFxcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgZXZlbnQudHlwZSBdIHx8IHt9O1xcblxcblxcdFxcdC8vIFVzZSB0aGUgZml4LWVkIGpRdWVyeS5FdmVudCByYXRoZXIgdGhhbiB0aGUgKHJlYWQtb25seSkgbmF0aXZlIGV2ZW50XFxuXFx0XFx0YXJnc1sgMCBdID0gZXZlbnQ7XFxuXFxuXFx0XFx0Zm9yICggaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKysgKSB7XFxuXFx0XFx0XFx0YXJnc1sgaSBdID0gYXJndW1lbnRzWyBpIF07XFxuXFx0XFx0fVxcblxcblxcdFxcdGV2ZW50LmRlbGVnYXRlVGFyZ2V0ID0gdGhpcztcXG5cXG5cXHRcXHQvLyBDYWxsIHRoZSBwcmVEaXNwYXRjaCBob29rIGZvciB0aGUgbWFwcGVkIHR5cGUsIGFuZCBsZXQgaXQgYmFpbCBpZiBkZXNpcmVkXFxuXFx0XFx0aWYgKCBzcGVjaWFsLnByZURpc3BhdGNoICYmIHNwZWNpYWwucHJlRGlzcGF0Y2guY2FsbCggdGhpcywgZXZlbnQgKSA9PT0gZmFsc2UgKSB7XFxuXFx0XFx0XFx0cmV0dXJuO1xcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBEZXRlcm1pbmUgaGFuZGxlcnNcXG5cXHRcXHRoYW5kbGVyUXVldWUgPSBqUXVlcnkuZXZlbnQuaGFuZGxlcnMuY2FsbCggdGhpcywgZXZlbnQsIGhhbmRsZXJzICk7XFxuXFxuXFx0XFx0Ly8gUnVuIGRlbGVnYXRlcyBmaXJzdDsgdGhleSBtYXkgd2FudCB0byBzdG9wIHByb3BhZ2F0aW9uIGJlbmVhdGggdXNcXG5cXHRcXHRpID0gMDtcXG5cXHRcXHR3aGlsZSAoICggbWF0Y2hlZCA9IGhhbmRsZXJRdWV1ZVsgaSsrIF0gKSAmJiAhZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSApIHtcXG5cXHRcXHRcXHRldmVudC5jdXJyZW50VGFyZ2V0ID0gbWF0Y2hlZC5lbGVtO1xcblxcblxcdFxcdFxcdGogPSAwO1xcblxcdFxcdFxcdHdoaWxlICggKCBoYW5kbGVPYmogPSBtYXRjaGVkLmhhbmRsZXJzWyBqKysgXSApICYmXFxuXFx0XFx0XFx0XFx0IWV2ZW50LmlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkKCkgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gVHJpZ2dlcmVkIGV2ZW50IG11c3QgZWl0aGVyIDEpIGhhdmUgbm8gbmFtZXNwYWNlLCBvciAyKSBoYXZlIG5hbWVzcGFjZShzKVxcblxcdFxcdFxcdFxcdC8vIGEgc3Vic2V0IG9yIGVxdWFsIHRvIHRob3NlIGluIHRoZSBib3VuZCBldmVudCAoYm90aCBjYW4gaGF2ZSBubyBuYW1lc3BhY2UpLlxcblxcdFxcdFxcdFxcdGlmICggIWV2ZW50LnJuYW1lc3BhY2UgfHwgZXZlbnQucm5hbWVzcGFjZS50ZXN0KCBoYW5kbGVPYmoubmFtZXNwYWNlICkgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0ZXZlbnQuaGFuZGxlT2JqID0gaGFuZGxlT2JqO1xcblxcdFxcdFxcdFxcdFxcdGV2ZW50LmRhdGEgPSBoYW5kbGVPYmouZGF0YTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRyZXQgPSAoICggalF1ZXJ5LmV2ZW50LnNwZWNpYWxbIGhhbmRsZU9iai5vcmlnVHlwZSBdIHx8IHt9ICkuaGFuZGxlIHx8XFxuXFx0XFx0XFx0XFx0XFx0XFx0aGFuZGxlT2JqLmhhbmRsZXIgKS5hcHBseSggbWF0Y2hlZC5lbGVtLCBhcmdzICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCByZXQgIT09IHVuZGVmaW5lZCApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoICggZXZlbnQucmVzdWx0ID0gcmV0ICkgPT09IGZhbHNlICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0ZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBDYWxsIHRoZSBwb3N0RGlzcGF0Y2ggaG9vayBmb3IgdGhlIG1hcHBlZCB0eXBlXFxuXFx0XFx0aWYgKCBzcGVjaWFsLnBvc3REaXNwYXRjaCApIHtcXG5cXHRcXHRcXHRzcGVjaWFsLnBvc3REaXNwYXRjaC5jYWxsKCB0aGlzLCBldmVudCApO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRyZXR1cm4gZXZlbnQucmVzdWx0O1xcblxcdH0sXFxuXFxuXFx0aGFuZGxlcnM6IGZ1bmN0aW9uKCBldmVudCwgaGFuZGxlcnMgKSB7XFxuXFx0XFx0dmFyIGksIGhhbmRsZU9iaiwgc2VsLCBtYXRjaGVkSGFuZGxlcnMsIG1hdGNoZWRTZWxlY3RvcnMsXFxuXFx0XFx0XFx0aGFuZGxlclF1ZXVlID0gW10sXFxuXFx0XFx0XFx0ZGVsZWdhdGVDb3VudCA9IGhhbmRsZXJzLmRlbGVnYXRlQ291bnQsXFxuXFx0XFx0XFx0Y3VyID0gZXZlbnQudGFyZ2V0O1xcblxcblxcdFxcdC8vIEZpbmQgZGVsZWdhdGUgaGFuZGxlcnNcXG5cXHRcXHRpZiAoIGRlbGVnYXRlQ291bnQgJiZcXG5cXG5cXHRcXHRcXHQvLyBTdXBwb3J0OiBJRSA8PTlcXG5cXHRcXHRcXHQvLyBCbGFjay1ob2xlIFNWRyA8dXNlPiBpbnN0YW5jZSB0cmVlcyAodHJhYy0xMzE4MClcXG5cXHRcXHRcXHRjdXIubm9kZVR5cGUgJiZcXG5cXG5cXHRcXHRcXHQvLyBTdXBwb3J0OiBGaXJlZm94IDw9NDJcXG5cXHRcXHRcXHQvLyBTdXBwcmVzcyBzcGVjLXZpb2xhdGluZyBjbGlja3MgaW5kaWNhdGluZyBhIG5vbi1wcmltYXJ5IHBvaW50ZXIgYnV0dG9uICh0cmFjLTM4NjEpXFxuXFx0XFx0XFx0Ly8gaHR0cHM6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy8jZXZlbnQtdHlwZS1jbGlja1xcblxcdFxcdFxcdC8vIFN1cHBvcnQ6IElFIDExIG9ubHlcXG5cXHRcXHRcXHQvLyAuLi5idXQgbm90IGFycm93IGtleSBcXFwiY2xpY2tzXFxcIiBvZiByYWRpbyBpbnB1dHMsIHdoaWNoIGNhbiBoYXZlIGBidXR0b25gIC0xIChnaC0yMzQzKVxcblxcdFxcdFxcdCEoIGV2ZW50LnR5cGUgPT09IFxcXCJjbGlja1xcXCIgJiYgZXZlbnQuYnV0dG9uID49IDEgKSApIHtcXG5cXG5cXHRcXHRcXHRmb3IgKCA7IGN1ciAhPT0gdGhpczsgY3VyID0gY3VyLnBhcmVudE5vZGUgfHwgdGhpcyApIHtcXG5cXG5cXHRcXHRcXHRcXHQvLyBEb24ndCBjaGVjayBub24tZWxlbWVudHMgKCMxMzIwOClcXG5cXHRcXHRcXHRcXHQvLyBEb24ndCBwcm9jZXNzIGNsaWNrcyBvbiBkaXNhYmxlZCBlbGVtZW50cyAoIzY5MTEsICM4MTY1LCAjMTEzODIsICMxMTc2NClcXG5cXHRcXHRcXHRcXHRpZiAoIGN1ci5ub2RlVHlwZSA9PT0gMSAmJiAhKCBldmVudC50eXBlID09PSBcXFwiY2xpY2tcXFwiICYmIGN1ci5kaXNhYmxlZCA9PT0gdHJ1ZSApICkge1xcblxcdFxcdFxcdFxcdFxcdG1hdGNoZWRIYW5kbGVycyA9IFtdO1xcblxcdFxcdFxcdFxcdFxcdG1hdGNoZWRTZWxlY3RvcnMgPSB7fTtcXG5cXHRcXHRcXHRcXHRcXHRmb3IgKCBpID0gMDsgaSA8IGRlbGVnYXRlQ291bnQ7IGkrKyApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRoYW5kbGVPYmogPSBoYW5kbGVyc1sgaSBdO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdC8vIERvbid0IGNvbmZsaWN0IHdpdGggT2JqZWN0LnByb3RvdHlwZSBwcm9wZXJ0aWVzICgjMTMyMDMpXFxuXFx0XFx0XFx0XFx0XFx0XFx0c2VsID0gaGFuZGxlT2JqLnNlbGVjdG9yICsgXFxcIiBcXFwiO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGlmICggbWF0Y2hlZFNlbGVjdG9yc1sgc2VsIF0gPT09IHVuZGVmaW5lZCApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRtYXRjaGVkU2VsZWN0b3JzWyBzZWwgXSA9IGhhbmRsZU9iai5uZWVkc0NvbnRleHQgP1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGpRdWVyeSggc2VsLCB0aGlzICkuaW5kZXgoIGN1ciApID4gLTEgOlxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGpRdWVyeS5maW5kKCBzZWwsIHRoaXMsIG51bGwsIFsgY3VyIF0gKS5sZW5ndGg7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdGlmICggbWF0Y2hlZFNlbGVjdG9yc1sgc2VsIF0gKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0bWF0Y2hlZEhhbmRsZXJzLnB1c2goIGhhbmRsZU9iaiApO1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBtYXRjaGVkSGFuZGxlcnMubGVuZ3RoICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGhhbmRsZXJRdWV1ZS5wdXNoKCB7IGVsZW06IGN1ciwgaGFuZGxlcnM6IG1hdGNoZWRIYW5kbGVycyB9ICk7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIEFkZCB0aGUgcmVtYWluaW5nIChkaXJlY3RseS1ib3VuZCkgaGFuZGxlcnNcXG5cXHRcXHRjdXIgPSB0aGlzO1xcblxcdFxcdGlmICggZGVsZWdhdGVDb3VudCA8IGhhbmRsZXJzLmxlbmd0aCApIHtcXG5cXHRcXHRcXHRoYW5kbGVyUXVldWUucHVzaCggeyBlbGVtOiBjdXIsIGhhbmRsZXJzOiBoYW5kbGVycy5zbGljZSggZGVsZWdhdGVDb3VudCApIH0gKTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0cmV0dXJuIGhhbmRsZXJRdWV1ZTtcXG5cXHR9LFxcblxcblxcdGFkZFByb3A6IGZ1bmN0aW9uKCBuYW1lLCBob29rICkge1xcblxcdFxcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggalF1ZXJ5LkV2ZW50LnByb3RvdHlwZSwgbmFtZSwge1xcblxcdFxcdFxcdGVudW1lcmFibGU6IHRydWUsXFxuXFx0XFx0XFx0Y29uZmlndXJhYmxlOiB0cnVlLFxcblxcblxcdFxcdFxcdGdldDogaXNGdW5jdGlvbiggaG9vayApID9cXG5cXHRcXHRcXHRcXHRmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIHRoaXMub3JpZ2luYWxFdmVudCApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gaG9vayggdGhpcy5vcmlnaW5hbEV2ZW50ICk7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH0gOlxcblxcdFxcdFxcdFxcdGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdFxcdFxcdGlmICggdGhpcy5vcmlnaW5hbEV2ZW50ICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiB0aGlzLm9yaWdpbmFsRXZlbnRbIG5hbWUgXTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fSxcXG5cXG5cXHRcXHRcXHRzZXQ6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcXG5cXHRcXHRcXHRcXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIHRoaXMsIG5hbWUsIHtcXG5cXHRcXHRcXHRcXHRcXHRlbnVtZXJhYmxlOiB0cnVlLFxcblxcdFxcdFxcdFxcdFxcdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcXG5cXHRcXHRcXHRcXHRcXHR3cml0YWJsZTogdHJ1ZSxcXG5cXHRcXHRcXHRcXHRcXHR2YWx1ZTogdmFsdWVcXG5cXHRcXHRcXHRcXHR9ICk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH0gKTtcXG5cXHR9LFxcblxcblxcdGZpeDogZnVuY3Rpb24oIG9yaWdpbmFsRXZlbnQgKSB7XFxuXFx0XFx0cmV0dXJuIG9yaWdpbmFsRXZlbnRbIGpRdWVyeS5leHBhbmRvIF0gP1xcblxcdFxcdFxcdG9yaWdpbmFsRXZlbnQgOlxcblxcdFxcdFxcdG5ldyBqUXVlcnkuRXZlbnQoIG9yaWdpbmFsRXZlbnQgKTtcXG5cXHR9LFxcblxcblxcdHNwZWNpYWw6IHtcXG5cXHRcXHRsb2FkOiB7XFxuXFxuXFx0XFx0XFx0Ly8gUHJldmVudCB0cmlnZ2VyZWQgaW1hZ2UubG9hZCBldmVudHMgZnJvbSBidWJibGluZyB0byB3aW5kb3cubG9hZFxcblxcdFxcdFxcdG5vQnViYmxlOiB0cnVlXFxuXFx0XFx0fSxcXG5cXHRcXHRmb2N1czoge1xcblxcblxcdFxcdFxcdC8vIEZpcmUgbmF0aXZlIGV2ZW50IGlmIHBvc3NpYmxlIHNvIGJsdXIvZm9jdXMgc2VxdWVuY2UgaXMgY29ycmVjdFxcblxcdFxcdFxcdHRyaWdnZXI6IGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdFxcdGlmICggdGhpcyAhPT0gc2FmZUFjdGl2ZUVsZW1lbnQoKSAmJiB0aGlzLmZvY3VzICkge1xcblxcdFxcdFxcdFxcdFxcdHRoaXMuZm9jdXMoKTtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gZmFsc2U7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH0sXFxuXFx0XFx0XFx0ZGVsZWdhdGVUeXBlOiBcXFwiZm9jdXNpblxcXCJcXG5cXHRcXHR9LFxcblxcdFxcdGJsdXI6IHtcXG5cXHRcXHRcXHR0cmlnZ2VyOiBmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHRcXHRpZiAoIHRoaXMgPT09IHNhZmVBY3RpdmVFbGVtZW50KCkgJiYgdGhpcy5ibHVyICkge1xcblxcdFxcdFxcdFxcdFxcdHRoaXMuYmx1cigpO1xcblxcdFxcdFxcdFxcdFxcdHJldHVybiBmYWxzZTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fSxcXG5cXHRcXHRcXHRkZWxlZ2F0ZVR5cGU6IFxcXCJmb2N1c291dFxcXCJcXG5cXHRcXHR9LFxcblxcdFxcdGNsaWNrOiB7XFxuXFxuXFx0XFx0XFx0Ly8gRm9yIGNoZWNrYm94LCBmaXJlIG5hdGl2ZSBldmVudCBzbyBjaGVja2VkIHN0YXRlIHdpbGwgYmUgcmlnaHRcXG5cXHRcXHRcXHR0cmlnZ2VyOiBmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHRcXHRpZiAoIHRoaXMudHlwZSA9PT0gXFxcImNoZWNrYm94XFxcIiAmJiB0aGlzLmNsaWNrICYmIG5vZGVOYW1lKCB0aGlzLCBcXFwiaW5wdXRcXFwiICkgKSB7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5jbGljaygpO1xcblxcdFxcdFxcdFxcdFxcdHJldHVybiBmYWxzZTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fSxcXG5cXG5cXHRcXHRcXHQvLyBGb3IgY3Jvc3MtYnJvd3NlciBjb25zaXN0ZW5jeSwgZG9uJ3QgZmlyZSBuYXRpdmUgLmNsaWNrKCkgb24gbGlua3NcXG5cXHRcXHRcXHRfZGVmYXVsdDogZnVuY3Rpb24oIGV2ZW50ICkge1xcblxcdFxcdFxcdFxcdHJldHVybiBub2RlTmFtZSggZXZlbnQudGFyZ2V0LCBcXFwiYVxcXCIgKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRiZWZvcmV1bmxvYWQ6IHtcXG5cXHRcXHRcXHRwb3N0RGlzcGF0Y2g6IGZ1bmN0aW9uKCBldmVudCApIHtcXG5cXG5cXHRcXHRcXHRcXHQvLyBTdXBwb3J0OiBGaXJlZm94IDIwK1xcblxcdFxcdFxcdFxcdC8vIEZpcmVmb3ggZG9lc24ndCBhbGVydCBpZiB0aGUgcmV0dXJuVmFsdWUgZmllbGQgaXMgbm90IHNldC5cXG5cXHRcXHRcXHRcXHRpZiAoIGV2ZW50LnJlc3VsdCAhPT0gdW5kZWZpbmVkICYmIGV2ZW50Lm9yaWdpbmFsRXZlbnQgKSB7XFxuXFx0XFx0XFx0XFx0XFx0ZXZlbnQub3JpZ2luYWxFdmVudC5yZXR1cm5WYWx1ZSA9IGV2ZW50LnJlc3VsdDtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXHR9XFxufTtcXG5cXG5qUXVlcnkucmVtb3ZlRXZlbnQgPSBmdW5jdGlvbiggZWxlbSwgdHlwZSwgaGFuZGxlICkge1xcblxcblxcdC8vIFRoaXMgXFxcImlmXFxcIiBpcyBuZWVkZWQgZm9yIHBsYWluIG9iamVjdHNcXG5cXHRpZiAoIGVsZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lciApIHtcXG5cXHRcXHRlbGVtLnJlbW92ZUV2ZW50TGlzdGVuZXIoIHR5cGUsIGhhbmRsZSApO1xcblxcdH1cXG59O1xcblxcbmpRdWVyeS5FdmVudCA9IGZ1bmN0aW9uKCBzcmMsIHByb3BzICkge1xcblxcblxcdC8vIEFsbG93IGluc3RhbnRpYXRpb24gd2l0aG91dCB0aGUgJ25ldycga2V5d29yZFxcblxcdGlmICggISggdGhpcyBpbnN0YW5jZW9mIGpRdWVyeS5FdmVudCApICkge1xcblxcdFxcdHJldHVybiBuZXcgalF1ZXJ5LkV2ZW50KCBzcmMsIHByb3BzICk7XFxuXFx0fVxcblxcblxcdC8vIEV2ZW50IG9iamVjdFxcblxcdGlmICggc3JjICYmIHNyYy50eXBlICkge1xcblxcdFxcdHRoaXMub3JpZ2luYWxFdmVudCA9IHNyYztcXG5cXHRcXHR0aGlzLnR5cGUgPSBzcmMudHlwZTtcXG5cXG5cXHRcXHQvLyBFdmVudHMgYnViYmxpbmcgdXAgdGhlIGRvY3VtZW50IG1heSBoYXZlIGJlZW4gbWFya2VkIGFzIHByZXZlbnRlZFxcblxcdFxcdC8vIGJ5IGEgaGFuZGxlciBsb3dlciBkb3duIHRoZSB0cmVlOyByZWZsZWN0IHRoZSBjb3JyZWN0IHZhbHVlLlxcblxcdFxcdHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gc3JjLmRlZmF1bHRQcmV2ZW50ZWQgfHxcXG5cXHRcXHRcXHRcXHRzcmMuZGVmYXVsdFByZXZlbnRlZCA9PT0gdW5kZWZpbmVkICYmXFxuXFxuXFx0XFx0XFx0XFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTIuMyBvbmx5XFxuXFx0XFx0XFx0XFx0c3JjLnJldHVyblZhbHVlID09PSBmYWxzZSA/XFxuXFx0XFx0XFx0cmV0dXJuVHJ1ZSA6XFxuXFx0XFx0XFx0cmV0dXJuRmFsc2U7XFxuXFxuXFx0XFx0Ly8gQ3JlYXRlIHRhcmdldCBwcm9wZXJ0aWVzXFxuXFx0XFx0Ly8gU3VwcG9ydDogU2FmYXJpIDw9NiAtIDcgb25seVxcblxcdFxcdC8vIFRhcmdldCBzaG91bGQgbm90IGJlIGEgdGV4dCBub2RlICgjNTA0LCAjMTMxNDMpXFxuXFx0XFx0dGhpcy50YXJnZXQgPSAoIHNyYy50YXJnZXQgJiYgc3JjLnRhcmdldC5ub2RlVHlwZSA9PT0gMyApID9cXG5cXHRcXHRcXHRzcmMudGFyZ2V0LnBhcmVudE5vZGUgOlxcblxcdFxcdFxcdHNyYy50YXJnZXQ7XFxuXFxuXFx0XFx0dGhpcy5jdXJyZW50VGFyZ2V0ID0gc3JjLmN1cnJlbnRUYXJnZXQ7XFxuXFx0XFx0dGhpcy5yZWxhdGVkVGFyZ2V0ID0gc3JjLnJlbGF0ZWRUYXJnZXQ7XFxuXFxuXFx0Ly8gRXZlbnQgdHlwZVxcblxcdH0gZWxzZSB7XFxuXFx0XFx0dGhpcy50eXBlID0gc3JjO1xcblxcdH1cXG5cXG5cXHQvLyBQdXQgZXhwbGljaXRseSBwcm92aWRlZCBwcm9wZXJ0aWVzIG9udG8gdGhlIGV2ZW50IG9iamVjdFxcblxcdGlmICggcHJvcHMgKSB7XFxuXFx0XFx0alF1ZXJ5LmV4dGVuZCggdGhpcywgcHJvcHMgKTtcXG5cXHR9XFxuXFxuXFx0Ly8gQ3JlYXRlIGEgdGltZXN0YW1wIGlmIGluY29taW5nIGV2ZW50IGRvZXNuJ3QgaGF2ZSBvbmVcXG5cXHR0aGlzLnRpbWVTdGFtcCA9IHNyYyAmJiBzcmMudGltZVN0YW1wIHx8IERhdGUubm93KCk7XFxuXFxuXFx0Ly8gTWFyayBpdCBhcyBmaXhlZFxcblxcdHRoaXNbIGpRdWVyeS5leHBhbmRvIF0gPSB0cnVlO1xcbn07XFxuXFxuLy8galF1ZXJ5LkV2ZW50IGlzIGJhc2VkIG9uIERPTTMgRXZlbnRzIGFzIHNwZWNpZmllZCBieSB0aGUgRUNNQVNjcmlwdCBMYW5ndWFnZSBCaW5kaW5nXFxuLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSLzIwMDMvV0QtRE9NLUxldmVsLTMtRXZlbnRzLTIwMDMwMzMxL2VjbWEtc2NyaXB0LWJpbmRpbmcuaHRtbFxcbmpRdWVyeS5FdmVudC5wcm90b3R5cGUgPSB7XFxuXFx0Y29uc3RydWN0b3I6IGpRdWVyeS5FdmVudCxcXG5cXHRpc0RlZmF1bHRQcmV2ZW50ZWQ6IHJldHVybkZhbHNlLFxcblxcdGlzUHJvcGFnYXRpb25TdG9wcGVkOiByZXR1cm5GYWxzZSxcXG5cXHRpc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZDogcmV0dXJuRmFsc2UsXFxuXFx0aXNTaW11bGF0ZWQ6IGZhbHNlLFxcblxcblxcdHByZXZlbnREZWZhdWx0OiBmdW5jdGlvbigpIHtcXG5cXHRcXHR2YXIgZSA9IHRoaXMub3JpZ2luYWxFdmVudDtcXG5cXG5cXHRcXHR0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IHJldHVyblRydWU7XFxuXFxuXFx0XFx0aWYgKCBlICYmICF0aGlzLmlzU2ltdWxhdGVkICkge1xcblxcdFxcdFxcdGUucHJldmVudERlZmF1bHQoKTtcXG5cXHRcXHR9XFxuXFx0fSxcXG5cXHRzdG9wUHJvcGFnYXRpb246IGZ1bmN0aW9uKCkge1xcblxcdFxcdHZhciBlID0gdGhpcy5vcmlnaW5hbEV2ZW50O1xcblxcblxcdFxcdHRoaXMuaXNQcm9wYWdhdGlvblN0b3BwZWQgPSByZXR1cm5UcnVlO1xcblxcblxcdFxcdGlmICggZSAmJiAhdGhpcy5pc1NpbXVsYXRlZCApIHtcXG5cXHRcXHRcXHRlLnN0b3BQcm9wYWdhdGlvbigpO1xcblxcdFxcdH1cXG5cXHR9LFxcblxcdHN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbjogZnVuY3Rpb24oKSB7XFxuXFx0XFx0dmFyIGUgPSB0aGlzLm9yaWdpbmFsRXZlbnQ7XFxuXFxuXFx0XFx0dGhpcy5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCA9IHJldHVyblRydWU7XFxuXFxuXFx0XFx0aWYgKCBlICYmICF0aGlzLmlzU2ltdWxhdGVkICkge1xcblxcdFxcdFxcdGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XFxuXFx0XFx0fVxcblxcblxcdFxcdHRoaXMuc3RvcFByb3BhZ2F0aW9uKCk7XFxuXFx0fVxcbn07XFxuXFxuLy8gSW5jbHVkZXMgYWxsIGNvbW1vbiBldmVudCBwcm9wcyBpbmNsdWRpbmcgS2V5RXZlbnQgYW5kIE1vdXNlRXZlbnQgc3BlY2lmaWMgcHJvcHNcXG5qUXVlcnkuZWFjaCgge1xcblxcdGFsdEtleTogdHJ1ZSxcXG5cXHRidWJibGVzOiB0cnVlLFxcblxcdGNhbmNlbGFibGU6IHRydWUsXFxuXFx0Y2hhbmdlZFRvdWNoZXM6IHRydWUsXFxuXFx0Y3RybEtleTogdHJ1ZSxcXG5cXHRkZXRhaWw6IHRydWUsXFxuXFx0ZXZlbnRQaGFzZTogdHJ1ZSxcXG5cXHRtZXRhS2V5OiB0cnVlLFxcblxcdHBhZ2VYOiB0cnVlLFxcblxcdHBhZ2VZOiB0cnVlLFxcblxcdHNoaWZ0S2V5OiB0cnVlLFxcblxcdHZpZXc6IHRydWUsXFxuXFx0XFxcImNoYXJcXFwiOiB0cnVlLFxcblxcdGNoYXJDb2RlOiB0cnVlLFxcblxcdGtleTogdHJ1ZSxcXG5cXHRrZXlDb2RlOiB0cnVlLFxcblxcdGJ1dHRvbjogdHJ1ZSxcXG5cXHRidXR0b25zOiB0cnVlLFxcblxcdGNsaWVudFg6IHRydWUsXFxuXFx0Y2xpZW50WTogdHJ1ZSxcXG5cXHRvZmZzZXRYOiB0cnVlLFxcblxcdG9mZnNldFk6IHRydWUsXFxuXFx0cG9pbnRlcklkOiB0cnVlLFxcblxcdHBvaW50ZXJUeXBlOiB0cnVlLFxcblxcdHNjcmVlblg6IHRydWUsXFxuXFx0c2NyZWVuWTogdHJ1ZSxcXG5cXHR0YXJnZXRUb3VjaGVzOiB0cnVlLFxcblxcdHRvRWxlbWVudDogdHJ1ZSxcXG5cXHR0b3VjaGVzOiB0cnVlLFxcblxcblxcdHdoaWNoOiBmdW5jdGlvbiggZXZlbnQgKSB7XFxuXFx0XFx0dmFyIGJ1dHRvbiA9IGV2ZW50LmJ1dHRvbjtcXG5cXG5cXHRcXHQvLyBBZGQgd2hpY2ggZm9yIGtleSBldmVudHNcXG5cXHRcXHRpZiAoIGV2ZW50LndoaWNoID09IG51bGwgJiYgcmtleUV2ZW50LnRlc3QoIGV2ZW50LnR5cGUgKSApIHtcXG5cXHRcXHRcXHRyZXR1cm4gZXZlbnQuY2hhckNvZGUgIT0gbnVsbCA/IGV2ZW50LmNoYXJDb2RlIDogZXZlbnQua2V5Q29kZTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gQWRkIHdoaWNoIGZvciBjbGljazogMSA9PT0gbGVmdDsgMiA9PT0gbWlkZGxlOyAzID09PSByaWdodFxcblxcdFxcdGlmICggIWV2ZW50LndoaWNoICYmIGJ1dHRvbiAhPT0gdW5kZWZpbmVkICYmIHJtb3VzZUV2ZW50LnRlc3QoIGV2ZW50LnR5cGUgKSApIHtcXG5cXHRcXHRcXHRpZiAoIGJ1dHRvbiAmIDEgKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIDE7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGlmICggYnV0dG9uICYgMiApIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gMztcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKCBidXR0b24gJiA0ICkge1xcblxcdFxcdFxcdFxcdHJldHVybiAyO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRyZXR1cm4gMDtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0cmV0dXJuIGV2ZW50LndoaWNoO1xcblxcdH1cXG59LCBqUXVlcnkuZXZlbnQuYWRkUHJvcCApO1xcblxcbi8vIENyZWF0ZSBtb3VzZWVudGVyL2xlYXZlIGV2ZW50cyB1c2luZyBtb3VzZW92ZXIvb3V0IGFuZCBldmVudC10aW1lIGNoZWNrc1xcbi8vIHNvIHRoYXQgZXZlbnQgZGVsZWdhdGlvbiB3b3JrcyBpbiBqUXVlcnkuXFxuLy8gRG8gdGhlIHNhbWUgZm9yIHBvaW50ZXJlbnRlci9wb2ludGVybGVhdmUgYW5kIHBvaW50ZXJvdmVyL3BvaW50ZXJvdXRcXG4vL1xcbi8vIFN1cHBvcnQ6IFNhZmFyaSA3IG9ubHlcXG4vLyBTYWZhcmkgc2VuZHMgbW91c2VlbnRlciB0b28gb2Z0ZW47IHNlZTpcXG4vLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD00NzAyNThcXG4vLyBmb3IgdGhlIGRlc2NyaXB0aW9uIG9mIHRoZSBidWcgKGl0IGV4aXN0ZWQgaW4gb2xkZXIgQ2hyb21lIHZlcnNpb25zIGFzIHdlbGwpLlxcbmpRdWVyeS5lYWNoKCB7XFxuXFx0bW91c2VlbnRlcjogXFxcIm1vdXNlb3ZlclxcXCIsXFxuXFx0bW91c2VsZWF2ZTogXFxcIm1vdXNlb3V0XFxcIixcXG5cXHRwb2ludGVyZW50ZXI6IFxcXCJwb2ludGVyb3ZlclxcXCIsXFxuXFx0cG9pbnRlcmxlYXZlOiBcXFwicG9pbnRlcm91dFxcXCJcXG59LCBmdW5jdGlvbiggb3JpZywgZml4ICkge1xcblxcdGpRdWVyeS5ldmVudC5zcGVjaWFsWyBvcmlnIF0gPSB7XFxuXFx0XFx0ZGVsZWdhdGVUeXBlOiBmaXgsXFxuXFx0XFx0YmluZFR5cGU6IGZpeCxcXG5cXG5cXHRcXHRoYW5kbGU6IGZ1bmN0aW9uKCBldmVudCApIHtcXG5cXHRcXHRcXHR2YXIgcmV0LFxcblxcdFxcdFxcdFxcdHRhcmdldCA9IHRoaXMsXFxuXFx0XFx0XFx0XFx0cmVsYXRlZCA9IGV2ZW50LnJlbGF0ZWRUYXJnZXQsXFxuXFx0XFx0XFx0XFx0aGFuZGxlT2JqID0gZXZlbnQuaGFuZGxlT2JqO1xcblxcblxcdFxcdFxcdC8vIEZvciBtb3VzZWVudGVyL2xlYXZlIGNhbGwgdGhlIGhhbmRsZXIgaWYgcmVsYXRlZCBpcyBvdXRzaWRlIHRoZSB0YXJnZXQuXFxuXFx0XFx0XFx0Ly8gTkI6IE5vIHJlbGF0ZWRUYXJnZXQgaWYgdGhlIG1vdXNlIGxlZnQvZW50ZXJlZCB0aGUgYnJvd3NlciB3aW5kb3dcXG5cXHRcXHRcXHRpZiAoICFyZWxhdGVkIHx8ICggcmVsYXRlZCAhPT0gdGFyZ2V0ICYmICFqUXVlcnkuY29udGFpbnMoIHRhcmdldCwgcmVsYXRlZCApICkgKSB7XFxuXFx0XFx0XFx0XFx0ZXZlbnQudHlwZSA9IGhhbmRsZU9iai5vcmlnVHlwZTtcXG5cXHRcXHRcXHRcXHRyZXQgPSBoYW5kbGVPYmouaGFuZGxlci5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XFxuXFx0XFx0XFx0XFx0ZXZlbnQudHlwZSA9IGZpeDtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0cmV0dXJuIHJldDtcXG5cXHRcXHR9XFxuXFx0fTtcXG59ICk7XFxuXFxualF1ZXJ5LmZuLmV4dGVuZCgge1xcblxcblxcdG9uOiBmdW5jdGlvbiggdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiApIHtcXG5cXHRcXHRyZXR1cm4gb24oIHRoaXMsIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4gKTtcXG5cXHR9LFxcblxcdG9uZTogZnVuY3Rpb24oIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4gKSB7XFxuXFx0XFx0cmV0dXJuIG9uKCB0aGlzLCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuLCAxICk7XFxuXFx0fSxcXG5cXHRvZmY6IGZ1bmN0aW9uKCB0eXBlcywgc2VsZWN0b3IsIGZuICkge1xcblxcdFxcdHZhciBoYW5kbGVPYmosIHR5cGU7XFxuXFx0XFx0aWYgKCB0eXBlcyAmJiB0eXBlcy5wcmV2ZW50RGVmYXVsdCAmJiB0eXBlcy5oYW5kbGVPYmogKSB7XFxuXFxuXFx0XFx0XFx0Ly8gKCBldmVudCApICBkaXNwYXRjaGVkIGpRdWVyeS5FdmVudFxcblxcdFxcdFxcdGhhbmRsZU9iaiA9IHR5cGVzLmhhbmRsZU9iajtcXG5cXHRcXHRcXHRqUXVlcnkoIHR5cGVzLmRlbGVnYXRlVGFyZ2V0ICkub2ZmKFxcblxcdFxcdFxcdFxcdGhhbmRsZU9iai5uYW1lc3BhY2UgP1xcblxcdFxcdFxcdFxcdFxcdGhhbmRsZU9iai5vcmlnVHlwZSArIFxcXCIuXFxcIiArIGhhbmRsZU9iai5uYW1lc3BhY2UgOlxcblxcdFxcdFxcdFxcdFxcdGhhbmRsZU9iai5vcmlnVHlwZSxcXG5cXHRcXHRcXHRcXHRoYW5kbGVPYmouc2VsZWN0b3IsXFxuXFx0XFx0XFx0XFx0aGFuZGxlT2JqLmhhbmRsZXJcXG5cXHRcXHRcXHQpO1xcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcdFxcdH1cXG5cXHRcXHRpZiAoIHR5cGVvZiB0eXBlcyA9PT0gXFxcIm9iamVjdFxcXCIgKSB7XFxuXFxuXFx0XFx0XFx0Ly8gKCB0eXBlcy1vYmplY3QgWywgc2VsZWN0b3JdIClcXG5cXHRcXHRcXHRmb3IgKCB0eXBlIGluIHR5cGVzICkge1xcblxcdFxcdFxcdFxcdHRoaXMub2ZmKCB0eXBlLCBzZWxlY3RvciwgdHlwZXNbIHR5cGUgXSApO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXHRcXHR9XFxuXFx0XFx0aWYgKCBzZWxlY3RvciA9PT0gZmFsc2UgfHwgdHlwZW9mIHNlbGVjdG9yID09PSBcXFwiZnVuY3Rpb25cXFwiICkge1xcblxcblxcdFxcdFxcdC8vICggdHlwZXMgWywgZm5dIClcXG5cXHRcXHRcXHRmbiA9IHNlbGVjdG9yO1xcblxcdFxcdFxcdHNlbGVjdG9yID0gdW5kZWZpbmVkO1xcblxcdFxcdH1cXG5cXHRcXHRpZiAoIGZuID09PSBmYWxzZSApIHtcXG5cXHRcXHRcXHRmbiA9IHJldHVybkZhbHNlO1xcblxcdFxcdH1cXG5cXHRcXHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHRqUXVlcnkuZXZlbnQucmVtb3ZlKCB0aGlzLCB0eXBlcywgZm4sIHNlbGVjdG9yICk7XFxuXFx0XFx0fSApO1xcblxcdH1cXG59ICk7XFxuXFxuXFxudmFyXFxuXFxuXFx0LyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiAqL1xcblxcblxcdC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZXNsaW50L2VzbGludC9pc3N1ZXMvMzIyOVxcblxcdHJ4aHRtbFRhZyA9IC88KD8hYXJlYXxicnxjb2x8ZW1iZWR8aHJ8aW1nfGlucHV0fGxpbmt8bWV0YXxwYXJhbSkoKFthLXpdW15cXFxcL1xcXFwwPlxcXFx4MjBcXFxcdFxcXFxyXFxcXG5cXFxcZl0qKVtePl0qKVxcXFwvPi9naSxcXG5cXG5cXHQvKiBlc2xpbnQtZW5hYmxlICovXFxuXFxuXFx0Ly8gU3VwcG9ydDogSUUgPD0xMCAtIDExLCBFZGdlIDEyIC0gMTMgb25seVxcblxcdC8vIEluIElFL0VkZ2UgdXNpbmcgcmVnZXggZ3JvdXBzIGhlcmUgY2F1c2VzIHNldmVyZSBzbG93ZG93bnMuXFxuXFx0Ly8gU2VlIGh0dHBzOi8vY29ubmVjdC5taWNyb3NvZnQuY29tL0lFL2ZlZWRiYWNrL2RldGFpbHMvMTczNjUxMi9cXG5cXHRybm9Jbm5lcmh0bWwgPSAvPHNjcmlwdHw8c3R5bGV8PGxpbmsvaSxcXG5cXG5cXHQvLyBjaGVja2VkPVxcXCJjaGVja2VkXFxcIiBvciBjaGVja2VkXFxuXFx0cmNoZWNrZWQgPSAvY2hlY2tlZFxcXFxzKig/OltePV18PVxcXFxzKi5jaGVja2VkLikvaSxcXG5cXHRyY2xlYW5TY3JpcHQgPSAvXlxcXFxzKjwhKD86XFxcXFtDREFUQVxcXFxbfC0tKXwoPzpcXFxcXVxcXFxdfC0tKT5cXFxccyokL2c7XFxuXFxuLy8gUHJlZmVyIGEgdGJvZHkgb3ZlciBpdHMgcGFyZW50IHRhYmxlIGZvciBjb250YWluaW5nIG5ldyByb3dzXFxuZnVuY3Rpb24gbWFuaXB1bGF0aW9uVGFyZ2V0KCBlbGVtLCBjb250ZW50ICkge1xcblxcdGlmICggbm9kZU5hbWUoIGVsZW0sIFxcXCJ0YWJsZVxcXCIgKSAmJlxcblxcdFxcdG5vZGVOYW1lKCBjb250ZW50Lm5vZGVUeXBlICE9PSAxMSA/IGNvbnRlbnQgOiBjb250ZW50LmZpcnN0Q2hpbGQsIFxcXCJ0clxcXCIgKSApIHtcXG5cXG5cXHRcXHRyZXR1cm4galF1ZXJ5KCBlbGVtICkuY2hpbGRyZW4oIFxcXCJ0Ym9keVxcXCIgKVsgMCBdIHx8IGVsZW07XFxuXFx0fVxcblxcblxcdHJldHVybiBlbGVtO1xcbn1cXG5cXG4vLyBSZXBsYWNlL3Jlc3RvcmUgdGhlIHR5cGUgYXR0cmlidXRlIG9mIHNjcmlwdCBlbGVtZW50cyBmb3Igc2FmZSBET00gbWFuaXB1bGF0aW9uXFxuZnVuY3Rpb24gZGlzYWJsZVNjcmlwdCggZWxlbSApIHtcXG5cXHRlbGVtLnR5cGUgPSAoIGVsZW0uZ2V0QXR0cmlidXRlKCBcXFwidHlwZVxcXCIgKSAhPT0gbnVsbCApICsgXFxcIi9cXFwiICsgZWxlbS50eXBlO1xcblxcdHJldHVybiBlbGVtO1xcbn1cXG5mdW5jdGlvbiByZXN0b3JlU2NyaXB0KCBlbGVtICkge1xcblxcdGlmICggKCBlbGVtLnR5cGUgfHwgXFxcIlxcXCIgKS5zbGljZSggMCwgNSApID09PSBcXFwidHJ1ZS9cXFwiICkge1xcblxcdFxcdGVsZW0udHlwZSA9IGVsZW0udHlwZS5zbGljZSggNSApO1xcblxcdH0gZWxzZSB7XFxuXFx0XFx0ZWxlbS5yZW1vdmVBdHRyaWJ1dGUoIFxcXCJ0eXBlXFxcIiApO1xcblxcdH1cXG5cXG5cXHRyZXR1cm4gZWxlbTtcXG59XFxuXFxuZnVuY3Rpb24gY2xvbmVDb3B5RXZlbnQoIHNyYywgZGVzdCApIHtcXG5cXHR2YXIgaSwgbCwgdHlwZSwgcGRhdGFPbGQsIHBkYXRhQ3VyLCB1ZGF0YU9sZCwgdWRhdGFDdXIsIGV2ZW50cztcXG5cXG5cXHRpZiAoIGRlc3Qubm9kZVR5cGUgIT09IDEgKSB7XFxuXFx0XFx0cmV0dXJuO1xcblxcdH1cXG5cXG5cXHQvLyAxLiBDb3B5IHByaXZhdGUgZGF0YTogZXZlbnRzLCBoYW5kbGVycywgZXRjLlxcblxcdGlmICggZGF0YVByaXYuaGFzRGF0YSggc3JjICkgKSB7XFxuXFx0XFx0cGRhdGFPbGQgPSBkYXRhUHJpdi5hY2Nlc3MoIHNyYyApO1xcblxcdFxcdHBkYXRhQ3VyID0gZGF0YVByaXYuc2V0KCBkZXN0LCBwZGF0YU9sZCApO1xcblxcdFxcdGV2ZW50cyA9IHBkYXRhT2xkLmV2ZW50cztcXG5cXG5cXHRcXHRpZiAoIGV2ZW50cyApIHtcXG5cXHRcXHRcXHRkZWxldGUgcGRhdGFDdXIuaGFuZGxlO1xcblxcdFxcdFxcdHBkYXRhQ3VyLmV2ZW50cyA9IHt9O1xcblxcblxcdFxcdFxcdGZvciAoIHR5cGUgaW4gZXZlbnRzICkge1xcblxcdFxcdFxcdFxcdGZvciAoIGkgPSAwLCBsID0gZXZlbnRzWyB0eXBlIF0ubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xcblxcdFxcdFxcdFxcdFxcdGpRdWVyeS5ldmVudC5hZGQoIGRlc3QsIHR5cGUsIGV2ZW50c1sgdHlwZSBdWyBpIF0gKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXHR9XFxuXFxuXFx0Ly8gMi4gQ29weSB1c2VyIGRhdGFcXG5cXHRpZiAoIGRhdGFVc2VyLmhhc0RhdGEoIHNyYyApICkge1xcblxcdFxcdHVkYXRhT2xkID0gZGF0YVVzZXIuYWNjZXNzKCBzcmMgKTtcXG5cXHRcXHR1ZGF0YUN1ciA9IGpRdWVyeS5leHRlbmQoIHt9LCB1ZGF0YU9sZCApO1xcblxcblxcdFxcdGRhdGFVc2VyLnNldCggZGVzdCwgdWRhdGFDdXIgKTtcXG5cXHR9XFxufVxcblxcbi8vIEZpeCBJRSBidWdzLCBzZWUgc3VwcG9ydCB0ZXN0c1xcbmZ1bmN0aW9uIGZpeElucHV0KCBzcmMsIGRlc3QgKSB7XFxuXFx0dmFyIG5vZGVOYW1lID0gZGVzdC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xcblxcblxcdC8vIEZhaWxzIHRvIHBlcnNpc3QgdGhlIGNoZWNrZWQgc3RhdGUgb2YgYSBjbG9uZWQgY2hlY2tib3ggb3IgcmFkaW8gYnV0dG9uLlxcblxcdGlmICggbm9kZU5hbWUgPT09IFxcXCJpbnB1dFxcXCIgJiYgcmNoZWNrYWJsZVR5cGUudGVzdCggc3JjLnR5cGUgKSApIHtcXG5cXHRcXHRkZXN0LmNoZWNrZWQgPSBzcmMuY2hlY2tlZDtcXG5cXG5cXHQvLyBGYWlscyB0byByZXR1cm4gdGhlIHNlbGVjdGVkIG9wdGlvbiB0byB0aGUgZGVmYXVsdCBzZWxlY3RlZCBzdGF0ZSB3aGVuIGNsb25pbmcgb3B0aW9uc1xcblxcdH0gZWxzZSBpZiAoIG5vZGVOYW1lID09PSBcXFwiaW5wdXRcXFwiIHx8IG5vZGVOYW1lID09PSBcXFwidGV4dGFyZWFcXFwiICkge1xcblxcdFxcdGRlc3QuZGVmYXVsdFZhbHVlID0gc3JjLmRlZmF1bHRWYWx1ZTtcXG5cXHR9XFxufVxcblxcbmZ1bmN0aW9uIGRvbU1hbmlwKCBjb2xsZWN0aW9uLCBhcmdzLCBjYWxsYmFjaywgaWdub3JlZCApIHtcXG5cXG5cXHQvLyBGbGF0dGVuIGFueSBuZXN0ZWQgYXJyYXlzXFxuXFx0YXJncyA9IGNvbmNhdC5hcHBseSggW10sIGFyZ3MgKTtcXG5cXG5cXHR2YXIgZnJhZ21lbnQsIGZpcnN0LCBzY3JpcHRzLCBoYXNTY3JpcHRzLCBub2RlLCBkb2MsXFxuXFx0XFx0aSA9IDAsXFxuXFx0XFx0bCA9IGNvbGxlY3Rpb24ubGVuZ3RoLFxcblxcdFxcdGlOb0Nsb25lID0gbCAtIDEsXFxuXFx0XFx0dmFsdWUgPSBhcmdzWyAwIF0sXFxuXFx0XFx0dmFsdWVJc0Z1bmN0aW9uID0gaXNGdW5jdGlvbiggdmFsdWUgKTtcXG5cXG5cXHQvLyBXZSBjYW4ndCBjbG9uZU5vZGUgZnJhZ21lbnRzIHRoYXQgY29udGFpbiBjaGVja2VkLCBpbiBXZWJLaXRcXG5cXHRpZiAoIHZhbHVlSXNGdW5jdGlvbiB8fFxcblxcdFxcdFxcdCggbCA+IDEgJiYgdHlwZW9mIHZhbHVlID09PSBcXFwic3RyaW5nXFxcIiAmJlxcblxcdFxcdFxcdFxcdCFzdXBwb3J0LmNoZWNrQ2xvbmUgJiYgcmNoZWNrZWQudGVzdCggdmFsdWUgKSApICkge1xcblxcdFxcdHJldHVybiBjb2xsZWN0aW9uLmVhY2goIGZ1bmN0aW9uKCBpbmRleCApIHtcXG5cXHRcXHRcXHR2YXIgc2VsZiA9IGNvbGxlY3Rpb24uZXEoIGluZGV4ICk7XFxuXFx0XFx0XFx0aWYgKCB2YWx1ZUlzRnVuY3Rpb24gKSB7XFxuXFx0XFx0XFx0XFx0YXJnc1sgMCBdID0gdmFsdWUuY2FsbCggdGhpcywgaW5kZXgsIHNlbGYuaHRtbCgpICk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGRvbU1hbmlwKCBzZWxmLCBhcmdzLCBjYWxsYmFjaywgaWdub3JlZCApO1xcblxcdFxcdH0gKTtcXG5cXHR9XFxuXFxuXFx0aWYgKCBsICkge1xcblxcdFxcdGZyYWdtZW50ID0gYnVpbGRGcmFnbWVudCggYXJncywgY29sbGVjdGlvblsgMCBdLm93bmVyRG9jdW1lbnQsIGZhbHNlLCBjb2xsZWN0aW9uLCBpZ25vcmVkICk7XFxuXFx0XFx0Zmlyc3QgPSBmcmFnbWVudC5maXJzdENoaWxkO1xcblxcblxcdFxcdGlmICggZnJhZ21lbnQuY2hpbGROb2Rlcy5sZW5ndGggPT09IDEgKSB7XFxuXFx0XFx0XFx0ZnJhZ21lbnQgPSBmaXJzdDtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gUmVxdWlyZSBlaXRoZXIgbmV3IGNvbnRlbnQgb3IgYW4gaW50ZXJlc3QgaW4gaWdub3JlZCBlbGVtZW50cyB0byBpbnZva2UgdGhlIGNhbGxiYWNrXFxuXFx0XFx0aWYgKCBmaXJzdCB8fCBpZ25vcmVkICkge1xcblxcdFxcdFxcdHNjcmlwdHMgPSBqUXVlcnkubWFwKCBnZXRBbGwoIGZyYWdtZW50LCBcXFwic2NyaXB0XFxcIiApLCBkaXNhYmxlU2NyaXB0ICk7XFxuXFx0XFx0XFx0aGFzU2NyaXB0cyA9IHNjcmlwdHMubGVuZ3RoO1xcblxcblxcdFxcdFxcdC8vIFVzZSB0aGUgb3JpZ2luYWwgZnJhZ21lbnQgZm9yIHRoZSBsYXN0IGl0ZW1cXG5cXHRcXHRcXHQvLyBpbnN0ZWFkIG9mIHRoZSBmaXJzdCBiZWNhdXNlIGl0IGNhbiBlbmQgdXBcXG5cXHRcXHRcXHQvLyBiZWluZyBlbXB0aWVkIGluY29ycmVjdGx5IGluIGNlcnRhaW4gc2l0dWF0aW9ucyAoIzgwNzApLlxcblxcdFxcdFxcdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcXG5cXHRcXHRcXHRcXHRub2RlID0gZnJhZ21lbnQ7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBpICE9PSBpTm9DbG9uZSApIHtcXG5cXHRcXHRcXHRcXHRcXHRub2RlID0galF1ZXJ5LmNsb25lKCBub2RlLCB0cnVlLCB0cnVlICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gS2VlcCByZWZlcmVuY2VzIHRvIGNsb25lZCBzY3JpcHRzIGZvciBsYXRlciByZXN0b3JhdGlvblxcblxcdFxcdFxcdFxcdFxcdGlmICggaGFzU2NyaXB0cyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIG9ubHksIFBoYW50b21KUyAxIG9ubHlcXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzIG9uIGFuY2llbnQgV2ViS2l0XFxuXFx0XFx0XFx0XFx0XFx0XFx0alF1ZXJ5Lm1lcmdlKCBzY3JpcHRzLCBnZXRBbGwoIG5vZGUsIFxcXCJzY3JpcHRcXFwiICkgKTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdGNhbGxiYWNrLmNhbGwoIGNvbGxlY3Rpb25bIGkgXSwgbm9kZSwgaSApO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpZiAoIGhhc1NjcmlwdHMgKSB7XFxuXFx0XFx0XFx0XFx0ZG9jID0gc2NyaXB0c1sgc2NyaXB0cy5sZW5ndGggLSAxIF0ub3duZXJEb2N1bWVudDtcXG5cXG5cXHRcXHRcXHRcXHQvLyBSZWVuYWJsZSBzY3JpcHRzXFxuXFx0XFx0XFx0XFx0alF1ZXJ5Lm1hcCggc2NyaXB0cywgcmVzdG9yZVNjcmlwdCApO1xcblxcblxcdFxcdFxcdFxcdC8vIEV2YWx1YXRlIGV4ZWN1dGFibGUgc2NyaXB0cyBvbiBmaXJzdCBkb2N1bWVudCBpbnNlcnRpb25cXG5cXHRcXHRcXHRcXHRmb3IgKCBpID0gMDsgaSA8IGhhc1NjcmlwdHM7IGkrKyApIHtcXG5cXHRcXHRcXHRcXHRcXHRub2RlID0gc2NyaXB0c1sgaSBdO1xcblxcdFxcdFxcdFxcdFxcdGlmICggcnNjcmlwdFR5cGUudGVzdCggbm9kZS50eXBlIHx8IFxcXCJcXFwiICkgJiZcXG5cXHRcXHRcXHRcXHRcXHRcXHQhZGF0YVByaXYuYWNjZXNzKCBub2RlLCBcXFwiZ2xvYmFsRXZhbFxcXCIgKSAmJlxcblxcdFxcdFxcdFxcdFxcdFxcdGpRdWVyeS5jb250YWlucyggZG9jLCBub2RlICkgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBub2RlLnNyYyAmJiAoIG5vZGUudHlwZSB8fCBcXFwiXFxcIiApLnRvTG93ZXJDYXNlKCkgICE9PSBcXFwibW9kdWxlXFxcIiApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBPcHRpb25hbCBBSkFYIGRlcGVuZGVuY3ksIGJ1dCB3b24ndCBydW4gc2NyaXB0cyBpZiBub3QgcHJlc2VudFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmICggalF1ZXJ5Ll9ldmFsVXJsICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGpRdWVyeS5fZXZhbFVybCggbm9kZS5zcmMgKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRET01FdmFsKCBub2RlLnRleHRDb250ZW50LnJlcGxhY2UoIHJjbGVhblNjcmlwdCwgXFxcIlxcXCIgKSwgZG9jLCBub2RlICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXHR9XFxuXFxuXFx0cmV0dXJuIGNvbGxlY3Rpb247XFxufVxcblxcbmZ1bmN0aW9uIHJlbW92ZSggZWxlbSwgc2VsZWN0b3IsIGtlZXBEYXRhICkge1xcblxcdHZhciBub2RlLFxcblxcdFxcdG5vZGVzID0gc2VsZWN0b3IgPyBqUXVlcnkuZmlsdGVyKCBzZWxlY3RvciwgZWxlbSApIDogZWxlbSxcXG5cXHRcXHRpID0gMDtcXG5cXG5cXHRmb3IgKCA7ICggbm9kZSA9IG5vZGVzWyBpIF0gKSAhPSBudWxsOyBpKysgKSB7XFxuXFx0XFx0aWYgKCAha2VlcERhdGEgJiYgbm9kZS5ub2RlVHlwZSA9PT0gMSApIHtcXG5cXHRcXHRcXHRqUXVlcnkuY2xlYW5EYXRhKCBnZXRBbGwoIG5vZGUgKSApO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRpZiAoIG5vZGUucGFyZW50Tm9kZSApIHtcXG5cXHRcXHRcXHRpZiAoIGtlZXBEYXRhICYmIGpRdWVyeS5jb250YWlucyggbm9kZS5vd25lckRvY3VtZW50LCBub2RlICkgKSB7XFxuXFx0XFx0XFx0XFx0c2V0R2xvYmFsRXZhbCggZ2V0QWxsKCBub2RlLCBcXFwic2NyaXB0XFxcIiApICk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdG5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCggbm9kZSApO1xcblxcdFxcdH1cXG5cXHR9XFxuXFxuXFx0cmV0dXJuIGVsZW07XFxufVxcblxcbmpRdWVyeS5leHRlbmQoIHtcXG5cXHRodG1sUHJlZmlsdGVyOiBmdW5jdGlvbiggaHRtbCApIHtcXG5cXHRcXHRyZXR1cm4gaHRtbC5yZXBsYWNlKCByeGh0bWxUYWcsIFxcXCI8JDE+PC8kMj5cXFwiICk7XFxuXFx0fSxcXG5cXG5cXHRjbG9uZTogZnVuY3Rpb24oIGVsZW0sIGRhdGFBbmRFdmVudHMsIGRlZXBEYXRhQW5kRXZlbnRzICkge1xcblxcdFxcdHZhciBpLCBsLCBzcmNFbGVtZW50cywgZGVzdEVsZW1lbnRzLFxcblxcdFxcdFxcdGNsb25lID0gZWxlbS5jbG9uZU5vZGUoIHRydWUgKSxcXG5cXHRcXHRcXHRpblBhZ2UgPSBqUXVlcnkuY29udGFpbnMoIGVsZW0ub3duZXJEb2N1bWVudCwgZWxlbSApO1xcblxcblxcdFxcdC8vIEZpeCBJRSBjbG9uaW5nIGlzc3Vlc1xcblxcdFxcdGlmICggIXN1cHBvcnQubm9DbG9uZUNoZWNrZWQgJiYgKCBlbGVtLm5vZGVUeXBlID09PSAxIHx8IGVsZW0ubm9kZVR5cGUgPT09IDExICkgJiZcXG5cXHRcXHRcXHRcXHQhalF1ZXJ5LmlzWE1MRG9jKCBlbGVtICkgKSB7XFxuXFxuXFx0XFx0XFx0Ly8gV2UgZXNjaGV3IFNpenpsZSBoZXJlIGZvciBwZXJmb3JtYW5jZSByZWFzb25zOiBodHRwczovL2pzcGVyZi5jb20vZ2V0YWxsLXZzLXNpenpsZS8yXFxuXFx0XFx0XFx0ZGVzdEVsZW1lbnRzID0gZ2V0QWxsKCBjbG9uZSApO1xcblxcdFxcdFxcdHNyY0VsZW1lbnRzID0gZ2V0QWxsKCBlbGVtICk7XFxuXFxuXFx0XFx0XFx0Zm9yICggaSA9IDAsIGwgPSBzcmNFbGVtZW50cy5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XFxuXFx0XFx0XFx0XFx0Zml4SW5wdXQoIHNyY0VsZW1lbnRzWyBpIF0sIGRlc3RFbGVtZW50c1sgaSBdICk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBDb3B5IHRoZSBldmVudHMgZnJvbSB0aGUgb3JpZ2luYWwgdG8gdGhlIGNsb25lXFxuXFx0XFx0aWYgKCBkYXRhQW5kRXZlbnRzICkge1xcblxcdFxcdFxcdGlmICggZGVlcERhdGFBbmRFdmVudHMgKSB7XFxuXFx0XFx0XFx0XFx0c3JjRWxlbWVudHMgPSBzcmNFbGVtZW50cyB8fCBnZXRBbGwoIGVsZW0gKTtcXG5cXHRcXHRcXHRcXHRkZXN0RWxlbWVudHMgPSBkZXN0RWxlbWVudHMgfHwgZ2V0QWxsKCBjbG9uZSApO1xcblxcblxcdFxcdFxcdFxcdGZvciAoIGkgPSAwLCBsID0gc3JjRWxlbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xcblxcdFxcdFxcdFxcdFxcdGNsb25lQ29weUV2ZW50KCBzcmNFbGVtZW50c1sgaSBdLCBkZXN0RWxlbWVudHNbIGkgXSApO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdGNsb25lQ29weUV2ZW50KCBlbGVtLCBjbG9uZSApO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gUHJlc2VydmUgc2NyaXB0IGV2YWx1YXRpb24gaGlzdG9yeVxcblxcdFxcdGRlc3RFbGVtZW50cyA9IGdldEFsbCggY2xvbmUsIFxcXCJzY3JpcHRcXFwiICk7XFxuXFx0XFx0aWYgKCBkZXN0RWxlbWVudHMubGVuZ3RoID4gMCApIHtcXG5cXHRcXHRcXHRzZXRHbG9iYWxFdmFsKCBkZXN0RWxlbWVudHMsICFpblBhZ2UgJiYgZ2V0QWxsKCBlbGVtLCBcXFwic2NyaXB0XFxcIiApICk7XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIFJldHVybiB0aGUgY2xvbmVkIHNldFxcblxcdFxcdHJldHVybiBjbG9uZTtcXG5cXHR9LFxcblxcblxcdGNsZWFuRGF0YTogZnVuY3Rpb24oIGVsZW1zICkge1xcblxcdFxcdHZhciBkYXRhLCBlbGVtLCB0eXBlLFxcblxcdFxcdFxcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbCxcXG5cXHRcXHRcXHRpID0gMDtcXG5cXG5cXHRcXHRmb3IgKCA7ICggZWxlbSA9IGVsZW1zWyBpIF0gKSAhPT0gdW5kZWZpbmVkOyBpKysgKSB7XFxuXFx0XFx0XFx0aWYgKCBhY2NlcHREYXRhKCBlbGVtICkgKSB7XFxuXFx0XFx0XFx0XFx0aWYgKCAoIGRhdGEgPSBlbGVtWyBkYXRhUHJpdi5leHBhbmRvIF0gKSApIHtcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIGRhdGEuZXZlbnRzICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGZvciAoIHR5cGUgaW4gZGF0YS5ldmVudHMgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBzcGVjaWFsWyB0eXBlIF0gKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0alF1ZXJ5LmV2ZW50LnJlbW92ZSggZWxlbSwgdHlwZSApO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIFRoaXMgaXMgYSBzaG9ydGN1dCB0byBhdm9pZCBqUXVlcnkuZXZlbnQucmVtb3ZlJ3Mgb3ZlcmhlYWRcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGpRdWVyeS5yZW1vdmVFdmVudCggZWxlbSwgdHlwZSwgZGF0YS5oYW5kbGUgKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBTdXBwb3J0OiBDaHJvbWUgPD0zNSAtIDQ1K1xcblxcdFxcdFxcdFxcdFxcdC8vIEFzc2lnbiB1bmRlZmluZWQgaW5zdGVhZCBvZiB1c2luZyBkZWxldGUsIHNlZSBEYXRhI3JlbW92ZVxcblxcdFxcdFxcdFxcdFxcdGVsZW1bIGRhdGFQcml2LmV4cGFuZG8gXSA9IHVuZGVmaW5lZDtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0aWYgKCBlbGVtWyBkYXRhVXNlci5leHBhbmRvIF0gKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gU3VwcG9ydDogQ2hyb21lIDw9MzUgLSA0NStcXG5cXHRcXHRcXHRcXHRcXHQvLyBBc3NpZ24gdW5kZWZpbmVkIGluc3RlYWQgb2YgdXNpbmcgZGVsZXRlLCBzZWUgRGF0YSNyZW1vdmVcXG5cXHRcXHRcXHRcXHRcXHRlbGVtWyBkYXRhVXNlci5leHBhbmRvIF0gPSB1bmRlZmluZWQ7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFx0fVxcbn0gKTtcXG5cXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XFxuXFx0ZGV0YWNoOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XFxuXFx0XFx0cmV0dXJuIHJlbW92ZSggdGhpcywgc2VsZWN0b3IsIHRydWUgKTtcXG5cXHR9LFxcblxcblxcdHJlbW92ZTogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xcblxcdFxcdHJldHVybiByZW1vdmUoIHRoaXMsIHNlbGVjdG9yICk7XFxuXFx0fSxcXG5cXG5cXHR0ZXh0OiBmdW5jdGlvbiggdmFsdWUgKSB7XFxuXFx0XFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIHZhbHVlICkge1xcblxcdFxcdFxcdHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID9cXG5cXHRcXHRcXHRcXHRqUXVlcnkudGV4dCggdGhpcyApIDpcXG5cXHRcXHRcXHRcXHR0aGlzLmVtcHR5KCkuZWFjaCggZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKCB0aGlzLm5vZGVUeXBlID09PSAxIHx8IHRoaXMubm9kZVR5cGUgPT09IDExIHx8IHRoaXMubm9kZVR5cGUgPT09IDkgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dGhpcy50ZXh0Q29udGVudCA9IHZhbHVlO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9ICk7XFxuXFx0XFx0fSwgbnVsbCwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggKTtcXG5cXHR9LFxcblxcblxcdGFwcGVuZDogZnVuY3Rpb24oKSB7XFxuXFx0XFx0cmV0dXJuIGRvbU1hbmlwKCB0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xcblxcdFxcdFxcdGlmICggdGhpcy5ub2RlVHlwZSA9PT0gMSB8fCB0aGlzLm5vZGVUeXBlID09PSAxMSB8fCB0aGlzLm5vZGVUeXBlID09PSA5ICkge1xcblxcdFxcdFxcdFxcdHZhciB0YXJnZXQgPSBtYW5pcHVsYXRpb25UYXJnZXQoIHRoaXMsIGVsZW0gKTtcXG5cXHRcXHRcXHRcXHR0YXJnZXQuYXBwZW5kQ2hpbGQoIGVsZW0gKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSApO1xcblxcdH0sXFxuXFxuXFx0cHJlcGVuZDogZnVuY3Rpb24oKSB7XFxuXFx0XFx0cmV0dXJuIGRvbU1hbmlwKCB0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xcblxcdFxcdFxcdGlmICggdGhpcy5ub2RlVHlwZSA9PT0gMSB8fCB0aGlzLm5vZGVUeXBlID09PSAxMSB8fCB0aGlzLm5vZGVUeXBlID09PSA5ICkge1xcblxcdFxcdFxcdFxcdHZhciB0YXJnZXQgPSBtYW5pcHVsYXRpb25UYXJnZXQoIHRoaXMsIGVsZW0gKTtcXG5cXHRcXHRcXHRcXHR0YXJnZXQuaW5zZXJ0QmVmb3JlKCBlbGVtLCB0YXJnZXQuZmlyc3RDaGlsZCApO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9ICk7XFxuXFx0fSxcXG5cXG5cXHRiZWZvcmU6IGZ1bmN0aW9uKCkge1xcblxcdFxcdHJldHVybiBkb21NYW5pcCggdGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcXG5cXHRcXHRcXHRpZiAoIHRoaXMucGFyZW50Tm9kZSApIHtcXG5cXHRcXHRcXHRcXHR0aGlzLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKCBlbGVtLCB0aGlzICk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH0gKTtcXG5cXHR9LFxcblxcblxcdGFmdGVyOiBmdW5jdGlvbigpIHtcXG5cXHRcXHRyZXR1cm4gZG9tTWFuaXAoIHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XFxuXFx0XFx0XFx0aWYgKCB0aGlzLnBhcmVudE5vZGUgKSB7XFxuXFx0XFx0XFx0XFx0dGhpcy5wYXJlbnROb2RlLmluc2VydEJlZm9yZSggZWxlbSwgdGhpcy5uZXh0U2libGluZyApO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9ICk7XFxuXFx0fSxcXG5cXG5cXHRlbXB0eTogZnVuY3Rpb24oKSB7XFxuXFx0XFx0dmFyIGVsZW0sXFxuXFx0XFx0XFx0aSA9IDA7XFxuXFxuXFx0XFx0Zm9yICggOyAoIGVsZW0gPSB0aGlzWyBpIF0gKSAhPSBudWxsOyBpKysgKSB7XFxuXFx0XFx0XFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICkge1xcblxcblxcdFxcdFxcdFxcdC8vIFByZXZlbnQgbWVtb3J5IGxlYWtzXFxuXFx0XFx0XFx0XFx0alF1ZXJ5LmNsZWFuRGF0YSggZ2V0QWxsKCBlbGVtLCBmYWxzZSApICk7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gUmVtb3ZlIGFueSByZW1haW5pbmcgbm9kZXNcXG5cXHRcXHRcXHRcXHRlbGVtLnRleHRDb250ZW50ID0gXFxcIlxcXCI7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXG5cXHRcXHRyZXR1cm4gdGhpcztcXG5cXHR9LFxcblxcblxcdGNsb25lOiBmdW5jdGlvbiggZGF0YUFuZEV2ZW50cywgZGVlcERhdGFBbmRFdmVudHMgKSB7XFxuXFx0XFx0ZGF0YUFuZEV2ZW50cyA9IGRhdGFBbmRFdmVudHMgPT0gbnVsbCA/IGZhbHNlIDogZGF0YUFuZEV2ZW50cztcXG5cXHRcXHRkZWVwRGF0YUFuZEV2ZW50cyA9IGRlZXBEYXRhQW5kRXZlbnRzID09IG51bGwgPyBkYXRhQW5kRXZlbnRzIDogZGVlcERhdGFBbmRFdmVudHM7XFxuXFxuXFx0XFx0cmV0dXJuIHRoaXMubWFwKCBmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHRyZXR1cm4galF1ZXJ5LmNsb25lKCB0aGlzLCBkYXRhQW5kRXZlbnRzLCBkZWVwRGF0YUFuZEV2ZW50cyApO1xcblxcdFxcdH0gKTtcXG5cXHR9LFxcblxcblxcdGh0bWw6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcXG5cXHRcXHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggdmFsdWUgKSB7XFxuXFx0XFx0XFx0dmFyIGVsZW0gPSB0aGlzWyAwIF0gfHwge30sXFxuXFx0XFx0XFx0XFx0aSA9IDAsXFxuXFx0XFx0XFx0XFx0bCA9IHRoaXMubGVuZ3RoO1xcblxcblxcdFxcdFxcdGlmICggdmFsdWUgPT09IHVuZGVmaW5lZCAmJiBlbGVtLm5vZGVUeXBlID09PSAxICkge1xcblxcdFxcdFxcdFxcdHJldHVybiBlbGVtLmlubmVySFRNTDtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gU2VlIGlmIHdlIGNhbiB0YWtlIGEgc2hvcnRjdXQgYW5kIGp1c3QgdXNlIGlubmVySFRNTFxcblxcdFxcdFxcdGlmICggdHlwZW9mIHZhbHVlID09PSBcXFwic3RyaW5nXFxcIiAmJiAhcm5vSW5uZXJodG1sLnRlc3QoIHZhbHVlICkgJiZcXG5cXHRcXHRcXHRcXHQhd3JhcE1hcFsgKCBydGFnTmFtZS5leGVjKCB2YWx1ZSApIHx8IFsgXFxcIlxcXCIsIFxcXCJcXFwiIF0gKVsgMSBdLnRvTG93ZXJDYXNlKCkgXSApIHtcXG5cXG5cXHRcXHRcXHRcXHR2YWx1ZSA9IGpRdWVyeS5odG1sUHJlZmlsdGVyKCB2YWx1ZSApO1xcblxcblxcdFxcdFxcdFxcdHRyeSB7XFxuXFx0XFx0XFx0XFx0XFx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGVsZW0gPSB0aGlzWyBpIF0gfHwge307XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gUmVtb3ZlIGVsZW1lbnQgbm9kZXMgYW5kIHByZXZlbnQgbWVtb3J5IGxlYWtzXFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGpRdWVyeS5jbGVhbkRhdGEoIGdldEFsbCggZWxlbSwgZmFsc2UgKSApO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGVsZW0uaW5uZXJIVE1MID0gdmFsdWU7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRlbGVtID0gMDtcXG5cXG5cXHRcXHRcXHRcXHQvLyBJZiB1c2luZyBpbm5lckhUTUwgdGhyb3dzIGFuIGV4Y2VwdGlvbiwgdXNlIHRoZSBmYWxsYmFjayBtZXRob2RcXG5cXHRcXHRcXHRcXHR9IGNhdGNoICggZSApIHt9XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGlmICggZWxlbSApIHtcXG5cXHRcXHRcXHRcXHR0aGlzLmVtcHR5KCkuYXBwZW5kKCB2YWx1ZSApO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9LCBudWxsLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCApO1xcblxcdH0sXFxuXFxuXFx0cmVwbGFjZVdpdGg6IGZ1bmN0aW9uKCkge1xcblxcdFxcdHZhciBpZ25vcmVkID0gW107XFxuXFxuXFx0XFx0Ly8gTWFrZSB0aGUgY2hhbmdlcywgcmVwbGFjaW5nIGVhY2ggbm9uLWlnbm9yZWQgY29udGV4dCBlbGVtZW50IHdpdGggdGhlIG5ldyBjb250ZW50XFxuXFx0XFx0cmV0dXJuIGRvbU1hbmlwKCB0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xcblxcdFxcdFxcdHZhciBwYXJlbnQgPSB0aGlzLnBhcmVudE5vZGU7XFxuXFxuXFx0XFx0XFx0aWYgKCBqUXVlcnkuaW5BcnJheSggdGhpcywgaWdub3JlZCApIDwgMCApIHtcXG5cXHRcXHRcXHRcXHRqUXVlcnkuY2xlYW5EYXRhKCBnZXRBbGwoIHRoaXMgKSApO1xcblxcdFxcdFxcdFxcdGlmICggcGFyZW50ICkge1xcblxcdFxcdFxcdFxcdFxcdHBhcmVudC5yZXBsYWNlQ2hpbGQoIGVsZW0sIHRoaXMgKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdC8vIEZvcmNlIGNhbGxiYWNrIGludm9jYXRpb25cXG5cXHRcXHR9LCBpZ25vcmVkICk7XFxuXFx0fVxcbn0gKTtcXG5cXG5qUXVlcnkuZWFjaCgge1xcblxcdGFwcGVuZFRvOiBcXFwiYXBwZW5kXFxcIixcXG5cXHRwcmVwZW5kVG86IFxcXCJwcmVwZW5kXFxcIixcXG5cXHRpbnNlcnRCZWZvcmU6IFxcXCJiZWZvcmVcXFwiLFxcblxcdGluc2VydEFmdGVyOiBcXFwiYWZ0ZXJcXFwiLFxcblxcdHJlcGxhY2VBbGw6IFxcXCJyZXBsYWNlV2l0aFxcXCJcXG59LCBmdW5jdGlvbiggbmFtZSwgb3JpZ2luYWwgKSB7XFxuXFx0alF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XFxuXFx0XFx0dmFyIGVsZW1zLFxcblxcdFxcdFxcdHJldCA9IFtdLFxcblxcdFxcdFxcdGluc2VydCA9IGpRdWVyeSggc2VsZWN0b3IgKSxcXG5cXHRcXHRcXHRsYXN0ID0gaW5zZXJ0Lmxlbmd0aCAtIDEsXFxuXFx0XFx0XFx0aSA9IDA7XFxuXFxuXFx0XFx0Zm9yICggOyBpIDw9IGxhc3Q7IGkrKyApIHtcXG5cXHRcXHRcXHRlbGVtcyA9IGkgPT09IGxhc3QgPyB0aGlzIDogdGhpcy5jbG9uZSggdHJ1ZSApO1xcblxcdFxcdFxcdGpRdWVyeSggaW5zZXJ0WyBpIF0gKVsgb3JpZ2luYWwgXSggZWxlbXMgKTtcXG5cXG5cXHRcXHRcXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIG9ubHksIFBoYW50b21KUyAxIG9ubHlcXG5cXHRcXHRcXHQvLyAuZ2V0KCkgYmVjYXVzZSBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzIG9uIGFuY2llbnQgV2ViS2l0XFxuXFx0XFx0XFx0cHVzaC5hcHBseSggcmV0LCBlbGVtcy5nZXQoKSApO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIHJldCApO1xcblxcdH07XFxufSApO1xcbnZhciBybnVtbm9ucHggPSBuZXcgUmVnRXhwKCBcXFwiXihcXFwiICsgcG51bSArIFxcXCIpKD8hcHgpW2EteiVdKyRcXFwiLCBcXFwiaVxcXCIgKTtcXG5cXG52YXIgZ2V0U3R5bGVzID0gZnVuY3Rpb24oIGVsZW0gKSB7XFxuXFxuXFx0XFx0Ly8gU3VwcG9ydDogSUUgPD0xMSBvbmx5LCBGaXJlZm94IDw9MzAgKCMxNTA5OCwgIzE0MTUwKVxcblxcdFxcdC8vIElFIHRocm93cyBvbiBlbGVtZW50cyBjcmVhdGVkIGluIHBvcHVwc1xcblxcdFxcdC8vIEZGIG1lYW53aGlsZSB0aHJvd3Mgb24gZnJhbWUgZWxlbWVudHMgdGhyb3VnaCBcXFwiZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZVxcXCJcXG5cXHRcXHR2YXIgdmlldyA9IGVsZW0ub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldztcXG5cXG5cXHRcXHRpZiAoICF2aWV3IHx8ICF2aWV3Lm9wZW5lciApIHtcXG5cXHRcXHRcXHR2aWV3ID0gd2luZG93O1xcblxcdFxcdH1cXG5cXG5cXHRcXHRyZXR1cm4gdmlldy5nZXRDb21wdXRlZFN0eWxlKCBlbGVtICk7XFxuXFx0fTtcXG5cXG52YXIgcmJveFN0eWxlID0gbmV3IFJlZ0V4cCggY3NzRXhwYW5kLmpvaW4oIFxcXCJ8XFxcIiApLCBcXFwiaVxcXCIgKTtcXG5cXG5cXG5cXG4oIGZ1bmN0aW9uKCkge1xcblxcblxcdC8vIEV4ZWN1dGluZyBib3RoIHBpeGVsUG9zaXRpb24gJiBib3hTaXppbmdSZWxpYWJsZSB0ZXN0cyByZXF1aXJlIG9ubHkgb25lIGxheW91dFxcblxcdC8vIHNvIHRoZXkncmUgZXhlY3V0ZWQgYXQgdGhlIHNhbWUgdGltZSB0byBzYXZlIHRoZSBzZWNvbmQgY29tcHV0YXRpb24uXFxuXFx0ZnVuY3Rpb24gY29tcHV0ZVN0eWxlVGVzdHMoKSB7XFxuXFxuXFx0XFx0Ly8gVGhpcyBpcyBhIHNpbmdsZXRvbiwgd2UgbmVlZCB0byBleGVjdXRlIGl0IG9ubHkgb25jZVxcblxcdFxcdGlmICggIWRpdiApIHtcXG5cXHRcXHRcXHRyZXR1cm47XFxuXFx0XFx0fVxcblxcblxcdFxcdGNvbnRhaW5lci5zdHlsZS5jc3NUZXh0ID0gXFxcInBvc2l0aW9uOmFic29sdXRlO2xlZnQ6LTExMTExcHg7d2lkdGg6NjBweDtcXFwiICtcXG5cXHRcXHRcXHRcXFwibWFyZ2luLXRvcDoxcHg7cGFkZGluZzowO2JvcmRlcjowXFxcIjtcXG5cXHRcXHRkaXYuc3R5bGUuY3NzVGV4dCA9XFxuXFx0XFx0XFx0XFxcInBvc2l0aW9uOnJlbGF0aXZlO2Rpc3BsYXk6YmxvY2s7Ym94LXNpemluZzpib3JkZXItYm94O292ZXJmbG93OnNjcm9sbDtcXFwiICtcXG5cXHRcXHRcXHRcXFwibWFyZ2luOmF1dG87Ym9yZGVyOjFweDtwYWRkaW5nOjFweDtcXFwiICtcXG5cXHRcXHRcXHRcXFwid2lkdGg6NjAlO3RvcDoxJVxcXCI7XFxuXFx0XFx0ZG9jdW1lbnRFbGVtZW50LmFwcGVuZENoaWxkKCBjb250YWluZXIgKS5hcHBlbmRDaGlsZCggZGl2ICk7XFxuXFxuXFx0XFx0dmFyIGRpdlN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoIGRpdiApO1xcblxcdFxcdHBpeGVsUG9zaXRpb25WYWwgPSBkaXZTdHlsZS50b3AgIT09IFxcXCIxJVxcXCI7XFxuXFxuXFx0XFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA0LjAgLSA0LjMgb25seSwgRmlyZWZveCA8PTMgLSA0NFxcblxcdFxcdHJlbGlhYmxlTWFyZ2luTGVmdFZhbCA9IHJvdW5kUGl4ZWxNZWFzdXJlcyggZGl2U3R5bGUubWFyZ2luTGVmdCApID09PSAxMjtcXG5cXG5cXHRcXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDQuMCAtIDQuMyBvbmx5LCBTYWZhcmkgPD05LjEgLSAxMC4xLCBpT1MgPD03LjAgLSA5LjNcXG5cXHRcXHQvLyBTb21lIHN0eWxlcyBjb21lIGJhY2sgd2l0aCBwZXJjZW50YWdlIHZhbHVlcywgZXZlbiB0aG91Z2ggdGhleSBzaG91bGRuJ3RcXG5cXHRcXHRkaXYuc3R5bGUucmlnaHQgPSBcXFwiNjAlXFxcIjtcXG5cXHRcXHRwaXhlbEJveFN0eWxlc1ZhbCA9IHJvdW5kUGl4ZWxNZWFzdXJlcyggZGl2U3R5bGUucmlnaHQgKSA9PT0gMzY7XFxuXFxuXFx0XFx0Ly8gU3VwcG9ydDogSUUgOSAtIDExIG9ubHlcXG5cXHRcXHQvLyBEZXRlY3QgbWlzcmVwb3J0aW5nIG9mIGNvbnRlbnQgZGltZW5zaW9ucyBmb3IgYm94LXNpemluZzpib3JkZXItYm94IGVsZW1lbnRzXFxuXFx0XFx0Ym94U2l6aW5nUmVsaWFibGVWYWwgPSByb3VuZFBpeGVsTWVhc3VyZXMoIGRpdlN0eWxlLndpZHRoICkgPT09IDM2O1xcblxcblxcdFxcdC8vIFN1cHBvcnQ6IElFIDkgb25seVxcblxcdFxcdC8vIERldGVjdCBvdmVyZmxvdzpzY3JvbGwgc2NyZXdpbmVzcyAoZ2gtMzY5OSlcXG5cXHRcXHRkaXYuc3R5bGUucG9zaXRpb24gPSBcXFwiYWJzb2x1dGVcXFwiO1xcblxcdFxcdHNjcm9sbGJveFNpemVWYWwgPSBkaXYub2Zmc2V0V2lkdGggPT09IDM2IHx8IFxcXCJhYnNvbHV0ZVxcXCI7XFxuXFxuXFx0XFx0ZG9jdW1lbnRFbGVtZW50LnJlbW92ZUNoaWxkKCBjb250YWluZXIgKTtcXG5cXG5cXHRcXHQvLyBOdWxsaWZ5IHRoZSBkaXYgc28gaXQgd291bGRuJ3QgYmUgc3RvcmVkIGluIHRoZSBtZW1vcnkgYW5kXFxuXFx0XFx0Ly8gaXQgd2lsbCBhbHNvIGJlIGEgc2lnbiB0aGF0IGNoZWNrcyBhbHJlYWR5IHBlcmZvcm1lZFxcblxcdFxcdGRpdiA9IG51bGw7XFxuXFx0fVxcblxcblxcdGZ1bmN0aW9uIHJvdW5kUGl4ZWxNZWFzdXJlcyggbWVhc3VyZSApIHtcXG5cXHRcXHRyZXR1cm4gTWF0aC5yb3VuZCggcGFyc2VGbG9hdCggbWVhc3VyZSApICk7XFxuXFx0fVxcblxcblxcdHZhciBwaXhlbFBvc2l0aW9uVmFsLCBib3hTaXppbmdSZWxpYWJsZVZhbCwgc2Nyb2xsYm94U2l6ZVZhbCwgcGl4ZWxCb3hTdHlsZXNWYWwsXFxuXFx0XFx0cmVsaWFibGVNYXJnaW5MZWZ0VmFsLFxcblxcdFxcdGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFxcXCJkaXZcXFwiICksXFxuXFx0XFx0ZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXFxcImRpdlxcXCIgKTtcXG5cXG5cXHQvLyBGaW5pc2ggZWFybHkgaW4gbGltaXRlZCAobm9uLWJyb3dzZXIpIGVudmlyb25tZW50c1xcblxcdGlmICggIWRpdi5zdHlsZSApIHtcXG5cXHRcXHRyZXR1cm47XFxuXFx0fVxcblxcblxcdC8vIFN1cHBvcnQ6IElFIDw9OSAtIDExIG9ubHlcXG5cXHQvLyBTdHlsZSBvZiBjbG9uZWQgZWxlbWVudCBhZmZlY3RzIHNvdXJjZSBlbGVtZW50IGNsb25lZCAoIzg5MDgpXFxuXFx0ZGl2LnN0eWxlLmJhY2tncm91bmRDbGlwID0gXFxcImNvbnRlbnQtYm94XFxcIjtcXG5cXHRkaXYuY2xvbmVOb2RlKCB0cnVlICkuc3R5bGUuYmFja2dyb3VuZENsaXAgPSBcXFwiXFxcIjtcXG5cXHRzdXBwb3J0LmNsZWFyQ2xvbmVTdHlsZSA9IGRpdi5zdHlsZS5iYWNrZ3JvdW5kQ2xpcCA9PT0gXFxcImNvbnRlbnQtYm94XFxcIjtcXG5cXG5cXHRqUXVlcnkuZXh0ZW5kKCBzdXBwb3J0LCB7XFxuXFx0XFx0Ym94U2l6aW5nUmVsaWFibGU6IGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdGNvbXB1dGVTdHlsZVRlc3RzKCk7XFxuXFx0XFx0XFx0cmV0dXJuIGJveFNpemluZ1JlbGlhYmxlVmFsO1xcblxcdFxcdH0sXFxuXFx0XFx0cGl4ZWxCb3hTdHlsZXM6IGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdGNvbXB1dGVTdHlsZVRlc3RzKCk7XFxuXFx0XFx0XFx0cmV0dXJuIHBpeGVsQm94U3R5bGVzVmFsO1xcblxcdFxcdH0sXFxuXFx0XFx0cGl4ZWxQb3NpdGlvbjogZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0Y29tcHV0ZVN0eWxlVGVzdHMoKTtcXG5cXHRcXHRcXHRyZXR1cm4gcGl4ZWxQb3NpdGlvblZhbDtcXG5cXHRcXHR9LFxcblxcdFxcdHJlbGlhYmxlTWFyZ2luTGVmdDogZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0Y29tcHV0ZVN0eWxlVGVzdHMoKTtcXG5cXHRcXHRcXHRyZXR1cm4gcmVsaWFibGVNYXJnaW5MZWZ0VmFsO1xcblxcdFxcdH0sXFxuXFx0XFx0c2Nyb2xsYm94U2l6ZTogZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0Y29tcHV0ZVN0eWxlVGVzdHMoKTtcXG5cXHRcXHRcXHRyZXR1cm4gc2Nyb2xsYm94U2l6ZVZhbDtcXG5cXHRcXHR9XFxuXFx0fSApO1xcbn0gKSgpO1xcblxcblxcbmZ1bmN0aW9uIGN1ckNTUyggZWxlbSwgbmFtZSwgY29tcHV0ZWQgKSB7XFxuXFx0dmFyIHdpZHRoLCBtaW5XaWR0aCwgbWF4V2lkdGgsIHJldCxcXG5cXG5cXHRcXHQvLyBTdXBwb3J0OiBGaXJlZm94IDUxK1xcblxcdFxcdC8vIFJldHJpZXZpbmcgc3R5bGUgYmVmb3JlIGNvbXB1dGVkIHNvbWVob3dcXG5cXHRcXHQvLyBmaXhlcyBhbiBpc3N1ZSB3aXRoIGdldHRpbmcgd3JvbmcgdmFsdWVzXFxuXFx0XFx0Ly8gb24gZGV0YWNoZWQgZWxlbWVudHNcXG5cXHRcXHRzdHlsZSA9IGVsZW0uc3R5bGU7XFxuXFxuXFx0Y29tcHV0ZWQgPSBjb21wdXRlZCB8fCBnZXRTdHlsZXMoIGVsZW0gKTtcXG5cXG5cXHQvLyBnZXRQcm9wZXJ0eVZhbHVlIGlzIG5lZWRlZCBmb3I6XFxuXFx0Ly8gICAuY3NzKCdmaWx0ZXInKSAoSUUgOSBvbmx5LCAjMTI1MzcpXFxuXFx0Ly8gICAuY3NzKCctLWN1c3RvbVByb3BlcnR5KSAoIzMxNDQpXFxuXFx0aWYgKCBjb21wdXRlZCApIHtcXG5cXHRcXHRyZXQgPSBjb21wdXRlZC5nZXRQcm9wZXJ0eVZhbHVlKCBuYW1lICkgfHwgY29tcHV0ZWRbIG5hbWUgXTtcXG5cXG5cXHRcXHRpZiAoIHJldCA9PT0gXFxcIlxcXCIgJiYgIWpRdWVyeS5jb250YWlucyggZWxlbS5vd25lckRvY3VtZW50LCBlbGVtICkgKSB7XFxuXFx0XFx0XFx0cmV0ID0galF1ZXJ5LnN0eWxlKCBlbGVtLCBuYW1lICk7XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIEEgdHJpYnV0ZSB0byB0aGUgXFxcImF3ZXNvbWUgaGFjayBieSBEZWFuIEVkd2FyZHNcXFwiXFxuXFx0XFx0Ly8gQW5kcm9pZCBCcm93c2VyIHJldHVybnMgcGVyY2VudGFnZSBmb3Igc29tZSB2YWx1ZXMsXFxuXFx0XFx0Ly8gYnV0IHdpZHRoIHNlZW1zIHRvIGJlIHJlbGlhYmx5IHBpeGVscy5cXG5cXHRcXHQvLyBUaGlzIGlzIGFnYWluc3QgdGhlIENTU09NIGRyYWZ0IHNwZWM6XFxuXFx0XFx0Ly8gaHR0cHM6Ly9kcmFmdHMuY3Nzd2cub3JnL2Nzc29tLyNyZXNvbHZlZC12YWx1ZXNcXG5cXHRcXHRpZiAoICFzdXBwb3J0LnBpeGVsQm94U3R5bGVzKCkgJiYgcm51bW5vbnB4LnRlc3QoIHJldCApICYmIHJib3hTdHlsZS50ZXN0KCBuYW1lICkgKSB7XFxuXFxuXFx0XFx0XFx0Ly8gUmVtZW1iZXIgdGhlIG9yaWdpbmFsIHZhbHVlc1xcblxcdFxcdFxcdHdpZHRoID0gc3R5bGUud2lkdGg7XFxuXFx0XFx0XFx0bWluV2lkdGggPSBzdHlsZS5taW5XaWR0aDtcXG5cXHRcXHRcXHRtYXhXaWR0aCA9IHN0eWxlLm1heFdpZHRoO1xcblxcblxcdFxcdFxcdC8vIFB1dCBpbiB0aGUgbmV3IHZhbHVlcyB0byBnZXQgYSBjb21wdXRlZCB2YWx1ZSBvdXRcXG5cXHRcXHRcXHRzdHlsZS5taW5XaWR0aCA9IHN0eWxlLm1heFdpZHRoID0gc3R5bGUud2lkdGggPSByZXQ7XFxuXFx0XFx0XFx0cmV0ID0gY29tcHV0ZWQud2lkdGg7XFxuXFxuXFx0XFx0XFx0Ly8gUmV2ZXJ0IHRoZSBjaGFuZ2VkIHZhbHVlc1xcblxcdFxcdFxcdHN0eWxlLndpZHRoID0gd2lkdGg7XFxuXFx0XFx0XFx0c3R5bGUubWluV2lkdGggPSBtaW5XaWR0aDtcXG5cXHRcXHRcXHRzdHlsZS5tYXhXaWR0aCA9IG1heFdpZHRoO1xcblxcdFxcdH1cXG5cXHR9XFxuXFxuXFx0cmV0dXJuIHJldCAhPT0gdW5kZWZpbmVkID9cXG5cXG5cXHRcXHQvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSBvbmx5XFxuXFx0XFx0Ly8gSUUgcmV0dXJucyB6SW5kZXggdmFsdWUgYXMgYW4gaW50ZWdlci5cXG5cXHRcXHRyZXQgKyBcXFwiXFxcIiA6XFxuXFx0XFx0cmV0O1xcbn1cXG5cXG5cXG5mdW5jdGlvbiBhZGRHZXRIb29rSWYoIGNvbmRpdGlvbkZuLCBob29rRm4gKSB7XFxuXFxuXFx0Ly8gRGVmaW5lIHRoZSBob29rLCB3ZSdsbCBjaGVjayBvbiB0aGUgZmlyc3QgcnVuIGlmIGl0J3MgcmVhbGx5IG5lZWRlZC5cXG5cXHRyZXR1cm4ge1xcblxcdFxcdGdldDogZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0aWYgKCBjb25kaXRpb25GbigpICkge1xcblxcblxcdFxcdFxcdFxcdC8vIEhvb2sgbm90IG5lZWRlZCAob3IgaXQncyBub3QgcG9zc2libGUgdG8gdXNlIGl0IGR1ZVxcblxcdFxcdFxcdFxcdC8vIHRvIG1pc3NpbmcgZGVwZW5kZW5jeSksIHJlbW92ZSBpdC5cXG5cXHRcXHRcXHRcXHRkZWxldGUgdGhpcy5nZXQ7XFxuXFx0XFx0XFx0XFx0cmV0dXJuO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBIb29rIG5lZWRlZDsgcmVkZWZpbmUgaXQgc28gdGhhdCB0aGUgc3VwcG9ydCB0ZXN0IGlzIG5vdCBleGVjdXRlZCBhZ2Fpbi5cXG5cXHRcXHRcXHRyZXR1cm4gKCB0aGlzLmdldCA9IGhvb2tGbiApLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcXG5cXHRcXHR9XFxuXFx0fTtcXG59XFxuXFxuXFxudmFyXFxuXFxuXFx0Ly8gU3dhcHBhYmxlIGlmIGRpc3BsYXkgaXMgbm9uZSBvciBzdGFydHMgd2l0aCB0YWJsZVxcblxcdC8vIGV4Y2VwdCBcXFwidGFibGVcXFwiLCBcXFwidGFibGUtY2VsbFxcXCIsIG9yIFxcXCJ0YWJsZS1jYXB0aW9uXFxcIlxcblxcdC8vIFNlZSBoZXJlIGZvciBkaXNwbGF5IHZhbHVlczogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9DU1MvZGlzcGxheVxcblxcdHJkaXNwbGF5c3dhcCA9IC9eKG5vbmV8dGFibGUoPyEtY1tlYV0pLispLyxcXG5cXHRyY3VzdG9tUHJvcCA9IC9eLS0vLFxcblxcdGNzc1Nob3cgPSB7IHBvc2l0aW9uOiBcXFwiYWJzb2x1dGVcXFwiLCB2aXNpYmlsaXR5OiBcXFwiaGlkZGVuXFxcIiwgZGlzcGxheTogXFxcImJsb2NrXFxcIiB9LFxcblxcdGNzc05vcm1hbFRyYW5zZm9ybSA9IHtcXG5cXHRcXHRsZXR0ZXJTcGFjaW5nOiBcXFwiMFxcXCIsXFxuXFx0XFx0Zm9udFdlaWdodDogXFxcIjQwMFxcXCJcXG5cXHR9LFxcblxcblxcdGNzc1ByZWZpeGVzID0gWyBcXFwiV2Via2l0XFxcIiwgXFxcIk1velxcXCIsIFxcXCJtc1xcXCIgXSxcXG5cXHRlbXB0eVN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXFxcImRpdlxcXCIgKS5zdHlsZTtcXG5cXG4vLyBSZXR1cm4gYSBjc3MgcHJvcGVydHkgbWFwcGVkIHRvIGEgcG90ZW50aWFsbHkgdmVuZG9yIHByZWZpeGVkIHByb3BlcnR5XFxuZnVuY3Rpb24gdmVuZG9yUHJvcE5hbWUoIG5hbWUgKSB7XFxuXFxuXFx0Ly8gU2hvcnRjdXQgZm9yIG5hbWVzIHRoYXQgYXJlIG5vdCB2ZW5kb3IgcHJlZml4ZWRcXG5cXHRpZiAoIG5hbWUgaW4gZW1wdHlTdHlsZSApIHtcXG5cXHRcXHRyZXR1cm4gbmFtZTtcXG5cXHR9XFxuXFxuXFx0Ly8gQ2hlY2sgZm9yIHZlbmRvciBwcmVmaXhlZCBuYW1lc1xcblxcdHZhciBjYXBOYW1lID0gbmFtZVsgMCBdLnRvVXBwZXJDYXNlKCkgKyBuYW1lLnNsaWNlKCAxICksXFxuXFx0XFx0aSA9IGNzc1ByZWZpeGVzLmxlbmd0aDtcXG5cXG5cXHR3aGlsZSAoIGktLSApIHtcXG5cXHRcXHRuYW1lID0gY3NzUHJlZml4ZXNbIGkgXSArIGNhcE5hbWU7XFxuXFx0XFx0aWYgKCBuYW1lIGluIGVtcHR5U3R5bGUgKSB7XFxuXFx0XFx0XFx0cmV0dXJuIG5hbWU7XFxuXFx0XFx0fVxcblxcdH1cXG59XFxuXFxuLy8gUmV0dXJuIGEgcHJvcGVydHkgbWFwcGVkIGFsb25nIHdoYXQgalF1ZXJ5LmNzc1Byb3BzIHN1Z2dlc3RzIG9yIHRvXFxuLy8gYSB2ZW5kb3IgcHJlZml4ZWQgcHJvcGVydHkuXFxuZnVuY3Rpb24gZmluYWxQcm9wTmFtZSggbmFtZSApIHtcXG5cXHR2YXIgcmV0ID0galF1ZXJ5LmNzc1Byb3BzWyBuYW1lIF07XFxuXFx0aWYgKCAhcmV0ICkge1xcblxcdFxcdHJldCA9IGpRdWVyeS5jc3NQcm9wc1sgbmFtZSBdID0gdmVuZG9yUHJvcE5hbWUoIG5hbWUgKSB8fCBuYW1lO1xcblxcdH1cXG5cXHRyZXR1cm4gcmV0O1xcbn1cXG5cXG5mdW5jdGlvbiBzZXRQb3NpdGl2ZU51bWJlciggZWxlbSwgdmFsdWUsIHN1YnRyYWN0ICkge1xcblxcblxcdC8vIEFueSByZWxhdGl2ZSAoKy8tKSB2YWx1ZXMgaGF2ZSBhbHJlYWR5IGJlZW5cXG5cXHQvLyBub3JtYWxpemVkIGF0IHRoaXMgcG9pbnRcXG5cXHR2YXIgbWF0Y2hlcyA9IHJjc3NOdW0uZXhlYyggdmFsdWUgKTtcXG5cXHRyZXR1cm4gbWF0Y2hlcyA/XFxuXFxuXFx0XFx0Ly8gR3VhcmQgYWdhaW5zdCB1bmRlZmluZWQgXFxcInN1YnRyYWN0XFxcIiwgZS5nLiwgd2hlbiB1c2VkIGFzIGluIGNzc0hvb2tzXFxuXFx0XFx0TWF0aC5tYXgoIDAsIG1hdGNoZXNbIDIgXSAtICggc3VidHJhY3QgfHwgMCApICkgKyAoIG1hdGNoZXNbIDMgXSB8fCBcXFwicHhcXFwiICkgOlxcblxcdFxcdHZhbHVlO1xcbn1cXG5cXG5mdW5jdGlvbiBib3hNb2RlbEFkanVzdG1lbnQoIGVsZW0sIGRpbWVuc2lvbiwgYm94LCBpc0JvcmRlckJveCwgc3R5bGVzLCBjb21wdXRlZFZhbCApIHtcXG5cXHR2YXIgaSA9IGRpbWVuc2lvbiA9PT0gXFxcIndpZHRoXFxcIiA/IDEgOiAwLFxcblxcdFxcdGV4dHJhID0gMCxcXG5cXHRcXHRkZWx0YSA9IDA7XFxuXFxuXFx0Ly8gQWRqdXN0bWVudCBtYXkgbm90IGJlIG5lY2Vzc2FyeVxcblxcdGlmICggYm94ID09PSAoIGlzQm9yZGVyQm94ID8gXFxcImJvcmRlclxcXCIgOiBcXFwiY29udGVudFxcXCIgKSApIHtcXG5cXHRcXHRyZXR1cm4gMDtcXG5cXHR9XFxuXFxuXFx0Zm9yICggOyBpIDwgNDsgaSArPSAyICkge1xcblxcblxcdFxcdC8vIEJvdGggYm94IG1vZGVscyBleGNsdWRlIG1hcmdpblxcblxcdFxcdGlmICggYm94ID09PSBcXFwibWFyZ2luXFxcIiApIHtcXG5cXHRcXHRcXHRkZWx0YSArPSBqUXVlcnkuY3NzKCBlbGVtLCBib3ggKyBjc3NFeHBhbmRbIGkgXSwgdHJ1ZSwgc3R5bGVzICk7XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIElmIHdlIGdldCBoZXJlIHdpdGggYSBjb250ZW50LWJveCwgd2UncmUgc2Vla2luZyBcXFwicGFkZGluZ1xcXCIgb3IgXFxcImJvcmRlclxcXCIgb3IgXFxcIm1hcmdpblxcXCJcXG5cXHRcXHRpZiAoICFpc0JvcmRlckJveCApIHtcXG5cXG5cXHRcXHRcXHQvLyBBZGQgcGFkZGluZ1xcblxcdFxcdFxcdGRlbHRhICs9IGpRdWVyeS5jc3MoIGVsZW0sIFxcXCJwYWRkaW5nXFxcIiArIGNzc0V4cGFuZFsgaSBdLCB0cnVlLCBzdHlsZXMgKTtcXG5cXG5cXHRcXHRcXHQvLyBGb3IgXFxcImJvcmRlclxcXCIgb3IgXFxcIm1hcmdpblxcXCIsIGFkZCBib3JkZXJcXG5cXHRcXHRcXHRpZiAoIGJveCAhPT0gXFxcInBhZGRpbmdcXFwiICkge1xcblxcdFxcdFxcdFxcdGRlbHRhICs9IGpRdWVyeS5jc3MoIGVsZW0sIFxcXCJib3JkZXJcXFwiICsgY3NzRXhwYW5kWyBpIF0gKyBcXFwiV2lkdGhcXFwiLCB0cnVlLCBzdHlsZXMgKTtcXG5cXG5cXHRcXHRcXHQvLyBCdXQgc3RpbGwga2VlcCB0cmFjayBvZiBpdCBvdGhlcndpc2VcXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdGV4dHJhICs9IGpRdWVyeS5jc3MoIGVsZW0sIFxcXCJib3JkZXJcXFwiICsgY3NzRXhwYW5kWyBpIF0gKyBcXFwiV2lkdGhcXFwiLCB0cnVlLCBzdHlsZXMgKTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0Ly8gSWYgd2UgZ2V0IGhlcmUgd2l0aCBhIGJvcmRlci1ib3ggKGNvbnRlbnQgKyBwYWRkaW5nICsgYm9yZGVyKSwgd2UncmUgc2Vla2luZyBcXFwiY29udGVudFxcXCIgb3JcXG5cXHRcXHQvLyBcXFwicGFkZGluZ1xcXCIgb3IgXFxcIm1hcmdpblxcXCJcXG5cXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdC8vIEZvciBcXFwiY29udGVudFxcXCIsIHN1YnRyYWN0IHBhZGRpbmdcXG5cXHRcXHRcXHRpZiAoIGJveCA9PT0gXFxcImNvbnRlbnRcXFwiICkge1xcblxcdFxcdFxcdFxcdGRlbHRhIC09IGpRdWVyeS5jc3MoIGVsZW0sIFxcXCJwYWRkaW5nXFxcIiArIGNzc0V4cGFuZFsgaSBdLCB0cnVlLCBzdHlsZXMgKTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gRm9yIFxcXCJjb250ZW50XFxcIiBvciBcXFwicGFkZGluZ1xcXCIsIHN1YnRyYWN0IGJvcmRlclxcblxcdFxcdFxcdGlmICggYm94ICE9PSBcXFwibWFyZ2luXFxcIiApIHtcXG5cXHRcXHRcXHRcXHRkZWx0YSAtPSBqUXVlcnkuY3NzKCBlbGVtLCBcXFwiYm9yZGVyXFxcIiArIGNzc0V4cGFuZFsgaSBdICsgXFxcIldpZHRoXFxcIiwgdHJ1ZSwgc3R5bGVzICk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXHR9XFxuXFxuXFx0Ly8gQWNjb3VudCBmb3IgcG9zaXRpdmUgY29udGVudC1ib3ggc2Nyb2xsIGd1dHRlciB3aGVuIHJlcXVlc3RlZCBieSBwcm92aWRpbmcgY29tcHV0ZWRWYWxcXG5cXHRpZiAoICFpc0JvcmRlckJveCAmJiBjb21wdXRlZFZhbCA+PSAwICkge1xcblxcblxcdFxcdC8vIG9mZnNldFdpZHRoL29mZnNldEhlaWdodCBpcyBhIHJvdW5kZWQgc3VtIG9mIGNvbnRlbnQsIHBhZGRpbmcsIHNjcm9sbCBndXR0ZXIsIGFuZCBib3JkZXJcXG5cXHRcXHQvLyBBc3N1bWluZyBpbnRlZ2VyIHNjcm9sbCBndXR0ZXIsIHN1YnRyYWN0IHRoZSByZXN0IGFuZCByb3VuZCBkb3duXFxuXFx0XFx0ZGVsdGEgKz0gTWF0aC5tYXgoIDAsIE1hdGguY2VpbChcXG5cXHRcXHRcXHRlbGVtWyBcXFwib2Zmc2V0XFxcIiArIGRpbWVuc2lvblsgMCBdLnRvVXBwZXJDYXNlKCkgKyBkaW1lbnNpb24uc2xpY2UoIDEgKSBdIC1cXG5cXHRcXHRcXHRjb21wdXRlZFZhbCAtXFxuXFx0XFx0XFx0ZGVsdGEgLVxcblxcdFxcdFxcdGV4dHJhIC1cXG5cXHRcXHRcXHQwLjVcXG5cXHRcXHQpICk7XFxuXFx0fVxcblxcblxcdHJldHVybiBkZWx0YTtcXG59XFxuXFxuZnVuY3Rpb24gZ2V0V2lkdGhPckhlaWdodCggZWxlbSwgZGltZW5zaW9uLCBleHRyYSApIHtcXG5cXG5cXHQvLyBTdGFydCB3aXRoIGNvbXB1dGVkIHN0eWxlXFxuXFx0dmFyIHN0eWxlcyA9IGdldFN0eWxlcyggZWxlbSApLFxcblxcdFxcdHZhbCA9IGN1ckNTUyggZWxlbSwgZGltZW5zaW9uLCBzdHlsZXMgKSxcXG5cXHRcXHRpc0JvcmRlckJveCA9IGpRdWVyeS5jc3MoIGVsZW0sIFxcXCJib3hTaXppbmdcXFwiLCBmYWxzZSwgc3R5bGVzICkgPT09IFxcXCJib3JkZXItYm94XFxcIixcXG5cXHRcXHR2YWx1ZUlzQm9yZGVyQm94ID0gaXNCb3JkZXJCb3g7XFxuXFxuXFx0Ly8gU3VwcG9ydDogRmlyZWZveCA8PTU0XFxuXFx0Ly8gUmV0dXJuIGEgY29uZm91bmRpbmcgbm9uLXBpeGVsIHZhbHVlIG9yIGZlaWduIGlnbm9yYW5jZSwgYXMgYXBwcm9wcmlhdGUuXFxuXFx0aWYgKCBybnVtbm9ucHgudGVzdCggdmFsICkgKSB7XFxuXFx0XFx0aWYgKCAhZXh0cmEgKSB7XFxuXFx0XFx0XFx0cmV0dXJuIHZhbDtcXG5cXHRcXHR9XFxuXFx0XFx0dmFsID0gXFxcImF1dG9cXFwiO1xcblxcdH1cXG5cXG5cXHQvLyBDaGVjayBmb3Igc3R5bGUgaW4gY2FzZSBhIGJyb3dzZXIgd2hpY2ggcmV0dXJucyB1bnJlbGlhYmxlIHZhbHVlc1xcblxcdC8vIGZvciBnZXRDb21wdXRlZFN0eWxlIHNpbGVudGx5IGZhbGxzIGJhY2sgdG8gdGhlIHJlbGlhYmxlIGVsZW0uc3R5bGVcXG5cXHR2YWx1ZUlzQm9yZGVyQm94ID0gdmFsdWVJc0JvcmRlckJveCAmJlxcblxcdFxcdCggc3VwcG9ydC5ib3hTaXppbmdSZWxpYWJsZSgpIHx8IHZhbCA9PT0gZWxlbS5zdHlsZVsgZGltZW5zaW9uIF0gKTtcXG5cXG5cXHQvLyBGYWxsIGJhY2sgdG8gb2Zmc2V0V2lkdGgvb2Zmc2V0SGVpZ2h0IHdoZW4gdmFsdWUgaXMgXFxcImF1dG9cXFwiXFxuXFx0Ly8gVGhpcyBoYXBwZW5zIGZvciBpbmxpbmUgZWxlbWVudHMgd2l0aCBubyBleHBsaWNpdCBzZXR0aW5nIChnaC0zNTcxKVxcblxcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjEgLSA0LjMgb25seVxcblxcdC8vIEFsc28gdXNlIG9mZnNldFdpZHRoL29mZnNldEhlaWdodCBmb3IgbWlzcmVwb3J0ZWQgaW5saW5lIGRpbWVuc2lvbnMgKGdoLTM2MDIpXFxuXFx0aWYgKCB2YWwgPT09IFxcXCJhdXRvXFxcIiB8fFxcblxcdFxcdCFwYXJzZUZsb2F0KCB2YWwgKSAmJiBqUXVlcnkuY3NzKCBlbGVtLCBcXFwiZGlzcGxheVxcXCIsIGZhbHNlLCBzdHlsZXMgKSA9PT0gXFxcImlubGluZVxcXCIgKSB7XFxuXFxuXFx0XFx0dmFsID0gZWxlbVsgXFxcIm9mZnNldFxcXCIgKyBkaW1lbnNpb25bIDAgXS50b1VwcGVyQ2FzZSgpICsgZGltZW5zaW9uLnNsaWNlKCAxICkgXTtcXG5cXG5cXHRcXHQvLyBvZmZzZXRXaWR0aC9vZmZzZXRIZWlnaHQgcHJvdmlkZSBib3JkZXItYm94IHZhbHVlc1xcblxcdFxcdHZhbHVlSXNCb3JkZXJCb3ggPSB0cnVlO1xcblxcdH1cXG5cXG5cXHQvLyBOb3JtYWxpemUgXFxcIlxcXCIgYW5kIGF1dG9cXG5cXHR2YWwgPSBwYXJzZUZsb2F0KCB2YWwgKSB8fCAwO1xcblxcblxcdC8vIEFkanVzdCBmb3IgdGhlIGVsZW1lbnQncyBib3ggbW9kZWxcXG5cXHRyZXR1cm4gKCB2YWwgK1xcblxcdFxcdGJveE1vZGVsQWRqdXN0bWVudChcXG5cXHRcXHRcXHRlbGVtLFxcblxcdFxcdFxcdGRpbWVuc2lvbixcXG5cXHRcXHRcXHRleHRyYSB8fCAoIGlzQm9yZGVyQm94ID8gXFxcImJvcmRlclxcXCIgOiBcXFwiY29udGVudFxcXCIgKSxcXG5cXHRcXHRcXHR2YWx1ZUlzQm9yZGVyQm94LFxcblxcdFxcdFxcdHN0eWxlcyxcXG5cXG5cXHRcXHRcXHQvLyBQcm92aWRlIHRoZSBjdXJyZW50IGNvbXB1dGVkIHNpemUgdG8gcmVxdWVzdCBzY3JvbGwgZ3V0dGVyIGNhbGN1bGF0aW9uIChnaC0zNTg5KVxcblxcdFxcdFxcdHZhbFxcblxcdFxcdClcXG5cXHQpICsgXFxcInB4XFxcIjtcXG59XFxuXFxualF1ZXJ5LmV4dGVuZCgge1xcblxcblxcdC8vIEFkZCBpbiBzdHlsZSBwcm9wZXJ0eSBob29rcyBmb3Igb3ZlcnJpZGluZyB0aGUgZGVmYXVsdFxcblxcdC8vIGJlaGF2aW9yIG9mIGdldHRpbmcgYW5kIHNldHRpbmcgYSBzdHlsZSBwcm9wZXJ0eVxcblxcdGNzc0hvb2tzOiB7XFxuXFx0XFx0b3BhY2l0eToge1xcblxcdFxcdFxcdGdldDogZnVuY3Rpb24oIGVsZW0sIGNvbXB1dGVkICkge1xcblxcdFxcdFxcdFxcdGlmICggY29tcHV0ZWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gV2Ugc2hvdWxkIGFsd2F5cyBnZXQgYSBudW1iZXIgYmFjayBmcm9tIG9wYWNpdHlcXG5cXHRcXHRcXHRcXHRcXHR2YXIgcmV0ID0gY3VyQ1NTKCBlbGVtLCBcXFwib3BhY2l0eVxcXCIgKTtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gcmV0ID09PSBcXFwiXFxcIiA/IFxcXCIxXFxcIiA6IHJldDtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXHR9LFxcblxcblxcdC8vIERvbid0IGF1dG9tYXRpY2FsbHkgYWRkIFxcXCJweFxcXCIgdG8gdGhlc2UgcG9zc2libHktdW5pdGxlc3MgcHJvcGVydGllc1xcblxcdGNzc051bWJlcjoge1xcblxcdFxcdFxcXCJhbmltYXRpb25JdGVyYXRpb25Db3VudFxcXCI6IHRydWUsXFxuXFx0XFx0XFxcImNvbHVtbkNvdW50XFxcIjogdHJ1ZSxcXG5cXHRcXHRcXFwiZmlsbE9wYWNpdHlcXFwiOiB0cnVlLFxcblxcdFxcdFxcXCJmbGV4R3Jvd1xcXCI6IHRydWUsXFxuXFx0XFx0XFxcImZsZXhTaHJpbmtcXFwiOiB0cnVlLFxcblxcdFxcdFxcXCJmb250V2VpZ2h0XFxcIjogdHJ1ZSxcXG5cXHRcXHRcXFwibGluZUhlaWdodFxcXCI6IHRydWUsXFxuXFx0XFx0XFxcIm9wYWNpdHlcXFwiOiB0cnVlLFxcblxcdFxcdFxcXCJvcmRlclxcXCI6IHRydWUsXFxuXFx0XFx0XFxcIm9ycGhhbnNcXFwiOiB0cnVlLFxcblxcdFxcdFxcXCJ3aWRvd3NcXFwiOiB0cnVlLFxcblxcdFxcdFxcXCJ6SW5kZXhcXFwiOiB0cnVlLFxcblxcdFxcdFxcXCJ6b29tXFxcIjogdHJ1ZVxcblxcdH0sXFxuXFxuXFx0Ly8gQWRkIGluIHByb3BlcnRpZXMgd2hvc2UgbmFtZXMgeW91IHdpc2ggdG8gZml4IGJlZm9yZVxcblxcdC8vIHNldHRpbmcgb3IgZ2V0dGluZyB0aGUgdmFsdWVcXG5cXHRjc3NQcm9wczoge30sXFxuXFxuXFx0Ly8gR2V0IGFuZCBzZXQgdGhlIHN0eWxlIHByb3BlcnR5IG9uIGEgRE9NIE5vZGVcXG5cXHRzdHlsZTogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIHZhbHVlLCBleHRyYSApIHtcXG5cXG5cXHRcXHQvLyBEb24ndCBzZXQgc3R5bGVzIG9uIHRleHQgYW5kIGNvbW1lbnQgbm9kZXNcXG5cXHRcXHRpZiAoICFlbGVtIHx8IGVsZW0ubm9kZVR5cGUgPT09IDMgfHwgZWxlbS5ub2RlVHlwZSA9PT0gOCB8fCAhZWxlbS5zdHlsZSApIHtcXG5cXHRcXHRcXHRyZXR1cm47XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIE1ha2Ugc3VyZSB0aGF0IHdlJ3JlIHdvcmtpbmcgd2l0aCB0aGUgcmlnaHQgbmFtZVxcblxcdFxcdHZhciByZXQsIHR5cGUsIGhvb2tzLFxcblxcdFxcdFxcdG9yaWdOYW1lID0gY2FtZWxDYXNlKCBuYW1lICksXFxuXFx0XFx0XFx0aXNDdXN0b21Qcm9wID0gcmN1c3RvbVByb3AudGVzdCggbmFtZSApLFxcblxcdFxcdFxcdHN0eWxlID0gZWxlbS5zdHlsZTtcXG5cXG5cXHRcXHQvLyBNYWtlIHN1cmUgdGhhdCB3ZSdyZSB3b3JraW5nIHdpdGggdGhlIHJpZ2h0IG5hbWUuIFdlIGRvbid0XFxuXFx0XFx0Ly8gd2FudCB0byBxdWVyeSB0aGUgdmFsdWUgaWYgaXQgaXMgYSBDU1MgY3VzdG9tIHByb3BlcnR5XFxuXFx0XFx0Ly8gc2luY2UgdGhleSBhcmUgdXNlci1kZWZpbmVkLlxcblxcdFxcdGlmICggIWlzQ3VzdG9tUHJvcCApIHtcXG5cXHRcXHRcXHRuYW1lID0gZmluYWxQcm9wTmFtZSggb3JpZ05hbWUgKTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gR2V0cyBob29rIGZvciB0aGUgcHJlZml4ZWQgdmVyc2lvbiwgdGhlbiB1bnByZWZpeGVkIHZlcnNpb25cXG5cXHRcXHRob29rcyA9IGpRdWVyeS5jc3NIb29rc1sgbmFtZSBdIHx8IGpRdWVyeS5jc3NIb29rc1sgb3JpZ05hbWUgXTtcXG5cXG5cXHRcXHQvLyBDaGVjayBpZiB3ZSdyZSBzZXR0aW5nIGEgdmFsdWVcXG5cXHRcXHRpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XFxuXFx0XFx0XFx0dHlwZSA9IHR5cGVvZiB2YWx1ZTtcXG5cXG5cXHRcXHRcXHQvLyBDb252ZXJ0IFxcXCIrPVxcXCIgb3IgXFxcIi09XFxcIiB0byByZWxhdGl2ZSBudW1iZXJzICgjNzM0NSlcXG5cXHRcXHRcXHRpZiAoIHR5cGUgPT09IFxcXCJzdHJpbmdcXFwiICYmICggcmV0ID0gcmNzc051bS5leGVjKCB2YWx1ZSApICkgJiYgcmV0WyAxIF0gKSB7XFxuXFx0XFx0XFx0XFx0dmFsdWUgPSBhZGp1c3RDU1MoIGVsZW0sIG5hbWUsIHJldCApO1xcblxcblxcdFxcdFxcdFxcdC8vIEZpeGVzIGJ1ZyAjOTIzN1xcblxcdFxcdFxcdFxcdHR5cGUgPSBcXFwibnVtYmVyXFxcIjtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gTWFrZSBzdXJlIHRoYXQgbnVsbCBhbmQgTmFOIHZhbHVlcyBhcmVuJ3Qgc2V0ICgjNzExNilcXG5cXHRcXHRcXHRpZiAoIHZhbHVlID09IG51bGwgfHwgdmFsdWUgIT09IHZhbHVlICkge1xcblxcdFxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gSWYgYSBudW1iZXIgd2FzIHBhc3NlZCBpbiwgYWRkIHRoZSB1bml0IChleGNlcHQgZm9yIGNlcnRhaW4gQ1NTIHByb3BlcnRpZXMpXFxuXFx0XFx0XFx0aWYgKCB0eXBlID09PSBcXFwibnVtYmVyXFxcIiApIHtcXG5cXHRcXHRcXHRcXHR2YWx1ZSArPSByZXQgJiYgcmV0WyAzIF0gfHwgKCBqUXVlcnkuY3NzTnVtYmVyWyBvcmlnTmFtZSBdID8gXFxcIlxcXCIgOiBcXFwicHhcXFwiICk7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIGJhY2tncm91bmQtKiBwcm9wcyBhZmZlY3Qgb3JpZ2luYWwgY2xvbmUncyB2YWx1ZXNcXG5cXHRcXHRcXHRpZiAoICFzdXBwb3J0LmNsZWFyQ2xvbmVTdHlsZSAmJiB2YWx1ZSA9PT0gXFxcIlxcXCIgJiYgbmFtZS5pbmRleE9mKCBcXFwiYmFja2dyb3VuZFxcXCIgKSA9PT0gMCApIHtcXG5cXHRcXHRcXHRcXHRzdHlsZVsgbmFtZSBdID0gXFxcImluaGVyaXRcXFwiO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBJZiBhIGhvb2sgd2FzIHByb3ZpZGVkLCB1c2UgdGhhdCB2YWx1ZSwgb3RoZXJ3aXNlIGp1c3Qgc2V0IHRoZSBzcGVjaWZpZWQgdmFsdWVcXG5cXHRcXHRcXHRpZiAoICFob29rcyB8fCAhKCBcXFwic2V0XFxcIiBpbiBob29rcyApIHx8XFxuXFx0XFx0XFx0XFx0KCB2YWx1ZSA9IGhvb2tzLnNldCggZWxlbSwgdmFsdWUsIGV4dHJhICkgKSAhPT0gdW5kZWZpbmVkICkge1xcblxcblxcdFxcdFxcdFxcdGlmICggaXNDdXN0b21Qcm9wICkge1xcblxcdFxcdFxcdFxcdFxcdHN0eWxlLnNldFByb3BlcnR5KCBuYW1lLCB2YWx1ZSApO1xcblxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0c3R5bGVbIG5hbWUgXSA9IHZhbHVlO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHQvLyBJZiBhIGhvb2sgd2FzIHByb3ZpZGVkIGdldCB0aGUgbm9uLWNvbXB1dGVkIHZhbHVlIGZyb20gdGhlcmVcXG5cXHRcXHRcXHRpZiAoIGhvb2tzICYmIFxcXCJnZXRcXFwiIGluIGhvb2tzICYmXFxuXFx0XFx0XFx0XFx0KCByZXQgPSBob29rcy5nZXQoIGVsZW0sIGZhbHNlLCBleHRyYSApICkgIT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHRcXHRcXHRyZXR1cm4gcmV0O1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBPdGhlcndpc2UganVzdCBnZXQgdGhlIHZhbHVlIGZyb20gdGhlIHN0eWxlIG9iamVjdFxcblxcdFxcdFxcdHJldHVybiBzdHlsZVsgbmFtZSBdO1xcblxcdFxcdH1cXG5cXHR9LFxcblxcblxcdGNzczogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGV4dHJhLCBzdHlsZXMgKSB7XFxuXFx0XFx0dmFyIHZhbCwgbnVtLCBob29rcyxcXG5cXHRcXHRcXHRvcmlnTmFtZSA9IGNhbWVsQ2FzZSggbmFtZSApLFxcblxcdFxcdFxcdGlzQ3VzdG9tUHJvcCA9IHJjdXN0b21Qcm9wLnRlc3QoIG5hbWUgKTtcXG5cXG5cXHRcXHQvLyBNYWtlIHN1cmUgdGhhdCB3ZSdyZSB3b3JraW5nIHdpdGggdGhlIHJpZ2h0IG5hbWUuIFdlIGRvbid0XFxuXFx0XFx0Ly8gd2FudCB0byBtb2RpZnkgdGhlIHZhbHVlIGlmIGl0IGlzIGEgQ1NTIGN1c3RvbSBwcm9wZXJ0eVxcblxcdFxcdC8vIHNpbmNlIHRoZXkgYXJlIHVzZXItZGVmaW5lZC5cXG5cXHRcXHRpZiAoICFpc0N1c3RvbVByb3AgKSB7XFxuXFx0XFx0XFx0bmFtZSA9IGZpbmFsUHJvcE5hbWUoIG9yaWdOYW1lICk7XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIFRyeSBwcmVmaXhlZCBuYW1lIGZvbGxvd2VkIGJ5IHRoZSB1bnByZWZpeGVkIG5hbWVcXG5cXHRcXHRob29rcyA9IGpRdWVyeS5jc3NIb29rc1sgbmFtZSBdIHx8IGpRdWVyeS5jc3NIb29rc1sgb3JpZ05hbWUgXTtcXG5cXG5cXHRcXHQvLyBJZiBhIGhvb2sgd2FzIHByb3ZpZGVkIGdldCB0aGUgY29tcHV0ZWQgdmFsdWUgZnJvbSB0aGVyZVxcblxcdFxcdGlmICggaG9va3MgJiYgXFxcImdldFxcXCIgaW4gaG9va3MgKSB7XFxuXFx0XFx0XFx0dmFsID0gaG9va3MuZ2V0KCBlbGVtLCB0cnVlLCBleHRyYSApO1xcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBPdGhlcndpc2UsIGlmIGEgd2F5IHRvIGdldCB0aGUgY29tcHV0ZWQgdmFsdWUgZXhpc3RzLCB1c2UgdGhhdFxcblxcdFxcdGlmICggdmFsID09PSB1bmRlZmluZWQgKSB7XFxuXFx0XFx0XFx0dmFsID0gY3VyQ1NTKCBlbGVtLCBuYW1lLCBzdHlsZXMgKTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gQ29udmVydCBcXFwibm9ybWFsXFxcIiB0byBjb21wdXRlZCB2YWx1ZVxcblxcdFxcdGlmICggdmFsID09PSBcXFwibm9ybWFsXFxcIiAmJiBuYW1lIGluIGNzc05vcm1hbFRyYW5zZm9ybSApIHtcXG5cXHRcXHRcXHR2YWwgPSBjc3NOb3JtYWxUcmFuc2Zvcm1bIG5hbWUgXTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gTWFrZSBudW1lcmljIGlmIGZvcmNlZCBvciBhIHF1YWxpZmllciB3YXMgcHJvdmlkZWQgYW5kIHZhbCBsb29rcyBudW1lcmljXFxuXFx0XFx0aWYgKCBleHRyYSA9PT0gXFxcIlxcXCIgfHwgZXh0cmEgKSB7XFxuXFx0XFx0XFx0bnVtID0gcGFyc2VGbG9hdCggdmFsICk7XFxuXFx0XFx0XFx0cmV0dXJuIGV4dHJhID09PSB0cnVlIHx8IGlzRmluaXRlKCBudW0gKSA/IG51bSB8fCAwIDogdmFsO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRyZXR1cm4gdmFsO1xcblxcdH1cXG59ICk7XFxuXFxualF1ZXJ5LmVhY2goIFsgXFxcImhlaWdodFxcXCIsIFxcXCJ3aWR0aFxcXCIgXSwgZnVuY3Rpb24oIGksIGRpbWVuc2lvbiApIHtcXG5cXHRqUXVlcnkuY3NzSG9va3NbIGRpbWVuc2lvbiBdID0ge1xcblxcdFxcdGdldDogZnVuY3Rpb24oIGVsZW0sIGNvbXB1dGVkLCBleHRyYSApIHtcXG5cXHRcXHRcXHRpZiAoIGNvbXB1dGVkICkge1xcblxcblxcdFxcdFxcdFxcdC8vIENlcnRhaW4gZWxlbWVudHMgY2FuIGhhdmUgZGltZW5zaW9uIGluZm8gaWYgd2UgaW52aXNpYmx5IHNob3cgdGhlbVxcblxcdFxcdFxcdFxcdC8vIGJ1dCBpdCBtdXN0IGhhdmUgYSBjdXJyZW50IGRpc3BsYXkgc3R5bGUgdGhhdCB3b3VsZCBiZW5lZml0XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHJkaXNwbGF5c3dhcC50ZXN0KCBqUXVlcnkuY3NzKCBlbGVtLCBcXFwiZGlzcGxheVxcXCIgKSApICYmXFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gU3VwcG9ydDogU2FmYXJpIDgrXFxuXFx0XFx0XFx0XFx0XFx0Ly8gVGFibGUgY29sdW1ucyBpbiBTYWZhcmkgaGF2ZSBub24temVybyBvZmZzZXRXaWR0aCAmIHplcm9cXG5cXHRcXHRcXHRcXHRcXHQvLyBnZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCB1bmxlc3MgZGlzcGxheSBpcyBjaGFuZ2VkLlxcblxcdFxcdFxcdFxcdFxcdC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seVxcblxcdFxcdFxcdFxcdFxcdC8vIFJ1bm5pbmcgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IG9uIGEgZGlzY29ubmVjdGVkIG5vZGVcXG5cXHRcXHRcXHRcXHRcXHQvLyBpbiBJRSB0aHJvd3MgYW4gZXJyb3IuXFxuXFx0XFx0XFx0XFx0XFx0KCAhZWxlbS5nZXRDbGllbnRSZWN0cygpLmxlbmd0aCB8fCAhZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCApID9cXG5cXHRcXHRcXHRcXHRcXHRcXHRzd2FwKCBlbGVtLCBjc3NTaG93LCBmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gZ2V0V2lkdGhPckhlaWdodCggZWxlbSwgZGltZW5zaW9uLCBleHRyYSApO1xcblxcdFxcdFxcdFxcdFxcdFxcdH0gKSA6XFxuXFx0XFx0XFx0XFx0XFx0XFx0Z2V0V2lkdGhPckhlaWdodCggZWxlbSwgZGltZW5zaW9uLCBleHRyYSApO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9LFxcblxcblxcdFxcdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlLCBleHRyYSApIHtcXG5cXHRcXHRcXHR2YXIgbWF0Y2hlcyxcXG5cXHRcXHRcXHRcXHRzdHlsZXMgPSBnZXRTdHlsZXMoIGVsZW0gKSxcXG5cXHRcXHRcXHRcXHRpc0JvcmRlckJveCA9IGpRdWVyeS5jc3MoIGVsZW0sIFxcXCJib3hTaXppbmdcXFwiLCBmYWxzZSwgc3R5bGVzICkgPT09IFxcXCJib3JkZXItYm94XFxcIixcXG5cXHRcXHRcXHRcXHRzdWJ0cmFjdCA9IGV4dHJhICYmIGJveE1vZGVsQWRqdXN0bWVudChcXG5cXHRcXHRcXHRcXHRcXHRlbGVtLFxcblxcdFxcdFxcdFxcdFxcdGRpbWVuc2lvbixcXG5cXHRcXHRcXHRcXHRcXHRleHRyYSxcXG5cXHRcXHRcXHRcXHRcXHRpc0JvcmRlckJveCxcXG5cXHRcXHRcXHRcXHRcXHRzdHlsZXNcXG5cXHRcXHRcXHRcXHQpO1xcblxcblxcdFxcdFxcdC8vIEFjY291bnQgZm9yIHVucmVsaWFibGUgYm9yZGVyLWJveCBkaW1lbnNpb25zIGJ5IGNvbXBhcmluZyBvZmZzZXQqIHRvIGNvbXB1dGVkIGFuZFxcblxcdFxcdFxcdC8vIGZha2luZyBhIGNvbnRlbnQtYm94IHRvIGdldCBib3JkZXIgYW5kIHBhZGRpbmcgKGdoLTM2OTkpXFxuXFx0XFx0XFx0aWYgKCBpc0JvcmRlckJveCAmJiBzdXBwb3J0LnNjcm9sbGJveFNpemUoKSA9PT0gc3R5bGVzLnBvc2l0aW9uICkge1xcblxcdFxcdFxcdFxcdHN1YnRyYWN0IC09IE1hdGguY2VpbChcXG5cXHRcXHRcXHRcXHRcXHRlbGVtWyBcXFwib2Zmc2V0XFxcIiArIGRpbWVuc2lvblsgMCBdLnRvVXBwZXJDYXNlKCkgKyBkaW1lbnNpb24uc2xpY2UoIDEgKSBdIC1cXG5cXHRcXHRcXHRcXHRcXHRwYXJzZUZsb2F0KCBzdHlsZXNbIGRpbWVuc2lvbiBdICkgLVxcblxcdFxcdFxcdFxcdFxcdGJveE1vZGVsQWRqdXN0bWVudCggZWxlbSwgZGltZW5zaW9uLCBcXFwiYm9yZGVyXFxcIiwgZmFsc2UsIHN0eWxlcyApIC1cXG5cXHRcXHRcXHRcXHRcXHQwLjVcXG5cXHRcXHRcXHRcXHQpO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBDb252ZXJ0IHRvIHBpeGVscyBpZiB2YWx1ZSBhZGp1c3RtZW50IGlzIG5lZWRlZFxcblxcdFxcdFxcdGlmICggc3VidHJhY3QgJiYgKCBtYXRjaGVzID0gcmNzc051bS5leGVjKCB2YWx1ZSApICkgJiZcXG5cXHRcXHRcXHRcXHQoIG1hdGNoZXNbIDMgXSB8fCBcXFwicHhcXFwiICkgIT09IFxcXCJweFxcXCIgKSB7XFxuXFxuXFx0XFx0XFx0XFx0ZWxlbS5zdHlsZVsgZGltZW5zaW9uIF0gPSB2YWx1ZTtcXG5cXHRcXHRcXHRcXHR2YWx1ZSA9IGpRdWVyeS5jc3MoIGVsZW0sIGRpbWVuc2lvbiApO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRyZXR1cm4gc2V0UG9zaXRpdmVOdW1iZXIoIGVsZW0sIHZhbHVlLCBzdWJ0cmFjdCApO1xcblxcdFxcdH1cXG5cXHR9O1xcbn0gKTtcXG5cXG5qUXVlcnkuY3NzSG9va3MubWFyZ2luTGVmdCA9IGFkZEdldEhvb2tJZiggc3VwcG9ydC5yZWxpYWJsZU1hcmdpbkxlZnQsXFxuXFx0ZnVuY3Rpb24oIGVsZW0sIGNvbXB1dGVkICkge1xcblxcdFxcdGlmICggY29tcHV0ZWQgKSB7XFxuXFx0XFx0XFx0cmV0dXJuICggcGFyc2VGbG9hdCggY3VyQ1NTKCBlbGVtLCBcXFwibWFyZ2luTGVmdFxcXCIgKSApIHx8XFxuXFx0XFx0XFx0XFx0ZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0IC1cXG5cXHRcXHRcXHRcXHRcXHRzd2FwKCBlbGVtLCB7IG1hcmdpbkxlZnQ6IDAgfSwgZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdDtcXG5cXHRcXHRcXHRcXHRcXHR9IClcXG5cXHRcXHRcXHRcXHQpICsgXFxcInB4XFxcIjtcXG5cXHRcXHR9XFxuXFx0fVxcbik7XFxuXFxuLy8gVGhlc2UgaG9va3MgYXJlIHVzZWQgYnkgYW5pbWF0ZSB0byBleHBhbmQgcHJvcGVydGllc1xcbmpRdWVyeS5lYWNoKCB7XFxuXFx0bWFyZ2luOiBcXFwiXFxcIixcXG5cXHRwYWRkaW5nOiBcXFwiXFxcIixcXG5cXHRib3JkZXI6IFxcXCJXaWR0aFxcXCJcXG59LCBmdW5jdGlvbiggcHJlZml4LCBzdWZmaXggKSB7XFxuXFx0alF1ZXJ5LmNzc0hvb2tzWyBwcmVmaXggKyBzdWZmaXggXSA9IHtcXG5cXHRcXHRleHBhbmQ6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcXG5cXHRcXHRcXHR2YXIgaSA9IDAsXFxuXFx0XFx0XFx0XFx0ZXhwYW5kZWQgPSB7fSxcXG5cXG5cXHRcXHRcXHRcXHQvLyBBc3N1bWVzIGEgc2luZ2xlIG51bWJlciBpZiBub3QgYSBzdHJpbmdcXG5cXHRcXHRcXHRcXHRwYXJ0cyA9IHR5cGVvZiB2YWx1ZSA9PT0gXFxcInN0cmluZ1xcXCIgPyB2YWx1ZS5zcGxpdCggXFxcIiBcXFwiICkgOiBbIHZhbHVlIF07XFxuXFxuXFx0XFx0XFx0Zm9yICggOyBpIDwgNDsgaSsrICkge1xcblxcdFxcdFxcdFxcdGV4cGFuZGVkWyBwcmVmaXggKyBjc3NFeHBhbmRbIGkgXSArIHN1ZmZpeCBdID1cXG5cXHRcXHRcXHRcXHRcXHRwYXJ0c1sgaSBdIHx8IHBhcnRzWyBpIC0gMiBdIHx8IHBhcnRzWyAwIF07XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHJldHVybiBleHBhbmRlZDtcXG5cXHRcXHR9XFxuXFx0fTtcXG5cXG5cXHRpZiAoIHByZWZpeCAhPT0gXFxcIm1hcmdpblxcXCIgKSB7XFxuXFx0XFx0alF1ZXJ5LmNzc0hvb2tzWyBwcmVmaXggKyBzdWZmaXggXS5zZXQgPSBzZXRQb3NpdGl2ZU51bWJlcjtcXG5cXHR9XFxufSApO1xcblxcbmpRdWVyeS5mbi5leHRlbmQoIHtcXG5cXHRjc3M6IGZ1bmN0aW9uKCBuYW1lLCB2YWx1ZSApIHtcXG5cXHRcXHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggZWxlbSwgbmFtZSwgdmFsdWUgKSB7XFxuXFx0XFx0XFx0dmFyIHN0eWxlcywgbGVuLFxcblxcdFxcdFxcdFxcdG1hcCA9IHt9LFxcblxcdFxcdFxcdFxcdGkgPSAwO1xcblxcblxcdFxcdFxcdGlmICggQXJyYXkuaXNBcnJheSggbmFtZSApICkge1xcblxcdFxcdFxcdFxcdHN0eWxlcyA9IGdldFN0eWxlcyggZWxlbSApO1xcblxcdFxcdFxcdFxcdGxlbiA9IG5hbWUubGVuZ3RoO1xcblxcblxcdFxcdFxcdFxcdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xcblxcdFxcdFxcdFxcdFxcdG1hcFsgbmFtZVsgaSBdIF0gPSBqUXVlcnkuY3NzKCBlbGVtLCBuYW1lWyBpIF0sIGZhbHNlLCBzdHlsZXMgKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0cmV0dXJuIG1hcDtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHZhbHVlICE9PSB1bmRlZmluZWQgP1xcblxcdFxcdFxcdFxcdGpRdWVyeS5zdHlsZSggZWxlbSwgbmFtZSwgdmFsdWUgKSA6XFxuXFx0XFx0XFx0XFx0alF1ZXJ5LmNzcyggZWxlbSwgbmFtZSApO1xcblxcdFxcdH0sIG5hbWUsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMSApO1xcblxcdH1cXG59ICk7XFxuXFxuXFxuZnVuY3Rpb24gVHdlZW4oIGVsZW0sIG9wdGlvbnMsIHByb3AsIGVuZCwgZWFzaW5nICkge1xcblxcdHJldHVybiBuZXcgVHdlZW4ucHJvdG90eXBlLmluaXQoIGVsZW0sIG9wdGlvbnMsIHByb3AsIGVuZCwgZWFzaW5nICk7XFxufVxcbmpRdWVyeS5Ud2VlbiA9IFR3ZWVuO1xcblxcblR3ZWVuLnByb3RvdHlwZSA9IHtcXG5cXHRjb25zdHJ1Y3RvcjogVHdlZW4sXFxuXFx0aW5pdDogZnVuY3Rpb24oIGVsZW0sIG9wdGlvbnMsIHByb3AsIGVuZCwgZWFzaW5nLCB1bml0ICkge1xcblxcdFxcdHRoaXMuZWxlbSA9IGVsZW07XFxuXFx0XFx0dGhpcy5wcm9wID0gcHJvcDtcXG5cXHRcXHR0aGlzLmVhc2luZyA9IGVhc2luZyB8fCBqUXVlcnkuZWFzaW5nLl9kZWZhdWx0O1xcblxcdFxcdHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XFxuXFx0XFx0dGhpcy5zdGFydCA9IHRoaXMubm93ID0gdGhpcy5jdXIoKTtcXG5cXHRcXHR0aGlzLmVuZCA9IGVuZDtcXG5cXHRcXHR0aGlzLnVuaXQgPSB1bml0IHx8ICggalF1ZXJ5LmNzc051bWJlclsgcHJvcCBdID8gXFxcIlxcXCIgOiBcXFwicHhcXFwiICk7XFxuXFx0fSxcXG5cXHRjdXI6IGZ1bmN0aW9uKCkge1xcblxcdFxcdHZhciBob29rcyA9IFR3ZWVuLnByb3BIb29rc1sgdGhpcy5wcm9wIF07XFxuXFxuXFx0XFx0cmV0dXJuIGhvb2tzICYmIGhvb2tzLmdldCA/XFxuXFx0XFx0XFx0aG9va3MuZ2V0KCB0aGlzICkgOlxcblxcdFxcdFxcdFR3ZWVuLnByb3BIb29rcy5fZGVmYXVsdC5nZXQoIHRoaXMgKTtcXG5cXHR9LFxcblxcdHJ1bjogZnVuY3Rpb24oIHBlcmNlbnQgKSB7XFxuXFx0XFx0dmFyIGVhc2VkLFxcblxcdFxcdFxcdGhvb2tzID0gVHdlZW4ucHJvcEhvb2tzWyB0aGlzLnByb3AgXTtcXG5cXG5cXHRcXHRpZiAoIHRoaXMub3B0aW9ucy5kdXJhdGlvbiApIHtcXG5cXHRcXHRcXHR0aGlzLnBvcyA9IGVhc2VkID0galF1ZXJ5LmVhc2luZ1sgdGhpcy5lYXNpbmcgXShcXG5cXHRcXHRcXHRcXHRwZXJjZW50LCB0aGlzLm9wdGlvbnMuZHVyYXRpb24gKiBwZXJjZW50LCAwLCAxLCB0aGlzLm9wdGlvbnMuZHVyYXRpb25cXG5cXHRcXHRcXHQpO1xcblxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0dGhpcy5wb3MgPSBlYXNlZCA9IHBlcmNlbnQ7XFxuXFx0XFx0fVxcblxcdFxcdHRoaXMubm93ID0gKCB0aGlzLmVuZCAtIHRoaXMuc3RhcnQgKSAqIGVhc2VkICsgdGhpcy5zdGFydDtcXG5cXG5cXHRcXHRpZiAoIHRoaXMub3B0aW9ucy5zdGVwICkge1xcblxcdFxcdFxcdHRoaXMub3B0aW9ucy5zdGVwLmNhbGwoIHRoaXMuZWxlbSwgdGhpcy5ub3csIHRoaXMgKTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0aWYgKCBob29rcyAmJiBob29rcy5zZXQgKSB7XFxuXFx0XFx0XFx0aG9va3Muc2V0KCB0aGlzICk7XFxuXFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRUd2Vlbi5wcm9wSG9va3MuX2RlZmF1bHQuc2V0KCB0aGlzICk7XFxuXFx0XFx0fVxcblxcdFxcdHJldHVybiB0aGlzO1xcblxcdH1cXG59O1xcblxcblR3ZWVuLnByb3RvdHlwZS5pbml0LnByb3RvdHlwZSA9IFR3ZWVuLnByb3RvdHlwZTtcXG5cXG5Ud2Vlbi5wcm9wSG9va3MgPSB7XFxuXFx0X2RlZmF1bHQ6IHtcXG5cXHRcXHRnZXQ6IGZ1bmN0aW9uKCB0d2VlbiApIHtcXG5cXHRcXHRcXHR2YXIgcmVzdWx0O1xcblxcblxcdFxcdFxcdC8vIFVzZSBhIHByb3BlcnR5IG9uIHRoZSBlbGVtZW50IGRpcmVjdGx5IHdoZW4gaXQgaXMgbm90IGEgRE9NIGVsZW1lbnQsXFxuXFx0XFx0XFx0Ly8gb3Igd2hlbiB0aGVyZSBpcyBubyBtYXRjaGluZyBzdHlsZSBwcm9wZXJ0eSB0aGF0IGV4aXN0cy5cXG5cXHRcXHRcXHRpZiAoIHR3ZWVuLmVsZW0ubm9kZVR5cGUgIT09IDEgfHxcXG5cXHRcXHRcXHRcXHR0d2Vlbi5lbGVtWyB0d2Vlbi5wcm9wIF0gIT0gbnVsbCAmJiB0d2Vlbi5lbGVtLnN0eWxlWyB0d2Vlbi5wcm9wIF0gPT0gbnVsbCApIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gdHdlZW4uZWxlbVsgdHdlZW4ucHJvcCBdO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBQYXNzaW5nIGFuIGVtcHR5IHN0cmluZyBhcyBhIDNyZCBwYXJhbWV0ZXIgdG8gLmNzcyB3aWxsIGF1dG9tYXRpY2FsbHlcXG5cXHRcXHRcXHQvLyBhdHRlbXB0IGEgcGFyc2VGbG9hdCBhbmQgZmFsbGJhY2sgdG8gYSBzdHJpbmcgaWYgdGhlIHBhcnNlIGZhaWxzLlxcblxcdFxcdFxcdC8vIFNpbXBsZSB2YWx1ZXMgc3VjaCBhcyBcXFwiMTBweFxcXCIgYXJlIHBhcnNlZCB0byBGbG9hdDtcXG5cXHRcXHRcXHQvLyBjb21wbGV4IHZhbHVlcyBzdWNoIGFzIFxcXCJyb3RhdGUoMXJhZClcXFwiIGFyZSByZXR1cm5lZCBhcy1pcy5cXG5cXHRcXHRcXHRyZXN1bHQgPSBqUXVlcnkuY3NzKCB0d2Vlbi5lbGVtLCB0d2Vlbi5wcm9wLCBcXFwiXFxcIiApO1xcblxcblxcdFxcdFxcdC8vIEVtcHR5IHN0cmluZ3MsIG51bGwsIHVuZGVmaW5lZCBhbmQgXFxcImF1dG9cXFwiIGFyZSBjb252ZXJ0ZWQgdG8gMC5cXG5cXHRcXHRcXHRyZXR1cm4gIXJlc3VsdCB8fCByZXN1bHQgPT09IFxcXCJhdXRvXFxcIiA/IDAgOiByZXN1bHQ7XFxuXFx0XFx0fSxcXG5cXHRcXHRzZXQ6IGZ1bmN0aW9uKCB0d2VlbiApIHtcXG5cXG5cXHRcXHRcXHQvLyBVc2Ugc3RlcCBob29rIGZvciBiYWNrIGNvbXBhdC5cXG5cXHRcXHRcXHQvLyBVc2UgY3NzSG9vayBpZiBpdHMgdGhlcmUuXFxuXFx0XFx0XFx0Ly8gVXNlIC5zdHlsZSBpZiBhdmFpbGFibGUgYW5kIHVzZSBwbGFpbiBwcm9wZXJ0aWVzIHdoZXJlIGF2YWlsYWJsZS5cXG5cXHRcXHRcXHRpZiAoIGpRdWVyeS5meC5zdGVwWyB0d2Vlbi5wcm9wIF0gKSB7XFxuXFx0XFx0XFx0XFx0alF1ZXJ5LmZ4LnN0ZXBbIHR3ZWVuLnByb3AgXSggdHdlZW4gKTtcXG5cXHRcXHRcXHR9IGVsc2UgaWYgKCB0d2Vlbi5lbGVtLm5vZGVUeXBlID09PSAxICYmXFxuXFx0XFx0XFx0XFx0KCB0d2Vlbi5lbGVtLnN0eWxlWyBqUXVlcnkuY3NzUHJvcHNbIHR3ZWVuLnByb3AgXSBdICE9IG51bGwgfHxcXG5cXHRcXHRcXHRcXHRcXHRqUXVlcnkuY3NzSG9va3NbIHR3ZWVuLnByb3AgXSApICkge1xcblxcdFxcdFxcdFxcdGpRdWVyeS5zdHlsZSggdHdlZW4uZWxlbSwgdHdlZW4ucHJvcCwgdHdlZW4ubm93ICsgdHdlZW4udW5pdCApO1xcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0dHdlZW4uZWxlbVsgdHdlZW4ucHJvcCBdID0gdHdlZW4ubm93O1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFx0fVxcbn07XFxuXFxuLy8gU3VwcG9ydDogSUUgPD05IG9ubHlcXG4vLyBQYW5pYyBiYXNlZCBhcHByb2FjaCB0byBzZXR0aW5nIHRoaW5ncyBvbiBkaXNjb25uZWN0ZWQgbm9kZXNcXG5Ud2Vlbi5wcm9wSG9va3Muc2Nyb2xsVG9wID0gVHdlZW4ucHJvcEhvb2tzLnNjcm9sbExlZnQgPSB7XFxuXFx0c2V0OiBmdW5jdGlvbiggdHdlZW4gKSB7XFxuXFx0XFx0aWYgKCB0d2Vlbi5lbGVtLm5vZGVUeXBlICYmIHR3ZWVuLmVsZW0ucGFyZW50Tm9kZSApIHtcXG5cXHRcXHRcXHR0d2Vlbi5lbGVtWyB0d2Vlbi5wcm9wIF0gPSB0d2Vlbi5ub3c7XFxuXFx0XFx0fVxcblxcdH1cXG59O1xcblxcbmpRdWVyeS5lYXNpbmcgPSB7XFxuXFx0bGluZWFyOiBmdW5jdGlvbiggcCApIHtcXG5cXHRcXHRyZXR1cm4gcDtcXG5cXHR9LFxcblxcdHN3aW5nOiBmdW5jdGlvbiggcCApIHtcXG5cXHRcXHRyZXR1cm4gMC41IC0gTWF0aC5jb3MoIHAgKiBNYXRoLlBJICkgLyAyO1xcblxcdH0sXFxuXFx0X2RlZmF1bHQ6IFxcXCJzd2luZ1xcXCJcXG59O1xcblxcbmpRdWVyeS5meCA9IFR3ZWVuLnByb3RvdHlwZS5pbml0O1xcblxcbi8vIEJhY2sgY29tcGF0IDwxLjggZXh0ZW5zaW9uIHBvaW50XFxualF1ZXJ5LmZ4LnN0ZXAgPSB7fTtcXG5cXG5cXG5cXG5cXG52YXJcXG5cXHRmeE5vdywgaW5Qcm9ncmVzcyxcXG5cXHRyZnh0eXBlcyA9IC9eKD86dG9nZ2xlfHNob3d8aGlkZSkkLyxcXG5cXHRycnVuID0gL3F1ZXVlSG9va3MkLztcXG5cXG5mdW5jdGlvbiBzY2hlZHVsZSgpIHtcXG5cXHRpZiAoIGluUHJvZ3Jlc3MgKSB7XFxuXFx0XFx0aWYgKCBkb2N1bWVudC5oaWRkZW4gPT09IGZhbHNlICYmIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgKSB7XFxuXFx0XFx0XFx0d2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSggc2NoZWR1bGUgKTtcXG5cXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdHdpbmRvdy5zZXRUaW1lb3V0KCBzY2hlZHVsZSwgalF1ZXJ5LmZ4LmludGVydmFsICk7XFxuXFx0XFx0fVxcblxcblxcdFxcdGpRdWVyeS5meC50aWNrKCk7XFxuXFx0fVxcbn1cXG5cXG4vLyBBbmltYXRpb25zIGNyZWF0ZWQgc3luY2hyb25vdXNseSB3aWxsIHJ1biBzeW5jaHJvbm91c2x5XFxuZnVuY3Rpb24gY3JlYXRlRnhOb3coKSB7XFxuXFx0d2luZG93LnNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xcblxcdFxcdGZ4Tm93ID0gdW5kZWZpbmVkO1xcblxcdH0gKTtcXG5cXHRyZXR1cm4gKCBmeE5vdyA9IERhdGUubm93KCkgKTtcXG59XFxuXFxuLy8gR2VuZXJhdGUgcGFyYW1ldGVycyB0byBjcmVhdGUgYSBzdGFuZGFyZCBhbmltYXRpb25cXG5mdW5jdGlvbiBnZW5GeCggdHlwZSwgaW5jbHVkZVdpZHRoICkge1xcblxcdHZhciB3aGljaCxcXG5cXHRcXHRpID0gMCxcXG5cXHRcXHRhdHRycyA9IHsgaGVpZ2h0OiB0eXBlIH07XFxuXFxuXFx0Ly8gSWYgd2UgaW5jbHVkZSB3aWR0aCwgc3RlcCB2YWx1ZSBpcyAxIHRvIGRvIGFsbCBjc3NFeHBhbmQgdmFsdWVzLFxcblxcdC8vIG90aGVyd2lzZSBzdGVwIHZhbHVlIGlzIDIgdG8gc2tpcCBvdmVyIExlZnQgYW5kIFJpZ2h0XFxuXFx0aW5jbHVkZVdpZHRoID0gaW5jbHVkZVdpZHRoID8gMSA6IDA7XFxuXFx0Zm9yICggOyBpIDwgNDsgaSArPSAyIC0gaW5jbHVkZVdpZHRoICkge1xcblxcdFxcdHdoaWNoID0gY3NzRXhwYW5kWyBpIF07XFxuXFx0XFx0YXR0cnNbIFxcXCJtYXJnaW5cXFwiICsgd2hpY2ggXSA9IGF0dHJzWyBcXFwicGFkZGluZ1xcXCIgKyB3aGljaCBdID0gdHlwZTtcXG5cXHR9XFxuXFxuXFx0aWYgKCBpbmNsdWRlV2lkdGggKSB7XFxuXFx0XFx0YXR0cnMub3BhY2l0eSA9IGF0dHJzLndpZHRoID0gdHlwZTtcXG5cXHR9XFxuXFxuXFx0cmV0dXJuIGF0dHJzO1xcbn1cXG5cXG5mdW5jdGlvbiBjcmVhdGVUd2VlbiggdmFsdWUsIHByb3AsIGFuaW1hdGlvbiApIHtcXG5cXHR2YXIgdHdlZW4sXFxuXFx0XFx0Y29sbGVjdGlvbiA9ICggQW5pbWF0aW9uLnR3ZWVuZXJzWyBwcm9wIF0gfHwgW10gKS5jb25jYXQoIEFuaW1hdGlvbi50d2VlbmVyc1sgXFxcIipcXFwiIF0gKSxcXG5cXHRcXHRpbmRleCA9IDAsXFxuXFx0XFx0bGVuZ3RoID0gY29sbGVjdGlvbi5sZW5ndGg7XFxuXFx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcXG5cXHRcXHRpZiAoICggdHdlZW4gPSBjb2xsZWN0aW9uWyBpbmRleCBdLmNhbGwoIGFuaW1hdGlvbiwgcHJvcCwgdmFsdWUgKSApICkge1xcblxcblxcdFxcdFxcdC8vIFdlJ3JlIGRvbmUgd2l0aCB0aGlzIHByb3BlcnR5XFxuXFx0XFx0XFx0cmV0dXJuIHR3ZWVuO1xcblxcdFxcdH1cXG5cXHR9XFxufVxcblxcbmZ1bmN0aW9uIGRlZmF1bHRQcmVmaWx0ZXIoIGVsZW0sIHByb3BzLCBvcHRzICkge1xcblxcdHZhciBwcm9wLCB2YWx1ZSwgdG9nZ2xlLCBob29rcywgb2xkZmlyZSwgcHJvcFR3ZWVuLCByZXN0b3JlRGlzcGxheSwgZGlzcGxheSxcXG5cXHRcXHRpc0JveCA9IFxcXCJ3aWR0aFxcXCIgaW4gcHJvcHMgfHwgXFxcImhlaWdodFxcXCIgaW4gcHJvcHMsXFxuXFx0XFx0YW5pbSA9IHRoaXMsXFxuXFx0XFx0b3JpZyA9IHt9LFxcblxcdFxcdHN0eWxlID0gZWxlbS5zdHlsZSxcXG5cXHRcXHRoaWRkZW4gPSBlbGVtLm5vZGVUeXBlICYmIGlzSGlkZGVuV2l0aGluVHJlZSggZWxlbSApLFxcblxcdFxcdGRhdGFTaG93ID0gZGF0YVByaXYuZ2V0KCBlbGVtLCBcXFwiZnhzaG93XFxcIiApO1xcblxcblxcdC8vIFF1ZXVlLXNraXBwaW5nIGFuaW1hdGlvbnMgaGlqYWNrIHRoZSBmeCBob29rc1xcblxcdGlmICggIW9wdHMucXVldWUgKSB7XFxuXFx0XFx0aG9va3MgPSBqUXVlcnkuX3F1ZXVlSG9va3MoIGVsZW0sIFxcXCJmeFxcXCIgKTtcXG5cXHRcXHRpZiAoIGhvb2tzLnVucXVldWVkID09IG51bGwgKSB7XFxuXFx0XFx0XFx0aG9va3MudW5xdWV1ZWQgPSAwO1xcblxcdFxcdFxcdG9sZGZpcmUgPSBob29rcy5lbXB0eS5maXJlO1xcblxcdFxcdFxcdGhvb2tzLmVtcHR5LmZpcmUgPSBmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHRcXHRpZiAoICFob29rcy51bnF1ZXVlZCApIHtcXG5cXHRcXHRcXHRcXHRcXHRvbGRmaXJlKCk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH07XFxuXFx0XFx0fVxcblxcdFxcdGhvb2tzLnVucXVldWVkKys7XFxuXFxuXFx0XFx0YW5pbS5hbHdheXMoIGZ1bmN0aW9uKCkge1xcblxcblxcdFxcdFxcdC8vIEVuc3VyZSB0aGUgY29tcGxldGUgaGFuZGxlciBpcyBjYWxsZWQgYmVmb3JlIHRoaXMgY29tcGxldGVzXFxuXFx0XFx0XFx0YW5pbS5hbHdheXMoIGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdFxcdGhvb2tzLnVucXVldWVkLS07XFxuXFx0XFx0XFx0XFx0aWYgKCAhalF1ZXJ5LnF1ZXVlKCBlbGVtLCBcXFwiZnhcXFwiICkubGVuZ3RoICkge1xcblxcdFxcdFxcdFxcdFxcdGhvb2tzLmVtcHR5LmZpcmUoKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fSApO1xcblxcdFxcdH0gKTtcXG5cXHR9XFxuXFxuXFx0Ly8gRGV0ZWN0IHNob3cvaGlkZSBhbmltYXRpb25zXFxuXFx0Zm9yICggcHJvcCBpbiBwcm9wcyApIHtcXG5cXHRcXHR2YWx1ZSA9IHByb3BzWyBwcm9wIF07XFxuXFx0XFx0aWYgKCByZnh0eXBlcy50ZXN0KCB2YWx1ZSApICkge1xcblxcdFxcdFxcdGRlbGV0ZSBwcm9wc1sgcHJvcCBdO1xcblxcdFxcdFxcdHRvZ2dsZSA9IHRvZ2dsZSB8fCB2YWx1ZSA9PT0gXFxcInRvZ2dsZVxcXCI7XFxuXFx0XFx0XFx0aWYgKCB2YWx1ZSA9PT0gKCBoaWRkZW4gPyBcXFwiaGlkZVxcXCIgOiBcXFwic2hvd1xcXCIgKSApIHtcXG5cXG5cXHRcXHRcXHRcXHQvLyBQcmV0ZW5kIHRvIGJlIGhpZGRlbiBpZiB0aGlzIGlzIGEgXFxcInNob3dcXFwiIGFuZFxcblxcdFxcdFxcdFxcdC8vIHRoZXJlIGlzIHN0aWxsIGRhdGEgZnJvbSBhIHN0b3BwZWQgc2hvdy9oaWRlXFxuXFx0XFx0XFx0XFx0aWYgKCB2YWx1ZSA9PT0gXFxcInNob3dcXFwiICYmIGRhdGFTaG93ICYmIGRhdGFTaG93WyBwcm9wIF0gIT09IHVuZGVmaW5lZCApIHtcXG5cXHRcXHRcXHRcXHRcXHRoaWRkZW4gPSB0cnVlO1xcblxcblxcdFxcdFxcdFxcdC8vIElnbm9yZSBhbGwgb3RoZXIgbm8tb3Agc2hvdy9oaWRlIGRhdGFcXG5cXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdGNvbnRpbnVlO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0b3JpZ1sgcHJvcCBdID0gZGF0YVNob3cgJiYgZGF0YVNob3dbIHByb3AgXSB8fCBqUXVlcnkuc3R5bGUoIGVsZW0sIHByb3AgKTtcXG5cXHRcXHR9XFxuXFx0fVxcblxcblxcdC8vIEJhaWwgb3V0IGlmIHRoaXMgaXMgYSBuby1vcCBsaWtlIC5oaWRlKCkuaGlkZSgpXFxuXFx0cHJvcFR3ZWVuID0gIWpRdWVyeS5pc0VtcHR5T2JqZWN0KCBwcm9wcyApO1xcblxcdGlmICggIXByb3BUd2VlbiAmJiBqUXVlcnkuaXNFbXB0eU9iamVjdCggb3JpZyApICkge1xcblxcdFxcdHJldHVybjtcXG5cXHR9XFxuXFxuXFx0Ly8gUmVzdHJpY3QgXFxcIm92ZXJmbG93XFxcIiBhbmQgXFxcImRpc3BsYXlcXFwiIHN0eWxlcyBkdXJpbmcgYm94IGFuaW1hdGlvbnNcXG5cXHRpZiAoIGlzQm94ICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XFxuXFxuXFx0XFx0Ly8gU3VwcG9ydDogSUUgPD05IC0gMTEsIEVkZ2UgMTIgLSAxNVxcblxcdFxcdC8vIFJlY29yZCBhbGwgMyBvdmVyZmxvdyBhdHRyaWJ1dGVzIGJlY2F1c2UgSUUgZG9lcyBub3QgaW5mZXIgdGhlIHNob3J0aGFuZFxcblxcdFxcdC8vIGZyb20gaWRlbnRpY2FsbHktdmFsdWVkIG92ZXJmbG93WCBhbmQgb3ZlcmZsb3dZIGFuZCBFZGdlIGp1c3QgbWlycm9yc1xcblxcdFxcdC8vIHRoZSBvdmVyZmxvd1ggdmFsdWUgdGhlcmUuXFxuXFx0XFx0b3B0cy5vdmVyZmxvdyA9IFsgc3R5bGUub3ZlcmZsb3csIHN0eWxlLm92ZXJmbG93WCwgc3R5bGUub3ZlcmZsb3dZIF07XFxuXFxuXFx0XFx0Ly8gSWRlbnRpZnkgYSBkaXNwbGF5IHR5cGUsIHByZWZlcnJpbmcgb2xkIHNob3cvaGlkZSBkYXRhIG92ZXIgdGhlIENTUyBjYXNjYWRlXFxuXFx0XFx0cmVzdG9yZURpc3BsYXkgPSBkYXRhU2hvdyAmJiBkYXRhU2hvdy5kaXNwbGF5O1xcblxcdFxcdGlmICggcmVzdG9yZURpc3BsYXkgPT0gbnVsbCApIHtcXG5cXHRcXHRcXHRyZXN0b3JlRGlzcGxheSA9IGRhdGFQcml2LmdldCggZWxlbSwgXFxcImRpc3BsYXlcXFwiICk7XFxuXFx0XFx0fVxcblxcdFxcdGRpc3BsYXkgPSBqUXVlcnkuY3NzKCBlbGVtLCBcXFwiZGlzcGxheVxcXCIgKTtcXG5cXHRcXHRpZiAoIGRpc3BsYXkgPT09IFxcXCJub25lXFxcIiApIHtcXG5cXHRcXHRcXHRpZiAoIHJlc3RvcmVEaXNwbGF5ICkge1xcblxcdFxcdFxcdFxcdGRpc3BsYXkgPSByZXN0b3JlRGlzcGxheTtcXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdC8vIEdldCBub25lbXB0eSB2YWx1ZShzKSBieSB0ZW1wb3JhcmlseSBmb3JjaW5nIHZpc2liaWxpdHlcXG5cXHRcXHRcXHRcXHRzaG93SGlkZSggWyBlbGVtIF0sIHRydWUgKTtcXG5cXHRcXHRcXHRcXHRyZXN0b3JlRGlzcGxheSA9IGVsZW0uc3R5bGUuZGlzcGxheSB8fCByZXN0b3JlRGlzcGxheTtcXG5cXHRcXHRcXHRcXHRkaXNwbGF5ID0galF1ZXJ5LmNzcyggZWxlbSwgXFxcImRpc3BsYXlcXFwiICk7XFxuXFx0XFx0XFx0XFx0c2hvd0hpZGUoIFsgZWxlbSBdICk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBBbmltYXRlIGlubGluZSBlbGVtZW50cyBhcyBpbmxpbmUtYmxvY2tcXG5cXHRcXHRpZiAoIGRpc3BsYXkgPT09IFxcXCJpbmxpbmVcXFwiIHx8IGRpc3BsYXkgPT09IFxcXCJpbmxpbmUtYmxvY2tcXFwiICYmIHJlc3RvcmVEaXNwbGF5ICE9IG51bGwgKSB7XFxuXFx0XFx0XFx0aWYgKCBqUXVlcnkuY3NzKCBlbGVtLCBcXFwiZmxvYXRcXFwiICkgPT09IFxcXCJub25lXFxcIiApIHtcXG5cXG5cXHRcXHRcXHRcXHQvLyBSZXN0b3JlIHRoZSBvcmlnaW5hbCBkaXNwbGF5IHZhbHVlIGF0IHRoZSBlbmQgb2YgcHVyZSBzaG93L2hpZGUgYW5pbWF0aW9uc1xcblxcdFxcdFxcdFxcdGlmICggIXByb3BUd2VlbiApIHtcXG5cXHRcXHRcXHRcXHRcXHRhbmltLmRvbmUoIGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHN0eWxlLmRpc3BsYXkgPSByZXN0b3JlRGlzcGxheTtcXG5cXHRcXHRcXHRcXHRcXHR9ICk7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKCByZXN0b3JlRGlzcGxheSA9PSBudWxsICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGRpc3BsYXkgPSBzdHlsZS5kaXNwbGF5O1xcblxcdFxcdFxcdFxcdFxcdFxcdHJlc3RvcmVEaXNwbGF5ID0gZGlzcGxheSA9PT0gXFxcIm5vbmVcXFwiID8gXFxcIlxcXCIgOiBkaXNwbGF5O1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0c3R5bGUuZGlzcGxheSA9IFxcXCJpbmxpbmUtYmxvY2tcXFwiO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFx0fVxcblxcblxcdGlmICggb3B0cy5vdmVyZmxvdyApIHtcXG5cXHRcXHRzdHlsZS5vdmVyZmxvdyA9IFxcXCJoaWRkZW5cXFwiO1xcblxcdFxcdGFuaW0uYWx3YXlzKCBmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHRzdHlsZS5vdmVyZmxvdyA9IG9wdHMub3ZlcmZsb3dbIDAgXTtcXG5cXHRcXHRcXHRzdHlsZS5vdmVyZmxvd1ggPSBvcHRzLm92ZXJmbG93WyAxIF07XFxuXFx0XFx0XFx0c3R5bGUub3ZlcmZsb3dZID0gb3B0cy5vdmVyZmxvd1sgMiBdO1xcblxcdFxcdH0gKTtcXG5cXHR9XFxuXFxuXFx0Ly8gSW1wbGVtZW50IHNob3cvaGlkZSBhbmltYXRpb25zXFxuXFx0cHJvcFR3ZWVuID0gZmFsc2U7XFxuXFx0Zm9yICggcHJvcCBpbiBvcmlnICkge1xcblxcblxcdFxcdC8vIEdlbmVyYWwgc2hvdy9oaWRlIHNldHVwIGZvciB0aGlzIGVsZW1lbnQgYW5pbWF0aW9uXFxuXFx0XFx0aWYgKCAhcHJvcFR3ZWVuICkge1xcblxcdFxcdFxcdGlmICggZGF0YVNob3cgKSB7XFxuXFx0XFx0XFx0XFx0aWYgKCBcXFwiaGlkZGVuXFxcIiBpbiBkYXRhU2hvdyApIHtcXG5cXHRcXHRcXHRcXHRcXHRoaWRkZW4gPSBkYXRhU2hvdy5oaWRkZW47XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0ZGF0YVNob3cgPSBkYXRhUHJpdi5hY2Nlc3MoIGVsZW0sIFxcXCJmeHNob3dcXFwiLCB7IGRpc3BsYXk6IHJlc3RvcmVEaXNwbGF5IH0gKTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gU3RvcmUgaGlkZGVuL3Zpc2libGUgZm9yIHRvZ2dsZSBzbyBgLnN0b3AoKS50b2dnbGUoKWAgXFxcInJldmVyc2VzXFxcIlxcblxcdFxcdFxcdGlmICggdG9nZ2xlICkge1xcblxcdFxcdFxcdFxcdGRhdGFTaG93LmhpZGRlbiA9ICFoaWRkZW47XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIFNob3cgZWxlbWVudHMgYmVmb3JlIGFuaW1hdGluZyB0aGVtXFxuXFx0XFx0XFx0aWYgKCBoaWRkZW4gKSB7XFxuXFx0XFx0XFx0XFx0c2hvd0hpZGUoIFsgZWxlbSBdLCB0cnVlICk7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8qIGVzbGludC1kaXNhYmxlIG5vLWxvb3AtZnVuYyAqL1xcblxcblxcdFxcdFxcdGFuaW0uZG9uZSggZnVuY3Rpb24oKSB7XFxuXFxuXFx0XFx0XFx0LyogZXNsaW50LWVuYWJsZSBuby1sb29wLWZ1bmMgKi9cXG5cXG5cXHRcXHRcXHRcXHQvLyBUaGUgZmluYWwgc3RlcCBvZiBhIFxcXCJoaWRlXFxcIiBhbmltYXRpb24gaXMgYWN0dWFsbHkgaGlkaW5nIHRoZSBlbGVtZW50XFxuXFx0XFx0XFx0XFx0aWYgKCAhaGlkZGVuICkge1xcblxcdFxcdFxcdFxcdFxcdHNob3dIaWRlKCBbIGVsZW0gXSApO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRkYXRhUHJpdi5yZW1vdmUoIGVsZW0sIFxcXCJmeHNob3dcXFwiICk7XFxuXFx0XFx0XFx0XFx0Zm9yICggcHJvcCBpbiBvcmlnICkge1xcblxcdFxcdFxcdFxcdFxcdGpRdWVyeS5zdHlsZSggZWxlbSwgcHJvcCwgb3JpZ1sgcHJvcCBdICk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH0gKTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gUGVyLXByb3BlcnR5IHNldHVwXFxuXFx0XFx0cHJvcFR3ZWVuID0gY3JlYXRlVHdlZW4oIGhpZGRlbiA/IGRhdGFTaG93WyBwcm9wIF0gOiAwLCBwcm9wLCBhbmltICk7XFxuXFx0XFx0aWYgKCAhKCBwcm9wIGluIGRhdGFTaG93ICkgKSB7XFxuXFx0XFx0XFx0ZGF0YVNob3dbIHByb3AgXSA9IHByb3BUd2Vlbi5zdGFydDtcXG5cXHRcXHRcXHRpZiAoIGhpZGRlbiApIHtcXG5cXHRcXHRcXHRcXHRwcm9wVHdlZW4uZW5kID0gcHJvcFR3ZWVuLnN0YXJ0O1xcblxcdFxcdFxcdFxcdHByb3BUd2Vlbi5zdGFydCA9IDA7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXHR9XFxufVxcblxcbmZ1bmN0aW9uIHByb3BGaWx0ZXIoIHByb3BzLCBzcGVjaWFsRWFzaW5nICkge1xcblxcdHZhciBpbmRleCwgbmFtZSwgZWFzaW5nLCB2YWx1ZSwgaG9va3M7XFxuXFxuXFx0Ly8gY2FtZWxDYXNlLCBzcGVjaWFsRWFzaW5nIGFuZCBleHBhbmQgY3NzSG9vayBwYXNzXFxuXFx0Zm9yICggaW5kZXggaW4gcHJvcHMgKSB7XFxuXFx0XFx0bmFtZSA9IGNhbWVsQ2FzZSggaW5kZXggKTtcXG5cXHRcXHRlYXNpbmcgPSBzcGVjaWFsRWFzaW5nWyBuYW1lIF07XFxuXFx0XFx0dmFsdWUgPSBwcm9wc1sgaW5kZXggXTtcXG5cXHRcXHRpZiAoIEFycmF5LmlzQXJyYXkoIHZhbHVlICkgKSB7XFxuXFx0XFx0XFx0ZWFzaW5nID0gdmFsdWVbIDEgXTtcXG5cXHRcXHRcXHR2YWx1ZSA9IHByb3BzWyBpbmRleCBdID0gdmFsdWVbIDAgXTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0aWYgKCBpbmRleCAhPT0gbmFtZSApIHtcXG5cXHRcXHRcXHRwcm9wc1sgbmFtZSBdID0gdmFsdWU7XFxuXFx0XFx0XFx0ZGVsZXRlIHByb3BzWyBpbmRleCBdO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRob29rcyA9IGpRdWVyeS5jc3NIb29rc1sgbmFtZSBdO1xcblxcdFxcdGlmICggaG9va3MgJiYgXFxcImV4cGFuZFxcXCIgaW4gaG9va3MgKSB7XFxuXFx0XFx0XFx0dmFsdWUgPSBob29rcy5leHBhbmQoIHZhbHVlICk7XFxuXFx0XFx0XFx0ZGVsZXRlIHByb3BzWyBuYW1lIF07XFxuXFxuXFx0XFx0XFx0Ly8gTm90IHF1aXRlICQuZXh0ZW5kLCB0aGlzIHdvbid0IG92ZXJ3cml0ZSBleGlzdGluZyBrZXlzLlxcblxcdFxcdFxcdC8vIFJldXNpbmcgJ2luZGV4JyBiZWNhdXNlIHdlIGhhdmUgdGhlIGNvcnJlY3QgXFxcIm5hbWVcXFwiXFxuXFx0XFx0XFx0Zm9yICggaW5kZXggaW4gdmFsdWUgKSB7XFxuXFx0XFx0XFx0XFx0aWYgKCAhKCBpbmRleCBpbiBwcm9wcyApICkge1xcblxcdFxcdFxcdFxcdFxcdHByb3BzWyBpbmRleCBdID0gdmFsdWVbIGluZGV4IF07XFxuXFx0XFx0XFx0XFx0XFx0c3BlY2lhbEVhc2luZ1sgaW5kZXggXSA9IGVhc2luZztcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0c3BlY2lhbEVhc2luZ1sgbmFtZSBdID0gZWFzaW5nO1xcblxcdFxcdH1cXG5cXHR9XFxufVxcblxcbmZ1bmN0aW9uIEFuaW1hdGlvbiggZWxlbSwgcHJvcGVydGllcywgb3B0aW9ucyApIHtcXG5cXHR2YXIgcmVzdWx0LFxcblxcdFxcdHN0b3BwZWQsXFxuXFx0XFx0aW5kZXggPSAwLFxcblxcdFxcdGxlbmd0aCA9IEFuaW1hdGlvbi5wcmVmaWx0ZXJzLmxlbmd0aCxcXG5cXHRcXHRkZWZlcnJlZCA9IGpRdWVyeS5EZWZlcnJlZCgpLmFsd2F5cyggZnVuY3Rpb24oKSB7XFxuXFxuXFx0XFx0XFx0Ly8gRG9uJ3QgbWF0Y2ggZWxlbSBpbiB0aGUgOmFuaW1hdGVkIHNlbGVjdG9yXFxuXFx0XFx0XFx0ZGVsZXRlIHRpY2suZWxlbTtcXG5cXHRcXHR9ICksXFxuXFx0XFx0dGljayA9IGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdGlmICggc3RvcHBlZCApIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gZmFsc2U7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHZhciBjdXJyZW50VGltZSA9IGZ4Tm93IHx8IGNyZWF0ZUZ4Tm93KCksXFxuXFx0XFx0XFx0XFx0cmVtYWluaW5nID0gTWF0aC5tYXgoIDAsIGFuaW1hdGlvbi5zdGFydFRpbWUgKyBhbmltYXRpb24uZHVyYXRpb24gLSBjdXJyZW50VGltZSApLFxcblxcblxcdFxcdFxcdFxcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgMi4zIG9ubHlcXG5cXHRcXHRcXHRcXHQvLyBBcmNoYWljIGNyYXNoIGJ1ZyB3b24ndCBhbGxvdyB1cyB0byB1c2UgYDEgLSAoIDAuNSB8fCAwIClgICgjMTI0OTcpXFxuXFx0XFx0XFx0XFx0dGVtcCA9IHJlbWFpbmluZyAvIGFuaW1hdGlvbi5kdXJhdGlvbiB8fCAwLFxcblxcdFxcdFxcdFxcdHBlcmNlbnQgPSAxIC0gdGVtcCxcXG5cXHRcXHRcXHRcXHRpbmRleCA9IDAsXFxuXFx0XFx0XFx0XFx0bGVuZ3RoID0gYW5pbWF0aW9uLnR3ZWVucy5sZW5ndGg7XFxuXFxuXFx0XFx0XFx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcXG5cXHRcXHRcXHRcXHRhbmltYXRpb24udHdlZW5zWyBpbmRleCBdLnJ1biggcGVyY2VudCApO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRkZWZlcnJlZC5ub3RpZnlXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgcGVyY2VudCwgcmVtYWluaW5nIF0gKTtcXG5cXG5cXHRcXHRcXHQvLyBJZiB0aGVyZSdzIG1vcmUgdG8gZG8sIHlpZWxkXFxuXFx0XFx0XFx0aWYgKCBwZXJjZW50IDwgMSAmJiBsZW5ndGggKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHJlbWFpbmluZztcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gSWYgdGhpcyB3YXMgYW4gZW1wdHkgYW5pbWF0aW9uLCBzeW50aGVzaXplIGEgZmluYWwgcHJvZ3Jlc3Mgbm90aWZpY2F0aW9uXFxuXFx0XFx0XFx0aWYgKCAhbGVuZ3RoICkge1xcblxcdFxcdFxcdFxcdGRlZmVycmVkLm5vdGlmeVdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uLCAxLCAwIF0gKTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gUmVzb2x2ZSB0aGUgYW5pbWF0aW9uIGFuZCByZXBvcnQgaXRzIGNvbmNsdXNpb25cXG5cXHRcXHRcXHRkZWZlcnJlZC5yZXNvbHZlV2l0aCggZWxlbSwgWyBhbmltYXRpb24gXSApO1xcblxcdFxcdFxcdHJldHVybiBmYWxzZTtcXG5cXHRcXHR9LFxcblxcdFxcdGFuaW1hdGlvbiA9IGRlZmVycmVkLnByb21pc2UoIHtcXG5cXHRcXHRcXHRlbGVtOiBlbGVtLFxcblxcdFxcdFxcdHByb3BzOiBqUXVlcnkuZXh0ZW5kKCB7fSwgcHJvcGVydGllcyApLFxcblxcdFxcdFxcdG9wdHM6IGpRdWVyeS5leHRlbmQoIHRydWUsIHtcXG5cXHRcXHRcXHRcXHRzcGVjaWFsRWFzaW5nOiB7fSxcXG5cXHRcXHRcXHRcXHRlYXNpbmc6IGpRdWVyeS5lYXNpbmcuX2RlZmF1bHRcXG5cXHRcXHRcXHR9LCBvcHRpb25zICksXFxuXFx0XFx0XFx0b3JpZ2luYWxQcm9wZXJ0aWVzOiBwcm9wZXJ0aWVzLFxcblxcdFxcdFxcdG9yaWdpbmFsT3B0aW9uczogb3B0aW9ucyxcXG5cXHRcXHRcXHRzdGFydFRpbWU6IGZ4Tm93IHx8IGNyZWF0ZUZ4Tm93KCksXFxuXFx0XFx0XFx0ZHVyYXRpb246IG9wdGlvbnMuZHVyYXRpb24sXFxuXFx0XFx0XFx0dHdlZW5zOiBbXSxcXG5cXHRcXHRcXHRjcmVhdGVUd2VlbjogZnVuY3Rpb24oIHByb3AsIGVuZCApIHtcXG5cXHRcXHRcXHRcXHR2YXIgdHdlZW4gPSBqUXVlcnkuVHdlZW4oIGVsZW0sIGFuaW1hdGlvbi5vcHRzLCBwcm9wLCBlbmQsXFxuXFx0XFx0XFx0XFx0XFx0XFx0YW5pbWF0aW9uLm9wdHMuc3BlY2lhbEVhc2luZ1sgcHJvcCBdIHx8IGFuaW1hdGlvbi5vcHRzLmVhc2luZyApO1xcblxcdFxcdFxcdFxcdGFuaW1hdGlvbi50d2VlbnMucHVzaCggdHdlZW4gKTtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gdHdlZW47XFxuXFx0XFx0XFx0fSxcXG5cXHRcXHRcXHRzdG9wOiBmdW5jdGlvbiggZ290b0VuZCApIHtcXG5cXHRcXHRcXHRcXHR2YXIgaW5kZXggPSAwLFxcblxcblxcdFxcdFxcdFxcdFxcdC8vIElmIHdlIGFyZSBnb2luZyB0byB0aGUgZW5kLCB3ZSB3YW50IHRvIHJ1biBhbGwgdGhlIHR3ZWVuc1xcblxcdFxcdFxcdFxcdFxcdC8vIG90aGVyd2lzZSB3ZSBza2lwIHRoaXMgcGFydFxcblxcdFxcdFxcdFxcdFxcdGxlbmd0aCA9IGdvdG9FbmQgPyBhbmltYXRpb24udHdlZW5zLmxlbmd0aCA6IDA7XFxuXFx0XFx0XFx0XFx0aWYgKCBzdG9wcGVkICkge1xcblxcdFxcdFxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRzdG9wcGVkID0gdHJ1ZTtcXG5cXHRcXHRcXHRcXHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xcblxcdFxcdFxcdFxcdFxcdGFuaW1hdGlvbi50d2VlbnNbIGluZGV4IF0ucnVuKCAxICk7XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdC8vIFJlc29sdmUgd2hlbiB3ZSBwbGF5ZWQgdGhlIGxhc3QgZnJhbWU7IG90aGVyd2lzZSwgcmVqZWN0XFxuXFx0XFx0XFx0XFx0aWYgKCBnb3RvRW5kICkge1xcblxcdFxcdFxcdFxcdFxcdGRlZmVycmVkLm5vdGlmeVdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uLCAxLCAwIF0gKTtcXG5cXHRcXHRcXHRcXHRcXHRkZWZlcnJlZC5yZXNvbHZlV2l0aCggZWxlbSwgWyBhbmltYXRpb24sIGdvdG9FbmQgXSApO1xcblxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0ZGVmZXJyZWQucmVqZWN0V2l0aCggZWxlbSwgWyBhbmltYXRpb24sIGdvdG9FbmQgXSApO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSApLFxcblxcdFxcdHByb3BzID0gYW5pbWF0aW9uLnByb3BzO1xcblxcblxcdHByb3BGaWx0ZXIoIHByb3BzLCBhbmltYXRpb24ub3B0cy5zcGVjaWFsRWFzaW5nICk7XFxuXFxuXFx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcXG5cXHRcXHRyZXN1bHQgPSBBbmltYXRpb24ucHJlZmlsdGVyc1sgaW5kZXggXS5jYWxsKCBhbmltYXRpb24sIGVsZW0sIHByb3BzLCBhbmltYXRpb24ub3B0cyApO1xcblxcdFxcdGlmICggcmVzdWx0ICkge1xcblxcdFxcdFxcdGlmICggaXNGdW5jdGlvbiggcmVzdWx0LnN0b3AgKSApIHtcXG5cXHRcXHRcXHRcXHRqUXVlcnkuX3F1ZXVlSG9va3MoIGFuaW1hdGlvbi5lbGVtLCBhbmltYXRpb24ub3B0cy5xdWV1ZSApLnN0b3AgPVxcblxcdFxcdFxcdFxcdFxcdHJlc3VsdC5zdG9wLmJpbmQoIHJlc3VsdCApO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRyZXR1cm4gcmVzdWx0O1xcblxcdFxcdH1cXG5cXHR9XFxuXFxuXFx0alF1ZXJ5Lm1hcCggcHJvcHMsIGNyZWF0ZVR3ZWVuLCBhbmltYXRpb24gKTtcXG5cXG5cXHRpZiAoIGlzRnVuY3Rpb24oIGFuaW1hdGlvbi5vcHRzLnN0YXJ0ICkgKSB7XFxuXFx0XFx0YW5pbWF0aW9uLm9wdHMuc3RhcnQuY2FsbCggZWxlbSwgYW5pbWF0aW9uICk7XFxuXFx0fVxcblxcblxcdC8vIEF0dGFjaCBjYWxsYmFja3MgZnJvbSBvcHRpb25zXFxuXFx0YW5pbWF0aW9uXFxuXFx0XFx0LnByb2dyZXNzKCBhbmltYXRpb24ub3B0cy5wcm9ncmVzcyApXFxuXFx0XFx0LmRvbmUoIGFuaW1hdGlvbi5vcHRzLmRvbmUsIGFuaW1hdGlvbi5vcHRzLmNvbXBsZXRlIClcXG5cXHRcXHQuZmFpbCggYW5pbWF0aW9uLm9wdHMuZmFpbCApXFxuXFx0XFx0LmFsd2F5cyggYW5pbWF0aW9uLm9wdHMuYWx3YXlzICk7XFxuXFxuXFx0alF1ZXJ5LmZ4LnRpbWVyKFxcblxcdFxcdGpRdWVyeS5leHRlbmQoIHRpY2ssIHtcXG5cXHRcXHRcXHRlbGVtOiBlbGVtLFxcblxcdFxcdFxcdGFuaW06IGFuaW1hdGlvbixcXG5cXHRcXHRcXHRxdWV1ZTogYW5pbWF0aW9uLm9wdHMucXVldWVcXG5cXHRcXHR9IClcXG5cXHQpO1xcblxcblxcdHJldHVybiBhbmltYXRpb247XFxufVxcblxcbmpRdWVyeS5BbmltYXRpb24gPSBqUXVlcnkuZXh0ZW5kKCBBbmltYXRpb24sIHtcXG5cXG5cXHR0d2VlbmVyczoge1xcblxcdFxcdFxcXCIqXFxcIjogWyBmdW5jdGlvbiggcHJvcCwgdmFsdWUgKSB7XFxuXFx0XFx0XFx0dmFyIHR3ZWVuID0gdGhpcy5jcmVhdGVUd2VlbiggcHJvcCwgdmFsdWUgKTtcXG5cXHRcXHRcXHRhZGp1c3RDU1MoIHR3ZWVuLmVsZW0sIHByb3AsIHJjc3NOdW0uZXhlYyggdmFsdWUgKSwgdHdlZW4gKTtcXG5cXHRcXHRcXHRyZXR1cm4gdHdlZW47XFxuXFx0XFx0fSBdXFxuXFx0fSxcXG5cXG5cXHR0d2VlbmVyOiBmdW5jdGlvbiggcHJvcHMsIGNhbGxiYWNrICkge1xcblxcdFxcdGlmICggaXNGdW5jdGlvbiggcHJvcHMgKSApIHtcXG5cXHRcXHRcXHRjYWxsYmFjayA9IHByb3BzO1xcblxcdFxcdFxcdHByb3BzID0gWyBcXFwiKlxcXCIgXTtcXG5cXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdHByb3BzID0gcHJvcHMubWF0Y2goIHJub3RodG1sd2hpdGUgKTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0dmFyIHByb3AsXFxuXFx0XFx0XFx0aW5kZXggPSAwLFxcblxcdFxcdFxcdGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcXG5cXG5cXHRcXHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xcblxcdFxcdFxcdHByb3AgPSBwcm9wc1sgaW5kZXggXTtcXG5cXHRcXHRcXHRBbmltYXRpb24udHdlZW5lcnNbIHByb3AgXSA9IEFuaW1hdGlvbi50d2VlbmVyc1sgcHJvcCBdIHx8IFtdO1xcblxcdFxcdFxcdEFuaW1hdGlvbi50d2VlbmVyc1sgcHJvcCBdLnVuc2hpZnQoIGNhbGxiYWNrICk7XFxuXFx0XFx0fVxcblxcdH0sXFxuXFxuXFx0cHJlZmlsdGVyczogWyBkZWZhdWx0UHJlZmlsdGVyIF0sXFxuXFxuXFx0cHJlZmlsdGVyOiBmdW5jdGlvbiggY2FsbGJhY2ssIHByZXBlbmQgKSB7XFxuXFx0XFx0aWYgKCBwcmVwZW5kICkge1xcblxcdFxcdFxcdEFuaW1hdGlvbi5wcmVmaWx0ZXJzLnVuc2hpZnQoIGNhbGxiYWNrICk7XFxuXFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRBbmltYXRpb24ucHJlZmlsdGVycy5wdXNoKCBjYWxsYmFjayApO1xcblxcdFxcdH1cXG5cXHR9XFxufSApO1xcblxcbmpRdWVyeS5zcGVlZCA9IGZ1bmN0aW9uKCBzcGVlZCwgZWFzaW5nLCBmbiApIHtcXG5cXHR2YXIgb3B0ID0gc3BlZWQgJiYgdHlwZW9mIHNwZWVkID09PSBcXFwib2JqZWN0XFxcIiA/IGpRdWVyeS5leHRlbmQoIHt9LCBzcGVlZCApIDoge1xcblxcdFxcdGNvbXBsZXRlOiBmbiB8fCAhZm4gJiYgZWFzaW5nIHx8XFxuXFx0XFx0XFx0aXNGdW5jdGlvbiggc3BlZWQgKSAmJiBzcGVlZCxcXG5cXHRcXHRkdXJhdGlvbjogc3BlZWQsXFxuXFx0XFx0ZWFzaW5nOiBmbiAmJiBlYXNpbmcgfHwgZWFzaW5nICYmICFpc0Z1bmN0aW9uKCBlYXNpbmcgKSAmJiBlYXNpbmdcXG5cXHR9O1xcblxcblxcdC8vIEdvIHRvIHRoZSBlbmQgc3RhdGUgaWYgZnggYXJlIG9mZlxcblxcdGlmICggalF1ZXJ5LmZ4Lm9mZiApIHtcXG5cXHRcXHRvcHQuZHVyYXRpb24gPSAwO1xcblxcblxcdH0gZWxzZSB7XFxuXFx0XFx0aWYgKCB0eXBlb2Ygb3B0LmR1cmF0aW9uICE9PSBcXFwibnVtYmVyXFxcIiApIHtcXG5cXHRcXHRcXHRpZiAoIG9wdC5kdXJhdGlvbiBpbiBqUXVlcnkuZnguc3BlZWRzICkge1xcblxcdFxcdFxcdFxcdG9wdC5kdXJhdGlvbiA9IGpRdWVyeS5meC5zcGVlZHNbIG9wdC5kdXJhdGlvbiBdO1xcblxcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0b3B0LmR1cmF0aW9uID0galF1ZXJ5LmZ4LnNwZWVkcy5fZGVmYXVsdDtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcdH1cXG5cXG5cXHQvLyBOb3JtYWxpemUgb3B0LnF1ZXVlIC0gdHJ1ZS91bmRlZmluZWQvbnVsbCAtPiBcXFwiZnhcXFwiXFxuXFx0aWYgKCBvcHQucXVldWUgPT0gbnVsbCB8fCBvcHQucXVldWUgPT09IHRydWUgKSB7XFxuXFx0XFx0b3B0LnF1ZXVlID0gXFxcImZ4XFxcIjtcXG5cXHR9XFxuXFxuXFx0Ly8gUXVldWVpbmdcXG5cXHRvcHQub2xkID0gb3B0LmNvbXBsZXRlO1xcblxcblxcdG9wdC5jb21wbGV0ZSA9IGZ1bmN0aW9uKCkge1xcblxcdFxcdGlmICggaXNGdW5jdGlvbiggb3B0Lm9sZCApICkge1xcblxcdFxcdFxcdG9wdC5vbGQuY2FsbCggdGhpcyApO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRpZiAoIG9wdC5xdWV1ZSApIHtcXG5cXHRcXHRcXHRqUXVlcnkuZGVxdWV1ZSggdGhpcywgb3B0LnF1ZXVlICk7XFxuXFx0XFx0fVxcblxcdH07XFxuXFxuXFx0cmV0dXJuIG9wdDtcXG59O1xcblxcbmpRdWVyeS5mbi5leHRlbmQoIHtcXG5cXHRmYWRlVG86IGZ1bmN0aW9uKCBzcGVlZCwgdG8sIGVhc2luZywgY2FsbGJhY2sgKSB7XFxuXFxuXFx0XFx0Ly8gU2hvdyBhbnkgaGlkZGVuIGVsZW1lbnRzIGFmdGVyIHNldHRpbmcgb3BhY2l0eSB0byAwXFxuXFx0XFx0cmV0dXJuIHRoaXMuZmlsdGVyKCBpc0hpZGRlbldpdGhpblRyZWUgKS5jc3MoIFxcXCJvcGFjaXR5XFxcIiwgMCApLnNob3coKVxcblxcblxcdFxcdFxcdC8vIEFuaW1hdGUgdG8gdGhlIHZhbHVlIHNwZWNpZmllZFxcblxcdFxcdFxcdC5lbmQoKS5hbmltYXRlKCB7IG9wYWNpdHk6IHRvIH0sIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICk7XFxuXFx0fSxcXG5cXHRhbmltYXRlOiBmdW5jdGlvbiggcHJvcCwgc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKSB7XFxuXFx0XFx0dmFyIGVtcHR5ID0galF1ZXJ5LmlzRW1wdHlPYmplY3QoIHByb3AgKSxcXG5cXHRcXHRcXHRvcHRhbGwgPSBqUXVlcnkuc3BlZWQoIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICksXFxuXFx0XFx0XFx0ZG9BbmltYXRpb24gPSBmdW5jdGlvbigpIHtcXG5cXG5cXHRcXHRcXHRcXHQvLyBPcGVyYXRlIG9uIGEgY29weSBvZiBwcm9wIHNvIHBlci1wcm9wZXJ0eSBlYXNpbmcgd29uJ3QgYmUgbG9zdFxcblxcdFxcdFxcdFxcdHZhciBhbmltID0gQW5pbWF0aW9uKCB0aGlzLCBqUXVlcnkuZXh0ZW5kKCB7fSwgcHJvcCApLCBvcHRhbGwgKTtcXG5cXG5cXHRcXHRcXHRcXHQvLyBFbXB0eSBhbmltYXRpb25zLCBvciBmaW5pc2hpbmcgcmVzb2x2ZXMgaW1tZWRpYXRlbHlcXG5cXHRcXHRcXHRcXHRpZiAoIGVtcHR5IHx8IGRhdGFQcml2LmdldCggdGhpcywgXFxcImZpbmlzaFxcXCIgKSApIHtcXG5cXHRcXHRcXHRcXHRcXHRhbmltLnN0b3AoIHRydWUgKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fTtcXG5cXHRcXHRcXHRkb0FuaW1hdGlvbi5maW5pc2ggPSBkb0FuaW1hdGlvbjtcXG5cXG5cXHRcXHRyZXR1cm4gZW1wdHkgfHwgb3B0YWxsLnF1ZXVlID09PSBmYWxzZSA/XFxuXFx0XFx0XFx0dGhpcy5lYWNoKCBkb0FuaW1hdGlvbiApIDpcXG5cXHRcXHRcXHR0aGlzLnF1ZXVlKCBvcHRhbGwucXVldWUsIGRvQW5pbWF0aW9uICk7XFxuXFx0fSxcXG5cXHRzdG9wOiBmdW5jdGlvbiggdHlwZSwgY2xlYXJRdWV1ZSwgZ290b0VuZCApIHtcXG5cXHRcXHR2YXIgc3RvcFF1ZXVlID0gZnVuY3Rpb24oIGhvb2tzICkge1xcblxcdFxcdFxcdHZhciBzdG9wID0gaG9va3Muc3RvcDtcXG5cXHRcXHRcXHRkZWxldGUgaG9va3Muc3RvcDtcXG5cXHRcXHRcXHRzdG9wKCBnb3RvRW5kICk7XFxuXFx0XFx0fTtcXG5cXG5cXHRcXHRpZiAoIHR5cGVvZiB0eXBlICE9PSBcXFwic3RyaW5nXFxcIiApIHtcXG5cXHRcXHRcXHRnb3RvRW5kID0gY2xlYXJRdWV1ZTtcXG5cXHRcXHRcXHRjbGVhclF1ZXVlID0gdHlwZTtcXG5cXHRcXHRcXHR0eXBlID0gdW5kZWZpbmVkO1xcblxcdFxcdH1cXG5cXHRcXHRpZiAoIGNsZWFyUXVldWUgJiYgdHlwZSAhPT0gZmFsc2UgKSB7XFxuXFx0XFx0XFx0dGhpcy5xdWV1ZSggdHlwZSB8fCBcXFwiZnhcXFwiLCBbXSApO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHR2YXIgZGVxdWV1ZSA9IHRydWUsXFxuXFx0XFx0XFx0XFx0aW5kZXggPSB0eXBlICE9IG51bGwgJiYgdHlwZSArIFxcXCJxdWV1ZUhvb2tzXFxcIixcXG5cXHRcXHRcXHRcXHR0aW1lcnMgPSBqUXVlcnkudGltZXJzLFxcblxcdFxcdFxcdFxcdGRhdGEgPSBkYXRhUHJpdi5nZXQoIHRoaXMgKTtcXG5cXG5cXHRcXHRcXHRpZiAoIGluZGV4ICkge1xcblxcdFxcdFxcdFxcdGlmICggZGF0YVsgaW5kZXggXSAmJiBkYXRhWyBpbmRleCBdLnN0b3AgKSB7XFxuXFx0XFx0XFx0XFx0XFx0c3RvcFF1ZXVlKCBkYXRhWyBpbmRleCBdICk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0Zm9yICggaW5kZXggaW4gZGF0YSApIHtcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIGRhdGFbIGluZGV4IF0gJiYgZGF0YVsgaW5kZXggXS5zdG9wICYmIHJydW4udGVzdCggaW5kZXggKSApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRzdG9wUXVldWUoIGRhdGFbIGluZGV4IF0gKTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRmb3IgKCBpbmRleCA9IHRpbWVycy5sZW5ndGg7IGluZGV4LS07ICkge1xcblxcdFxcdFxcdFxcdGlmICggdGltZXJzWyBpbmRleCBdLmVsZW0gPT09IHRoaXMgJiZcXG5cXHRcXHRcXHRcXHRcXHQoIHR5cGUgPT0gbnVsbCB8fCB0aW1lcnNbIGluZGV4IF0ucXVldWUgPT09IHR5cGUgKSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHR0aW1lcnNbIGluZGV4IF0uYW5pbS5zdG9wKCBnb3RvRW5kICk7XFxuXFx0XFx0XFx0XFx0XFx0ZGVxdWV1ZSA9IGZhbHNlO1xcblxcdFxcdFxcdFxcdFxcdHRpbWVycy5zcGxpY2UoIGluZGV4LCAxICk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBTdGFydCB0aGUgbmV4dCBpbiB0aGUgcXVldWUgaWYgdGhlIGxhc3Qgc3RlcCB3YXNuJ3QgZm9yY2VkLlxcblxcdFxcdFxcdC8vIFRpbWVycyBjdXJyZW50bHkgd2lsbCBjYWxsIHRoZWlyIGNvbXBsZXRlIGNhbGxiYWNrcywgd2hpY2hcXG5cXHRcXHRcXHQvLyB3aWxsIGRlcXVldWUgYnV0IG9ubHkgaWYgdGhleSB3ZXJlIGdvdG9FbmQuXFxuXFx0XFx0XFx0aWYgKCBkZXF1ZXVlIHx8ICFnb3RvRW5kICkge1xcblxcdFxcdFxcdFxcdGpRdWVyeS5kZXF1ZXVlKCB0aGlzLCB0eXBlICk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH0gKTtcXG5cXHR9LFxcblxcdGZpbmlzaDogZnVuY3Rpb24oIHR5cGUgKSB7XFxuXFx0XFx0aWYgKCB0eXBlICE9PSBmYWxzZSApIHtcXG5cXHRcXHRcXHR0eXBlID0gdHlwZSB8fCBcXFwiZnhcXFwiO1xcblxcdFxcdH1cXG5cXHRcXHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHR2YXIgaW5kZXgsXFxuXFx0XFx0XFx0XFx0ZGF0YSA9IGRhdGFQcml2LmdldCggdGhpcyApLFxcblxcdFxcdFxcdFxcdHF1ZXVlID0gZGF0YVsgdHlwZSArIFxcXCJxdWV1ZVxcXCIgXSxcXG5cXHRcXHRcXHRcXHRob29rcyA9IGRhdGFbIHR5cGUgKyBcXFwicXVldWVIb29rc1xcXCIgXSxcXG5cXHRcXHRcXHRcXHR0aW1lcnMgPSBqUXVlcnkudGltZXJzLFxcblxcdFxcdFxcdFxcdGxlbmd0aCA9IHF1ZXVlID8gcXVldWUubGVuZ3RoIDogMDtcXG5cXG5cXHRcXHRcXHQvLyBFbmFibGUgZmluaXNoaW5nIGZsYWcgb24gcHJpdmF0ZSBkYXRhXFxuXFx0XFx0XFx0ZGF0YS5maW5pc2ggPSB0cnVlO1xcblxcblxcdFxcdFxcdC8vIEVtcHR5IHRoZSBxdWV1ZSBmaXJzdFxcblxcdFxcdFxcdGpRdWVyeS5xdWV1ZSggdGhpcywgdHlwZSwgW10gKTtcXG5cXG5cXHRcXHRcXHRpZiAoIGhvb2tzICYmIGhvb2tzLnN0b3AgKSB7XFxuXFx0XFx0XFx0XFx0aG9va3Muc3RvcC5jYWxsKCB0aGlzLCB0cnVlICk7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIExvb2sgZm9yIGFueSBhY3RpdmUgYW5pbWF0aW9ucywgYW5kIGZpbmlzaCB0aGVtXFxuXFx0XFx0XFx0Zm9yICggaW5kZXggPSB0aW1lcnMubGVuZ3RoOyBpbmRleC0tOyApIHtcXG5cXHRcXHRcXHRcXHRpZiAoIHRpbWVyc1sgaW5kZXggXS5lbGVtID09PSB0aGlzICYmIHRpbWVyc1sgaW5kZXggXS5xdWV1ZSA9PT0gdHlwZSApIHtcXG5cXHRcXHRcXHRcXHRcXHR0aW1lcnNbIGluZGV4IF0uYW5pbS5zdG9wKCB0cnVlICk7XFxuXFx0XFx0XFx0XFx0XFx0dGltZXJzLnNwbGljZSggaW5kZXgsIDEgKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIExvb2sgZm9yIGFueSBhbmltYXRpb25zIGluIHRoZSBvbGQgcXVldWUgYW5kIGZpbmlzaCB0aGVtXFxuXFx0XFx0XFx0Zm9yICggaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcXG5cXHRcXHRcXHRcXHRpZiAoIHF1ZXVlWyBpbmRleCBdICYmIHF1ZXVlWyBpbmRleCBdLmZpbmlzaCApIHtcXG5cXHRcXHRcXHRcXHRcXHRxdWV1ZVsgaW5kZXggXS5maW5pc2guY2FsbCggdGhpcyApO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gVHVybiBvZmYgZmluaXNoaW5nIGZsYWdcXG5cXHRcXHRcXHRkZWxldGUgZGF0YS5maW5pc2g7XFxuXFx0XFx0fSApO1xcblxcdH1cXG59ICk7XFxuXFxualF1ZXJ5LmVhY2goIFsgXFxcInRvZ2dsZVxcXCIsIFxcXCJzaG93XFxcIiwgXFxcImhpZGVcXFwiIF0sIGZ1bmN0aW9uKCBpLCBuYW1lICkge1xcblxcdHZhciBjc3NGbiA9IGpRdWVyeS5mblsgbmFtZSBdO1xcblxcdGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICkge1xcblxcdFxcdHJldHVybiBzcGVlZCA9PSBudWxsIHx8IHR5cGVvZiBzcGVlZCA9PT0gXFxcImJvb2xlYW5cXFwiID9cXG5cXHRcXHRcXHRjc3NGbi5hcHBseSggdGhpcywgYXJndW1lbnRzICkgOlxcblxcdFxcdFxcdHRoaXMuYW5pbWF0ZSggZ2VuRngoIG5hbWUsIHRydWUgKSwgc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKTtcXG5cXHR9O1xcbn0gKTtcXG5cXG4vLyBHZW5lcmF0ZSBzaG9ydGN1dHMgZm9yIGN1c3RvbSBhbmltYXRpb25zXFxualF1ZXJ5LmVhY2goIHtcXG5cXHRzbGlkZURvd246IGdlbkZ4KCBcXFwic2hvd1xcXCIgKSxcXG5cXHRzbGlkZVVwOiBnZW5GeCggXFxcImhpZGVcXFwiICksXFxuXFx0c2xpZGVUb2dnbGU6IGdlbkZ4KCBcXFwidG9nZ2xlXFxcIiApLFxcblxcdGZhZGVJbjogeyBvcGFjaXR5OiBcXFwic2hvd1xcXCIgfSxcXG5cXHRmYWRlT3V0OiB7IG9wYWNpdHk6IFxcXCJoaWRlXFxcIiB9LFxcblxcdGZhZGVUb2dnbGU6IHsgb3BhY2l0eTogXFxcInRvZ2dsZVxcXCIgfVxcbn0sIGZ1bmN0aW9uKCBuYW1lLCBwcm9wcyApIHtcXG5cXHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApIHtcXG5cXHRcXHRyZXR1cm4gdGhpcy5hbmltYXRlKCBwcm9wcywgc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKTtcXG5cXHR9O1xcbn0gKTtcXG5cXG5qUXVlcnkudGltZXJzID0gW107XFxualF1ZXJ5LmZ4LnRpY2sgPSBmdW5jdGlvbigpIHtcXG5cXHR2YXIgdGltZXIsXFxuXFx0XFx0aSA9IDAsXFxuXFx0XFx0dGltZXJzID0galF1ZXJ5LnRpbWVycztcXG5cXG5cXHRmeE5vdyA9IERhdGUubm93KCk7XFxuXFxuXFx0Zm9yICggOyBpIDwgdGltZXJzLmxlbmd0aDsgaSsrICkge1xcblxcdFxcdHRpbWVyID0gdGltZXJzWyBpIF07XFxuXFxuXFx0XFx0Ly8gUnVuIHRoZSB0aW1lciBhbmQgc2FmZWx5IHJlbW92ZSBpdCB3aGVuIGRvbmUgKGFsbG93aW5nIGZvciBleHRlcm5hbCByZW1vdmFsKVxcblxcdFxcdGlmICggIXRpbWVyKCkgJiYgdGltZXJzWyBpIF0gPT09IHRpbWVyICkge1xcblxcdFxcdFxcdHRpbWVycy5zcGxpY2UoIGktLSwgMSApO1xcblxcdFxcdH1cXG5cXHR9XFxuXFxuXFx0aWYgKCAhdGltZXJzLmxlbmd0aCApIHtcXG5cXHRcXHRqUXVlcnkuZnguc3RvcCgpO1xcblxcdH1cXG5cXHRmeE5vdyA9IHVuZGVmaW5lZDtcXG59O1xcblxcbmpRdWVyeS5meC50aW1lciA9IGZ1bmN0aW9uKCB0aW1lciApIHtcXG5cXHRqUXVlcnkudGltZXJzLnB1c2goIHRpbWVyICk7XFxuXFx0alF1ZXJ5LmZ4LnN0YXJ0KCk7XFxufTtcXG5cXG5qUXVlcnkuZnguaW50ZXJ2YWwgPSAxMztcXG5qUXVlcnkuZnguc3RhcnQgPSBmdW5jdGlvbigpIHtcXG5cXHRpZiAoIGluUHJvZ3Jlc3MgKSB7XFxuXFx0XFx0cmV0dXJuO1xcblxcdH1cXG5cXG5cXHRpblByb2dyZXNzID0gdHJ1ZTtcXG5cXHRzY2hlZHVsZSgpO1xcbn07XFxuXFxualF1ZXJ5LmZ4LnN0b3AgPSBmdW5jdGlvbigpIHtcXG5cXHRpblByb2dyZXNzID0gbnVsbDtcXG59O1xcblxcbmpRdWVyeS5meC5zcGVlZHMgPSB7XFxuXFx0c2xvdzogNjAwLFxcblxcdGZhc3Q6IDIwMCxcXG5cXG5cXHQvLyBEZWZhdWx0IHNwZWVkXFxuXFx0X2RlZmF1bHQ6IDQwMFxcbn07XFxuXFxuXFxuLy8gQmFzZWQgb2ZmIG9mIHRoZSBwbHVnaW4gYnkgQ2xpbnQgSGVsZmVycywgd2l0aCBwZXJtaXNzaW9uLlxcbi8vIGh0dHBzOi8vd2ViLmFyY2hpdmUub3JnL3dlYi8yMDEwMDMyNDAxNDc0Ny9odHRwOi8vYmxpbmRzaWduYWxzLmNvbS9pbmRleC5waHAvMjAwOS8wNy9qcXVlcnktZGVsYXkvXFxualF1ZXJ5LmZuLmRlbGF5ID0gZnVuY3Rpb24oIHRpbWUsIHR5cGUgKSB7XFxuXFx0dGltZSA9IGpRdWVyeS5meCA/IGpRdWVyeS5meC5zcGVlZHNbIHRpbWUgXSB8fCB0aW1lIDogdGltZTtcXG5cXHR0eXBlID0gdHlwZSB8fCBcXFwiZnhcXFwiO1xcblxcblxcdHJldHVybiB0aGlzLnF1ZXVlKCB0eXBlLCBmdW5jdGlvbiggbmV4dCwgaG9va3MgKSB7XFxuXFx0XFx0dmFyIHRpbWVvdXQgPSB3aW5kb3cuc2V0VGltZW91dCggbmV4dCwgdGltZSApO1xcblxcdFxcdGhvb2tzLnN0b3AgPSBmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHR3aW5kb3cuY2xlYXJUaW1lb3V0KCB0aW1lb3V0ICk7XFxuXFx0XFx0fTtcXG5cXHR9ICk7XFxufTtcXG5cXG5cXG4oIGZ1bmN0aW9uKCkge1xcblxcdHZhciBpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFxcXCJpbnB1dFxcXCIgKSxcXG5cXHRcXHRzZWxlY3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcXFwic2VsZWN0XFxcIiApLFxcblxcdFxcdG9wdCA9IHNlbGVjdC5hcHBlbmRDaGlsZCggZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXFxcIm9wdGlvblxcXCIgKSApO1xcblxcblxcdGlucHV0LnR5cGUgPSBcXFwiY2hlY2tib3hcXFwiO1xcblxcblxcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjMgb25seVxcblxcdC8vIERlZmF1bHQgdmFsdWUgZm9yIGEgY2hlY2tib3ggc2hvdWxkIGJlIFxcXCJvblxcXCJcXG5cXHRzdXBwb3J0LmNoZWNrT24gPSBpbnB1dC52YWx1ZSAhPT0gXFxcIlxcXCI7XFxuXFxuXFx0Ly8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XFxuXFx0Ly8gTXVzdCBhY2Nlc3Mgc2VsZWN0ZWRJbmRleCB0byBtYWtlIGRlZmF1bHQgb3B0aW9ucyBzZWxlY3RcXG5cXHRzdXBwb3J0Lm9wdFNlbGVjdGVkID0gb3B0LnNlbGVjdGVkO1xcblxcblxcdC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seVxcblxcdC8vIEFuIGlucHV0IGxvc2VzIGl0cyB2YWx1ZSBhZnRlciBiZWNvbWluZyBhIHJhZGlvXFxuXFx0aW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcXFwiaW5wdXRcXFwiICk7XFxuXFx0aW5wdXQudmFsdWUgPSBcXFwidFxcXCI7XFxuXFx0aW5wdXQudHlwZSA9IFxcXCJyYWRpb1xcXCI7XFxuXFx0c3VwcG9ydC5yYWRpb1ZhbHVlID0gaW5wdXQudmFsdWUgPT09IFxcXCJ0XFxcIjtcXG59ICkoKTtcXG5cXG5cXG52YXIgYm9vbEhvb2ssXFxuXFx0YXR0ckhhbmRsZSA9IGpRdWVyeS5leHByLmF0dHJIYW5kbGU7XFxuXFxualF1ZXJ5LmZuLmV4dGVuZCgge1xcblxcdGF0dHI6IGZ1bmN0aW9uKCBuYW1lLCB2YWx1ZSApIHtcXG5cXHRcXHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBqUXVlcnkuYXR0ciwgbmFtZSwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggPiAxICk7XFxuXFx0fSxcXG5cXG5cXHRyZW1vdmVBdHRyOiBmdW5jdGlvbiggbmFtZSApIHtcXG5cXHRcXHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHRqUXVlcnkucmVtb3ZlQXR0ciggdGhpcywgbmFtZSApO1xcblxcdFxcdH0gKTtcXG5cXHR9XFxufSApO1xcblxcbmpRdWVyeS5leHRlbmQoIHtcXG5cXHRhdHRyOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgdmFsdWUgKSB7XFxuXFx0XFx0dmFyIHJldCwgaG9va3MsXFxuXFx0XFx0XFx0blR5cGUgPSBlbGVtLm5vZGVUeXBlO1xcblxcblxcdFxcdC8vIERvbid0IGdldC9zZXQgYXR0cmlidXRlcyBvbiB0ZXh0LCBjb21tZW50IGFuZCBhdHRyaWJ1dGUgbm9kZXNcXG5cXHRcXHRpZiAoIG5UeXBlID09PSAzIHx8IG5UeXBlID09PSA4IHx8IG5UeXBlID09PSAyICkge1xcblxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gRmFsbGJhY2sgdG8gcHJvcCB3aGVuIGF0dHJpYnV0ZXMgYXJlIG5vdCBzdXBwb3J0ZWRcXG5cXHRcXHRpZiAoIHR5cGVvZiBlbGVtLmdldEF0dHJpYnV0ZSA9PT0gXFxcInVuZGVmaW5lZFxcXCIgKSB7XFxuXFx0XFx0XFx0cmV0dXJuIGpRdWVyeS5wcm9wKCBlbGVtLCBuYW1lLCB2YWx1ZSApO1xcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBBdHRyaWJ1dGUgaG9va3MgYXJlIGRldGVybWluZWQgYnkgdGhlIGxvd2VyY2FzZSB2ZXJzaW9uXFxuXFx0XFx0Ly8gR3JhYiBuZWNlc3NhcnkgaG9vayBpZiBvbmUgaXMgZGVmaW5lZFxcblxcdFxcdGlmICggblR5cGUgIT09IDEgfHwgIWpRdWVyeS5pc1hNTERvYyggZWxlbSApICkge1xcblxcdFxcdFxcdGhvb2tzID0galF1ZXJ5LmF0dHJIb29rc1sgbmFtZS50b0xvd2VyQ2FzZSgpIF0gfHxcXG5cXHRcXHRcXHRcXHQoIGpRdWVyeS5leHByLm1hdGNoLmJvb2wudGVzdCggbmFtZSApID8gYm9vbEhvb2sgOiB1bmRlZmluZWQgKTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0aWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xcblxcdFxcdFxcdGlmICggdmFsdWUgPT09IG51bGwgKSB7XFxuXFx0XFx0XFx0XFx0alF1ZXJ5LnJlbW92ZUF0dHIoIGVsZW0sIG5hbWUgKTtcXG5cXHRcXHRcXHRcXHRyZXR1cm47XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGlmICggaG9va3MgJiYgXFxcInNldFxcXCIgaW4gaG9va3MgJiZcXG5cXHRcXHRcXHRcXHQoIHJldCA9IGhvb2tzLnNldCggZWxlbSwgdmFsdWUsIG5hbWUgKSApICE9PSB1bmRlZmluZWQgKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHJldDtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0ZWxlbS5zZXRBdHRyaWJ1dGUoIG5hbWUsIHZhbHVlICsgXFxcIlxcXCIgKTtcXG5cXHRcXHRcXHRyZXR1cm4gdmFsdWU7XFxuXFx0XFx0fVxcblxcblxcdFxcdGlmICggaG9va3MgJiYgXFxcImdldFxcXCIgaW4gaG9va3MgJiYgKCByZXQgPSBob29rcy5nZXQoIGVsZW0sIG5hbWUgKSApICE9PSBudWxsICkge1xcblxcdFxcdFxcdHJldHVybiByZXQ7XFxuXFx0XFx0fVxcblxcblxcdFxcdHJldCA9IGpRdWVyeS5maW5kLmF0dHIoIGVsZW0sIG5hbWUgKTtcXG5cXG5cXHRcXHQvLyBOb24tZXhpc3RlbnQgYXR0cmlidXRlcyByZXR1cm4gbnVsbCwgd2Ugbm9ybWFsaXplIHRvIHVuZGVmaW5lZFxcblxcdFxcdHJldHVybiByZXQgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IHJldDtcXG5cXHR9LFxcblxcblxcdGF0dHJIb29rczoge1xcblxcdFxcdHR5cGU6IHtcXG5cXHRcXHRcXHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSApIHtcXG5cXHRcXHRcXHRcXHRpZiAoICFzdXBwb3J0LnJhZGlvVmFsdWUgJiYgdmFsdWUgPT09IFxcXCJyYWRpb1xcXCIgJiZcXG5cXHRcXHRcXHRcXHRcXHRub2RlTmFtZSggZWxlbSwgXFxcImlucHV0XFxcIiApICkge1xcblxcdFxcdFxcdFxcdFxcdHZhciB2YWwgPSBlbGVtLnZhbHVlO1xcblxcdFxcdFxcdFxcdFxcdGVsZW0uc2V0QXR0cmlidXRlKCBcXFwidHlwZVxcXCIsIHZhbHVlICk7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKCB2YWwgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0ZWxlbS52YWx1ZSA9IHZhbDtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIHZhbHVlO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcdH0sXFxuXFxuXFx0cmVtb3ZlQXR0cjogZnVuY3Rpb24oIGVsZW0sIHZhbHVlICkge1xcblxcdFxcdHZhciBuYW1lLFxcblxcdFxcdFxcdGkgPSAwLFxcblxcblxcdFxcdFxcdC8vIEF0dHJpYnV0ZSBuYW1lcyBjYW4gY29udGFpbiBub24tSFRNTCB3aGl0ZXNwYWNlIGNoYXJhY3RlcnNcXG5cXHRcXHRcXHQvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNhdHRyaWJ1dGVzLTJcXG5cXHRcXHRcXHRhdHRyTmFtZXMgPSB2YWx1ZSAmJiB2YWx1ZS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApO1xcblxcblxcdFxcdGlmICggYXR0ck5hbWVzICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XFxuXFx0XFx0XFx0d2hpbGUgKCAoIG5hbWUgPSBhdHRyTmFtZXNbIGkrKyBdICkgKSB7XFxuXFx0XFx0XFx0XFx0ZWxlbS5yZW1vdmVBdHRyaWJ1dGUoIG5hbWUgKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcdH1cXG59ICk7XFxuXFxuLy8gSG9va3MgZm9yIGJvb2xlYW4gYXR0cmlidXRlc1xcbmJvb2xIb29rID0ge1xcblxcdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlLCBuYW1lICkge1xcblxcdFxcdGlmICggdmFsdWUgPT09IGZhbHNlICkge1xcblxcblxcdFxcdFxcdC8vIFJlbW92ZSBib29sZWFuIGF0dHJpYnV0ZXMgd2hlbiBzZXQgdG8gZmFsc2VcXG5cXHRcXHRcXHRqUXVlcnkucmVtb3ZlQXR0ciggZWxlbSwgbmFtZSApO1xcblxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0ZWxlbS5zZXRBdHRyaWJ1dGUoIG5hbWUsIG5hbWUgKTtcXG5cXHRcXHR9XFxuXFx0XFx0cmV0dXJuIG5hbWU7XFxuXFx0fVxcbn07XFxuXFxualF1ZXJ5LmVhY2goIGpRdWVyeS5leHByLm1hdGNoLmJvb2wuc291cmNlLm1hdGNoKCAvXFxcXHcrL2cgKSwgZnVuY3Rpb24oIGksIG5hbWUgKSB7XFxuXFx0dmFyIGdldHRlciA9IGF0dHJIYW5kbGVbIG5hbWUgXSB8fCBqUXVlcnkuZmluZC5hdHRyO1xcblxcblxcdGF0dHJIYW5kbGVbIG5hbWUgXSA9IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBpc1hNTCApIHtcXG5cXHRcXHR2YXIgcmV0LCBoYW5kbGUsXFxuXFx0XFx0XFx0bG93ZXJjYXNlTmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcXG5cXG5cXHRcXHRpZiAoICFpc1hNTCApIHtcXG5cXG5cXHRcXHRcXHQvLyBBdm9pZCBhbiBpbmZpbml0ZSBsb29wIGJ5IHRlbXBvcmFyaWx5IHJlbW92aW5nIHRoaXMgZnVuY3Rpb24gZnJvbSB0aGUgZ2V0dGVyXFxuXFx0XFx0XFx0aGFuZGxlID0gYXR0ckhhbmRsZVsgbG93ZXJjYXNlTmFtZSBdO1xcblxcdFxcdFxcdGF0dHJIYW5kbGVbIGxvd2VyY2FzZU5hbWUgXSA9IHJldDtcXG5cXHRcXHRcXHRyZXQgPSBnZXR0ZXIoIGVsZW0sIG5hbWUsIGlzWE1MICkgIT0gbnVsbCA/XFxuXFx0XFx0XFx0XFx0bG93ZXJjYXNlTmFtZSA6XFxuXFx0XFx0XFx0XFx0bnVsbDtcXG5cXHRcXHRcXHRhdHRySGFuZGxlWyBsb3dlcmNhc2VOYW1lIF0gPSBoYW5kbGU7XFxuXFx0XFx0fVxcblxcdFxcdHJldHVybiByZXQ7XFxuXFx0fTtcXG59ICk7XFxuXFxuXFxuXFxuXFxudmFyIHJmb2N1c2FibGUgPSAvXig/OmlucHV0fHNlbGVjdHx0ZXh0YXJlYXxidXR0b24pJC9pLFxcblxcdHJjbGlja2FibGUgPSAvXig/OmF8YXJlYSkkL2k7XFxuXFxualF1ZXJ5LmZuLmV4dGVuZCgge1xcblxcdHByb3A6IGZ1bmN0aW9uKCBuYW1lLCB2YWx1ZSApIHtcXG5cXHRcXHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBqUXVlcnkucHJvcCwgbmFtZSwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggPiAxICk7XFxuXFx0fSxcXG5cXG5cXHRyZW1vdmVQcm9wOiBmdW5jdGlvbiggbmFtZSApIHtcXG5cXHRcXHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHRkZWxldGUgdGhpc1sgalF1ZXJ5LnByb3BGaXhbIG5hbWUgXSB8fCBuYW1lIF07XFxuXFx0XFx0fSApO1xcblxcdH1cXG59ICk7XFxuXFxualF1ZXJ5LmV4dGVuZCgge1xcblxcdHByb3A6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCB2YWx1ZSApIHtcXG5cXHRcXHR2YXIgcmV0LCBob29rcyxcXG5cXHRcXHRcXHRuVHlwZSA9IGVsZW0ubm9kZVR5cGU7XFxuXFxuXFx0XFx0Ly8gRG9uJ3QgZ2V0L3NldCBwcm9wZXJ0aWVzIG9uIHRleHQsIGNvbW1lbnQgYW5kIGF0dHJpYnV0ZSBub2Rlc1xcblxcdFxcdGlmICggblR5cGUgPT09IDMgfHwgblR5cGUgPT09IDggfHwgblR5cGUgPT09IDIgKSB7XFxuXFx0XFx0XFx0cmV0dXJuO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRpZiAoIG5UeXBlICE9PSAxIHx8ICFqUXVlcnkuaXNYTUxEb2MoIGVsZW0gKSApIHtcXG5cXG5cXHRcXHRcXHQvLyBGaXggbmFtZSBhbmQgYXR0YWNoIGhvb2tzXFxuXFx0XFx0XFx0bmFtZSA9IGpRdWVyeS5wcm9wRml4WyBuYW1lIF0gfHwgbmFtZTtcXG5cXHRcXHRcXHRob29rcyA9IGpRdWVyeS5wcm9wSG9va3NbIG5hbWUgXTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0aWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xcblxcdFxcdFxcdGlmICggaG9va3MgJiYgXFxcInNldFxcXCIgaW4gaG9va3MgJiZcXG5cXHRcXHRcXHRcXHQoIHJldCA9IGhvb2tzLnNldCggZWxlbSwgdmFsdWUsIG5hbWUgKSApICE9PSB1bmRlZmluZWQgKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHJldDtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cmV0dXJuICggZWxlbVsgbmFtZSBdID0gdmFsdWUgKTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0aWYgKCBob29rcyAmJiBcXFwiZ2V0XFxcIiBpbiBob29rcyAmJiAoIHJldCA9IGhvb2tzLmdldCggZWxlbSwgbmFtZSApICkgIT09IG51bGwgKSB7XFxuXFx0XFx0XFx0cmV0dXJuIHJldDtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0cmV0dXJuIGVsZW1bIG5hbWUgXTtcXG5cXHR9LFxcblxcblxcdHByb3BIb29rczoge1xcblxcdFxcdHRhYkluZGV4OiB7XFxuXFx0XFx0XFx0Z2V0OiBmdW5jdGlvbiggZWxlbSApIHtcXG5cXG5cXHRcXHRcXHRcXHQvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSBvbmx5XFxuXFx0XFx0XFx0XFx0Ly8gZWxlbS50YWJJbmRleCBkb2Vzbid0IGFsd2F5cyByZXR1cm4gdGhlXFxuXFx0XFx0XFx0XFx0Ly8gY29ycmVjdCB2YWx1ZSB3aGVuIGl0IGhhc24ndCBiZWVuIGV4cGxpY2l0bHkgc2V0XFxuXFx0XFx0XFx0XFx0Ly8gaHR0cHM6Ly93ZWIuYXJjaGl2ZS5vcmcvd2ViLzIwMTQxMTE2MjMzMzQ3L2h0dHA6Ly9mbHVpZHByb2plY3Qub3JnL2Jsb2cvMjAwOC8wMS8wOS9nZXR0aW5nLXNldHRpbmctYW5kLXJlbW92aW5nLXRhYmluZGV4LXZhbHVlcy13aXRoLWphdmFzY3JpcHQvXFxuXFx0XFx0XFx0XFx0Ly8gVXNlIHByb3BlciBhdHRyaWJ1dGUgcmV0cmlldmFsKCMxMjA3MilcXG5cXHRcXHRcXHRcXHR2YXIgdGFiaW5kZXggPSBqUXVlcnkuZmluZC5hdHRyKCBlbGVtLCBcXFwidGFiaW5kZXhcXFwiICk7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCB0YWJpbmRleCApIHtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gcGFyc2VJbnQoIHRhYmluZGV4LCAxMCApO1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRpZiAoXFxuXFx0XFx0XFx0XFx0XFx0cmZvY3VzYWJsZS50ZXN0KCBlbGVtLm5vZGVOYW1lICkgfHxcXG5cXHRcXHRcXHRcXHRcXHRyY2xpY2thYmxlLnRlc3QoIGVsZW0ubm9kZU5hbWUgKSAmJlxcblxcdFxcdFxcdFxcdFxcdGVsZW0uaHJlZlxcblxcdFxcdFxcdFxcdCkge1xcblxcdFxcdFxcdFxcdFxcdHJldHVybiAwO1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRyZXR1cm4gLTE7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXHR9LFxcblxcblxcdHByb3BGaXg6IHtcXG5cXHRcXHRcXFwiZm9yXFxcIjogXFxcImh0bWxGb3JcXFwiLFxcblxcdFxcdFxcXCJjbGFzc1xcXCI6IFxcXCJjbGFzc05hbWVcXFwiXFxuXFx0fVxcbn0gKTtcXG5cXG4vLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcXG4vLyBBY2Nlc3NpbmcgdGhlIHNlbGVjdGVkSW5kZXggcHJvcGVydHlcXG4vLyBmb3JjZXMgdGhlIGJyb3dzZXIgdG8gcmVzcGVjdCBzZXR0aW5nIHNlbGVjdGVkXFxuLy8gb24gdGhlIG9wdGlvblxcbi8vIFRoZSBnZXR0ZXIgZW5zdXJlcyBhIGRlZmF1bHQgb3B0aW9uIGlzIHNlbGVjdGVkXFxuLy8gd2hlbiBpbiBhbiBvcHRncm91cFxcbi8vIGVzbGludCBydWxlIFxcXCJuby11bnVzZWQtZXhwcmVzc2lvbnNcXFwiIGlzIGRpc2FibGVkIGZvciB0aGlzIGNvZGVcXG4vLyBzaW5jZSBpdCBjb25zaWRlcnMgc3VjaCBhY2Nlc3Npb25zIG5vb3BcXG5pZiAoICFzdXBwb3J0Lm9wdFNlbGVjdGVkICkge1xcblxcdGpRdWVyeS5wcm9wSG9va3Muc2VsZWN0ZWQgPSB7XFxuXFx0XFx0Z2V0OiBmdW5jdGlvbiggZWxlbSApIHtcXG5cXG5cXHRcXHRcXHQvKiBlc2xpbnQgbm8tdW51c2VkLWV4cHJlc3Npb25zOiBcXFwib2ZmXFxcIiAqL1xcblxcblxcdFxcdFxcdHZhciBwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGU7XFxuXFx0XFx0XFx0aWYgKCBwYXJlbnQgJiYgcGFyZW50LnBhcmVudE5vZGUgKSB7XFxuXFx0XFx0XFx0XFx0cGFyZW50LnBhcmVudE5vZGUuc2VsZWN0ZWRJbmRleDtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0cmV0dXJuIG51bGw7XFxuXFx0XFx0fSxcXG5cXHRcXHRzZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xcblxcblxcdFxcdFxcdC8qIGVzbGludCBuby11bnVzZWQtZXhwcmVzc2lvbnM6IFxcXCJvZmZcXFwiICovXFxuXFxuXFx0XFx0XFx0dmFyIHBhcmVudCA9IGVsZW0ucGFyZW50Tm9kZTtcXG5cXHRcXHRcXHRpZiAoIHBhcmVudCApIHtcXG5cXHRcXHRcXHRcXHRwYXJlbnQuc2VsZWN0ZWRJbmRleDtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIHBhcmVudC5wYXJlbnROb2RlICkge1xcblxcdFxcdFxcdFxcdFxcdHBhcmVudC5wYXJlbnROb2RlLnNlbGVjdGVkSW5kZXg7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFx0fTtcXG59XFxuXFxualF1ZXJ5LmVhY2goIFtcXG5cXHRcXFwidGFiSW5kZXhcXFwiLFxcblxcdFxcXCJyZWFkT25seVxcXCIsXFxuXFx0XFxcIm1heExlbmd0aFxcXCIsXFxuXFx0XFxcImNlbGxTcGFjaW5nXFxcIixcXG5cXHRcXFwiY2VsbFBhZGRpbmdcXFwiLFxcblxcdFxcXCJyb3dTcGFuXFxcIixcXG5cXHRcXFwiY29sU3BhblxcXCIsXFxuXFx0XFxcInVzZU1hcFxcXCIsXFxuXFx0XFxcImZyYW1lQm9yZGVyXFxcIixcXG5cXHRcXFwiY29udGVudEVkaXRhYmxlXFxcIlxcbl0sIGZ1bmN0aW9uKCkge1xcblxcdGpRdWVyeS5wcm9wRml4WyB0aGlzLnRvTG93ZXJDYXNlKCkgXSA9IHRoaXM7XFxufSApO1xcblxcblxcblxcblxcblxcdC8vIFN0cmlwIGFuZCBjb2xsYXBzZSB3aGl0ZXNwYWNlIGFjY29yZGluZyB0byBIVE1MIHNwZWNcXG5cXHQvLyBodHRwczovL2luZnJhLnNwZWMud2hhdHdnLm9yZy8jc3RyaXAtYW5kLWNvbGxhcHNlLWFzY2lpLXdoaXRlc3BhY2VcXG5cXHRmdW5jdGlvbiBzdHJpcEFuZENvbGxhcHNlKCB2YWx1ZSApIHtcXG5cXHRcXHR2YXIgdG9rZW5zID0gdmFsdWUubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbXTtcXG5cXHRcXHRyZXR1cm4gdG9rZW5zLmpvaW4oIFxcXCIgXFxcIiApO1xcblxcdH1cXG5cXG5cXG5mdW5jdGlvbiBnZXRDbGFzcyggZWxlbSApIHtcXG5cXHRyZXR1cm4gZWxlbS5nZXRBdHRyaWJ1dGUgJiYgZWxlbS5nZXRBdHRyaWJ1dGUoIFxcXCJjbGFzc1xcXCIgKSB8fCBcXFwiXFxcIjtcXG59XFxuXFxuZnVuY3Rpb24gY2xhc3Nlc1RvQXJyYXkoIHZhbHVlICkge1xcblxcdGlmICggQXJyYXkuaXNBcnJheSggdmFsdWUgKSApIHtcXG5cXHRcXHRyZXR1cm4gdmFsdWU7XFxuXFx0fVxcblxcdGlmICggdHlwZW9mIHZhbHVlID09PSBcXFwic3RyaW5nXFxcIiApIHtcXG5cXHRcXHRyZXR1cm4gdmFsdWUubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbXTtcXG5cXHR9XFxuXFx0cmV0dXJuIFtdO1xcbn1cXG5cXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XFxuXFx0YWRkQ2xhc3M6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcXG5cXHRcXHR2YXIgY2xhc3NlcywgZWxlbSwgY3VyLCBjdXJWYWx1ZSwgY2xhenosIGosIGZpbmFsVmFsdWUsXFxuXFx0XFx0XFx0aSA9IDA7XFxuXFxuXFx0XFx0aWYgKCBpc0Z1bmN0aW9uKCB2YWx1ZSApICkge1xcblxcdFxcdFxcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBqICkge1xcblxcdFxcdFxcdFxcdGpRdWVyeSggdGhpcyApLmFkZENsYXNzKCB2YWx1ZS5jYWxsKCB0aGlzLCBqLCBnZXRDbGFzcyggdGhpcyApICkgKTtcXG5cXHRcXHRcXHR9ICk7XFxuXFx0XFx0fVxcblxcblxcdFxcdGNsYXNzZXMgPSBjbGFzc2VzVG9BcnJheSggdmFsdWUgKTtcXG5cXG5cXHRcXHRpZiAoIGNsYXNzZXMubGVuZ3RoICkge1xcblxcdFxcdFxcdHdoaWxlICggKCBlbGVtID0gdGhpc1sgaSsrIF0gKSApIHtcXG5cXHRcXHRcXHRcXHRjdXJWYWx1ZSA9IGdldENsYXNzKCBlbGVtICk7XFxuXFx0XFx0XFx0XFx0Y3VyID0gZWxlbS5ub2RlVHlwZSA9PT0gMSAmJiAoIFxcXCIgXFxcIiArIHN0cmlwQW5kQ29sbGFwc2UoIGN1clZhbHVlICkgKyBcXFwiIFxcXCIgKTtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIGN1ciApIHtcXG5cXHRcXHRcXHRcXHRcXHRqID0gMDtcXG5cXHRcXHRcXHRcXHRcXHR3aGlsZSAoICggY2xhenogPSBjbGFzc2VzWyBqKysgXSApICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGlmICggY3VyLmluZGV4T2YoIFxcXCIgXFxcIiArIGNsYXp6ICsgXFxcIiBcXFwiICkgPCAwICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGN1ciArPSBjbGF6eiArIFxcXCIgXFxcIjtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdC8vIE9ubHkgYXNzaWduIGlmIGRpZmZlcmVudCB0byBhdm9pZCB1bm5lZWRlZCByZW5kZXJpbmcuXFxuXFx0XFx0XFx0XFx0XFx0ZmluYWxWYWx1ZSA9IHN0cmlwQW5kQ29sbGFwc2UoIGN1ciApO1xcblxcdFxcdFxcdFxcdFxcdGlmICggY3VyVmFsdWUgIT09IGZpbmFsVmFsdWUgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0ZWxlbS5zZXRBdHRyaWJ1dGUoIFxcXCJjbGFzc1xcXCIsIGZpbmFsVmFsdWUgKTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFxuXFx0XFx0cmV0dXJuIHRoaXM7XFxuXFx0fSxcXG5cXG5cXHRyZW1vdmVDbGFzczogZnVuY3Rpb24oIHZhbHVlICkge1xcblxcdFxcdHZhciBjbGFzc2VzLCBlbGVtLCBjdXIsIGN1clZhbHVlLCBjbGF6eiwgaiwgZmluYWxWYWx1ZSxcXG5cXHRcXHRcXHRpID0gMDtcXG5cXG5cXHRcXHRpZiAoIGlzRnVuY3Rpb24oIHZhbHVlICkgKSB7XFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGogKSB7XFxuXFx0XFx0XFx0XFx0alF1ZXJ5KCB0aGlzICkucmVtb3ZlQ2xhc3MoIHZhbHVlLmNhbGwoIHRoaXMsIGosIGdldENsYXNzKCB0aGlzICkgKSApO1xcblxcdFxcdFxcdH0gKTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0aWYgKCAhYXJndW1lbnRzLmxlbmd0aCApIHtcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5hdHRyKCBcXFwiY2xhc3NcXFwiLCBcXFwiXFxcIiApO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRjbGFzc2VzID0gY2xhc3Nlc1RvQXJyYXkoIHZhbHVlICk7XFxuXFxuXFx0XFx0aWYgKCBjbGFzc2VzLmxlbmd0aCApIHtcXG5cXHRcXHRcXHR3aGlsZSAoICggZWxlbSA9IHRoaXNbIGkrKyBdICkgKSB7XFxuXFx0XFx0XFx0XFx0Y3VyVmFsdWUgPSBnZXRDbGFzcyggZWxlbSApO1xcblxcblxcdFxcdFxcdFxcdC8vIFRoaXMgZXhwcmVzc2lvbiBpcyBoZXJlIGZvciBiZXR0ZXIgY29tcHJlc3NpYmlsaXR5IChzZWUgYWRkQ2xhc3MpXFxuXFx0XFx0XFx0XFx0Y3VyID0gZWxlbS5ub2RlVHlwZSA9PT0gMSAmJiAoIFxcXCIgXFxcIiArIHN0cmlwQW5kQ29sbGFwc2UoIGN1clZhbHVlICkgKyBcXFwiIFxcXCIgKTtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIGN1ciApIHtcXG5cXHRcXHRcXHRcXHRcXHRqID0gMDtcXG5cXHRcXHRcXHRcXHRcXHR3aGlsZSAoICggY2xhenogPSBjbGFzc2VzWyBqKysgXSApICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdC8vIFJlbW92ZSAqYWxsKiBpbnN0YW5jZXNcXG5cXHRcXHRcXHRcXHRcXHRcXHR3aGlsZSAoIGN1ci5pbmRleE9mKCBcXFwiIFxcXCIgKyBjbGF6eiArIFxcXCIgXFxcIiApID4gLTEgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Y3VyID0gY3VyLnJlcGxhY2UoIFxcXCIgXFxcIiArIGNsYXp6ICsgXFxcIiBcXFwiLCBcXFwiIFxcXCIgKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdC8vIE9ubHkgYXNzaWduIGlmIGRpZmZlcmVudCB0byBhdm9pZCB1bm5lZWRlZCByZW5kZXJpbmcuXFxuXFx0XFx0XFx0XFx0XFx0ZmluYWxWYWx1ZSA9IHN0cmlwQW5kQ29sbGFwc2UoIGN1ciApO1xcblxcdFxcdFxcdFxcdFxcdGlmICggY3VyVmFsdWUgIT09IGZpbmFsVmFsdWUgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0ZWxlbS5zZXRBdHRyaWJ1dGUoIFxcXCJjbGFzc1xcXCIsIGZpbmFsVmFsdWUgKTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFxuXFx0XFx0cmV0dXJuIHRoaXM7XFxuXFx0fSxcXG5cXG5cXHR0b2dnbGVDbGFzczogZnVuY3Rpb24oIHZhbHVlLCBzdGF0ZVZhbCApIHtcXG5cXHRcXHR2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZSxcXG5cXHRcXHRcXHRpc1ZhbGlkVmFsdWUgPSB0eXBlID09PSBcXFwic3RyaW5nXFxcIiB8fCBBcnJheS5pc0FycmF5KCB2YWx1ZSApO1xcblxcblxcdFxcdGlmICggdHlwZW9mIHN0YXRlVmFsID09PSBcXFwiYm9vbGVhblxcXCIgJiYgaXNWYWxpZFZhbHVlICkge1xcblxcdFxcdFxcdHJldHVybiBzdGF0ZVZhbCA/IHRoaXMuYWRkQ2xhc3MoIHZhbHVlICkgOiB0aGlzLnJlbW92ZUNsYXNzKCB2YWx1ZSApO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRpZiAoIGlzRnVuY3Rpb24oIHZhbHVlICkgKSB7XFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGkgKSB7XFxuXFx0XFx0XFx0XFx0alF1ZXJ5KCB0aGlzICkudG9nZ2xlQ2xhc3MoXFxuXFx0XFx0XFx0XFx0XFx0dmFsdWUuY2FsbCggdGhpcywgaSwgZ2V0Q2xhc3MoIHRoaXMgKSwgc3RhdGVWYWwgKSxcXG5cXHRcXHRcXHRcXHRcXHRzdGF0ZVZhbFxcblxcdFxcdFxcdFxcdCk7XFxuXFx0XFx0XFx0fSApO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHR2YXIgY2xhc3NOYW1lLCBpLCBzZWxmLCBjbGFzc05hbWVzO1xcblxcblxcdFxcdFxcdGlmICggaXNWYWxpZFZhbHVlICkge1xcblxcblxcdFxcdFxcdFxcdC8vIFRvZ2dsZSBpbmRpdmlkdWFsIGNsYXNzIG5hbWVzXFxuXFx0XFx0XFx0XFx0aSA9IDA7XFxuXFx0XFx0XFx0XFx0c2VsZiA9IGpRdWVyeSggdGhpcyApO1xcblxcdFxcdFxcdFxcdGNsYXNzTmFtZXMgPSBjbGFzc2VzVG9BcnJheSggdmFsdWUgKTtcXG5cXG5cXHRcXHRcXHRcXHR3aGlsZSAoICggY2xhc3NOYW1lID0gY2xhc3NOYW1lc1sgaSsrIF0gKSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBDaGVjayBlYWNoIGNsYXNzTmFtZSBnaXZlbiwgc3BhY2Ugc2VwYXJhdGVkIGxpc3RcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIHNlbGYuaGFzQ2xhc3MoIGNsYXNzTmFtZSApICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHNlbGYucmVtb3ZlQ2xhc3MoIGNsYXNzTmFtZSApO1xcblxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0c2VsZi5hZGRDbGFzcyggY2xhc3NOYW1lICk7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBUb2dnbGUgd2hvbGUgY2xhc3MgbmFtZVxcblxcdFxcdFxcdH0gZWxzZSBpZiAoIHZhbHVlID09PSB1bmRlZmluZWQgfHwgdHlwZSA9PT0gXFxcImJvb2xlYW5cXFwiICkge1xcblxcdFxcdFxcdFxcdGNsYXNzTmFtZSA9IGdldENsYXNzKCB0aGlzICk7XFxuXFx0XFx0XFx0XFx0aWYgKCBjbGFzc05hbWUgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gU3RvcmUgY2xhc3NOYW1lIGlmIHNldFxcblxcdFxcdFxcdFxcdFxcdGRhdGFQcml2LnNldCggdGhpcywgXFxcIl9fY2xhc3NOYW1lX19cXFwiLCBjbGFzc05hbWUgKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0Ly8gSWYgdGhlIGVsZW1lbnQgaGFzIGEgY2xhc3MgbmFtZSBvciBpZiB3ZSdyZSBwYXNzZWQgYGZhbHNlYCxcXG5cXHRcXHRcXHRcXHQvLyB0aGVuIHJlbW92ZSB0aGUgd2hvbGUgY2xhc3NuYW1lIChpZiB0aGVyZSB3YXMgb25lLCB0aGUgYWJvdmUgc2F2ZWQgaXQpLlxcblxcdFxcdFxcdFxcdC8vIE90aGVyd2lzZSBicmluZyBiYWNrIHdoYXRldmVyIHdhcyBwcmV2aW91c2x5IHNhdmVkIChpZiBhbnl0aGluZyksXFxuXFx0XFx0XFx0XFx0Ly8gZmFsbGluZyBiYWNrIHRvIHRoZSBlbXB0eSBzdHJpbmcgaWYgbm90aGluZyB3YXMgc3RvcmVkLlxcblxcdFxcdFxcdFxcdGlmICggdGhpcy5zZXRBdHRyaWJ1dGUgKSB7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5zZXRBdHRyaWJ1dGUoIFxcXCJjbGFzc1xcXCIsXFxuXFx0XFx0XFx0XFx0XFx0XFx0Y2xhc3NOYW1lIHx8IHZhbHVlID09PSBmYWxzZSA/XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFxcIlxcXCIgOlxcblxcdFxcdFxcdFxcdFxcdFxcdGRhdGFQcml2LmdldCggdGhpcywgXFxcIl9fY2xhc3NOYW1lX19cXFwiICkgfHwgXFxcIlxcXCJcXG5cXHRcXHRcXHRcXHRcXHQpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSApO1xcblxcdH0sXFxuXFxuXFx0aGFzQ2xhc3M6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcXG5cXHRcXHR2YXIgY2xhc3NOYW1lLCBlbGVtLFxcblxcdFxcdFxcdGkgPSAwO1xcblxcblxcdFxcdGNsYXNzTmFtZSA9IFxcXCIgXFxcIiArIHNlbGVjdG9yICsgXFxcIiBcXFwiO1xcblxcdFxcdHdoaWxlICggKCBlbGVtID0gdGhpc1sgaSsrIF0gKSApIHtcXG5cXHRcXHRcXHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgJiZcXG5cXHRcXHRcXHRcXHQoIFxcXCIgXFxcIiArIHN0cmlwQW5kQ29sbGFwc2UoIGdldENsYXNzKCBlbGVtICkgKSArIFxcXCIgXFxcIiApLmluZGV4T2YoIGNsYXNzTmFtZSApID4gLTEgKSB7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIHRydWU7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXG5cXHRcXHRyZXR1cm4gZmFsc2U7XFxuXFx0fVxcbn0gKTtcXG5cXG5cXG5cXG5cXG52YXIgcnJldHVybiA9IC9cXFxcci9nO1xcblxcbmpRdWVyeS5mbi5leHRlbmQoIHtcXG5cXHR2YWw6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcXG5cXHRcXHR2YXIgaG9va3MsIHJldCwgdmFsdWVJc0Z1bmN0aW9uLFxcblxcdFxcdFxcdGVsZW0gPSB0aGlzWyAwIF07XFxuXFxuXFx0XFx0aWYgKCAhYXJndW1lbnRzLmxlbmd0aCApIHtcXG5cXHRcXHRcXHRpZiAoIGVsZW0gKSB7XFxuXFx0XFx0XFx0XFx0aG9va3MgPSBqUXVlcnkudmFsSG9va3NbIGVsZW0udHlwZSBdIHx8XFxuXFx0XFx0XFx0XFx0XFx0alF1ZXJ5LnZhbEhvb2tzWyBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgXTtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIGhvb2tzICYmXFxuXFx0XFx0XFx0XFx0XFx0XFxcImdldFxcXCIgaW4gaG9va3MgJiZcXG5cXHRcXHRcXHRcXHRcXHQoIHJldCA9IGhvb2tzLmdldCggZWxlbSwgXFxcInZhbHVlXFxcIiApICkgIT09IHVuZGVmaW5lZFxcblxcdFxcdFxcdFxcdCkge1xcblxcdFxcdFxcdFxcdFxcdHJldHVybiByZXQ7XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdHJldCA9IGVsZW0udmFsdWU7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gSGFuZGxlIG1vc3QgY29tbW9uIHN0cmluZyBjYXNlc1xcblxcdFxcdFxcdFxcdGlmICggdHlwZW9mIHJldCA9PT0gXFxcInN0cmluZ1xcXCIgKSB7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIHJldC5yZXBsYWNlKCBycmV0dXJuLCBcXFwiXFxcIiApO1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHQvLyBIYW5kbGUgY2FzZXMgd2hlcmUgdmFsdWUgaXMgbnVsbC91bmRlZiBvciBudW1iZXJcXG5cXHRcXHRcXHRcXHRyZXR1cm4gcmV0ID09IG51bGwgPyBcXFwiXFxcIiA6IHJldDtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cmV0dXJuO1xcblxcdFxcdH1cXG5cXG5cXHRcXHR2YWx1ZUlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uKCB2YWx1ZSApO1xcblxcblxcdFxcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBpICkge1xcblxcdFxcdFxcdHZhciB2YWw7XFxuXFxuXFx0XFx0XFx0aWYgKCB0aGlzLm5vZGVUeXBlICE9PSAxICkge1xcblxcdFxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKCB2YWx1ZUlzRnVuY3Rpb24gKSB7XFxuXFx0XFx0XFx0XFx0dmFsID0gdmFsdWUuY2FsbCggdGhpcywgaSwgalF1ZXJ5KCB0aGlzICkudmFsKCkgKTtcXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdHZhbCA9IHZhbHVlO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBUcmVhdCBudWxsL3VuZGVmaW5lZCBhcyBcXFwiXFxcIjsgY29udmVydCBudW1iZXJzIHRvIHN0cmluZ1xcblxcdFxcdFxcdGlmICggdmFsID09IG51bGwgKSB7XFxuXFx0XFx0XFx0XFx0dmFsID0gXFxcIlxcXCI7XFxuXFxuXFx0XFx0XFx0fSBlbHNlIGlmICggdHlwZW9mIHZhbCA9PT0gXFxcIm51bWJlclxcXCIgKSB7XFxuXFx0XFx0XFx0XFx0dmFsICs9IFxcXCJcXFwiO1xcblxcblxcdFxcdFxcdH0gZWxzZSBpZiAoIEFycmF5LmlzQXJyYXkoIHZhbCApICkge1xcblxcdFxcdFxcdFxcdHZhbCA9IGpRdWVyeS5tYXAoIHZhbCwgZnVuY3Rpb24oIHZhbHVlICkge1xcblxcdFxcdFxcdFxcdFxcdHJldHVybiB2YWx1ZSA9PSBudWxsID8gXFxcIlxcXCIgOiB2YWx1ZSArIFxcXCJcXFwiO1xcblxcdFxcdFxcdFxcdH0gKTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aG9va3MgPSBqUXVlcnkudmFsSG9va3NbIHRoaXMudHlwZSBdIHx8IGpRdWVyeS52YWxIb29rc1sgdGhpcy5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpIF07XFxuXFxuXFx0XFx0XFx0Ly8gSWYgc2V0IHJldHVybnMgdW5kZWZpbmVkLCBmYWxsIGJhY2sgdG8gbm9ybWFsIHNldHRpbmdcXG5cXHRcXHRcXHRpZiAoICFob29rcyB8fCAhKCBcXFwic2V0XFxcIiBpbiBob29rcyApIHx8IGhvb2tzLnNldCggdGhpcywgdmFsLCBcXFwidmFsdWVcXFwiICkgPT09IHVuZGVmaW5lZCApIHtcXG5cXHRcXHRcXHRcXHR0aGlzLnZhbHVlID0gdmFsO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9ICk7XFxuXFx0fVxcbn0gKTtcXG5cXG5qUXVlcnkuZXh0ZW5kKCB7XFxuXFx0dmFsSG9va3M6IHtcXG5cXHRcXHRvcHRpb246IHtcXG5cXHRcXHRcXHRnZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xcblxcblxcdFxcdFxcdFxcdHZhciB2YWwgPSBqUXVlcnkuZmluZC5hdHRyKCBlbGVtLCBcXFwidmFsdWVcXFwiICk7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHZhbCAhPSBudWxsID9cXG5cXHRcXHRcXHRcXHRcXHR2YWwgOlxcblxcblxcdFxcdFxcdFxcdFxcdC8vIFN1cHBvcnQ6IElFIDw9MTAgLSAxMSBvbmx5XFxuXFx0XFx0XFx0XFx0XFx0Ly8gb3B0aW9uLnRleHQgdGhyb3dzIGV4Y2VwdGlvbnMgKCMxNDY4NiwgIzE0ODU4KVxcblxcdFxcdFxcdFxcdFxcdC8vIFN0cmlwIGFuZCBjb2xsYXBzZSB3aGl0ZXNwYWNlXFxuXFx0XFx0XFx0XFx0XFx0Ly8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy8jc3RyaXAtYW5kLWNvbGxhcHNlLXdoaXRlc3BhY2VcXG5cXHRcXHRcXHRcXHRcXHRzdHJpcEFuZENvbGxhcHNlKCBqUXVlcnkudGV4dCggZWxlbSApICk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH0sXFxuXFx0XFx0c2VsZWN0OiB7XFxuXFx0XFx0XFx0Z2V0OiBmdW5jdGlvbiggZWxlbSApIHtcXG5cXHRcXHRcXHRcXHR2YXIgdmFsdWUsIG9wdGlvbiwgaSxcXG5cXHRcXHRcXHRcXHRcXHRvcHRpb25zID0gZWxlbS5vcHRpb25zLFxcblxcdFxcdFxcdFxcdFxcdGluZGV4ID0gZWxlbS5zZWxlY3RlZEluZGV4LFxcblxcdFxcdFxcdFxcdFxcdG9uZSA9IGVsZW0udHlwZSA9PT0gXFxcInNlbGVjdC1vbmVcXFwiLFxcblxcdFxcdFxcdFxcdFxcdHZhbHVlcyA9IG9uZSA/IG51bGwgOiBbXSxcXG5cXHRcXHRcXHRcXHRcXHRtYXggPSBvbmUgPyBpbmRleCArIDEgOiBvcHRpb25zLmxlbmd0aDtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIGluZGV4IDwgMCApIHtcXG5cXHRcXHRcXHRcXHRcXHRpID0gbWF4O1xcblxcblxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0aSA9IG9uZSA/IGluZGV4IDogMDtcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0Ly8gTG9vcCB0aHJvdWdoIGFsbCB0aGUgc2VsZWN0ZWQgb3B0aW9uc1xcblxcdFxcdFxcdFxcdGZvciAoIDsgaSA8IG1heDsgaSsrICkge1xcblxcdFxcdFxcdFxcdFxcdG9wdGlvbiA9IG9wdGlvbnNbIGkgXTtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBTdXBwb3J0OiBJRSA8PTkgb25seVxcblxcdFxcdFxcdFxcdFxcdC8vIElFOC05IGRvZXNuJ3QgdXBkYXRlIHNlbGVjdGVkIGFmdGVyIGZvcm0gcmVzZXQgKCMyNTUxKVxcblxcdFxcdFxcdFxcdFxcdGlmICggKCBvcHRpb24uc2VsZWN0ZWQgfHwgaSA9PT0gaW5kZXggKSAmJlxcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIERvbid0IHJldHVybiBvcHRpb25zIHRoYXQgYXJlIGRpc2FibGVkIG9yIGluIGEgZGlzYWJsZWQgb3B0Z3JvdXBcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQhb3B0aW9uLmRpc2FibGVkICYmXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0KCAhb3B0aW9uLnBhcmVudE5vZGUuZGlzYWJsZWQgfHxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQhbm9kZU5hbWUoIG9wdGlvbi5wYXJlbnROb2RlLCBcXFwib3B0Z3JvdXBcXFwiICkgKSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBHZXQgdGhlIHNwZWNpZmljIHZhbHVlIGZvciB0aGUgb3B0aW9uXFxuXFx0XFx0XFx0XFx0XFx0XFx0dmFsdWUgPSBqUXVlcnkoIG9wdGlvbiApLnZhbCgpO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdC8vIFdlIGRvbid0IG5lZWQgYW4gYXJyYXkgZm9yIG9uZSBzZWxlY3RzXFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBvbmUgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIHZhbHVlO1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBNdWx0aS1TZWxlY3RzIHJldHVybiBhbiBhcnJheVxcblxcdFxcdFxcdFxcdFxcdFxcdHZhbHVlcy5wdXNoKCB2YWx1ZSApO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0cmV0dXJuIHZhbHVlcztcXG5cXHRcXHRcXHR9LFxcblxcblxcdFxcdFxcdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlICkge1xcblxcdFxcdFxcdFxcdHZhciBvcHRpb25TZXQsIG9wdGlvbixcXG5cXHRcXHRcXHRcXHRcXHRvcHRpb25zID0gZWxlbS5vcHRpb25zLFxcblxcdFxcdFxcdFxcdFxcdHZhbHVlcyA9IGpRdWVyeS5tYWtlQXJyYXkoIHZhbHVlICksXFxuXFx0XFx0XFx0XFx0XFx0aSA9IG9wdGlvbnMubGVuZ3RoO1xcblxcblxcdFxcdFxcdFxcdHdoaWxlICggaS0tICkge1xcblxcdFxcdFxcdFxcdFxcdG9wdGlvbiA9IG9wdGlvbnNbIGkgXTtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvKiBlc2xpbnQtZGlzYWJsZSBuby1jb25kLWFzc2lnbiAqL1xcblxcblxcdFxcdFxcdFxcdFxcdGlmICggb3B0aW9uLnNlbGVjdGVkID1cXG5cXHRcXHRcXHRcXHRcXHRcXHRqUXVlcnkuaW5BcnJheSggalF1ZXJ5LnZhbEhvb2tzLm9wdGlvbi5nZXQoIG9wdGlvbiApLCB2YWx1ZXMgKSA+IC0xXFxuXFx0XFx0XFx0XFx0XFx0KSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0b3B0aW9uU2V0ID0gdHJ1ZTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0LyogZXNsaW50LWVuYWJsZSBuby1jb25kLWFzc2lnbiAqL1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHQvLyBGb3JjZSBicm93c2VycyB0byBiZWhhdmUgY29uc2lzdGVudGx5IHdoZW4gbm9uLW1hdGNoaW5nIHZhbHVlIGlzIHNldFxcblxcdFxcdFxcdFxcdGlmICggIW9wdGlvblNldCApIHtcXG5cXHRcXHRcXHRcXHRcXHRlbGVtLnNlbGVjdGVkSW5kZXggPSAtMTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHZhbHVlcztcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcdH1cXG59ICk7XFxuXFxuLy8gUmFkaW9zIGFuZCBjaGVja2JveGVzIGdldHRlci9zZXR0ZXJcXG5qUXVlcnkuZWFjaCggWyBcXFwicmFkaW9cXFwiLCBcXFwiY2hlY2tib3hcXFwiIF0sIGZ1bmN0aW9uKCkge1xcblxcdGpRdWVyeS52YWxIb29rc1sgdGhpcyBdID0ge1xcblxcdFxcdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlICkge1xcblxcdFxcdFxcdGlmICggQXJyYXkuaXNBcnJheSggdmFsdWUgKSApIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gKCBlbGVtLmNoZWNrZWQgPSBqUXVlcnkuaW5BcnJheSggalF1ZXJ5KCBlbGVtICkudmFsKCksIHZhbHVlICkgPiAtMSApO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFx0fTtcXG5cXHRpZiAoICFzdXBwb3J0LmNoZWNrT24gKSB7XFxuXFx0XFx0alF1ZXJ5LnZhbEhvb2tzWyB0aGlzIF0uZ2V0ID0gZnVuY3Rpb24oIGVsZW0gKSB7XFxuXFx0XFx0XFx0cmV0dXJuIGVsZW0uZ2V0QXR0cmlidXRlKCBcXFwidmFsdWVcXFwiICkgPT09IG51bGwgPyBcXFwib25cXFwiIDogZWxlbS52YWx1ZTtcXG5cXHRcXHR9O1xcblxcdH1cXG59ICk7XFxuXFxuXFxuXFxuXFxuLy8gUmV0dXJuIGpRdWVyeSBmb3IgYXR0cmlidXRlcy1vbmx5IGluY2x1c2lvblxcblxcblxcbnN1cHBvcnQuZm9jdXNpbiA9IFxcXCJvbmZvY3VzaW5cXFwiIGluIHdpbmRvdztcXG5cXG5cXG52YXIgcmZvY3VzTW9ycGggPSAvXig/OmZvY3VzaW5mb2N1c3xmb2N1c291dGJsdXIpJC8sXFxuXFx0c3RvcFByb3BhZ2F0aW9uQ2FsbGJhY2sgPSBmdW5jdGlvbiggZSApIHtcXG5cXHRcXHRlLnN0b3BQcm9wYWdhdGlvbigpO1xcblxcdH07XFxuXFxualF1ZXJ5LmV4dGVuZCggalF1ZXJ5LmV2ZW50LCB7XFxuXFxuXFx0dHJpZ2dlcjogZnVuY3Rpb24oIGV2ZW50LCBkYXRhLCBlbGVtLCBvbmx5SGFuZGxlcnMgKSB7XFxuXFxuXFx0XFx0dmFyIGksIGN1ciwgdG1wLCBidWJibGVUeXBlLCBvbnR5cGUsIGhhbmRsZSwgc3BlY2lhbCwgbGFzdEVsZW1lbnQsXFxuXFx0XFx0XFx0ZXZlbnRQYXRoID0gWyBlbGVtIHx8IGRvY3VtZW50IF0sXFxuXFx0XFx0XFx0dHlwZSA9IGhhc093bi5jYWxsKCBldmVudCwgXFxcInR5cGVcXFwiICkgPyBldmVudC50eXBlIDogZXZlbnQsXFxuXFx0XFx0XFx0bmFtZXNwYWNlcyA9IGhhc093bi5jYWxsKCBldmVudCwgXFxcIm5hbWVzcGFjZVxcXCIgKSA/IGV2ZW50Lm5hbWVzcGFjZS5zcGxpdCggXFxcIi5cXFwiICkgOiBbXTtcXG5cXG5cXHRcXHRjdXIgPSBsYXN0RWxlbWVudCA9IHRtcCA9IGVsZW0gPSBlbGVtIHx8IGRvY3VtZW50O1xcblxcblxcdFxcdC8vIERvbid0IGRvIGV2ZW50cyBvbiB0ZXh0IGFuZCBjb21tZW50IG5vZGVzXFxuXFx0XFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAzIHx8IGVsZW0ubm9kZVR5cGUgPT09IDggKSB7XFxuXFx0XFx0XFx0cmV0dXJuO1xcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBmb2N1cy9ibHVyIG1vcnBocyB0byBmb2N1c2luL291dDsgZW5zdXJlIHdlJ3JlIG5vdCBmaXJpbmcgdGhlbSByaWdodCBub3dcXG5cXHRcXHRpZiAoIHJmb2N1c01vcnBoLnRlc3QoIHR5cGUgKyBqUXVlcnkuZXZlbnQudHJpZ2dlcmVkICkgKSB7XFxuXFx0XFx0XFx0cmV0dXJuO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRpZiAoIHR5cGUuaW5kZXhPZiggXFxcIi5cXFwiICkgPiAtMSApIHtcXG5cXG5cXHRcXHRcXHQvLyBOYW1lc3BhY2VkIHRyaWdnZXI7IGNyZWF0ZSBhIHJlZ2V4cCB0byBtYXRjaCBldmVudCB0eXBlIGluIGhhbmRsZSgpXFxuXFx0XFx0XFx0bmFtZXNwYWNlcyA9IHR5cGUuc3BsaXQoIFxcXCIuXFxcIiApO1xcblxcdFxcdFxcdHR5cGUgPSBuYW1lc3BhY2VzLnNoaWZ0KCk7XFxuXFx0XFx0XFx0bmFtZXNwYWNlcy5zb3J0KCk7XFxuXFx0XFx0fVxcblxcdFxcdG9udHlwZSA9IHR5cGUuaW5kZXhPZiggXFxcIjpcXFwiICkgPCAwICYmIFxcXCJvblxcXCIgKyB0eXBlO1xcblxcblxcdFxcdC8vIENhbGxlciBjYW4gcGFzcyBpbiBhIGpRdWVyeS5FdmVudCBvYmplY3QsIE9iamVjdCwgb3IganVzdCBhbiBldmVudCB0eXBlIHN0cmluZ1xcblxcdFxcdGV2ZW50ID0gZXZlbnRbIGpRdWVyeS5leHBhbmRvIF0gP1xcblxcdFxcdFxcdGV2ZW50IDpcXG5cXHRcXHRcXHRuZXcgalF1ZXJ5LkV2ZW50KCB0eXBlLCB0eXBlb2YgZXZlbnQgPT09IFxcXCJvYmplY3RcXFwiICYmIGV2ZW50ICk7XFxuXFxuXFx0XFx0Ly8gVHJpZ2dlciBiaXRtYXNrOiAmIDEgZm9yIG5hdGl2ZSBoYW5kbGVyczsgJiAyIGZvciBqUXVlcnkgKGFsd2F5cyB0cnVlKVxcblxcdFxcdGV2ZW50LmlzVHJpZ2dlciA9IG9ubHlIYW5kbGVycyA/IDIgOiAzO1xcblxcdFxcdGV2ZW50Lm5hbWVzcGFjZSA9IG5hbWVzcGFjZXMuam9pbiggXFxcIi5cXFwiICk7XFxuXFx0XFx0ZXZlbnQucm5hbWVzcGFjZSA9IGV2ZW50Lm5hbWVzcGFjZSA/XFxuXFx0XFx0XFx0bmV3IFJlZ0V4cCggXFxcIihefFxcXFxcXFxcLilcXFwiICsgbmFtZXNwYWNlcy5qb2luKCBcXFwiXFxcXFxcXFwuKD86LipcXFxcXFxcXC58KVxcXCIgKSArIFxcXCIoXFxcXFxcXFwufCQpXFxcIiApIDpcXG5cXHRcXHRcXHRudWxsO1xcblxcblxcdFxcdC8vIENsZWFuIHVwIHRoZSBldmVudCBpbiBjYXNlIGl0IGlzIGJlaW5nIHJldXNlZFxcblxcdFxcdGV2ZW50LnJlc3VsdCA9IHVuZGVmaW5lZDtcXG5cXHRcXHRpZiAoICFldmVudC50YXJnZXQgKSB7XFxuXFx0XFx0XFx0ZXZlbnQudGFyZ2V0ID0gZWxlbTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gQ2xvbmUgYW55IGluY29taW5nIGRhdGEgYW5kIHByZXBlbmQgdGhlIGV2ZW50LCBjcmVhdGluZyB0aGUgaGFuZGxlciBhcmcgbGlzdFxcblxcdFxcdGRhdGEgPSBkYXRhID09IG51bGwgP1xcblxcdFxcdFxcdFsgZXZlbnQgXSA6XFxuXFx0XFx0XFx0alF1ZXJ5Lm1ha2VBcnJheSggZGF0YSwgWyBldmVudCBdICk7XFxuXFxuXFx0XFx0Ly8gQWxsb3cgc3BlY2lhbCBldmVudHMgdG8gZHJhdyBvdXRzaWRlIHRoZSBsaW5lc1xcblxcdFxcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9O1xcblxcdFxcdGlmICggIW9ubHlIYW5kbGVycyAmJiBzcGVjaWFsLnRyaWdnZXIgJiYgc3BlY2lhbC50cmlnZ2VyLmFwcGx5KCBlbGVtLCBkYXRhICkgPT09IGZhbHNlICkge1xcblxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gRGV0ZXJtaW5lIGV2ZW50IHByb3BhZ2F0aW9uIHBhdGggaW4gYWR2YW5jZSwgcGVyIFczQyBldmVudHMgc3BlYyAoIzk5NTEpXFxuXFx0XFx0Ly8gQnViYmxlIHVwIHRvIGRvY3VtZW50LCB0aGVuIHRvIHdpbmRvdzsgd2F0Y2ggZm9yIGEgZ2xvYmFsIG93bmVyRG9jdW1lbnQgdmFyICgjOTcyNClcXG5cXHRcXHRpZiAoICFvbmx5SGFuZGxlcnMgJiYgIXNwZWNpYWwubm9CdWJibGUgJiYgIWlzV2luZG93KCBlbGVtICkgKSB7XFxuXFxuXFx0XFx0XFx0YnViYmxlVHlwZSA9IHNwZWNpYWwuZGVsZWdhdGVUeXBlIHx8IHR5cGU7XFxuXFx0XFx0XFx0aWYgKCAhcmZvY3VzTW9ycGgudGVzdCggYnViYmxlVHlwZSArIHR5cGUgKSApIHtcXG5cXHRcXHRcXHRcXHRjdXIgPSBjdXIucGFyZW50Tm9kZTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0Zm9yICggOyBjdXI7IGN1ciA9IGN1ci5wYXJlbnROb2RlICkge1xcblxcdFxcdFxcdFxcdGV2ZW50UGF0aC5wdXNoKCBjdXIgKTtcXG5cXHRcXHRcXHRcXHR0bXAgPSBjdXI7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIE9ubHkgYWRkIHdpbmRvdyBpZiB3ZSBnb3QgdG8gZG9jdW1lbnQgKGUuZy4sIG5vdCBwbGFpbiBvYmogb3IgZGV0YWNoZWQgRE9NKVxcblxcdFxcdFxcdGlmICggdG1wID09PSAoIGVsZW0ub3duZXJEb2N1bWVudCB8fCBkb2N1bWVudCApICkge1xcblxcdFxcdFxcdFxcdGV2ZW50UGF0aC5wdXNoKCB0bXAuZGVmYXVsdFZpZXcgfHwgdG1wLnBhcmVudFdpbmRvdyB8fCB3aW5kb3cgKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIEZpcmUgaGFuZGxlcnMgb24gdGhlIGV2ZW50IHBhdGhcXG5cXHRcXHRpID0gMDtcXG5cXHRcXHR3aGlsZSAoICggY3VyID0gZXZlbnRQYXRoWyBpKysgXSApICYmICFldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpICkge1xcblxcdFxcdFxcdGxhc3RFbGVtZW50ID0gY3VyO1xcblxcdFxcdFxcdGV2ZW50LnR5cGUgPSBpID4gMSA/XFxuXFx0XFx0XFx0XFx0YnViYmxlVHlwZSA6XFxuXFx0XFx0XFx0XFx0c3BlY2lhbC5iaW5kVHlwZSB8fCB0eXBlO1xcblxcblxcdFxcdFxcdC8vIGpRdWVyeSBoYW5kbGVyXFxuXFx0XFx0XFx0aGFuZGxlID0gKCBkYXRhUHJpdi5nZXQoIGN1ciwgXFxcImV2ZW50c1xcXCIgKSB8fCB7fSApWyBldmVudC50eXBlIF0gJiZcXG5cXHRcXHRcXHRcXHRkYXRhUHJpdi5nZXQoIGN1ciwgXFxcImhhbmRsZVxcXCIgKTtcXG5cXHRcXHRcXHRpZiAoIGhhbmRsZSApIHtcXG5cXHRcXHRcXHRcXHRoYW5kbGUuYXBwbHkoIGN1ciwgZGF0YSApO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBOYXRpdmUgaGFuZGxlclxcblxcdFxcdFxcdGhhbmRsZSA9IG9udHlwZSAmJiBjdXJbIG9udHlwZSBdO1xcblxcdFxcdFxcdGlmICggaGFuZGxlICYmIGhhbmRsZS5hcHBseSAmJiBhY2NlcHREYXRhKCBjdXIgKSApIHtcXG5cXHRcXHRcXHRcXHRldmVudC5yZXN1bHQgPSBoYW5kbGUuYXBwbHkoIGN1ciwgZGF0YSApO1xcblxcdFxcdFxcdFxcdGlmICggZXZlbnQucmVzdWx0ID09PSBmYWxzZSApIHtcXG5cXHRcXHRcXHRcXHRcXHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcdFxcdGV2ZW50LnR5cGUgPSB0eXBlO1xcblxcblxcdFxcdC8vIElmIG5vYm9keSBwcmV2ZW50ZWQgdGhlIGRlZmF1bHQgYWN0aW9uLCBkbyBpdCBub3dcXG5cXHRcXHRpZiAoICFvbmx5SGFuZGxlcnMgJiYgIWV2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpICkge1xcblxcblxcdFxcdFxcdGlmICggKCAhc3BlY2lhbC5fZGVmYXVsdCB8fFxcblxcdFxcdFxcdFxcdHNwZWNpYWwuX2RlZmF1bHQuYXBwbHkoIGV2ZW50UGF0aC5wb3AoKSwgZGF0YSApID09PSBmYWxzZSApICYmXFxuXFx0XFx0XFx0XFx0YWNjZXB0RGF0YSggZWxlbSApICkge1xcblxcblxcdFxcdFxcdFxcdC8vIENhbGwgYSBuYXRpdmUgRE9NIG1ldGhvZCBvbiB0aGUgdGFyZ2V0IHdpdGggdGhlIHNhbWUgbmFtZSBhcyB0aGUgZXZlbnQuXFxuXFx0XFx0XFx0XFx0Ly8gRG9uJ3QgZG8gZGVmYXVsdCBhY3Rpb25zIG9uIHdpbmRvdywgdGhhdCdzIHdoZXJlIGdsb2JhbCB2YXJpYWJsZXMgYmUgKCM2MTcwKVxcblxcdFxcdFxcdFxcdGlmICggb250eXBlICYmIGlzRnVuY3Rpb24oIGVsZW1bIHR5cGUgXSApICYmICFpc1dpbmRvdyggZWxlbSApICkge1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIERvbid0IHJlLXRyaWdnZXIgYW4gb25GT08gZXZlbnQgd2hlbiB3ZSBjYWxsIGl0cyBGT08oKSBtZXRob2RcXG5cXHRcXHRcXHRcXHRcXHR0bXAgPSBlbGVtWyBvbnR5cGUgXTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRpZiAoIHRtcCApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRlbGVtWyBvbnR5cGUgXSA9IG51bGw7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdC8vIFByZXZlbnQgcmUtdHJpZ2dlcmluZyBvZiB0aGUgc2FtZSBldmVudCwgc2luY2Ugd2UgYWxyZWFkeSBidWJibGVkIGl0IGFib3ZlXFxuXFx0XFx0XFx0XFx0XFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXJlZCA9IHR5cGU7XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGxhc3RFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoIHR5cGUsIHN0b3BQcm9wYWdhdGlvbkNhbGxiYWNrICk7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdGVsZW1bIHR5cGUgXSgpO1xcblxcblxcdFxcdFxcdFxcdFxcdGlmICggZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRsYXN0RWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCB0eXBlLCBzdG9wUHJvcGFnYXRpb25DYWxsYmFjayApO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRqUXVlcnkuZXZlbnQudHJpZ2dlcmVkID0gdW5kZWZpbmVkO1xcblxcblxcdFxcdFxcdFxcdFxcdGlmICggdG1wICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGVsZW1bIG9udHlwZSBdID0gdG1wO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXG5cXHRcXHRyZXR1cm4gZXZlbnQucmVzdWx0O1xcblxcdH0sXFxuXFxuXFx0Ly8gUGlnZ3liYWNrIG9uIGEgZG9ub3IgZXZlbnQgdG8gc2ltdWxhdGUgYSBkaWZmZXJlbnQgb25lXFxuXFx0Ly8gVXNlZCBvbmx5IGZvciBgZm9jdXMoaW4gfCBvdXQpYCBldmVudHNcXG5cXHRzaW11bGF0ZTogZnVuY3Rpb24oIHR5cGUsIGVsZW0sIGV2ZW50ICkge1xcblxcdFxcdHZhciBlID0galF1ZXJ5LmV4dGVuZChcXG5cXHRcXHRcXHRuZXcgalF1ZXJ5LkV2ZW50KCksXFxuXFx0XFx0XFx0ZXZlbnQsXFxuXFx0XFx0XFx0e1xcblxcdFxcdFxcdFxcdHR5cGU6IHR5cGUsXFxuXFx0XFx0XFx0XFx0aXNTaW11bGF0ZWQ6IHRydWVcXG5cXHRcXHRcXHR9XFxuXFx0XFx0KTtcXG5cXG5cXHRcXHRqUXVlcnkuZXZlbnQudHJpZ2dlciggZSwgbnVsbCwgZWxlbSApO1xcblxcdH1cXG5cXG59ICk7XFxuXFxualF1ZXJ5LmZuLmV4dGVuZCgge1xcblxcblxcdHRyaWdnZXI6IGZ1bmN0aW9uKCB0eXBlLCBkYXRhICkge1xcblxcdFxcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdGpRdWVyeS5ldmVudC50cmlnZ2VyKCB0eXBlLCBkYXRhLCB0aGlzICk7XFxuXFx0XFx0fSApO1xcblxcdH0sXFxuXFx0dHJpZ2dlckhhbmRsZXI6IGZ1bmN0aW9uKCB0eXBlLCBkYXRhICkge1xcblxcdFxcdHZhciBlbGVtID0gdGhpc1sgMCBdO1xcblxcdFxcdGlmICggZWxlbSApIHtcXG5cXHRcXHRcXHRyZXR1cm4galF1ZXJ5LmV2ZW50LnRyaWdnZXIoIHR5cGUsIGRhdGEsIGVsZW0sIHRydWUgKTtcXG5cXHRcXHR9XFxuXFx0fVxcbn0gKTtcXG5cXG5cXG4vLyBTdXBwb3J0OiBGaXJlZm94IDw9NDRcXG4vLyBGaXJlZm94IGRvZXNuJ3QgaGF2ZSBmb2N1cyhpbiB8IG91dCkgZXZlbnRzXFxuLy8gUmVsYXRlZCB0aWNrZXQgLSBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02ODc3ODdcXG4vL1xcbi8vIFN1cHBvcnQ6IENocm9tZSA8PTQ4IC0gNDksIFNhZmFyaSA8PTkuMCAtIDkuMVxcbi8vIGZvY3VzKGluIHwgb3V0KSBldmVudHMgZmlyZSBhZnRlciBmb2N1cyAmIGJsdXIgZXZlbnRzLFxcbi8vIHdoaWNoIGlzIHNwZWMgdmlvbGF0aW9uIC0gaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzLyNldmVudHMtZm9jdXNldmVudC1ldmVudC1vcmRlclxcbi8vIFJlbGF0ZWQgdGlja2V0IC0gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NDQ5ODU3XFxuaWYgKCAhc3VwcG9ydC5mb2N1c2luICkge1xcblxcdGpRdWVyeS5lYWNoKCB7IGZvY3VzOiBcXFwiZm9jdXNpblxcXCIsIGJsdXI6IFxcXCJmb2N1c291dFxcXCIgfSwgZnVuY3Rpb24oIG9yaWcsIGZpeCApIHtcXG5cXG5cXHRcXHQvLyBBdHRhY2ggYSBzaW5nbGUgY2FwdHVyaW5nIGhhbmRsZXIgb24gdGhlIGRvY3VtZW50IHdoaWxlIHNvbWVvbmUgd2FudHMgZm9jdXNpbi9mb2N1c291dFxcblxcdFxcdHZhciBoYW5kbGVyID0gZnVuY3Rpb24oIGV2ZW50ICkge1xcblxcdFxcdFxcdGpRdWVyeS5ldmVudC5zaW11bGF0ZSggZml4LCBldmVudC50YXJnZXQsIGpRdWVyeS5ldmVudC5maXgoIGV2ZW50ICkgKTtcXG5cXHRcXHR9O1xcblxcblxcdFxcdGpRdWVyeS5ldmVudC5zcGVjaWFsWyBmaXggXSA9IHtcXG5cXHRcXHRcXHRzZXR1cDogZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0XFx0dmFyIGRvYyA9IHRoaXMub3duZXJEb2N1bWVudCB8fCB0aGlzLFxcblxcdFxcdFxcdFxcdFxcdGF0dGFjaGVzID0gZGF0YVByaXYuYWNjZXNzKCBkb2MsIGZpeCApO1xcblxcblxcdFxcdFxcdFxcdGlmICggIWF0dGFjaGVzICkge1xcblxcdFxcdFxcdFxcdFxcdGRvYy5hZGRFdmVudExpc3RlbmVyKCBvcmlnLCBoYW5kbGVyLCB0cnVlICk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdGRhdGFQcml2LmFjY2VzcyggZG9jLCBmaXgsICggYXR0YWNoZXMgfHwgMCApICsgMSApO1xcblxcdFxcdFxcdH0sXFxuXFx0XFx0XFx0dGVhcmRvd246IGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdFxcdHZhciBkb2MgPSB0aGlzLm93bmVyRG9jdW1lbnQgfHwgdGhpcyxcXG5cXHRcXHRcXHRcXHRcXHRhdHRhY2hlcyA9IGRhdGFQcml2LmFjY2VzcyggZG9jLCBmaXggKSAtIDE7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCAhYXR0YWNoZXMgKSB7XFxuXFx0XFx0XFx0XFx0XFx0ZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoIG9yaWcsIGhhbmRsZXIsIHRydWUgKTtcXG5cXHRcXHRcXHRcXHRcXHRkYXRhUHJpdi5yZW1vdmUoIGRvYywgZml4ICk7XFxuXFxuXFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHRkYXRhUHJpdi5hY2Nlc3MoIGRvYywgZml4LCBhdHRhY2hlcyApO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0fTtcXG5cXHR9ICk7XFxufVxcbnZhciBsb2NhdGlvbiA9IHdpbmRvdy5sb2NhdGlvbjtcXG5cXG52YXIgbm9uY2UgPSBEYXRlLm5vdygpO1xcblxcbnZhciBycXVlcnkgPSAoIC9cXFxcPy8gKTtcXG5cXG5cXG5cXG4vLyBDcm9zcy1icm93c2VyIHhtbCBwYXJzaW5nXFxualF1ZXJ5LnBhcnNlWE1MID0gZnVuY3Rpb24oIGRhdGEgKSB7XFxuXFx0dmFyIHhtbDtcXG5cXHRpZiAoICFkYXRhIHx8IHR5cGVvZiBkYXRhICE9PSBcXFwic3RyaW5nXFxcIiApIHtcXG5cXHRcXHRyZXR1cm4gbnVsbDtcXG5cXHR9XFxuXFxuXFx0Ly8gU3VwcG9ydDogSUUgOSAtIDExIG9ubHlcXG5cXHQvLyBJRSB0aHJvd3Mgb24gcGFyc2VGcm9tU3RyaW5nIHdpdGggaW52YWxpZCBpbnB1dC5cXG5cXHR0cnkge1xcblxcdFxcdHhtbCA9ICggbmV3IHdpbmRvdy5ET01QYXJzZXIoKSApLnBhcnNlRnJvbVN0cmluZyggZGF0YSwgXFxcInRleHQveG1sXFxcIiApO1xcblxcdH0gY2F0Y2ggKCBlICkge1xcblxcdFxcdHhtbCA9IHVuZGVmaW5lZDtcXG5cXHR9XFxuXFxuXFx0aWYgKCAheG1sIHx8IHhtbC5nZXRFbGVtZW50c0J5VGFnTmFtZSggXFxcInBhcnNlcmVycm9yXFxcIiApLmxlbmd0aCApIHtcXG5cXHRcXHRqUXVlcnkuZXJyb3IoIFxcXCJJbnZhbGlkIFhNTDogXFxcIiArIGRhdGEgKTtcXG5cXHR9XFxuXFx0cmV0dXJuIHhtbDtcXG59O1xcblxcblxcbnZhclxcblxcdHJicmFja2V0ID0gL1xcXFxbXFxcXF0kLyxcXG5cXHRyQ1JMRiA9IC9cXFxccj9cXFxcbi9nLFxcblxcdHJzdWJtaXR0ZXJUeXBlcyA9IC9eKD86c3VibWl0fGJ1dHRvbnxpbWFnZXxyZXNldHxmaWxlKSQvaSxcXG5cXHRyc3VibWl0dGFibGUgPSAvXig/OmlucHV0fHNlbGVjdHx0ZXh0YXJlYXxrZXlnZW4pL2k7XFxuXFxuZnVuY3Rpb24gYnVpbGRQYXJhbXMoIHByZWZpeCwgb2JqLCB0cmFkaXRpb25hbCwgYWRkICkge1xcblxcdHZhciBuYW1lO1xcblxcblxcdGlmICggQXJyYXkuaXNBcnJheSggb2JqICkgKSB7XFxuXFxuXFx0XFx0Ly8gU2VyaWFsaXplIGFycmF5IGl0ZW0uXFxuXFx0XFx0alF1ZXJ5LmVhY2goIG9iaiwgZnVuY3Rpb24oIGksIHYgKSB7XFxuXFx0XFx0XFx0aWYgKCB0cmFkaXRpb25hbCB8fCByYnJhY2tldC50ZXN0KCBwcmVmaXggKSApIHtcXG5cXG5cXHRcXHRcXHRcXHQvLyBUcmVhdCBlYWNoIGFycmF5IGl0ZW0gYXMgYSBzY2FsYXIuXFxuXFx0XFx0XFx0XFx0YWRkKCBwcmVmaXgsIHYgKTtcXG5cXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdC8vIEl0ZW0gaXMgbm9uLXNjYWxhciAoYXJyYXkgb3Igb2JqZWN0KSwgZW5jb2RlIGl0cyBudW1lcmljIGluZGV4LlxcblxcdFxcdFxcdFxcdGJ1aWxkUGFyYW1zKFxcblxcdFxcdFxcdFxcdFxcdHByZWZpeCArIFxcXCJbXFxcIiArICggdHlwZW9mIHYgPT09IFxcXCJvYmplY3RcXFwiICYmIHYgIT0gbnVsbCA/IGkgOiBcXFwiXFxcIiApICsgXFxcIl1cXFwiLFxcblxcdFxcdFxcdFxcdFxcdHYsXFxuXFx0XFx0XFx0XFx0XFx0dHJhZGl0aW9uYWwsXFxuXFx0XFx0XFx0XFx0XFx0YWRkXFxuXFx0XFx0XFx0XFx0KTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSApO1xcblxcblxcdH0gZWxzZSBpZiAoICF0cmFkaXRpb25hbCAmJiB0b1R5cGUoIG9iaiApID09PSBcXFwib2JqZWN0XFxcIiApIHtcXG5cXG5cXHRcXHQvLyBTZXJpYWxpemUgb2JqZWN0IGl0ZW0uXFxuXFx0XFx0Zm9yICggbmFtZSBpbiBvYmogKSB7XFxuXFx0XFx0XFx0YnVpbGRQYXJhbXMoIHByZWZpeCArIFxcXCJbXFxcIiArIG5hbWUgKyBcXFwiXVxcXCIsIG9ialsgbmFtZSBdLCB0cmFkaXRpb25hbCwgYWRkICk7XFxuXFx0XFx0fVxcblxcblxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0Ly8gU2VyaWFsaXplIHNjYWxhciBpdGVtLlxcblxcdFxcdGFkZCggcHJlZml4LCBvYmogKTtcXG5cXHR9XFxufVxcblxcbi8vIFNlcmlhbGl6ZSBhbiBhcnJheSBvZiBmb3JtIGVsZW1lbnRzIG9yIGEgc2V0IG9mXFxuLy8ga2V5L3ZhbHVlcyBpbnRvIGEgcXVlcnkgc3RyaW5nXFxualF1ZXJ5LnBhcmFtID0gZnVuY3Rpb24oIGEsIHRyYWRpdGlvbmFsICkge1xcblxcdHZhciBwcmVmaXgsXFxuXFx0XFx0cyA9IFtdLFxcblxcdFxcdGFkZCA9IGZ1bmN0aW9uKCBrZXksIHZhbHVlT3JGdW5jdGlvbiApIHtcXG5cXG5cXHRcXHRcXHQvLyBJZiB2YWx1ZSBpcyBhIGZ1bmN0aW9uLCBpbnZva2UgaXQgYW5kIHVzZSBpdHMgcmV0dXJuIHZhbHVlXFxuXFx0XFx0XFx0dmFyIHZhbHVlID0gaXNGdW5jdGlvbiggdmFsdWVPckZ1bmN0aW9uICkgP1xcblxcdFxcdFxcdFxcdHZhbHVlT3JGdW5jdGlvbigpIDpcXG5cXHRcXHRcXHRcXHR2YWx1ZU9yRnVuY3Rpb247XFxuXFxuXFx0XFx0XFx0c1sgcy5sZW5ndGggXSA9IGVuY29kZVVSSUNvbXBvbmVudCgga2V5ICkgKyBcXFwiPVxcXCIgK1xcblxcdFxcdFxcdFxcdGVuY29kZVVSSUNvbXBvbmVudCggdmFsdWUgPT0gbnVsbCA/IFxcXCJcXFwiIDogdmFsdWUgKTtcXG5cXHRcXHR9O1xcblxcblxcdC8vIElmIGFuIGFycmF5IHdhcyBwYXNzZWQgaW4sIGFzc3VtZSB0aGF0IGl0IGlzIGFuIGFycmF5IG9mIGZvcm0gZWxlbWVudHMuXFxuXFx0aWYgKCBBcnJheS5pc0FycmF5KCBhICkgfHwgKCBhLmpxdWVyeSAmJiAhalF1ZXJ5LmlzUGxhaW5PYmplY3QoIGEgKSApICkge1xcblxcblxcdFxcdC8vIFNlcmlhbGl6ZSB0aGUgZm9ybSBlbGVtZW50c1xcblxcdFxcdGpRdWVyeS5lYWNoKCBhLCBmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHRhZGQoIHRoaXMubmFtZSwgdGhpcy52YWx1ZSApO1xcblxcdFxcdH0gKTtcXG5cXG5cXHR9IGVsc2Uge1xcblxcblxcdFxcdC8vIElmIHRyYWRpdGlvbmFsLCBlbmNvZGUgdGhlIFxcXCJvbGRcXFwiIHdheSAodGhlIHdheSAxLjMuMiBvciBvbGRlclxcblxcdFxcdC8vIGRpZCBpdCksIG90aGVyd2lzZSBlbmNvZGUgcGFyYW1zIHJlY3Vyc2l2ZWx5LlxcblxcdFxcdGZvciAoIHByZWZpeCBpbiBhICkge1xcblxcdFxcdFxcdGJ1aWxkUGFyYW1zKCBwcmVmaXgsIGFbIHByZWZpeCBdLCB0cmFkaXRpb25hbCwgYWRkICk7XFxuXFx0XFx0fVxcblxcdH1cXG5cXG5cXHQvLyBSZXR1cm4gdGhlIHJlc3VsdGluZyBzZXJpYWxpemF0aW9uXFxuXFx0cmV0dXJuIHMuam9pbiggXFxcIiZcXFwiICk7XFxufTtcXG5cXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XFxuXFx0c2VyaWFsaXplOiBmdW5jdGlvbigpIHtcXG5cXHRcXHRyZXR1cm4galF1ZXJ5LnBhcmFtKCB0aGlzLnNlcmlhbGl6ZUFycmF5KCkgKTtcXG5cXHR9LFxcblxcdHNlcmlhbGl6ZUFycmF5OiBmdW5jdGlvbigpIHtcXG5cXHRcXHRyZXR1cm4gdGhpcy5tYXAoIGZ1bmN0aW9uKCkge1xcblxcblxcdFxcdFxcdC8vIENhbiBhZGQgcHJvcEhvb2sgZm9yIFxcXCJlbGVtZW50c1xcXCIgdG8gZmlsdGVyIG9yIGFkZCBmb3JtIGVsZW1lbnRzXFxuXFx0XFx0XFx0dmFyIGVsZW1lbnRzID0galF1ZXJ5LnByb3AoIHRoaXMsIFxcXCJlbGVtZW50c1xcXCIgKTtcXG5cXHRcXHRcXHRyZXR1cm4gZWxlbWVudHMgPyBqUXVlcnkubWFrZUFycmF5KCBlbGVtZW50cyApIDogdGhpcztcXG5cXHRcXHR9IClcXG5cXHRcXHQuZmlsdGVyKCBmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHR2YXIgdHlwZSA9IHRoaXMudHlwZTtcXG5cXG5cXHRcXHRcXHQvLyBVc2UgLmlzKCBcXFwiOmRpc2FibGVkXFxcIiApIHNvIHRoYXQgZmllbGRzZXRbZGlzYWJsZWRdIHdvcmtzXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMubmFtZSAmJiAhalF1ZXJ5KCB0aGlzICkuaXMoIFxcXCI6ZGlzYWJsZWRcXFwiICkgJiZcXG5cXHRcXHRcXHRcXHRyc3VibWl0dGFibGUudGVzdCggdGhpcy5ub2RlTmFtZSApICYmICFyc3VibWl0dGVyVHlwZXMudGVzdCggdHlwZSApICYmXFxuXFx0XFx0XFx0XFx0KCB0aGlzLmNoZWNrZWQgfHwgIXJjaGVja2FibGVUeXBlLnRlc3QoIHR5cGUgKSApO1xcblxcdFxcdH0gKVxcblxcdFxcdC5tYXAoIGZ1bmN0aW9uKCBpLCBlbGVtICkge1xcblxcdFxcdFxcdHZhciB2YWwgPSBqUXVlcnkoIHRoaXMgKS52YWwoKTtcXG5cXG5cXHRcXHRcXHRpZiAoIHZhbCA9PSBudWxsICkge1xcblxcdFxcdFxcdFxcdHJldHVybiBudWxsO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpZiAoIEFycmF5LmlzQXJyYXkoIHZhbCApICkge1xcblxcdFxcdFxcdFxcdHJldHVybiBqUXVlcnkubWFwKCB2YWwsIGZ1bmN0aW9uKCB2YWwgKSB7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIHsgbmFtZTogZWxlbS5uYW1lLCB2YWx1ZTogdmFsLnJlcGxhY2UoIHJDUkxGLCBcXFwiXFxcXHJcXFxcblxcXCIgKSB9O1xcblxcdFxcdFxcdFxcdH0gKTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHsgbmFtZTogZWxlbS5uYW1lLCB2YWx1ZTogdmFsLnJlcGxhY2UoIHJDUkxGLCBcXFwiXFxcXHJcXFxcblxcXCIgKSB9O1xcblxcdFxcdH0gKS5nZXQoKTtcXG5cXHR9XFxufSApO1xcblxcblxcbnZhclxcblxcdHIyMCA9IC8lMjAvZyxcXG5cXHRyaGFzaCA9IC8jLiokLyxcXG5cXHRyYW50aUNhY2hlID0gLyhbPyZdKV89W14mXSovLFxcblxcdHJoZWFkZXJzID0gL14oLio/KTpbIFxcXFx0XSooW15cXFxcclxcXFxuXSopJC9tZyxcXG5cXG5cXHQvLyAjNzY1MywgIzgxMjUsICM4MTUyOiBsb2NhbCBwcm90b2NvbCBkZXRlY3Rpb25cXG5cXHRybG9jYWxQcm90b2NvbCA9IC9eKD86YWJvdXR8YXBwfGFwcC1zdG9yYWdlfC4rLWV4dGVuc2lvbnxmaWxlfHJlc3x3aWRnZXQpOiQvLFxcblxcdHJub0NvbnRlbnQgPSAvXig/OkdFVHxIRUFEKSQvLFxcblxcdHJwcm90b2NvbCA9IC9eXFxcXC9cXFxcLy8sXFxuXFxuXFx0LyogUHJlZmlsdGVyc1xcblxcdCAqIDEpIFRoZXkgYXJlIHVzZWZ1bCB0byBpbnRyb2R1Y2UgY3VzdG9tIGRhdGFUeXBlcyAoc2VlIGFqYXgvanNvbnAuanMgZm9yIGFuIGV4YW1wbGUpXFxuXFx0ICogMikgVGhlc2UgYXJlIGNhbGxlZDpcXG5cXHQgKiAgICAtIEJFRk9SRSBhc2tpbmcgZm9yIGEgdHJhbnNwb3J0XFxuXFx0ICogICAgLSBBRlRFUiBwYXJhbSBzZXJpYWxpemF0aW9uIChzLmRhdGEgaXMgYSBzdHJpbmcgaWYgcy5wcm9jZXNzRGF0YSBpcyB0cnVlKVxcblxcdCAqIDMpIGtleSBpcyB0aGUgZGF0YVR5cGVcXG5cXHQgKiA0KSB0aGUgY2F0Y2hhbGwgc3ltYm9sIFxcXCIqXFxcIiBjYW4gYmUgdXNlZFxcblxcdCAqIDUpIGV4ZWN1dGlvbiB3aWxsIHN0YXJ0IHdpdGggdHJhbnNwb3J0IGRhdGFUeXBlIGFuZCBUSEVOIGNvbnRpbnVlIGRvd24gdG8gXFxcIipcXFwiIGlmIG5lZWRlZFxcblxcdCAqL1xcblxcdHByZWZpbHRlcnMgPSB7fSxcXG5cXG5cXHQvKiBUcmFuc3BvcnRzIGJpbmRpbmdzXFxuXFx0ICogMSkga2V5IGlzIHRoZSBkYXRhVHlwZVxcblxcdCAqIDIpIHRoZSBjYXRjaGFsbCBzeW1ib2wgXFxcIipcXFwiIGNhbiBiZSB1c2VkXFxuXFx0ICogMykgc2VsZWN0aW9uIHdpbGwgc3RhcnQgd2l0aCB0cmFuc3BvcnQgZGF0YVR5cGUgYW5kIFRIRU4gZ28gdG8gXFxcIipcXFwiIGlmIG5lZWRlZFxcblxcdCAqL1xcblxcdHRyYW5zcG9ydHMgPSB7fSxcXG5cXG5cXHQvLyBBdm9pZCBjb21tZW50LXByb2xvZyBjaGFyIHNlcXVlbmNlICgjMTAwOTgpOyBtdXN0IGFwcGVhc2UgbGludCBhbmQgZXZhZGUgY29tcHJlc3Npb25cXG5cXHRhbGxUeXBlcyA9IFxcXCIqL1xcXCIuY29uY2F0KCBcXFwiKlxcXCIgKSxcXG5cXG5cXHQvLyBBbmNob3IgdGFnIGZvciBwYXJzaW5nIHRoZSBkb2N1bWVudCBvcmlnaW5cXG5cXHRvcmlnaW5BbmNob3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcXFwiYVxcXCIgKTtcXG5cXHRvcmlnaW5BbmNob3IuaHJlZiA9IGxvY2F0aW9uLmhyZWY7XFxuXFxuLy8gQmFzZSBcXFwiY29uc3RydWN0b3JcXFwiIGZvciBqUXVlcnkuYWpheFByZWZpbHRlciBhbmQgalF1ZXJ5LmFqYXhUcmFuc3BvcnRcXG5mdW5jdGlvbiBhZGRUb1ByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHN0cnVjdHVyZSApIHtcXG5cXG5cXHQvLyBkYXRhVHlwZUV4cHJlc3Npb24gaXMgb3B0aW9uYWwgYW5kIGRlZmF1bHRzIHRvIFxcXCIqXFxcIlxcblxcdHJldHVybiBmdW5jdGlvbiggZGF0YVR5cGVFeHByZXNzaW9uLCBmdW5jICkge1xcblxcblxcdFxcdGlmICggdHlwZW9mIGRhdGFUeXBlRXhwcmVzc2lvbiAhPT0gXFxcInN0cmluZ1xcXCIgKSB7XFxuXFx0XFx0XFx0ZnVuYyA9IGRhdGFUeXBlRXhwcmVzc2lvbjtcXG5cXHRcXHRcXHRkYXRhVHlwZUV4cHJlc3Npb24gPSBcXFwiKlxcXCI7XFxuXFx0XFx0fVxcblxcblxcdFxcdHZhciBkYXRhVHlwZSxcXG5cXHRcXHRcXHRpID0gMCxcXG5cXHRcXHRcXHRkYXRhVHlwZXMgPSBkYXRhVHlwZUV4cHJlc3Npb24udG9Mb3dlckNhc2UoKS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFtdO1xcblxcblxcdFxcdGlmICggaXNGdW5jdGlvbiggZnVuYyApICkge1xcblxcblxcdFxcdFxcdC8vIEZvciBlYWNoIGRhdGFUeXBlIGluIHRoZSBkYXRhVHlwZUV4cHJlc3Npb25cXG5cXHRcXHRcXHR3aGlsZSAoICggZGF0YVR5cGUgPSBkYXRhVHlwZXNbIGkrKyBdICkgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gUHJlcGVuZCBpZiByZXF1ZXN0ZWRcXG5cXHRcXHRcXHRcXHRpZiAoIGRhdGFUeXBlWyAwIF0gPT09IFxcXCIrXFxcIiApIHtcXG5cXHRcXHRcXHRcXHRcXHRkYXRhVHlwZSA9IGRhdGFUeXBlLnNsaWNlKCAxICkgfHwgXFxcIipcXFwiO1xcblxcdFxcdFxcdFxcdFxcdCggc3RydWN0dXJlWyBkYXRhVHlwZSBdID0gc3RydWN0dXJlWyBkYXRhVHlwZSBdIHx8IFtdICkudW5zaGlmdCggZnVuYyApO1xcblxcblxcdFxcdFxcdFxcdC8vIE90aGVyd2lzZSBhcHBlbmRcXG5cXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdCggc3RydWN0dXJlWyBkYXRhVHlwZSBdID0gc3RydWN0dXJlWyBkYXRhVHlwZSBdIHx8IFtdICkucHVzaCggZnVuYyApO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcdH07XFxufVxcblxcbi8vIEJhc2UgaW5zcGVjdGlvbiBmdW5jdGlvbiBmb3IgcHJlZmlsdGVycyBhbmQgdHJhbnNwb3J0c1xcbmZ1bmN0aW9uIGluc3BlY3RQcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCBzdHJ1Y3R1cmUsIG9wdGlvbnMsIG9yaWdpbmFsT3B0aW9ucywganFYSFIgKSB7XFxuXFxuXFx0dmFyIGluc3BlY3RlZCA9IHt9LFxcblxcdFxcdHNlZWtpbmdUcmFuc3BvcnQgPSAoIHN0cnVjdHVyZSA9PT0gdHJhbnNwb3J0cyApO1xcblxcblxcdGZ1bmN0aW9uIGluc3BlY3QoIGRhdGFUeXBlICkge1xcblxcdFxcdHZhciBzZWxlY3RlZDtcXG5cXHRcXHRpbnNwZWN0ZWRbIGRhdGFUeXBlIF0gPSB0cnVlO1xcblxcdFxcdGpRdWVyeS5lYWNoKCBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gfHwgW10sIGZ1bmN0aW9uKCBfLCBwcmVmaWx0ZXJPckZhY3RvcnkgKSB7XFxuXFx0XFx0XFx0dmFyIGRhdGFUeXBlT3JUcmFuc3BvcnQgPSBwcmVmaWx0ZXJPckZhY3RvcnkoIG9wdGlvbnMsIG9yaWdpbmFsT3B0aW9ucywganFYSFIgKTtcXG5cXHRcXHRcXHRpZiAoIHR5cGVvZiBkYXRhVHlwZU9yVHJhbnNwb3J0ID09PSBcXFwic3RyaW5nXFxcIiAmJlxcblxcdFxcdFxcdFxcdCFzZWVraW5nVHJhbnNwb3J0ICYmICFpbnNwZWN0ZWRbIGRhdGFUeXBlT3JUcmFuc3BvcnQgXSApIHtcXG5cXG5cXHRcXHRcXHRcXHRvcHRpb25zLmRhdGFUeXBlcy51bnNoaWZ0KCBkYXRhVHlwZU9yVHJhbnNwb3J0ICk7XFxuXFx0XFx0XFx0XFx0aW5zcGVjdCggZGF0YVR5cGVPclRyYW5zcG9ydCApO1xcblxcdFxcdFxcdFxcdHJldHVybiBmYWxzZTtcXG5cXHRcXHRcXHR9IGVsc2UgaWYgKCBzZWVraW5nVHJhbnNwb3J0ICkge1xcblxcdFxcdFxcdFxcdHJldHVybiAhKCBzZWxlY3RlZCA9IGRhdGFUeXBlT3JUcmFuc3BvcnQgKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSApO1xcblxcdFxcdHJldHVybiBzZWxlY3RlZDtcXG5cXHR9XFxuXFxuXFx0cmV0dXJuIGluc3BlY3QoIG9wdGlvbnMuZGF0YVR5cGVzWyAwIF0gKSB8fCAhaW5zcGVjdGVkWyBcXFwiKlxcXCIgXSAmJiBpbnNwZWN0KCBcXFwiKlxcXCIgKTtcXG59XFxuXFxuLy8gQSBzcGVjaWFsIGV4dGVuZCBmb3IgYWpheCBvcHRpb25zXFxuLy8gdGhhdCB0YWtlcyBcXFwiZmxhdFxcXCIgb3B0aW9ucyAobm90IHRvIGJlIGRlZXAgZXh0ZW5kZWQpXFxuLy8gRml4ZXMgIzk4ODdcXG5mdW5jdGlvbiBhamF4RXh0ZW5kKCB0YXJnZXQsIHNyYyApIHtcXG5cXHR2YXIga2V5LCBkZWVwLFxcblxcdFxcdGZsYXRPcHRpb25zID0galF1ZXJ5LmFqYXhTZXR0aW5ncy5mbGF0T3B0aW9ucyB8fCB7fTtcXG5cXG5cXHRmb3IgKCBrZXkgaW4gc3JjICkge1xcblxcdFxcdGlmICggc3JjWyBrZXkgXSAhPT0gdW5kZWZpbmVkICkge1xcblxcdFxcdFxcdCggZmxhdE9wdGlvbnNbIGtleSBdID8gdGFyZ2V0IDogKCBkZWVwIHx8ICggZGVlcCA9IHt9ICkgKSApWyBrZXkgXSA9IHNyY1sga2V5IF07XFxuXFx0XFx0fVxcblxcdH1cXG5cXHRpZiAoIGRlZXAgKSB7XFxuXFx0XFx0alF1ZXJ5LmV4dGVuZCggdHJ1ZSwgdGFyZ2V0LCBkZWVwICk7XFxuXFx0fVxcblxcblxcdHJldHVybiB0YXJnZXQ7XFxufVxcblxcbi8qIEhhbmRsZXMgcmVzcG9uc2VzIHRvIGFuIGFqYXggcmVxdWVzdDpcXG4gKiAtIGZpbmRzIHRoZSByaWdodCBkYXRhVHlwZSAobWVkaWF0ZXMgYmV0d2VlbiBjb250ZW50LXR5cGUgYW5kIGV4cGVjdGVkIGRhdGFUeXBlKVxcbiAqIC0gcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyByZXNwb25zZVxcbiAqL1xcbmZ1bmN0aW9uIGFqYXhIYW5kbGVSZXNwb25zZXMoIHMsIGpxWEhSLCByZXNwb25zZXMgKSB7XFxuXFxuXFx0dmFyIGN0LCB0eXBlLCBmaW5hbERhdGFUeXBlLCBmaXJzdERhdGFUeXBlLFxcblxcdFxcdGNvbnRlbnRzID0gcy5jb250ZW50cyxcXG5cXHRcXHRkYXRhVHlwZXMgPSBzLmRhdGFUeXBlcztcXG5cXG5cXHQvLyBSZW1vdmUgYXV0byBkYXRhVHlwZSBhbmQgZ2V0IGNvbnRlbnQtdHlwZSBpbiB0aGUgcHJvY2Vzc1xcblxcdHdoaWxlICggZGF0YVR5cGVzWyAwIF0gPT09IFxcXCIqXFxcIiApIHtcXG5cXHRcXHRkYXRhVHlwZXMuc2hpZnQoKTtcXG5cXHRcXHRpZiAoIGN0ID09PSB1bmRlZmluZWQgKSB7XFxuXFx0XFx0XFx0Y3QgPSBzLm1pbWVUeXBlIHx8IGpxWEhSLmdldFJlc3BvbnNlSGVhZGVyKCBcXFwiQ29udGVudC1UeXBlXFxcIiApO1xcblxcdFxcdH1cXG5cXHR9XFxuXFxuXFx0Ly8gQ2hlY2sgaWYgd2UncmUgZGVhbGluZyB3aXRoIGEga25vd24gY29udGVudC10eXBlXFxuXFx0aWYgKCBjdCApIHtcXG5cXHRcXHRmb3IgKCB0eXBlIGluIGNvbnRlbnRzICkge1xcblxcdFxcdFxcdGlmICggY29udGVudHNbIHR5cGUgXSAmJiBjb250ZW50c1sgdHlwZSBdLnRlc3QoIGN0ICkgKSB7XFxuXFx0XFx0XFx0XFx0ZGF0YVR5cGVzLnVuc2hpZnQoIHR5cGUgKTtcXG5cXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcdH1cXG5cXG5cXHQvLyBDaGVjayB0byBzZWUgaWYgd2UgaGF2ZSBhIHJlc3BvbnNlIGZvciB0aGUgZXhwZWN0ZWQgZGF0YVR5cGVcXG5cXHRpZiAoIGRhdGFUeXBlc1sgMCBdIGluIHJlc3BvbnNlcyApIHtcXG5cXHRcXHRmaW5hbERhdGFUeXBlID0gZGF0YVR5cGVzWyAwIF07XFxuXFx0fSBlbHNlIHtcXG5cXG5cXHRcXHQvLyBUcnkgY29udmVydGlibGUgZGF0YVR5cGVzXFxuXFx0XFx0Zm9yICggdHlwZSBpbiByZXNwb25zZXMgKSB7XFxuXFx0XFx0XFx0aWYgKCAhZGF0YVR5cGVzWyAwIF0gfHwgcy5jb252ZXJ0ZXJzWyB0eXBlICsgXFxcIiBcXFwiICsgZGF0YVR5cGVzWyAwIF0gXSApIHtcXG5cXHRcXHRcXHRcXHRmaW5hbERhdGFUeXBlID0gdHlwZTtcXG5cXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0aWYgKCAhZmlyc3REYXRhVHlwZSApIHtcXG5cXHRcXHRcXHRcXHRmaXJzdERhdGFUeXBlID0gdHlwZTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIE9yIGp1c3QgdXNlIGZpcnN0IG9uZVxcblxcdFxcdGZpbmFsRGF0YVR5cGUgPSBmaW5hbERhdGFUeXBlIHx8IGZpcnN0RGF0YVR5cGU7XFxuXFx0fVxcblxcblxcdC8vIElmIHdlIGZvdW5kIGEgZGF0YVR5cGVcXG5cXHQvLyBXZSBhZGQgdGhlIGRhdGFUeXBlIHRvIHRoZSBsaXN0IGlmIG5lZWRlZFxcblxcdC8vIGFuZCByZXR1cm4gdGhlIGNvcnJlc3BvbmRpbmcgcmVzcG9uc2VcXG5cXHRpZiAoIGZpbmFsRGF0YVR5cGUgKSB7XFxuXFx0XFx0aWYgKCBmaW5hbERhdGFUeXBlICE9PSBkYXRhVHlwZXNbIDAgXSApIHtcXG5cXHRcXHRcXHRkYXRhVHlwZXMudW5zaGlmdCggZmluYWxEYXRhVHlwZSApO1xcblxcdFxcdH1cXG5cXHRcXHRyZXR1cm4gcmVzcG9uc2VzWyBmaW5hbERhdGFUeXBlIF07XFxuXFx0fVxcbn1cXG5cXG4vKiBDaGFpbiBjb252ZXJzaW9ucyBnaXZlbiB0aGUgcmVxdWVzdCBhbmQgdGhlIG9yaWdpbmFsIHJlc3BvbnNlXFxuICogQWxzbyBzZXRzIHRoZSByZXNwb25zZVhYWCBmaWVsZHMgb24gdGhlIGpxWEhSIGluc3RhbmNlXFxuICovXFxuZnVuY3Rpb24gYWpheENvbnZlcnQoIHMsIHJlc3BvbnNlLCBqcVhIUiwgaXNTdWNjZXNzICkge1xcblxcdHZhciBjb252MiwgY3VycmVudCwgY29udiwgdG1wLCBwcmV2LFxcblxcdFxcdGNvbnZlcnRlcnMgPSB7fSxcXG5cXG5cXHRcXHQvLyBXb3JrIHdpdGggYSBjb3B5IG9mIGRhdGFUeXBlcyBpbiBjYXNlIHdlIG5lZWQgdG8gbW9kaWZ5IGl0IGZvciBjb252ZXJzaW9uXFxuXFx0XFx0ZGF0YVR5cGVzID0gcy5kYXRhVHlwZXMuc2xpY2UoKTtcXG5cXG5cXHQvLyBDcmVhdGUgY29udmVydGVycyBtYXAgd2l0aCBsb3dlcmNhc2VkIGtleXNcXG5cXHRpZiAoIGRhdGFUeXBlc1sgMSBdICkge1xcblxcdFxcdGZvciAoIGNvbnYgaW4gcy5jb252ZXJ0ZXJzICkge1xcblxcdFxcdFxcdGNvbnZlcnRlcnNbIGNvbnYudG9Mb3dlckNhc2UoKSBdID0gcy5jb252ZXJ0ZXJzWyBjb252IF07XFxuXFx0XFx0fVxcblxcdH1cXG5cXG5cXHRjdXJyZW50ID0gZGF0YVR5cGVzLnNoaWZ0KCk7XFxuXFxuXFx0Ly8gQ29udmVydCB0byBlYWNoIHNlcXVlbnRpYWwgZGF0YVR5cGVcXG5cXHR3aGlsZSAoIGN1cnJlbnQgKSB7XFxuXFxuXFx0XFx0aWYgKCBzLnJlc3BvbnNlRmllbGRzWyBjdXJyZW50IF0gKSB7XFxuXFx0XFx0XFx0anFYSFJbIHMucmVzcG9uc2VGaWVsZHNbIGN1cnJlbnQgXSBdID0gcmVzcG9uc2U7XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIEFwcGx5IHRoZSBkYXRhRmlsdGVyIGlmIHByb3ZpZGVkXFxuXFx0XFx0aWYgKCAhcHJldiAmJiBpc1N1Y2Nlc3MgJiYgcy5kYXRhRmlsdGVyICkge1xcblxcdFxcdFxcdHJlc3BvbnNlID0gcy5kYXRhRmlsdGVyKCByZXNwb25zZSwgcy5kYXRhVHlwZSApO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRwcmV2ID0gY3VycmVudDtcXG5cXHRcXHRjdXJyZW50ID0gZGF0YVR5cGVzLnNoaWZ0KCk7XFxuXFxuXFx0XFx0aWYgKCBjdXJyZW50ICkge1xcblxcblxcdFxcdFxcdC8vIFRoZXJlJ3Mgb25seSB3b3JrIHRvIGRvIGlmIGN1cnJlbnQgZGF0YVR5cGUgaXMgbm9uLWF1dG9cXG5cXHRcXHRcXHRpZiAoIGN1cnJlbnQgPT09IFxcXCIqXFxcIiApIHtcXG5cXG5cXHRcXHRcXHRcXHRjdXJyZW50ID0gcHJldjtcXG5cXG5cXHRcXHRcXHQvLyBDb252ZXJ0IHJlc3BvbnNlIGlmIHByZXYgZGF0YVR5cGUgaXMgbm9uLWF1dG8gYW5kIGRpZmZlcnMgZnJvbSBjdXJyZW50XFxuXFx0XFx0XFx0fSBlbHNlIGlmICggcHJldiAhPT0gXFxcIipcXFwiICYmIHByZXYgIT09IGN1cnJlbnQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gU2VlayBhIGRpcmVjdCBjb252ZXJ0ZXJcXG5cXHRcXHRcXHRcXHRjb252ID0gY29udmVydGVyc1sgcHJldiArIFxcXCIgXFxcIiArIGN1cnJlbnQgXSB8fCBjb252ZXJ0ZXJzWyBcXFwiKiBcXFwiICsgY3VycmVudCBdO1xcblxcblxcdFxcdFxcdFxcdC8vIElmIG5vbmUgZm91bmQsIHNlZWsgYSBwYWlyXFxuXFx0XFx0XFx0XFx0aWYgKCAhY29udiApIHtcXG5cXHRcXHRcXHRcXHRcXHRmb3IgKCBjb252MiBpbiBjb252ZXJ0ZXJzICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdC8vIElmIGNvbnYyIG91dHB1dHMgY3VycmVudFxcblxcdFxcdFxcdFxcdFxcdFxcdHRtcCA9IGNvbnYyLnNwbGl0KCBcXFwiIFxcXCIgKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoIHRtcFsgMSBdID09PSBjdXJyZW50ICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIElmIHByZXYgY2FuIGJlIGNvbnZlcnRlZCB0byBhY2NlcHRlZCBpbnB1dFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGNvbnYgPSBjb252ZXJ0ZXJzWyBwcmV2ICsgXFxcIiBcXFwiICsgdG1wWyAwIF0gXSB8fFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGNvbnZlcnRlcnNbIFxcXCIqIFxcXCIgKyB0bXBbIDAgXSBdO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmICggY29udiApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBDb25kZW5zZSBlcXVpdmFsZW5jZSBjb252ZXJ0ZXJzXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBjb252ID09PSB0cnVlICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGNvbnYgPSBjb252ZXJ0ZXJzWyBjb252MiBdO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIE90aGVyd2lzZSwgaW5zZXJ0IHRoZSBpbnRlcm1lZGlhdGUgZGF0YVR5cGVcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR9IGVsc2UgaWYgKCBjb252ZXJ0ZXJzWyBjb252MiBdICE9PSB0cnVlICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGN1cnJlbnQgPSB0bXBbIDAgXTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRkYXRhVHlwZXMudW5zaGlmdCggdG1wWyAxIF0gKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdC8vIEFwcGx5IGNvbnZlcnRlciAoaWYgbm90IGFuIGVxdWl2YWxlbmNlKVxcblxcdFxcdFxcdFxcdGlmICggY29udiAhPT0gdHJ1ZSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBVbmxlc3MgZXJyb3JzIGFyZSBhbGxvd2VkIHRvIGJ1YmJsZSwgY2F0Y2ggYW5kIHJldHVybiB0aGVtXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBjb252ICYmIHMudGhyb3dzICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHJlc3BvbnNlID0gY29udiggcmVzcG9uc2UgKTtcXG5cXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdFxcdHRyeSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0cmVzcG9uc2UgPSBjb252KCByZXNwb25zZSApO1xcblxcdFxcdFxcdFxcdFxcdFxcdH0gY2F0Y2ggKCBlICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0c3RhdGU6IFxcXCJwYXJzZXJlcnJvclxcXCIsXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ZXJyb3I6IGNvbnYgPyBlIDogXFxcIk5vIGNvbnZlcnNpb24gZnJvbSBcXFwiICsgcHJldiArIFxcXCIgdG8gXFxcIiArIGN1cnJlbnRcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9O1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFx0fVxcblxcblxcdHJldHVybiB7IHN0YXRlOiBcXFwic3VjY2Vzc1xcXCIsIGRhdGE6IHJlc3BvbnNlIH07XFxufVxcblxcbmpRdWVyeS5leHRlbmQoIHtcXG5cXG5cXHQvLyBDb3VudGVyIGZvciBob2xkaW5nIHRoZSBudW1iZXIgb2YgYWN0aXZlIHF1ZXJpZXNcXG5cXHRhY3RpdmU6IDAsXFxuXFxuXFx0Ly8gTGFzdC1Nb2RpZmllZCBoZWFkZXIgY2FjaGUgZm9yIG5leHQgcmVxdWVzdFxcblxcdGxhc3RNb2RpZmllZDoge30sXFxuXFx0ZXRhZzoge30sXFxuXFxuXFx0YWpheFNldHRpbmdzOiB7XFxuXFx0XFx0dXJsOiBsb2NhdGlvbi5ocmVmLFxcblxcdFxcdHR5cGU6IFxcXCJHRVRcXFwiLFxcblxcdFxcdGlzTG9jYWw6IHJsb2NhbFByb3RvY29sLnRlc3QoIGxvY2F0aW9uLnByb3RvY29sICksXFxuXFx0XFx0Z2xvYmFsOiB0cnVlLFxcblxcdFxcdHByb2Nlc3NEYXRhOiB0cnVlLFxcblxcdFxcdGFzeW5jOiB0cnVlLFxcblxcdFxcdGNvbnRlbnRUeXBlOiBcXFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkOyBjaGFyc2V0PVVURi04XFxcIixcXG5cXG5cXHRcXHQvKlxcblxcdFxcdHRpbWVvdXQ6IDAsXFxuXFx0XFx0ZGF0YTogbnVsbCxcXG5cXHRcXHRkYXRhVHlwZTogbnVsbCxcXG5cXHRcXHR1c2VybmFtZTogbnVsbCxcXG5cXHRcXHRwYXNzd29yZDogbnVsbCxcXG5cXHRcXHRjYWNoZTogbnVsbCxcXG5cXHRcXHR0aHJvd3M6IGZhbHNlLFxcblxcdFxcdHRyYWRpdGlvbmFsOiBmYWxzZSxcXG5cXHRcXHRoZWFkZXJzOiB7fSxcXG5cXHRcXHQqL1xcblxcblxcdFxcdGFjY2VwdHM6IHtcXG5cXHRcXHRcXHRcXFwiKlxcXCI6IGFsbFR5cGVzLFxcblxcdFxcdFxcdHRleHQ6IFxcXCJ0ZXh0L3BsYWluXFxcIixcXG5cXHRcXHRcXHRodG1sOiBcXFwidGV4dC9odG1sXFxcIixcXG5cXHRcXHRcXHR4bWw6IFxcXCJhcHBsaWNhdGlvbi94bWwsIHRleHQveG1sXFxcIixcXG5cXHRcXHRcXHRqc29uOiBcXFwiYXBwbGljYXRpb24vanNvbiwgdGV4dC9qYXZhc2NyaXB0XFxcIlxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Y29udGVudHM6IHtcXG5cXHRcXHRcXHR4bWw6IC9cXFxcYnhtbFxcXFxiLyxcXG5cXHRcXHRcXHRodG1sOiAvXFxcXGJodG1sLyxcXG5cXHRcXHRcXHRqc29uOiAvXFxcXGJqc29uXFxcXGIvXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRyZXNwb25zZUZpZWxkczoge1xcblxcdFxcdFxcdHhtbDogXFxcInJlc3BvbnNlWE1MXFxcIixcXG5cXHRcXHRcXHR0ZXh0OiBcXFwicmVzcG9uc2VUZXh0XFxcIixcXG5cXHRcXHRcXHRqc29uOiBcXFwicmVzcG9uc2VKU09OXFxcIlxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Ly8gRGF0YSBjb252ZXJ0ZXJzXFxuXFx0XFx0Ly8gS2V5cyBzZXBhcmF0ZSBzb3VyY2UgKG9yIGNhdGNoYWxsIFxcXCIqXFxcIikgYW5kIGRlc3RpbmF0aW9uIHR5cGVzIHdpdGggYSBzaW5nbGUgc3BhY2VcXG5cXHRcXHRjb252ZXJ0ZXJzOiB7XFxuXFxuXFx0XFx0XFx0Ly8gQ29udmVydCBhbnl0aGluZyB0byB0ZXh0XFxuXFx0XFx0XFx0XFxcIiogdGV4dFxcXCI6IFN0cmluZyxcXG5cXG5cXHRcXHRcXHQvLyBUZXh0IHRvIGh0bWwgKHRydWUgPSBubyB0cmFuc2Zvcm1hdGlvbilcXG5cXHRcXHRcXHRcXFwidGV4dCBodG1sXFxcIjogdHJ1ZSxcXG5cXG5cXHRcXHRcXHQvLyBFdmFsdWF0ZSB0ZXh0IGFzIGEganNvbiBleHByZXNzaW9uXFxuXFx0XFx0XFx0XFxcInRleHQganNvblxcXCI6IEpTT04ucGFyc2UsXFxuXFxuXFx0XFx0XFx0Ly8gUGFyc2UgdGV4dCBhcyB4bWxcXG5cXHRcXHRcXHRcXFwidGV4dCB4bWxcXFwiOiBqUXVlcnkucGFyc2VYTUxcXG5cXHRcXHR9LFxcblxcblxcdFxcdC8vIEZvciBvcHRpb25zIHRoYXQgc2hvdWxkbid0IGJlIGRlZXAgZXh0ZW5kZWQ6XFxuXFx0XFx0Ly8geW91IGNhbiBhZGQgeW91ciBvd24gY3VzdG9tIG9wdGlvbnMgaGVyZSBpZlxcblxcdFxcdC8vIGFuZCB3aGVuIHlvdSBjcmVhdGUgb25lIHRoYXQgc2hvdWxkbid0IGJlXFxuXFx0XFx0Ly8gZGVlcCBleHRlbmRlZCAoc2VlIGFqYXhFeHRlbmQpXFxuXFx0XFx0ZmxhdE9wdGlvbnM6IHtcXG5cXHRcXHRcXHR1cmw6IHRydWUsXFxuXFx0XFx0XFx0Y29udGV4dDogdHJ1ZVxcblxcdFxcdH1cXG5cXHR9LFxcblxcblxcdC8vIENyZWF0ZXMgYSBmdWxsIGZsZWRnZWQgc2V0dGluZ3Mgb2JqZWN0IGludG8gdGFyZ2V0XFxuXFx0Ly8gd2l0aCBib3RoIGFqYXhTZXR0aW5ncyBhbmQgc2V0dGluZ3MgZmllbGRzLlxcblxcdC8vIElmIHRhcmdldCBpcyBvbWl0dGVkLCB3cml0ZXMgaW50byBhamF4U2V0dGluZ3MuXFxuXFx0YWpheFNldHVwOiBmdW5jdGlvbiggdGFyZ2V0LCBzZXR0aW5ncyApIHtcXG5cXHRcXHRyZXR1cm4gc2V0dGluZ3MgP1xcblxcblxcdFxcdFxcdC8vIEJ1aWxkaW5nIGEgc2V0dGluZ3Mgb2JqZWN0XFxuXFx0XFx0XFx0YWpheEV4dGVuZCggYWpheEV4dGVuZCggdGFyZ2V0LCBqUXVlcnkuYWpheFNldHRpbmdzICksIHNldHRpbmdzICkgOlxcblxcblxcdFxcdFxcdC8vIEV4dGVuZGluZyBhamF4U2V0dGluZ3NcXG5cXHRcXHRcXHRhamF4RXh0ZW5kKCBqUXVlcnkuYWpheFNldHRpbmdzLCB0YXJnZXQgKTtcXG5cXHR9LFxcblxcblxcdGFqYXhQcmVmaWx0ZXI6IGFkZFRvUHJlZmlsdGVyc09yVHJhbnNwb3J0cyggcHJlZmlsdGVycyApLFxcblxcdGFqYXhUcmFuc3BvcnQ6IGFkZFRvUHJlZmlsdGVyc09yVHJhbnNwb3J0cyggdHJhbnNwb3J0cyApLFxcblxcblxcdC8vIE1haW4gbWV0aG9kXFxuXFx0YWpheDogZnVuY3Rpb24oIHVybCwgb3B0aW9ucyApIHtcXG5cXG5cXHRcXHQvLyBJZiB1cmwgaXMgYW4gb2JqZWN0LCBzaW11bGF0ZSBwcmUtMS41IHNpZ25hdHVyZVxcblxcdFxcdGlmICggdHlwZW9mIHVybCA9PT0gXFxcIm9iamVjdFxcXCIgKSB7XFxuXFx0XFx0XFx0b3B0aW9ucyA9IHVybDtcXG5cXHRcXHRcXHR1cmwgPSB1bmRlZmluZWQ7XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIEZvcmNlIG9wdGlvbnMgdG8gYmUgYW4gb2JqZWN0XFxuXFx0XFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XFxuXFxuXFx0XFx0dmFyIHRyYW5zcG9ydCxcXG5cXG5cXHRcXHRcXHQvLyBVUkwgd2l0aG91dCBhbnRpLWNhY2hlIHBhcmFtXFxuXFx0XFx0XFx0Y2FjaGVVUkwsXFxuXFxuXFx0XFx0XFx0Ly8gUmVzcG9uc2UgaGVhZGVyc1xcblxcdFxcdFxcdHJlc3BvbnNlSGVhZGVyc1N0cmluZyxcXG5cXHRcXHRcXHRyZXNwb25zZUhlYWRlcnMsXFxuXFxuXFx0XFx0XFx0Ly8gdGltZW91dCBoYW5kbGVcXG5cXHRcXHRcXHR0aW1lb3V0VGltZXIsXFxuXFxuXFx0XFx0XFx0Ly8gVXJsIGNsZWFudXAgdmFyXFxuXFx0XFx0XFx0dXJsQW5jaG9yLFxcblxcblxcdFxcdFxcdC8vIFJlcXVlc3Qgc3RhdGUgKGJlY29tZXMgZmFsc2UgdXBvbiBzZW5kIGFuZCB0cnVlIHVwb24gY29tcGxldGlvbilcXG5cXHRcXHRcXHRjb21wbGV0ZWQsXFxuXFxuXFx0XFx0XFx0Ly8gVG8ga25vdyBpZiBnbG9iYWwgZXZlbnRzIGFyZSB0byBiZSBkaXNwYXRjaGVkXFxuXFx0XFx0XFx0ZmlyZUdsb2JhbHMsXFxuXFxuXFx0XFx0XFx0Ly8gTG9vcCB2YXJpYWJsZVxcblxcdFxcdFxcdGksXFxuXFxuXFx0XFx0XFx0Ly8gdW5jYWNoZWQgcGFydCBvZiB0aGUgdXJsXFxuXFx0XFx0XFx0dW5jYWNoZWQsXFxuXFxuXFx0XFx0XFx0Ly8gQ3JlYXRlIHRoZSBmaW5hbCBvcHRpb25zIG9iamVjdFxcblxcdFxcdFxcdHMgPSBqUXVlcnkuYWpheFNldHVwKCB7fSwgb3B0aW9ucyApLFxcblxcblxcdFxcdFxcdC8vIENhbGxiYWNrcyBjb250ZXh0XFxuXFx0XFx0XFx0Y2FsbGJhY2tDb250ZXh0ID0gcy5jb250ZXh0IHx8IHMsXFxuXFxuXFx0XFx0XFx0Ly8gQ29udGV4dCBmb3IgZ2xvYmFsIGV2ZW50cyBpcyBjYWxsYmFja0NvbnRleHQgaWYgaXQgaXMgYSBET00gbm9kZSBvciBqUXVlcnkgY29sbGVjdGlvblxcblxcdFxcdFxcdGdsb2JhbEV2ZW50Q29udGV4dCA9IHMuY29udGV4dCAmJlxcblxcdFxcdFxcdFxcdCggY2FsbGJhY2tDb250ZXh0Lm5vZGVUeXBlIHx8IGNhbGxiYWNrQ29udGV4dC5qcXVlcnkgKSA/XFxuXFx0XFx0XFx0XFx0XFx0alF1ZXJ5KCBjYWxsYmFja0NvbnRleHQgKSA6XFxuXFx0XFx0XFx0XFx0XFx0alF1ZXJ5LmV2ZW50LFxcblxcblxcdFxcdFxcdC8vIERlZmVycmVkc1xcblxcdFxcdFxcdGRlZmVycmVkID0galF1ZXJ5LkRlZmVycmVkKCksXFxuXFx0XFx0XFx0Y29tcGxldGVEZWZlcnJlZCA9IGpRdWVyeS5DYWxsYmFja3MoIFxcXCJvbmNlIG1lbW9yeVxcXCIgKSxcXG5cXG5cXHRcXHRcXHQvLyBTdGF0dXMtZGVwZW5kZW50IGNhbGxiYWNrc1xcblxcdFxcdFxcdHN0YXR1c0NvZGUgPSBzLnN0YXR1c0NvZGUgfHwge30sXFxuXFxuXFx0XFx0XFx0Ly8gSGVhZGVycyAodGhleSBhcmUgc2VudCBhbGwgYXQgb25jZSlcXG5cXHRcXHRcXHRyZXF1ZXN0SGVhZGVycyA9IHt9LFxcblxcdFxcdFxcdHJlcXVlc3RIZWFkZXJzTmFtZXMgPSB7fSxcXG5cXG5cXHRcXHRcXHQvLyBEZWZhdWx0IGFib3J0IG1lc3NhZ2VcXG5cXHRcXHRcXHRzdHJBYm9ydCA9IFxcXCJjYW5jZWxlZFxcXCIsXFxuXFxuXFx0XFx0XFx0Ly8gRmFrZSB4aHJcXG5cXHRcXHRcXHRqcVhIUiA9IHtcXG5cXHRcXHRcXHRcXHRyZWFkeVN0YXRlOiAwLFxcblxcblxcdFxcdFxcdFxcdC8vIEJ1aWxkcyBoZWFkZXJzIGhhc2h0YWJsZSBpZiBuZWVkZWRcXG5cXHRcXHRcXHRcXHRnZXRSZXNwb25zZUhlYWRlcjogZnVuY3Rpb24oIGtleSApIHtcXG5cXHRcXHRcXHRcXHRcXHR2YXIgbWF0Y2g7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBjb21wbGV0ZWQgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKCAhcmVzcG9uc2VIZWFkZXJzICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHJlc3BvbnNlSGVhZGVycyA9IHt9O1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHdoaWxlICggKCBtYXRjaCA9IHJoZWFkZXJzLmV4ZWMoIHJlc3BvbnNlSGVhZGVyc1N0cmluZyApICkgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0cmVzcG9uc2VIZWFkZXJzWyBtYXRjaFsgMSBdLnRvTG93ZXJDYXNlKCkgXSA9IG1hdGNoWyAyIF07XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHRtYXRjaCA9IHJlc3BvbnNlSGVhZGVyc1sga2V5LnRvTG93ZXJDYXNlKCkgXTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIG1hdGNoID09IG51bGwgPyBudWxsIDogbWF0Y2g7XFxuXFx0XFx0XFx0XFx0fSxcXG5cXG5cXHRcXHRcXHRcXHQvLyBSYXcgc3RyaW5nXFxuXFx0XFx0XFx0XFx0Z2V0QWxsUmVzcG9uc2VIZWFkZXJzOiBmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gY29tcGxldGVkID8gcmVzcG9uc2VIZWFkZXJzU3RyaW5nIDogbnVsbDtcXG5cXHRcXHRcXHRcXHR9LFxcblxcblxcdFxcdFxcdFxcdC8vIENhY2hlcyB0aGUgaGVhZGVyXFxuXFx0XFx0XFx0XFx0c2V0UmVxdWVzdEhlYWRlcjogZnVuY3Rpb24oIG5hbWUsIHZhbHVlICkge1xcblxcdFxcdFxcdFxcdFxcdGlmICggY29tcGxldGVkID09IG51bGwgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0bmFtZSA9IHJlcXVlc3RIZWFkZXJzTmFtZXNbIG5hbWUudG9Mb3dlckNhc2UoKSBdID1cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRyZXF1ZXN0SGVhZGVyc05hbWVzWyBuYW1lLnRvTG93ZXJDYXNlKCkgXSB8fCBuYW1lO1xcblxcdFxcdFxcdFxcdFxcdFxcdHJlcXVlc3RIZWFkZXJzWyBuYW1lIF0gPSB2YWx1ZTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFx0XFx0XFx0XFx0fSxcXG5cXG5cXHRcXHRcXHRcXHQvLyBPdmVycmlkZXMgcmVzcG9uc2UgY29udGVudC10eXBlIGhlYWRlclxcblxcdFxcdFxcdFxcdG92ZXJyaWRlTWltZVR5cGU6IGZ1bmN0aW9uKCB0eXBlICkge1xcblxcdFxcdFxcdFxcdFxcdGlmICggY29tcGxldGVkID09IG51bGwgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0cy5taW1lVHlwZSA9IHR5cGU7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcdFxcdFxcdFxcdH0sXFxuXFxuXFx0XFx0XFx0XFx0Ly8gU3RhdHVzLWRlcGVuZGVudCBjYWxsYmFja3NcXG5cXHRcXHRcXHRcXHRzdGF0dXNDb2RlOiBmdW5jdGlvbiggbWFwICkge1xcblxcdFxcdFxcdFxcdFxcdHZhciBjb2RlO1xcblxcdFxcdFxcdFxcdFxcdGlmICggbWFwICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGlmICggY29tcGxldGVkICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIEV4ZWN1dGUgdGhlIGFwcHJvcHJpYXRlIGNhbGxiYWNrc1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGpxWEhSLmFsd2F5cyggbWFwWyBqcVhIUi5zdGF0dXMgXSApO1xcblxcdFxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gTGF6eS1hZGQgdGhlIG5ldyBjYWxsYmFja3MgaW4gYSB3YXkgdGhhdCBwcmVzZXJ2ZXMgb2xkIG9uZXNcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRmb3IgKCBjb2RlIGluIG1hcCApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRzdGF0dXNDb2RlWyBjb2RlIF0gPSBbIHN0YXR1c0NvZGVbIGNvZGUgXSwgbWFwWyBjb2RlIF0gXTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXHRcXHRcXHRcXHR9LFxcblxcblxcdFxcdFxcdFxcdC8vIENhbmNlbCB0aGUgcmVxdWVzdFxcblxcdFxcdFxcdFxcdGFib3J0OiBmdW5jdGlvbiggc3RhdHVzVGV4dCApIHtcXG5cXHRcXHRcXHRcXHRcXHR2YXIgZmluYWxUZXh0ID0gc3RhdHVzVGV4dCB8fCBzdHJBYm9ydDtcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIHRyYW5zcG9ydCApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHR0cmFuc3BvcnQuYWJvcnQoIGZpbmFsVGV4dCApO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRkb25lKCAwLCBmaW5hbFRleHQgKTtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fTtcXG5cXG5cXHRcXHQvLyBBdHRhY2ggZGVmZXJyZWRzXFxuXFx0XFx0ZGVmZXJyZWQucHJvbWlzZSgganFYSFIgKTtcXG5cXG5cXHRcXHQvLyBBZGQgcHJvdG9jb2wgaWYgbm90IHByb3ZpZGVkIChwcmVmaWx0ZXJzIG1pZ2h0IGV4cGVjdCBpdClcXG5cXHRcXHQvLyBIYW5kbGUgZmFsc3kgdXJsIGluIHRoZSBzZXR0aW5ncyBvYmplY3QgKCMxMDA5MzogY29uc2lzdGVuY3kgd2l0aCBvbGQgc2lnbmF0dXJlKVxcblxcdFxcdC8vIFdlIGFsc28gdXNlIHRoZSB1cmwgcGFyYW1ldGVyIGlmIGF2YWlsYWJsZVxcblxcdFxcdHMudXJsID0gKCAoIHVybCB8fCBzLnVybCB8fCBsb2NhdGlvbi5ocmVmICkgKyBcXFwiXFxcIiApXFxuXFx0XFx0XFx0LnJlcGxhY2UoIHJwcm90b2NvbCwgbG9jYXRpb24ucHJvdG9jb2wgKyBcXFwiLy9cXFwiICk7XFxuXFxuXFx0XFx0Ly8gQWxpYXMgbWV0aG9kIG9wdGlvbiB0byB0eXBlIGFzIHBlciB0aWNrZXQgIzEyMDA0XFxuXFx0XFx0cy50eXBlID0gb3B0aW9ucy5tZXRob2QgfHwgb3B0aW9ucy50eXBlIHx8IHMubWV0aG9kIHx8IHMudHlwZTtcXG5cXG5cXHRcXHQvLyBFeHRyYWN0IGRhdGFUeXBlcyBsaXN0XFxuXFx0XFx0cy5kYXRhVHlwZXMgPSAoIHMuZGF0YVR5cGUgfHwgXFxcIipcXFwiICkudG9Mb3dlckNhc2UoKS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFsgXFxcIlxcXCIgXTtcXG5cXG5cXHRcXHQvLyBBIGNyb3NzLWRvbWFpbiByZXF1ZXN0IGlzIGluIG9yZGVyIHdoZW4gdGhlIG9yaWdpbiBkb2Vzbid0IG1hdGNoIHRoZSBjdXJyZW50IG9yaWdpbi5cXG5cXHRcXHRpZiAoIHMuY3Jvc3NEb21haW4gPT0gbnVsbCApIHtcXG5cXHRcXHRcXHR1cmxBbmNob3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcXFwiYVxcXCIgKTtcXG5cXG5cXHRcXHRcXHQvLyBTdXBwb3J0OiBJRSA8PTggLSAxMSwgRWRnZSAxMiAtIDE1XFxuXFx0XFx0XFx0Ly8gSUUgdGhyb3dzIGV4Y2VwdGlvbiBvbiBhY2Nlc3NpbmcgdGhlIGhyZWYgcHJvcGVydHkgaWYgdXJsIGlzIG1hbGZvcm1lZCxcXG5cXHRcXHRcXHQvLyBlLmcuIGh0dHA6Ly9leGFtcGxlLmNvbTo4MHgvXFxuXFx0XFx0XFx0dHJ5IHtcXG5cXHRcXHRcXHRcXHR1cmxBbmNob3IuaHJlZiA9IHMudXJsO1xcblxcblxcdFxcdFxcdFxcdC8vIFN1cHBvcnQ6IElFIDw9OCAtIDExIG9ubHlcXG5cXHRcXHRcXHRcXHQvLyBBbmNob3IncyBob3N0IHByb3BlcnR5IGlzbid0IGNvcnJlY3RseSBzZXQgd2hlbiBzLnVybCBpcyByZWxhdGl2ZVxcblxcdFxcdFxcdFxcdHVybEFuY2hvci5ocmVmID0gdXJsQW5jaG9yLmhyZWY7XFxuXFx0XFx0XFx0XFx0cy5jcm9zc0RvbWFpbiA9IG9yaWdpbkFuY2hvci5wcm90b2NvbCArIFxcXCIvL1xcXCIgKyBvcmlnaW5BbmNob3IuaG9zdCAhPT1cXG5cXHRcXHRcXHRcXHRcXHR1cmxBbmNob3IucHJvdG9jb2wgKyBcXFwiLy9cXFwiICsgdXJsQW5jaG9yLmhvc3Q7XFxuXFx0XFx0XFx0fSBjYXRjaCAoIGUgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gSWYgdGhlcmUgaXMgYW4gZXJyb3IgcGFyc2luZyB0aGUgVVJMLCBhc3N1bWUgaXQgaXMgY3Jvc3NEb21haW4sXFxuXFx0XFx0XFx0XFx0Ly8gaXQgY2FuIGJlIHJlamVjdGVkIGJ5IHRoZSB0cmFuc3BvcnQgaWYgaXQgaXMgaW52YWxpZFxcblxcdFxcdFxcdFxcdHMuY3Jvc3NEb21haW4gPSB0cnVlO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gQ29udmVydCBkYXRhIGlmIG5vdCBhbHJlYWR5IGEgc3RyaW5nXFxuXFx0XFx0aWYgKCBzLmRhdGEgJiYgcy5wcm9jZXNzRGF0YSAmJiB0eXBlb2Ygcy5kYXRhICE9PSBcXFwic3RyaW5nXFxcIiApIHtcXG5cXHRcXHRcXHRzLmRhdGEgPSBqUXVlcnkucGFyYW0oIHMuZGF0YSwgcy50cmFkaXRpb25hbCApO1xcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBBcHBseSBwcmVmaWx0ZXJzXFxuXFx0XFx0aW5zcGVjdFByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHByZWZpbHRlcnMsIHMsIG9wdGlvbnMsIGpxWEhSICk7XFxuXFxuXFx0XFx0Ly8gSWYgcmVxdWVzdCB3YXMgYWJvcnRlZCBpbnNpZGUgYSBwcmVmaWx0ZXIsIHN0b3AgdGhlcmVcXG5cXHRcXHRpZiAoIGNvbXBsZXRlZCApIHtcXG5cXHRcXHRcXHRyZXR1cm4ganFYSFI7XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIFdlIGNhbiBmaXJlIGdsb2JhbCBldmVudHMgYXMgb2Ygbm93IGlmIGFza2VkIHRvXFxuXFx0XFx0Ly8gRG9uJ3QgZmlyZSBldmVudHMgaWYgalF1ZXJ5LmV2ZW50IGlzIHVuZGVmaW5lZCBpbiBhbiBBTUQtdXNhZ2Ugc2NlbmFyaW8gKCMxNTExOClcXG5cXHRcXHRmaXJlR2xvYmFscyA9IGpRdWVyeS5ldmVudCAmJiBzLmdsb2JhbDtcXG5cXG5cXHRcXHQvLyBXYXRjaCBmb3IgYSBuZXcgc2V0IG9mIHJlcXVlc3RzXFxuXFx0XFx0aWYgKCBmaXJlR2xvYmFscyAmJiBqUXVlcnkuYWN0aXZlKysgPT09IDAgKSB7XFxuXFx0XFx0XFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXIoIFxcXCJhamF4U3RhcnRcXFwiICk7XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIFVwcGVyY2FzZSB0aGUgdHlwZVxcblxcdFxcdHMudHlwZSA9IHMudHlwZS50b1VwcGVyQ2FzZSgpO1xcblxcblxcdFxcdC8vIERldGVybWluZSBpZiByZXF1ZXN0IGhhcyBjb250ZW50XFxuXFx0XFx0cy5oYXNDb250ZW50ID0gIXJub0NvbnRlbnQudGVzdCggcy50eXBlICk7XFxuXFxuXFx0XFx0Ly8gU2F2ZSB0aGUgVVJMIGluIGNhc2Ugd2UncmUgdG95aW5nIHdpdGggdGhlIElmLU1vZGlmaWVkLVNpbmNlXFxuXFx0XFx0Ly8gYW5kL29yIElmLU5vbmUtTWF0Y2ggaGVhZGVyIGxhdGVyIG9uXFxuXFx0XFx0Ly8gUmVtb3ZlIGhhc2ggdG8gc2ltcGxpZnkgdXJsIG1hbmlwdWxhdGlvblxcblxcdFxcdGNhY2hlVVJMID0gcy51cmwucmVwbGFjZSggcmhhc2gsIFxcXCJcXFwiICk7XFxuXFxuXFx0XFx0Ly8gTW9yZSBvcHRpb25zIGhhbmRsaW5nIGZvciByZXF1ZXN0cyB3aXRoIG5vIGNvbnRlbnRcXG5cXHRcXHRpZiAoICFzLmhhc0NvbnRlbnQgKSB7XFxuXFxuXFx0XFx0XFx0Ly8gUmVtZW1iZXIgdGhlIGhhc2ggc28gd2UgY2FuIHB1dCBpdCBiYWNrXFxuXFx0XFx0XFx0dW5jYWNoZWQgPSBzLnVybC5zbGljZSggY2FjaGVVUkwubGVuZ3RoICk7XFxuXFxuXFx0XFx0XFx0Ly8gSWYgZGF0YSBpcyBhdmFpbGFibGUgYW5kIHNob3VsZCBiZSBwcm9jZXNzZWQsIGFwcGVuZCBkYXRhIHRvIHVybFxcblxcdFxcdFxcdGlmICggcy5kYXRhICYmICggcy5wcm9jZXNzRGF0YSB8fCB0eXBlb2Ygcy5kYXRhID09PSBcXFwic3RyaW5nXFxcIiApICkge1xcblxcdFxcdFxcdFxcdGNhY2hlVVJMICs9ICggcnF1ZXJ5LnRlc3QoIGNhY2hlVVJMICkgPyBcXFwiJlxcXCIgOiBcXFwiP1xcXCIgKSArIHMuZGF0YTtcXG5cXG5cXHRcXHRcXHRcXHQvLyAjOTY4MjogcmVtb3ZlIGRhdGEgc28gdGhhdCBpdCdzIG5vdCB1c2VkIGluIGFuIGV2ZW50dWFsIHJldHJ5XFxuXFx0XFx0XFx0XFx0ZGVsZXRlIHMuZGF0YTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gQWRkIG9yIHVwZGF0ZSBhbnRpLWNhY2hlIHBhcmFtIGlmIG5lZWRlZFxcblxcdFxcdFxcdGlmICggcy5jYWNoZSA9PT0gZmFsc2UgKSB7XFxuXFx0XFx0XFx0XFx0Y2FjaGVVUkwgPSBjYWNoZVVSTC5yZXBsYWNlKCByYW50aUNhY2hlLCBcXFwiJDFcXFwiICk7XFxuXFx0XFx0XFx0XFx0dW5jYWNoZWQgPSAoIHJxdWVyeS50ZXN0KCBjYWNoZVVSTCApID8gXFxcIiZcXFwiIDogXFxcIj9cXFwiICkgKyBcXFwiXz1cXFwiICsgKCBub25jZSsrICkgKyB1bmNhY2hlZDtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gUHV0IGhhc2ggYW5kIGFudGktY2FjaGUgb24gdGhlIFVSTCB0aGF0IHdpbGwgYmUgcmVxdWVzdGVkIChnaC0xNzMyKVxcblxcdFxcdFxcdHMudXJsID0gY2FjaGVVUkwgKyB1bmNhY2hlZDtcXG5cXG5cXHRcXHQvLyBDaGFuZ2UgJyUyMCcgdG8gJysnIGlmIHRoaXMgaXMgZW5jb2RlZCBmb3JtIGJvZHkgY29udGVudCAoZ2gtMjY1OClcXG5cXHRcXHR9IGVsc2UgaWYgKCBzLmRhdGEgJiYgcy5wcm9jZXNzRGF0YSAmJlxcblxcdFxcdFxcdCggcy5jb250ZW50VHlwZSB8fCBcXFwiXFxcIiApLmluZGV4T2YoIFxcXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcXFwiICkgPT09IDAgKSB7XFxuXFx0XFx0XFx0cy5kYXRhID0gcy5kYXRhLnJlcGxhY2UoIHIyMCwgXFxcIitcXFwiICk7XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIFNldCB0aGUgSWYtTW9kaWZpZWQtU2luY2UgYW5kL29yIElmLU5vbmUtTWF0Y2ggaGVhZGVyLCBpZiBpbiBpZk1vZGlmaWVkIG1vZGUuXFxuXFx0XFx0aWYgKCBzLmlmTW9kaWZpZWQgKSB7XFxuXFx0XFx0XFx0aWYgKCBqUXVlcnkubGFzdE1vZGlmaWVkWyBjYWNoZVVSTCBdICkge1xcblxcdFxcdFxcdFxcdGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoIFxcXCJJZi1Nb2RpZmllZC1TaW5jZVxcXCIsIGpRdWVyeS5sYXN0TW9kaWZpZWRbIGNhY2hlVVJMIF0gKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0aWYgKCBqUXVlcnkuZXRhZ1sgY2FjaGVVUkwgXSApIHtcXG5cXHRcXHRcXHRcXHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKCBcXFwiSWYtTm9uZS1NYXRjaFxcXCIsIGpRdWVyeS5ldGFnWyBjYWNoZVVSTCBdICk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBTZXQgdGhlIGNvcnJlY3QgaGVhZGVyLCBpZiBkYXRhIGlzIGJlaW5nIHNlbnRcXG5cXHRcXHRpZiAoIHMuZGF0YSAmJiBzLmhhc0NvbnRlbnQgJiYgcy5jb250ZW50VHlwZSAhPT0gZmFsc2UgfHwgb3B0aW9ucy5jb250ZW50VHlwZSApIHtcXG5cXHRcXHRcXHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKCBcXFwiQ29udGVudC1UeXBlXFxcIiwgcy5jb250ZW50VHlwZSApO1xcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBTZXQgdGhlIEFjY2VwdHMgaGVhZGVyIGZvciB0aGUgc2VydmVyLCBkZXBlbmRpbmcgb24gdGhlIGRhdGFUeXBlXFxuXFx0XFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlcihcXG5cXHRcXHRcXHRcXFwiQWNjZXB0XFxcIixcXG5cXHRcXHRcXHRzLmRhdGFUeXBlc1sgMCBdICYmIHMuYWNjZXB0c1sgcy5kYXRhVHlwZXNbIDAgXSBdID9cXG5cXHRcXHRcXHRcXHRzLmFjY2VwdHNbIHMuZGF0YVR5cGVzWyAwIF0gXSArXFxuXFx0XFx0XFx0XFx0XFx0KCBzLmRhdGFUeXBlc1sgMCBdICE9PSBcXFwiKlxcXCIgPyBcXFwiLCBcXFwiICsgYWxsVHlwZXMgKyBcXFwiOyBxPTAuMDFcXFwiIDogXFxcIlxcXCIgKSA6XFxuXFx0XFx0XFx0XFx0cy5hY2NlcHRzWyBcXFwiKlxcXCIgXVxcblxcdFxcdCk7XFxuXFxuXFx0XFx0Ly8gQ2hlY2sgZm9yIGhlYWRlcnMgb3B0aW9uXFxuXFx0XFx0Zm9yICggaSBpbiBzLmhlYWRlcnMgKSB7XFxuXFx0XFx0XFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlciggaSwgcy5oZWFkZXJzWyBpIF0gKTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gQWxsb3cgY3VzdG9tIGhlYWRlcnMvbWltZXR5cGVzIGFuZCBlYXJseSBhYm9ydFxcblxcdFxcdGlmICggcy5iZWZvcmVTZW5kICYmXFxuXFx0XFx0XFx0KCBzLmJlZm9yZVNlbmQuY2FsbCggY2FsbGJhY2tDb250ZXh0LCBqcVhIUiwgcyApID09PSBmYWxzZSB8fCBjb21wbGV0ZWQgKSApIHtcXG5cXG5cXHRcXHRcXHQvLyBBYm9ydCBpZiBub3QgZG9uZSBhbHJlYWR5IGFuZCByZXR1cm5cXG5cXHRcXHRcXHRyZXR1cm4ganFYSFIuYWJvcnQoKTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gQWJvcnRpbmcgaXMgbm8gbG9uZ2VyIGEgY2FuY2VsbGF0aW9uXFxuXFx0XFx0c3RyQWJvcnQgPSBcXFwiYWJvcnRcXFwiO1xcblxcblxcdFxcdC8vIEluc3RhbGwgY2FsbGJhY2tzIG9uIGRlZmVycmVkc1xcblxcdFxcdGNvbXBsZXRlRGVmZXJyZWQuYWRkKCBzLmNvbXBsZXRlICk7XFxuXFx0XFx0anFYSFIuZG9uZSggcy5zdWNjZXNzICk7XFxuXFx0XFx0anFYSFIuZmFpbCggcy5lcnJvciApO1xcblxcblxcdFxcdC8vIEdldCB0cmFuc3BvcnRcXG5cXHRcXHR0cmFuc3BvcnQgPSBpbnNwZWN0UHJlZmlsdGVyc09yVHJhbnNwb3J0cyggdHJhbnNwb3J0cywgcywgb3B0aW9ucywganFYSFIgKTtcXG5cXG5cXHRcXHQvLyBJZiBubyB0cmFuc3BvcnQsIHdlIGF1dG8tYWJvcnRcXG5cXHRcXHRpZiAoICF0cmFuc3BvcnQgKSB7XFxuXFx0XFx0XFx0ZG9uZSggLTEsIFxcXCJObyBUcmFuc3BvcnRcXFwiICk7XFxuXFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRqcVhIUi5yZWFkeVN0YXRlID0gMTtcXG5cXG5cXHRcXHRcXHQvLyBTZW5kIGdsb2JhbCBldmVudFxcblxcdFxcdFxcdGlmICggZmlyZUdsb2JhbHMgKSB7XFxuXFx0XFx0XFx0XFx0Z2xvYmFsRXZlbnRDb250ZXh0LnRyaWdnZXIoIFxcXCJhamF4U2VuZFxcXCIsIFsganFYSFIsIHMgXSApO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBJZiByZXF1ZXN0IHdhcyBhYm9ydGVkIGluc2lkZSBhamF4U2VuZCwgc3RvcCB0aGVyZVxcblxcdFxcdFxcdGlmICggY29tcGxldGVkICkge1xcblxcdFxcdFxcdFxcdHJldHVybiBqcVhIUjtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gVGltZW91dFxcblxcdFxcdFxcdGlmICggcy5hc3luYyAmJiBzLnRpbWVvdXQgPiAwICkge1xcblxcdFxcdFxcdFxcdHRpbWVvdXRUaW1lciA9IHdpbmRvdy5zZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHRcXHRcXHRqcVhIUi5hYm9ydCggXFxcInRpbWVvdXRcXFwiICk7XFxuXFx0XFx0XFx0XFx0fSwgcy50aW1lb3V0ICk7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHRyeSB7XFxuXFx0XFx0XFx0XFx0Y29tcGxldGVkID0gZmFsc2U7XFxuXFx0XFx0XFx0XFx0dHJhbnNwb3J0LnNlbmQoIHJlcXVlc3RIZWFkZXJzLCBkb25lICk7XFxuXFx0XFx0XFx0fSBjYXRjaCAoIGUgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gUmV0aHJvdyBwb3N0LWNvbXBsZXRpb24gZXhjZXB0aW9uc1xcblxcdFxcdFxcdFxcdGlmICggY29tcGxldGVkICkge1xcblxcdFxcdFxcdFxcdFxcdHRocm93IGU7XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdC8vIFByb3BhZ2F0ZSBvdGhlcnMgYXMgcmVzdWx0c1xcblxcdFxcdFxcdFxcdGRvbmUoIC0xLCBlICk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBDYWxsYmFjayBmb3Igd2hlbiBldmVyeXRoaW5nIGlzIGRvbmVcXG5cXHRcXHRmdW5jdGlvbiBkb25lKCBzdGF0dXMsIG5hdGl2ZVN0YXR1c1RleHQsIHJlc3BvbnNlcywgaGVhZGVycyApIHtcXG5cXHRcXHRcXHR2YXIgaXNTdWNjZXNzLCBzdWNjZXNzLCBlcnJvciwgcmVzcG9uc2UsIG1vZGlmaWVkLFxcblxcdFxcdFxcdFxcdHN0YXR1c1RleHQgPSBuYXRpdmVTdGF0dXNUZXh0O1xcblxcblxcdFxcdFxcdC8vIElnbm9yZSByZXBlYXQgaW52b2NhdGlvbnNcXG5cXHRcXHRcXHRpZiAoIGNvbXBsZXRlZCApIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm47XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGNvbXBsZXRlZCA9IHRydWU7XFxuXFxuXFx0XFx0XFx0Ly8gQ2xlYXIgdGltZW91dCBpZiBpdCBleGlzdHNcXG5cXHRcXHRcXHRpZiAoIHRpbWVvdXRUaW1lciApIHtcXG5cXHRcXHRcXHRcXHR3aW5kb3cuY2xlYXJUaW1lb3V0KCB0aW1lb3V0VGltZXIgKTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gRGVyZWZlcmVuY2UgdHJhbnNwb3J0IGZvciBlYXJseSBnYXJiYWdlIGNvbGxlY3Rpb25cXG5cXHRcXHRcXHQvLyAobm8gbWF0dGVyIGhvdyBsb25nIHRoZSBqcVhIUiBvYmplY3Qgd2lsbCBiZSB1c2VkKVxcblxcdFxcdFxcdHRyYW5zcG9ydCA9IHVuZGVmaW5lZDtcXG5cXG5cXHRcXHRcXHQvLyBDYWNoZSByZXNwb25zZSBoZWFkZXJzXFxuXFx0XFx0XFx0cmVzcG9uc2VIZWFkZXJzU3RyaW5nID0gaGVhZGVycyB8fCBcXFwiXFxcIjtcXG5cXG5cXHRcXHRcXHQvLyBTZXQgcmVhZHlTdGF0ZVxcblxcdFxcdFxcdGpxWEhSLnJlYWR5U3RhdGUgPSBzdGF0dXMgPiAwID8gNCA6IDA7XFxuXFxuXFx0XFx0XFx0Ly8gRGV0ZXJtaW5lIGlmIHN1Y2Nlc3NmdWxcXG5cXHRcXHRcXHRpc1N1Y2Nlc3MgPSBzdGF0dXMgPj0gMjAwICYmIHN0YXR1cyA8IDMwMCB8fCBzdGF0dXMgPT09IDMwNDtcXG5cXG5cXHRcXHRcXHQvLyBHZXQgcmVzcG9uc2UgZGF0YVxcblxcdFxcdFxcdGlmICggcmVzcG9uc2VzICkge1xcblxcdFxcdFxcdFxcdHJlc3BvbnNlID0gYWpheEhhbmRsZVJlc3BvbnNlcyggcywganFYSFIsIHJlc3BvbnNlcyApO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBDb252ZXJ0IG5vIG1hdHRlciB3aGF0ICh0aGF0IHdheSByZXNwb25zZVhYWCBmaWVsZHMgYXJlIGFsd2F5cyBzZXQpXFxuXFx0XFx0XFx0cmVzcG9uc2UgPSBhamF4Q29udmVydCggcywgcmVzcG9uc2UsIGpxWEhSLCBpc1N1Y2Nlc3MgKTtcXG5cXG5cXHRcXHRcXHQvLyBJZiBzdWNjZXNzZnVsLCBoYW5kbGUgdHlwZSBjaGFpbmluZ1xcblxcdFxcdFxcdGlmICggaXNTdWNjZXNzICkge1xcblxcblxcdFxcdFxcdFxcdC8vIFNldCB0aGUgSWYtTW9kaWZpZWQtU2luY2UgYW5kL29yIElmLU5vbmUtTWF0Y2ggaGVhZGVyLCBpZiBpbiBpZk1vZGlmaWVkIG1vZGUuXFxuXFx0XFx0XFx0XFx0aWYgKCBzLmlmTW9kaWZpZWQgKSB7XFxuXFx0XFx0XFx0XFx0XFx0bW9kaWZpZWQgPSBqcVhIUi5nZXRSZXNwb25zZUhlYWRlciggXFxcIkxhc3QtTW9kaWZpZWRcXFwiICk7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBtb2RpZmllZCApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRqUXVlcnkubGFzdE1vZGlmaWVkWyBjYWNoZVVSTCBdID0gbW9kaWZpZWQ7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdG1vZGlmaWVkID0ganFYSFIuZ2V0UmVzcG9uc2VIZWFkZXIoIFxcXCJldGFnXFxcIiApO1xcblxcdFxcdFxcdFxcdFxcdGlmICggbW9kaWZpZWQgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0alF1ZXJ5LmV0YWdbIGNhY2hlVVJMIF0gPSBtb2RpZmllZDtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdC8vIGlmIG5vIGNvbnRlbnRcXG5cXHRcXHRcXHRcXHRpZiAoIHN0YXR1cyA9PT0gMjA0IHx8IHMudHlwZSA9PT0gXFxcIkhFQURcXFwiICkge1xcblxcdFxcdFxcdFxcdFxcdHN0YXR1c1RleHQgPSBcXFwibm9jb250ZW50XFxcIjtcXG5cXG5cXHRcXHRcXHRcXHQvLyBpZiBub3QgbW9kaWZpZWRcXG5cXHRcXHRcXHRcXHR9IGVsc2UgaWYgKCBzdGF0dXMgPT09IDMwNCApIHtcXG5cXHRcXHRcXHRcXHRcXHRzdGF0dXNUZXh0ID0gXFxcIm5vdG1vZGlmaWVkXFxcIjtcXG5cXG5cXHRcXHRcXHRcXHQvLyBJZiB3ZSBoYXZlIGRhdGEsIGxldCdzIGNvbnZlcnQgaXRcXG5cXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdHN0YXR1c1RleHQgPSByZXNwb25zZS5zdGF0ZTtcXG5cXHRcXHRcXHRcXHRcXHRzdWNjZXNzID0gcmVzcG9uc2UuZGF0YTtcXG5cXHRcXHRcXHRcXHRcXHRlcnJvciA9IHJlc3BvbnNlLmVycm9yO1xcblxcdFxcdFxcdFxcdFxcdGlzU3VjY2VzcyA9ICFlcnJvcjtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHQvLyBFeHRyYWN0IGVycm9yIGZyb20gc3RhdHVzVGV4dCBhbmQgbm9ybWFsaXplIGZvciBub24tYWJvcnRzXFxuXFx0XFx0XFx0XFx0ZXJyb3IgPSBzdGF0dXNUZXh0O1xcblxcdFxcdFxcdFxcdGlmICggc3RhdHVzIHx8ICFzdGF0dXNUZXh0ICkge1xcblxcdFxcdFxcdFxcdFxcdHN0YXR1c1RleHQgPSBcXFwiZXJyb3JcXFwiO1xcblxcdFxcdFxcdFxcdFxcdGlmICggc3RhdHVzIDwgMCApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRzdGF0dXMgPSAwO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIFNldCBkYXRhIGZvciB0aGUgZmFrZSB4aHIgb2JqZWN0XFxuXFx0XFx0XFx0anFYSFIuc3RhdHVzID0gc3RhdHVzO1xcblxcdFxcdFxcdGpxWEhSLnN0YXR1c1RleHQgPSAoIG5hdGl2ZVN0YXR1c1RleHQgfHwgc3RhdHVzVGV4dCApICsgXFxcIlxcXCI7XFxuXFxuXFx0XFx0XFx0Ly8gU3VjY2Vzcy9FcnJvclxcblxcdFxcdFxcdGlmICggaXNTdWNjZXNzICkge1xcblxcdFxcdFxcdFxcdGRlZmVycmVkLnJlc29sdmVXaXRoKCBjYWxsYmFja0NvbnRleHQsIFsgc3VjY2Vzcywgc3RhdHVzVGV4dCwganFYSFIgXSApO1xcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0ZGVmZXJyZWQucmVqZWN0V2l0aCggY2FsbGJhY2tDb250ZXh0LCBbIGpxWEhSLCBzdGF0dXNUZXh0LCBlcnJvciBdICk7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIFN0YXR1cy1kZXBlbmRlbnQgY2FsbGJhY2tzXFxuXFx0XFx0XFx0anFYSFIuc3RhdHVzQ29kZSggc3RhdHVzQ29kZSApO1xcblxcdFxcdFxcdHN0YXR1c0NvZGUgPSB1bmRlZmluZWQ7XFxuXFxuXFx0XFx0XFx0aWYgKCBmaXJlR2xvYmFscyApIHtcXG5cXHRcXHRcXHRcXHRnbG9iYWxFdmVudENvbnRleHQudHJpZ2dlciggaXNTdWNjZXNzID8gXFxcImFqYXhTdWNjZXNzXFxcIiA6IFxcXCJhamF4RXJyb3JcXFwiLFxcblxcdFxcdFxcdFxcdFxcdFsganFYSFIsIHMsIGlzU3VjY2VzcyA/IHN1Y2Nlc3MgOiBlcnJvciBdICk7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIENvbXBsZXRlXFxuXFx0XFx0XFx0Y29tcGxldGVEZWZlcnJlZC5maXJlV2l0aCggY2FsbGJhY2tDb250ZXh0LCBbIGpxWEhSLCBzdGF0dXNUZXh0IF0gKTtcXG5cXG5cXHRcXHRcXHRpZiAoIGZpcmVHbG9iYWxzICkge1xcblxcdFxcdFxcdFxcdGdsb2JhbEV2ZW50Q29udGV4dC50cmlnZ2VyKCBcXFwiYWpheENvbXBsZXRlXFxcIiwgWyBqcVhIUiwgcyBdICk7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gSGFuZGxlIHRoZSBnbG9iYWwgQUpBWCBjb3VudGVyXFxuXFx0XFx0XFx0XFx0aWYgKCAhKCAtLWpRdWVyeS5hY3RpdmUgKSApIHtcXG5cXHRcXHRcXHRcXHRcXHRqUXVlcnkuZXZlbnQudHJpZ2dlciggXFxcImFqYXhTdG9wXFxcIiApO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcblxcdFxcdHJldHVybiBqcVhIUjtcXG5cXHR9LFxcblxcblxcdGdldEpTT046IGZ1bmN0aW9uKCB1cmwsIGRhdGEsIGNhbGxiYWNrICkge1xcblxcdFxcdHJldHVybiBqUXVlcnkuZ2V0KCB1cmwsIGRhdGEsIGNhbGxiYWNrLCBcXFwianNvblxcXCIgKTtcXG5cXHR9LFxcblxcblxcdGdldFNjcmlwdDogZnVuY3Rpb24oIHVybCwgY2FsbGJhY2sgKSB7XFxuXFx0XFx0cmV0dXJuIGpRdWVyeS5nZXQoIHVybCwgdW5kZWZpbmVkLCBjYWxsYmFjaywgXFxcInNjcmlwdFxcXCIgKTtcXG5cXHR9XFxufSApO1xcblxcbmpRdWVyeS5lYWNoKCBbIFxcXCJnZXRcXFwiLCBcXFwicG9zdFxcXCIgXSwgZnVuY3Rpb24oIGksIG1ldGhvZCApIHtcXG5cXHRqUXVlcnlbIG1ldGhvZCBdID0gZnVuY3Rpb24oIHVybCwgZGF0YSwgY2FsbGJhY2ssIHR5cGUgKSB7XFxuXFxuXFx0XFx0Ly8gU2hpZnQgYXJndW1lbnRzIGlmIGRhdGEgYXJndW1lbnQgd2FzIG9taXR0ZWRcXG5cXHRcXHRpZiAoIGlzRnVuY3Rpb24oIGRhdGEgKSApIHtcXG5cXHRcXHRcXHR0eXBlID0gdHlwZSB8fCBjYWxsYmFjaztcXG5cXHRcXHRcXHRjYWxsYmFjayA9IGRhdGE7XFxuXFx0XFx0XFx0ZGF0YSA9IHVuZGVmaW5lZDtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gVGhlIHVybCBjYW4gYmUgYW4gb3B0aW9ucyBvYmplY3QgKHdoaWNoIHRoZW4gbXVzdCBoYXZlIC51cmwpXFxuXFx0XFx0cmV0dXJuIGpRdWVyeS5hamF4KCBqUXVlcnkuZXh0ZW5kKCB7XFxuXFx0XFx0XFx0dXJsOiB1cmwsXFxuXFx0XFx0XFx0dHlwZTogbWV0aG9kLFxcblxcdFxcdFxcdGRhdGFUeXBlOiB0eXBlLFxcblxcdFxcdFxcdGRhdGE6IGRhdGEsXFxuXFx0XFx0XFx0c3VjY2VzczogY2FsbGJhY2tcXG5cXHRcXHR9LCBqUXVlcnkuaXNQbGFpbk9iamVjdCggdXJsICkgJiYgdXJsICkgKTtcXG5cXHR9O1xcbn0gKTtcXG5cXG5cXG5qUXVlcnkuX2V2YWxVcmwgPSBmdW5jdGlvbiggdXJsICkge1xcblxcdHJldHVybiBqUXVlcnkuYWpheCgge1xcblxcdFxcdHVybDogdXJsLFxcblxcblxcdFxcdC8vIE1ha2UgdGhpcyBleHBsaWNpdCwgc2luY2UgdXNlciBjYW4gb3ZlcnJpZGUgdGhpcyB0aHJvdWdoIGFqYXhTZXR1cCAoIzExMjY0KVxcblxcdFxcdHR5cGU6IFxcXCJHRVRcXFwiLFxcblxcdFxcdGRhdGFUeXBlOiBcXFwic2NyaXB0XFxcIixcXG5cXHRcXHRjYWNoZTogdHJ1ZSxcXG5cXHRcXHRhc3luYzogZmFsc2UsXFxuXFx0XFx0Z2xvYmFsOiBmYWxzZSxcXG5cXHRcXHRcXFwidGhyb3dzXFxcIjogdHJ1ZVxcblxcdH0gKTtcXG59O1xcblxcblxcbmpRdWVyeS5mbi5leHRlbmQoIHtcXG5cXHR3cmFwQWxsOiBmdW5jdGlvbiggaHRtbCApIHtcXG5cXHRcXHR2YXIgd3JhcDtcXG5cXG5cXHRcXHRpZiAoIHRoaXNbIDAgXSApIHtcXG5cXHRcXHRcXHRpZiAoIGlzRnVuY3Rpb24oIGh0bWwgKSApIHtcXG5cXHRcXHRcXHRcXHRodG1sID0gaHRtbC5jYWxsKCB0aGlzWyAwIF0gKTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gVGhlIGVsZW1lbnRzIHRvIHdyYXAgdGhlIHRhcmdldCBhcm91bmRcXG5cXHRcXHRcXHR3cmFwID0galF1ZXJ5KCBodG1sLCB0aGlzWyAwIF0ub3duZXJEb2N1bWVudCApLmVxKCAwICkuY2xvbmUoIHRydWUgKTtcXG5cXG5cXHRcXHRcXHRpZiAoIHRoaXNbIDAgXS5wYXJlbnROb2RlICkge1xcblxcdFxcdFxcdFxcdHdyYXAuaW5zZXJ0QmVmb3JlKCB0aGlzWyAwIF0gKTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0d3JhcC5tYXAoIGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdFxcdHZhciBlbGVtID0gdGhpcztcXG5cXG5cXHRcXHRcXHRcXHR3aGlsZSAoIGVsZW0uZmlyc3RFbGVtZW50Q2hpbGQgKSB7XFxuXFx0XFx0XFx0XFx0XFx0ZWxlbSA9IGVsZW0uZmlyc3RFbGVtZW50Q2hpbGQ7XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdHJldHVybiBlbGVtO1xcblxcdFxcdFxcdH0gKS5hcHBlbmQoIHRoaXMgKTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0cmV0dXJuIHRoaXM7XFxuXFx0fSxcXG5cXG5cXHR3cmFwSW5uZXI6IGZ1bmN0aW9uKCBodG1sICkge1xcblxcdFxcdGlmICggaXNGdW5jdGlvbiggaHRtbCApICkge1xcblxcdFxcdFxcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBpICkge1xcblxcdFxcdFxcdFxcdGpRdWVyeSggdGhpcyApLndyYXBJbm5lciggaHRtbC5jYWxsKCB0aGlzLCBpICkgKTtcXG5cXHRcXHRcXHR9ICk7XFxuXFx0XFx0fVxcblxcblxcdFxcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdHZhciBzZWxmID0galF1ZXJ5KCB0aGlzICksXFxuXFx0XFx0XFx0XFx0Y29udGVudHMgPSBzZWxmLmNvbnRlbnRzKCk7XFxuXFxuXFx0XFx0XFx0aWYgKCBjb250ZW50cy5sZW5ndGggKSB7XFxuXFx0XFx0XFx0XFx0Y29udGVudHMud3JhcEFsbCggaHRtbCApO1xcblxcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0c2VsZi5hcHBlbmQoIGh0bWwgKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSApO1xcblxcdH0sXFxuXFxuXFx0d3JhcDogZnVuY3Rpb24oIGh0bWwgKSB7XFxuXFx0XFx0dmFyIGh0bWxJc0Z1bmN0aW9uID0gaXNGdW5jdGlvbiggaHRtbCApO1xcblxcblxcdFxcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBpICkge1xcblxcdFxcdFxcdGpRdWVyeSggdGhpcyApLndyYXBBbGwoIGh0bWxJc0Z1bmN0aW9uID8gaHRtbC5jYWxsKCB0aGlzLCBpICkgOiBodG1sICk7XFxuXFx0XFx0fSApO1xcblxcdH0sXFxuXFxuXFx0dW53cmFwOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XFxuXFx0XFx0dGhpcy5wYXJlbnQoIHNlbGVjdG9yICkubm90KCBcXFwiYm9keVxcXCIgKS5lYWNoKCBmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHRqUXVlcnkoIHRoaXMgKS5yZXBsYWNlV2l0aCggdGhpcy5jaGlsZE5vZGVzICk7XFxuXFx0XFx0fSApO1xcblxcdFxcdHJldHVybiB0aGlzO1xcblxcdH1cXG59ICk7XFxuXFxuXFxualF1ZXJ5LmV4cHIucHNldWRvcy5oaWRkZW4gPSBmdW5jdGlvbiggZWxlbSApIHtcXG5cXHRyZXR1cm4gIWpRdWVyeS5leHByLnBzZXVkb3MudmlzaWJsZSggZWxlbSApO1xcbn07XFxualF1ZXJ5LmV4cHIucHNldWRvcy52aXNpYmxlID0gZnVuY3Rpb24oIGVsZW0gKSB7XFxuXFx0cmV0dXJuICEhKCBlbGVtLm9mZnNldFdpZHRoIHx8IGVsZW0ub2Zmc2V0SGVpZ2h0IHx8IGVsZW0uZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGggKTtcXG59O1xcblxcblxcblxcblxcbmpRdWVyeS5hamF4U2V0dGluZ3MueGhyID0gZnVuY3Rpb24oKSB7XFxuXFx0dHJ5IHtcXG5cXHRcXHRyZXR1cm4gbmV3IHdpbmRvdy5YTUxIdHRwUmVxdWVzdCgpO1xcblxcdH0gY2F0Y2ggKCBlICkge31cXG59O1xcblxcbnZhciB4aHJTdWNjZXNzU3RhdHVzID0ge1xcblxcblxcdFxcdC8vIEZpbGUgcHJvdG9jb2wgYWx3YXlzIHlpZWxkcyBzdGF0dXMgY29kZSAwLCBhc3N1bWUgMjAwXFxuXFx0XFx0MDogMjAwLFxcblxcblxcdFxcdC8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XFxuXFx0XFx0Ly8gIzE0NTA6IHNvbWV0aW1lcyBJRSByZXR1cm5zIDEyMjMgd2hlbiBpdCBzaG91bGQgYmUgMjA0XFxuXFx0XFx0MTIyMzogMjA0XFxuXFx0fSxcXG5cXHR4aHJTdXBwb3J0ZWQgPSBqUXVlcnkuYWpheFNldHRpbmdzLnhocigpO1xcblxcbnN1cHBvcnQuY29ycyA9ICEheGhyU3VwcG9ydGVkICYmICggXFxcIndpdGhDcmVkZW50aWFsc1xcXCIgaW4geGhyU3VwcG9ydGVkICk7XFxuc3VwcG9ydC5hamF4ID0geGhyU3VwcG9ydGVkID0gISF4aHJTdXBwb3J0ZWQ7XFxuXFxualF1ZXJ5LmFqYXhUcmFuc3BvcnQoIGZ1bmN0aW9uKCBvcHRpb25zICkge1xcblxcdHZhciBjYWxsYmFjaywgZXJyb3JDYWxsYmFjaztcXG5cXG5cXHQvLyBDcm9zcyBkb21haW4gb25seSBhbGxvd2VkIGlmIHN1cHBvcnRlZCB0aHJvdWdoIFhNTEh0dHBSZXF1ZXN0XFxuXFx0aWYgKCBzdXBwb3J0LmNvcnMgfHwgeGhyU3VwcG9ydGVkICYmICFvcHRpb25zLmNyb3NzRG9tYWluICkge1xcblxcdFxcdHJldHVybiB7XFxuXFx0XFx0XFx0c2VuZDogZnVuY3Rpb24oIGhlYWRlcnMsIGNvbXBsZXRlICkge1xcblxcdFxcdFxcdFxcdHZhciBpLFxcblxcdFxcdFxcdFxcdFxcdHhociA9IG9wdGlvbnMueGhyKCk7XFxuXFxuXFx0XFx0XFx0XFx0eGhyLm9wZW4oXFxuXFx0XFx0XFx0XFx0XFx0b3B0aW9ucy50eXBlLFxcblxcdFxcdFxcdFxcdFxcdG9wdGlvbnMudXJsLFxcblxcdFxcdFxcdFxcdFxcdG9wdGlvbnMuYXN5bmMsXFxuXFx0XFx0XFx0XFx0XFx0b3B0aW9ucy51c2VybmFtZSxcXG5cXHRcXHRcXHRcXHRcXHRvcHRpb25zLnBhc3N3b3JkXFxuXFx0XFx0XFx0XFx0KTtcXG5cXG5cXHRcXHRcXHRcXHQvLyBBcHBseSBjdXN0b20gZmllbGRzIGlmIHByb3ZpZGVkXFxuXFx0XFx0XFx0XFx0aWYgKCBvcHRpb25zLnhockZpZWxkcyApIHtcXG5cXHRcXHRcXHRcXHRcXHRmb3IgKCBpIGluIG9wdGlvbnMueGhyRmllbGRzICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHhoclsgaSBdID0gb3B0aW9ucy54aHJGaWVsZHNbIGkgXTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdC8vIE92ZXJyaWRlIG1pbWUgdHlwZSBpZiBuZWVkZWRcXG5cXHRcXHRcXHRcXHRpZiAoIG9wdGlvbnMubWltZVR5cGUgJiYgeGhyLm92ZXJyaWRlTWltZVR5cGUgKSB7XFxuXFx0XFx0XFx0XFx0XFx0eGhyLm92ZXJyaWRlTWltZVR5cGUoIG9wdGlvbnMubWltZVR5cGUgKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0Ly8gWC1SZXF1ZXN0ZWQtV2l0aCBoZWFkZXJcXG5cXHRcXHRcXHRcXHQvLyBGb3IgY3Jvc3MtZG9tYWluIHJlcXVlc3RzLCBzZWVpbmcgYXMgY29uZGl0aW9ucyBmb3IgYSBwcmVmbGlnaHQgYXJlXFxuXFx0XFx0XFx0XFx0Ly8gYWtpbiB0byBhIGppZ3NhdyBwdXp6bGUsIHdlIHNpbXBseSBuZXZlciBzZXQgaXQgdG8gYmUgc3VyZS5cXG5cXHRcXHRcXHRcXHQvLyAoaXQgY2FuIGFsd2F5cyBiZSBzZXQgb24gYSBwZXItcmVxdWVzdCBiYXNpcyBvciBldmVuIHVzaW5nIGFqYXhTZXR1cClcXG5cXHRcXHRcXHRcXHQvLyBGb3Igc2FtZS1kb21haW4gcmVxdWVzdHMsIHdvbid0IGNoYW5nZSBoZWFkZXIgaWYgYWxyZWFkeSBwcm92aWRlZC5cXG5cXHRcXHRcXHRcXHRpZiAoICFvcHRpb25zLmNyb3NzRG9tYWluICYmICFoZWFkZXJzWyBcXFwiWC1SZXF1ZXN0ZWQtV2l0aFxcXCIgXSApIHtcXG5cXHRcXHRcXHRcXHRcXHRoZWFkZXJzWyBcXFwiWC1SZXF1ZXN0ZWQtV2l0aFxcXCIgXSA9IFxcXCJYTUxIdHRwUmVxdWVzdFxcXCI7XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdC8vIFNldCBoZWFkZXJzXFxuXFx0XFx0XFx0XFx0Zm9yICggaSBpbiBoZWFkZXJzICkge1xcblxcdFxcdFxcdFxcdFxcdHhoci5zZXRSZXF1ZXN0SGVhZGVyKCBpLCBoZWFkZXJzWyBpIF0gKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0Ly8gQ2FsbGJhY2tcXG5cXHRcXHRcXHRcXHRjYWxsYmFjayA9IGZ1bmN0aW9uKCB0eXBlICkge1xcblxcdFxcdFxcdFxcdFxcdHJldHVybiBmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoIGNhbGxiYWNrICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGNhbGxiYWNrID0gZXJyb3JDYWxsYmFjayA9IHhoci5vbmxvYWQgPVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHhoci5vbmVycm9yID0geGhyLm9uYWJvcnQgPSB4aHIub250aW1lb3V0ID1cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbDtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoIHR5cGUgPT09IFxcXCJhYm9ydFxcXCIgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0eGhyLmFib3J0KCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fSBlbHNlIGlmICggdHlwZSA9PT0gXFxcImVycm9yXFxcIiApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBTdXBwb3J0OiBJRSA8PTkgb25seVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIE9uIGEgbWFudWFsIG5hdGl2ZSBhYm9ydCwgSUU5IHRocm93c1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIGVycm9ycyBvbiBhbnkgcHJvcGVydHkgYWNjZXNzIHRoYXQgaXMgbm90IHJlYWR5U3RhdGVcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoIHR5cGVvZiB4aHIuc3RhdHVzICE9PSBcXFwibnVtYmVyXFxcIiApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRjb21wbGV0ZSggMCwgXFxcImVycm9yXFxcIiApO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Y29tcGxldGUoXFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gRmlsZTogcHJvdG9jb2wgYWx3YXlzIHlpZWxkcyBzdGF0dXMgMDsgc2VlICM4NjA1LCAjMTQyMDdcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR4aHIuc3RhdHVzLFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHhoci5zdGF0dXNUZXh0XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0KTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRjb21wbGV0ZShcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR4aHJTdWNjZXNzU3RhdHVzWyB4aHIuc3RhdHVzIF0gfHwgeGhyLnN0YXR1cyxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR4aHIuc3RhdHVzVGV4dCxcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBTdXBwb3J0OiBJRSA8PTkgb25seVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIElFOSBoYXMgbm8gWEhSMiBidXQgdGhyb3dzIG9uIGJpbmFyeSAodHJhYy0xMTQyNilcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBGb3IgWEhSMiBub24tdGV4dCwgbGV0IHRoZSBjYWxsZXIgaGFuZGxlIGl0IChnaC0yNDk4KVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdCggeGhyLnJlc3BvbnNlVHlwZSB8fCBcXFwidGV4dFxcXCIgKSAhPT0gXFxcInRleHRcXFwiICB8fFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHR5cGVvZiB4aHIucmVzcG9uc2VUZXh0ICE9PSBcXFwic3RyaW5nXFxcIiA/XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0eyBiaW5hcnk6IHhoci5yZXNwb25zZSB9IDpcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR7IHRleHQ6IHhoci5yZXNwb25zZVRleHQgfSxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR4aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKClcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0fTtcXG5cXHRcXHRcXHRcXHR9O1xcblxcblxcdFxcdFxcdFxcdC8vIExpc3RlbiB0byBldmVudHNcXG5cXHRcXHRcXHRcXHR4aHIub25sb2FkID0gY2FsbGJhY2soKTtcXG5cXHRcXHRcXHRcXHRlcnJvckNhbGxiYWNrID0geGhyLm9uZXJyb3IgPSB4aHIub250aW1lb3V0ID0gY2FsbGJhY2soIFxcXCJlcnJvclxcXCIgKTtcXG5cXG5cXHRcXHRcXHRcXHQvLyBTdXBwb3J0OiBJRSA5IG9ubHlcXG5cXHRcXHRcXHRcXHQvLyBVc2Ugb25yZWFkeXN0YXRlY2hhbmdlIHRvIHJlcGxhY2Ugb25hYm9ydFxcblxcdFxcdFxcdFxcdC8vIHRvIGhhbmRsZSB1bmNhdWdodCBhYm9ydHNcXG5cXHRcXHRcXHRcXHRpZiAoIHhoci5vbmFib3J0ICE9PSB1bmRlZmluZWQgKSB7XFxuXFx0XFx0XFx0XFx0XFx0eGhyLm9uYWJvcnQgPSBlcnJvckNhbGxiYWNrO1xcblxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0eGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdC8vIENoZWNrIHJlYWR5U3RhdGUgYmVmb3JlIHRpbWVvdXQgYXMgaXQgY2hhbmdlc1xcblxcdFxcdFxcdFxcdFxcdFxcdGlmICggeGhyLnJlYWR5U3RhdGUgPT09IDQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gQWxsb3cgb25lcnJvciB0byBiZSBjYWxsZWQgZmlyc3QsXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gYnV0IHRoYXQgd2lsbCBub3QgaGFuZGxlIGEgbmF0aXZlIGFib3J0XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gQWxzbywgc2F2ZSBlcnJvckNhbGxiYWNrIHRvIGEgdmFyaWFibGVcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBhcyB4aHIub25lcnJvciBjYW5ub3QgYmUgYWNjZXNzZWRcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR3aW5kb3cuc2V0VGltZW91dCggZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBjYWxsYmFjayApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRlcnJvckNhbGxiYWNrKCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH0gKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0fTtcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0Ly8gQ3JlYXRlIHRoZSBhYm9ydCBjYWxsYmFja1xcblxcdFxcdFxcdFxcdGNhbGxiYWNrID0gY2FsbGJhY2soIFxcXCJhYm9ydFxcXCIgKTtcXG5cXG5cXHRcXHRcXHRcXHR0cnkge1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIERvIHNlbmQgdGhlIHJlcXVlc3QgKHRoaXMgbWF5IHJhaXNlIGFuIGV4Y2VwdGlvbilcXG5cXHRcXHRcXHRcXHRcXHR4aHIuc2VuZCggb3B0aW9ucy5oYXNDb250ZW50ICYmIG9wdGlvbnMuZGF0YSB8fCBudWxsICk7XFxuXFx0XFx0XFx0XFx0fSBjYXRjaCAoIGUgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gIzE0NjgzOiBPbmx5IHJldGhyb3cgaWYgdGhpcyBoYXNuJ3QgYmVlbiBub3RpZmllZCBhcyBhbiBlcnJvciB5ZXRcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIGNhbGxiYWNrICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHRocm93IGU7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9LFxcblxcblxcdFxcdFxcdGFib3J0OiBmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHRcXHRpZiAoIGNhbGxiYWNrICkge1xcblxcdFxcdFxcdFxcdFxcdGNhbGxiYWNrKCk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHR9O1xcblxcdH1cXG59ICk7XFxuXFxuXFxuXFxuXFxuLy8gUHJldmVudCBhdXRvLWV4ZWN1dGlvbiBvZiBzY3JpcHRzIHdoZW4gbm8gZXhwbGljaXQgZGF0YVR5cGUgd2FzIHByb3ZpZGVkIChTZWUgZ2gtMjQzMilcXG5qUXVlcnkuYWpheFByZWZpbHRlciggZnVuY3Rpb24oIHMgKSB7XFxuXFx0aWYgKCBzLmNyb3NzRG9tYWluICkge1xcblxcdFxcdHMuY29udGVudHMuc2NyaXB0ID0gZmFsc2U7XFxuXFx0fVxcbn0gKTtcXG5cXG4vLyBJbnN0YWxsIHNjcmlwdCBkYXRhVHlwZVxcbmpRdWVyeS5hamF4U2V0dXAoIHtcXG5cXHRhY2NlcHRzOiB7XFxuXFx0XFx0c2NyaXB0OiBcXFwidGV4dC9qYXZhc2NyaXB0LCBhcHBsaWNhdGlvbi9qYXZhc2NyaXB0LCBcXFwiICtcXG5cXHRcXHRcXHRcXFwiYXBwbGljYXRpb24vZWNtYXNjcmlwdCwgYXBwbGljYXRpb24veC1lY21hc2NyaXB0XFxcIlxcblxcdH0sXFxuXFx0Y29udGVudHM6IHtcXG5cXHRcXHRzY3JpcHQ6IC9cXFxcYig/OmphdmF8ZWNtYSlzY3JpcHRcXFxcYi9cXG5cXHR9LFxcblxcdGNvbnZlcnRlcnM6IHtcXG5cXHRcXHRcXFwidGV4dCBzY3JpcHRcXFwiOiBmdW5jdGlvbiggdGV4dCApIHtcXG5cXHRcXHRcXHRqUXVlcnkuZ2xvYmFsRXZhbCggdGV4dCApO1xcblxcdFxcdFxcdHJldHVybiB0ZXh0O1xcblxcdFxcdH1cXG5cXHR9XFxufSApO1xcblxcbi8vIEhhbmRsZSBjYWNoZSdzIHNwZWNpYWwgY2FzZSBhbmQgY3Jvc3NEb21haW5cXG5qUXVlcnkuYWpheFByZWZpbHRlciggXFxcInNjcmlwdFxcXCIsIGZ1bmN0aW9uKCBzICkge1xcblxcdGlmICggcy5jYWNoZSA9PT0gdW5kZWZpbmVkICkge1xcblxcdFxcdHMuY2FjaGUgPSBmYWxzZTtcXG5cXHR9XFxuXFx0aWYgKCBzLmNyb3NzRG9tYWluICkge1xcblxcdFxcdHMudHlwZSA9IFxcXCJHRVRcXFwiO1xcblxcdH1cXG59ICk7XFxuXFxuLy8gQmluZCBzY3JpcHQgdGFnIGhhY2sgdHJhbnNwb3J0XFxualF1ZXJ5LmFqYXhUcmFuc3BvcnQoIFxcXCJzY3JpcHRcXFwiLCBmdW5jdGlvbiggcyApIHtcXG5cXG5cXHQvLyBUaGlzIHRyYW5zcG9ydCBvbmx5IGRlYWxzIHdpdGggY3Jvc3MgZG9tYWluIHJlcXVlc3RzXFxuXFx0aWYgKCBzLmNyb3NzRG9tYWluICkge1xcblxcdFxcdHZhciBzY3JpcHQsIGNhbGxiYWNrO1xcblxcdFxcdHJldHVybiB7XFxuXFx0XFx0XFx0c2VuZDogZnVuY3Rpb24oIF8sIGNvbXBsZXRlICkge1xcblxcdFxcdFxcdFxcdHNjcmlwdCA9IGpRdWVyeSggXFxcIjxzY3JpcHQ+XFxcIiApLnByb3AoIHtcXG5cXHRcXHRcXHRcXHRcXHRjaGFyc2V0OiBzLnNjcmlwdENoYXJzZXQsXFxuXFx0XFx0XFx0XFx0XFx0c3JjOiBzLnVybFxcblxcdFxcdFxcdFxcdH0gKS5vbihcXG5cXHRcXHRcXHRcXHRcXHRcXFwibG9hZCBlcnJvclxcXCIsXFxuXFx0XFx0XFx0XFx0XFx0Y2FsbGJhY2sgPSBmdW5jdGlvbiggZXZ0ICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHNjcmlwdC5yZW1vdmUoKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRjYWxsYmFjayA9IG51bGw7XFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBldnQgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Y29tcGxldGUoIGV2dC50eXBlID09PSBcXFwiZXJyb3JcXFwiID8gNDA0IDogMjAwLCBldnQudHlwZSApO1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0KTtcXG5cXG5cXHRcXHRcXHRcXHQvLyBVc2UgbmF0aXZlIERPTSBtYW5pcHVsYXRpb24gdG8gYXZvaWQgb3VyIGRvbU1hbmlwIEFKQVggdHJpY2tlcnlcXG5cXHRcXHRcXHRcXHRkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKCBzY3JpcHRbIDAgXSApO1xcblxcdFxcdFxcdH0sXFxuXFx0XFx0XFx0YWJvcnQ6IGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdFxcdGlmICggY2FsbGJhY2sgKSB7XFxuXFx0XFx0XFx0XFx0XFx0Y2FsbGJhY2soKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcdFxcdH07XFxuXFx0fVxcbn0gKTtcXG5cXG5cXG5cXG5cXG52YXIgb2xkQ2FsbGJhY2tzID0gW10sXFxuXFx0cmpzb25wID0gLyg9KVxcXFw/KD89JnwkKXxcXFxcP1xcXFw/LztcXG5cXG4vLyBEZWZhdWx0IGpzb25wIHNldHRpbmdzXFxualF1ZXJ5LmFqYXhTZXR1cCgge1xcblxcdGpzb25wOiBcXFwiY2FsbGJhY2tcXFwiLFxcblxcdGpzb25wQ2FsbGJhY2s6IGZ1bmN0aW9uKCkge1xcblxcdFxcdHZhciBjYWxsYmFjayA9IG9sZENhbGxiYWNrcy5wb3AoKSB8fCAoIGpRdWVyeS5leHBhbmRvICsgXFxcIl9cXFwiICsgKCBub25jZSsrICkgKTtcXG5cXHRcXHR0aGlzWyBjYWxsYmFjayBdID0gdHJ1ZTtcXG5cXHRcXHRyZXR1cm4gY2FsbGJhY2s7XFxuXFx0fVxcbn0gKTtcXG5cXG4vLyBEZXRlY3QsIG5vcm1hbGl6ZSBvcHRpb25zIGFuZCBpbnN0YWxsIGNhbGxiYWNrcyBmb3IganNvbnAgcmVxdWVzdHNcXG5qUXVlcnkuYWpheFByZWZpbHRlciggXFxcImpzb24ganNvbnBcXFwiLCBmdW5jdGlvbiggcywgb3JpZ2luYWxTZXR0aW5ncywganFYSFIgKSB7XFxuXFxuXFx0dmFyIGNhbGxiYWNrTmFtZSwgb3ZlcndyaXR0ZW4sIHJlc3BvbnNlQ29udGFpbmVyLFxcblxcdFxcdGpzb25Qcm9wID0gcy5qc29ucCAhPT0gZmFsc2UgJiYgKCByanNvbnAudGVzdCggcy51cmwgKSA/XFxuXFx0XFx0XFx0XFxcInVybFxcXCIgOlxcblxcdFxcdFxcdHR5cGVvZiBzLmRhdGEgPT09IFxcXCJzdHJpbmdcXFwiICYmXFxuXFx0XFx0XFx0XFx0KCBzLmNvbnRlbnRUeXBlIHx8IFxcXCJcXFwiIClcXG5cXHRcXHRcXHRcXHRcXHQuaW5kZXhPZiggXFxcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFxcXCIgKSA9PT0gMCAmJlxcblxcdFxcdFxcdFxcdHJqc29ucC50ZXN0KCBzLmRhdGEgKSAmJiBcXFwiZGF0YVxcXCJcXG5cXHRcXHQpO1xcblxcblxcdC8vIEhhbmRsZSBpZmYgdGhlIGV4cGVjdGVkIGRhdGEgdHlwZSBpcyBcXFwianNvbnBcXFwiIG9yIHdlIGhhdmUgYSBwYXJhbWV0ZXIgdG8gc2V0XFxuXFx0aWYgKCBqc29uUHJvcCB8fCBzLmRhdGFUeXBlc1sgMCBdID09PSBcXFwianNvbnBcXFwiICkge1xcblxcblxcdFxcdC8vIEdldCBjYWxsYmFjayBuYW1lLCByZW1lbWJlcmluZyBwcmVleGlzdGluZyB2YWx1ZSBhc3NvY2lhdGVkIHdpdGggaXRcXG5cXHRcXHRjYWxsYmFja05hbWUgPSBzLmpzb25wQ2FsbGJhY2sgPSBpc0Z1bmN0aW9uKCBzLmpzb25wQ2FsbGJhY2sgKSA/XFxuXFx0XFx0XFx0cy5qc29ucENhbGxiYWNrKCkgOlxcblxcdFxcdFxcdHMuanNvbnBDYWxsYmFjaztcXG5cXG5cXHRcXHQvLyBJbnNlcnQgY2FsbGJhY2sgaW50byB1cmwgb3IgZm9ybSBkYXRhXFxuXFx0XFx0aWYgKCBqc29uUHJvcCApIHtcXG5cXHRcXHRcXHRzWyBqc29uUHJvcCBdID0gc1sganNvblByb3AgXS5yZXBsYWNlKCByanNvbnAsIFxcXCIkMVxcXCIgKyBjYWxsYmFja05hbWUgKTtcXG5cXHRcXHR9IGVsc2UgaWYgKCBzLmpzb25wICE9PSBmYWxzZSApIHtcXG5cXHRcXHRcXHRzLnVybCArPSAoIHJxdWVyeS50ZXN0KCBzLnVybCApID8gXFxcIiZcXFwiIDogXFxcIj9cXFwiICkgKyBzLmpzb25wICsgXFxcIj1cXFwiICsgY2FsbGJhY2tOYW1lO1xcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBVc2UgZGF0YSBjb252ZXJ0ZXIgdG8gcmV0cmlldmUganNvbiBhZnRlciBzY3JpcHQgZXhlY3V0aW9uXFxuXFx0XFx0cy5jb252ZXJ0ZXJzWyBcXFwic2NyaXB0IGpzb25cXFwiIF0gPSBmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHRpZiAoICFyZXNwb25zZUNvbnRhaW5lciApIHtcXG5cXHRcXHRcXHRcXHRqUXVlcnkuZXJyb3IoIGNhbGxiYWNrTmFtZSArIFxcXCIgd2FzIG5vdCBjYWxsZWRcXFwiICk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHJldHVybiByZXNwb25zZUNvbnRhaW5lclsgMCBdO1xcblxcdFxcdH07XFxuXFxuXFx0XFx0Ly8gRm9yY2UganNvbiBkYXRhVHlwZVxcblxcdFxcdHMuZGF0YVR5cGVzWyAwIF0gPSBcXFwianNvblxcXCI7XFxuXFxuXFx0XFx0Ly8gSW5zdGFsbCBjYWxsYmFja1xcblxcdFxcdG92ZXJ3cml0dGVuID0gd2luZG93WyBjYWxsYmFja05hbWUgXTtcXG5cXHRcXHR3aW5kb3dbIGNhbGxiYWNrTmFtZSBdID0gZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0cmVzcG9uc2VDb250YWluZXIgPSBhcmd1bWVudHM7XFxuXFx0XFx0fTtcXG5cXG5cXHRcXHQvLyBDbGVhbi11cCBmdW5jdGlvbiAoZmlyZXMgYWZ0ZXIgY29udmVydGVycylcXG5cXHRcXHRqcVhIUi5hbHdheXMoIGZ1bmN0aW9uKCkge1xcblxcblxcdFxcdFxcdC8vIElmIHByZXZpb3VzIHZhbHVlIGRpZG4ndCBleGlzdCAtIHJlbW92ZSBpdFxcblxcdFxcdFxcdGlmICggb3ZlcndyaXR0ZW4gPT09IHVuZGVmaW5lZCApIHtcXG5cXHRcXHRcXHRcXHRqUXVlcnkoIHdpbmRvdyApLnJlbW92ZVByb3AoIGNhbGxiYWNrTmFtZSApO1xcblxcblxcdFxcdFxcdC8vIE90aGVyd2lzZSByZXN0b3JlIHByZWV4aXN0aW5nIHZhbHVlXFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHR3aW5kb3dbIGNhbGxiYWNrTmFtZSBdID0gb3ZlcndyaXR0ZW47XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIFNhdmUgYmFjayBhcyBmcmVlXFxuXFx0XFx0XFx0aWYgKCBzWyBjYWxsYmFja05hbWUgXSApIHtcXG5cXG5cXHRcXHRcXHRcXHQvLyBNYWtlIHN1cmUgdGhhdCByZS11c2luZyB0aGUgb3B0aW9ucyBkb2Vzbid0IHNjcmV3IHRoaW5ncyBhcm91bmRcXG5cXHRcXHRcXHRcXHRzLmpzb25wQ2FsbGJhY2sgPSBvcmlnaW5hbFNldHRpbmdzLmpzb25wQ2FsbGJhY2s7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gU2F2ZSB0aGUgY2FsbGJhY2sgbmFtZSBmb3IgZnV0dXJlIHVzZVxcblxcdFxcdFxcdFxcdG9sZENhbGxiYWNrcy5wdXNoKCBjYWxsYmFja05hbWUgKTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gQ2FsbCBpZiBpdCB3YXMgYSBmdW5jdGlvbiBhbmQgd2UgaGF2ZSBhIHJlc3BvbnNlXFxuXFx0XFx0XFx0aWYgKCByZXNwb25zZUNvbnRhaW5lciAmJiBpc0Z1bmN0aW9uKCBvdmVyd3JpdHRlbiApICkge1xcblxcdFxcdFxcdFxcdG92ZXJ3cml0dGVuKCByZXNwb25zZUNvbnRhaW5lclsgMCBdICk7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHJlc3BvbnNlQ29udGFpbmVyID0gb3ZlcndyaXR0ZW4gPSB1bmRlZmluZWQ7XFxuXFx0XFx0fSApO1xcblxcblxcdFxcdC8vIERlbGVnYXRlIHRvIHNjcmlwdFxcblxcdFxcdHJldHVybiBcXFwic2NyaXB0XFxcIjtcXG5cXHR9XFxufSApO1xcblxcblxcblxcblxcbi8vIFN1cHBvcnQ6IFNhZmFyaSA4IG9ubHlcXG4vLyBJbiBTYWZhcmkgOCBkb2N1bWVudHMgY3JlYXRlZCB2aWEgZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uY3JlYXRlSFRNTERvY3VtZW50XFxuLy8gY29sbGFwc2Ugc2libGluZyBmb3JtczogdGhlIHNlY29uZCBvbmUgYmVjb21lcyBhIGNoaWxkIG9mIHRoZSBmaXJzdCBvbmUuXFxuLy8gQmVjYXVzZSBvZiB0aGF0LCB0aGlzIHNlY3VyaXR5IG1lYXN1cmUgaGFzIHRvIGJlIGRpc2FibGVkIGluIFNhZmFyaSA4Llxcbi8vIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xMzczMzdcXG5zdXBwb3J0LmNyZWF0ZUhUTUxEb2N1bWVudCA9ICggZnVuY3Rpb24oKSB7XFxuXFx0dmFyIGJvZHkgPSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5jcmVhdGVIVE1MRG9jdW1lbnQoIFxcXCJcXFwiICkuYm9keTtcXG5cXHRib2R5LmlubmVySFRNTCA9IFxcXCI8Zm9ybT48L2Zvcm0+PGZvcm0+PC9mb3JtPlxcXCI7XFxuXFx0cmV0dXJuIGJvZHkuY2hpbGROb2Rlcy5sZW5ndGggPT09IDI7XFxufSApKCk7XFxuXFxuXFxuLy8gQXJndW1lbnQgXFxcImRhdGFcXFwiIHNob3VsZCBiZSBzdHJpbmcgb2YgaHRtbFxcbi8vIGNvbnRleHQgKG9wdGlvbmFsKTogSWYgc3BlY2lmaWVkLCB0aGUgZnJhZ21lbnQgd2lsbCBiZSBjcmVhdGVkIGluIHRoaXMgY29udGV4dCxcXG4vLyBkZWZhdWx0cyB0byBkb2N1bWVudFxcbi8vIGtlZXBTY3JpcHRzIChvcHRpb25hbCk6IElmIHRydWUsIHdpbGwgaW5jbHVkZSBzY3JpcHRzIHBhc3NlZCBpbiB0aGUgaHRtbCBzdHJpbmdcXG5qUXVlcnkucGFyc2VIVE1MID0gZnVuY3Rpb24oIGRhdGEsIGNvbnRleHQsIGtlZXBTY3JpcHRzICkge1xcblxcdGlmICggdHlwZW9mIGRhdGEgIT09IFxcXCJzdHJpbmdcXFwiICkge1xcblxcdFxcdHJldHVybiBbXTtcXG5cXHR9XFxuXFx0aWYgKCB0eXBlb2YgY29udGV4dCA9PT0gXFxcImJvb2xlYW5cXFwiICkge1xcblxcdFxcdGtlZXBTY3JpcHRzID0gY29udGV4dDtcXG5cXHRcXHRjb250ZXh0ID0gZmFsc2U7XFxuXFx0fVxcblxcblxcdHZhciBiYXNlLCBwYXJzZWQsIHNjcmlwdHM7XFxuXFxuXFx0aWYgKCAhY29udGV4dCApIHtcXG5cXG5cXHRcXHQvLyBTdG9wIHNjcmlwdHMgb3IgaW5saW5lIGV2ZW50IGhhbmRsZXJzIGZyb20gYmVpbmcgZXhlY3V0ZWQgaW1tZWRpYXRlbHlcXG5cXHRcXHQvLyBieSB1c2luZyBkb2N1bWVudC5pbXBsZW1lbnRhdGlvblxcblxcdFxcdGlmICggc3VwcG9ydC5jcmVhdGVIVE1MRG9jdW1lbnQgKSB7XFxuXFx0XFx0XFx0Y29udGV4dCA9IGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmNyZWF0ZUhUTUxEb2N1bWVudCggXFxcIlxcXCIgKTtcXG5cXG5cXHRcXHRcXHQvLyBTZXQgdGhlIGJhc2UgaHJlZiBmb3IgdGhlIGNyZWF0ZWQgZG9jdW1lbnRcXG5cXHRcXHRcXHQvLyBzbyBhbnkgcGFyc2VkIGVsZW1lbnRzIHdpdGggVVJMc1xcblxcdFxcdFxcdC8vIGFyZSBiYXNlZCBvbiB0aGUgZG9jdW1lbnQncyBVUkwgKGdoLTI5NjUpXFxuXFx0XFx0XFx0YmFzZSA9IGNvbnRleHQuY3JlYXRlRWxlbWVudCggXFxcImJhc2VcXFwiICk7XFxuXFx0XFx0XFx0YmFzZS5ocmVmID0gZG9jdW1lbnQubG9jYXRpb24uaHJlZjtcXG5cXHRcXHRcXHRjb250ZXh0LmhlYWQuYXBwZW5kQ2hpbGQoIGJhc2UgKTtcXG5cXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdGNvbnRleHQgPSBkb2N1bWVudDtcXG5cXHRcXHR9XFxuXFx0fVxcblxcblxcdHBhcnNlZCA9IHJzaW5nbGVUYWcuZXhlYyggZGF0YSApO1xcblxcdHNjcmlwdHMgPSAha2VlcFNjcmlwdHMgJiYgW107XFxuXFxuXFx0Ly8gU2luZ2xlIHRhZ1xcblxcdGlmICggcGFyc2VkICkge1xcblxcdFxcdHJldHVybiBbIGNvbnRleHQuY3JlYXRlRWxlbWVudCggcGFyc2VkWyAxIF0gKSBdO1xcblxcdH1cXG5cXG5cXHRwYXJzZWQgPSBidWlsZEZyYWdtZW50KCBbIGRhdGEgXSwgY29udGV4dCwgc2NyaXB0cyApO1xcblxcblxcdGlmICggc2NyaXB0cyAmJiBzY3JpcHRzLmxlbmd0aCApIHtcXG5cXHRcXHRqUXVlcnkoIHNjcmlwdHMgKS5yZW1vdmUoKTtcXG5cXHR9XFxuXFxuXFx0cmV0dXJuIGpRdWVyeS5tZXJnZSggW10sIHBhcnNlZC5jaGlsZE5vZGVzICk7XFxufTtcXG5cXG5cXG4vKipcXG4gKiBMb2FkIGEgdXJsIGludG8gYSBwYWdlXFxuICovXFxualF1ZXJ5LmZuLmxvYWQgPSBmdW5jdGlvbiggdXJsLCBwYXJhbXMsIGNhbGxiYWNrICkge1xcblxcdHZhciBzZWxlY3RvciwgdHlwZSwgcmVzcG9uc2UsXFxuXFx0XFx0c2VsZiA9IHRoaXMsXFxuXFx0XFx0b2ZmID0gdXJsLmluZGV4T2YoIFxcXCIgXFxcIiApO1xcblxcblxcdGlmICggb2ZmID4gLTEgKSB7XFxuXFx0XFx0c2VsZWN0b3IgPSBzdHJpcEFuZENvbGxhcHNlKCB1cmwuc2xpY2UoIG9mZiApICk7XFxuXFx0XFx0dXJsID0gdXJsLnNsaWNlKCAwLCBvZmYgKTtcXG5cXHR9XFxuXFxuXFx0Ly8gSWYgaXQncyBhIGZ1bmN0aW9uXFxuXFx0aWYgKCBpc0Z1bmN0aW9uKCBwYXJhbXMgKSApIHtcXG5cXG5cXHRcXHQvLyBXZSBhc3N1bWUgdGhhdCBpdCdzIHRoZSBjYWxsYmFja1xcblxcdFxcdGNhbGxiYWNrID0gcGFyYW1zO1xcblxcdFxcdHBhcmFtcyA9IHVuZGVmaW5lZDtcXG5cXG5cXHQvLyBPdGhlcndpc2UsIGJ1aWxkIGEgcGFyYW0gc3RyaW5nXFxuXFx0fSBlbHNlIGlmICggcGFyYW1zICYmIHR5cGVvZiBwYXJhbXMgPT09IFxcXCJvYmplY3RcXFwiICkge1xcblxcdFxcdHR5cGUgPSBcXFwiUE9TVFxcXCI7XFxuXFx0fVxcblxcblxcdC8vIElmIHdlIGhhdmUgZWxlbWVudHMgdG8gbW9kaWZ5LCBtYWtlIHRoZSByZXF1ZXN0XFxuXFx0aWYgKCBzZWxmLmxlbmd0aCA+IDAgKSB7XFxuXFx0XFx0alF1ZXJ5LmFqYXgoIHtcXG5cXHRcXHRcXHR1cmw6IHVybCxcXG5cXG5cXHRcXHRcXHQvLyBJZiBcXFwidHlwZVxcXCIgdmFyaWFibGUgaXMgdW5kZWZpbmVkLCB0aGVuIFxcXCJHRVRcXFwiIG1ldGhvZCB3aWxsIGJlIHVzZWQuXFxuXFx0XFx0XFx0Ly8gTWFrZSB2YWx1ZSBvZiB0aGlzIGZpZWxkIGV4cGxpY2l0IHNpbmNlXFxuXFx0XFx0XFx0Ly8gdXNlciBjYW4gb3ZlcnJpZGUgaXQgdGhyb3VnaCBhamF4U2V0dXAgbWV0aG9kXFxuXFx0XFx0XFx0dHlwZTogdHlwZSB8fCBcXFwiR0VUXFxcIixcXG5cXHRcXHRcXHRkYXRhVHlwZTogXFxcImh0bWxcXFwiLFxcblxcdFxcdFxcdGRhdGE6IHBhcmFtc1xcblxcdFxcdH0gKS5kb25lKCBmdW5jdGlvbiggcmVzcG9uc2VUZXh0ICkge1xcblxcblxcdFxcdFxcdC8vIFNhdmUgcmVzcG9uc2UgZm9yIHVzZSBpbiBjb21wbGV0ZSBjYWxsYmFja1xcblxcdFxcdFxcdHJlc3BvbnNlID0gYXJndW1lbnRzO1xcblxcblxcdFxcdFxcdHNlbGYuaHRtbCggc2VsZWN0b3IgP1xcblxcblxcdFxcdFxcdFxcdC8vIElmIGEgc2VsZWN0b3Igd2FzIHNwZWNpZmllZCwgbG9jYXRlIHRoZSByaWdodCBlbGVtZW50cyBpbiBhIGR1bW15IGRpdlxcblxcdFxcdFxcdFxcdC8vIEV4Y2x1ZGUgc2NyaXB0cyB0byBhdm9pZCBJRSAnUGVybWlzc2lvbiBEZW5pZWQnIGVycm9yc1xcblxcdFxcdFxcdFxcdGpRdWVyeSggXFxcIjxkaXY+XFxcIiApLmFwcGVuZCggalF1ZXJ5LnBhcnNlSFRNTCggcmVzcG9uc2VUZXh0ICkgKS5maW5kKCBzZWxlY3RvciApIDpcXG5cXG5cXHRcXHRcXHRcXHQvLyBPdGhlcndpc2UgdXNlIHRoZSBmdWxsIHJlc3VsdFxcblxcdFxcdFxcdFxcdHJlc3BvbnNlVGV4dCApO1xcblxcblxcdFxcdC8vIElmIHRoZSByZXF1ZXN0IHN1Y2NlZWRzLCB0aGlzIGZ1bmN0aW9uIGdldHMgXFxcImRhdGFcXFwiLCBcXFwic3RhdHVzXFxcIiwgXFxcImpxWEhSXFxcIlxcblxcdFxcdC8vIGJ1dCB0aGV5IGFyZSBpZ25vcmVkIGJlY2F1c2UgcmVzcG9uc2Ugd2FzIHNldCBhYm92ZS5cXG5cXHRcXHQvLyBJZiBpdCBmYWlscywgdGhpcyBmdW5jdGlvbiBnZXRzIFxcXCJqcVhIUlxcXCIsIFxcXCJzdGF0dXNcXFwiLCBcXFwiZXJyb3JcXFwiXFxuXFx0XFx0fSApLmFsd2F5cyggY2FsbGJhY2sgJiYgZnVuY3Rpb24oIGpxWEhSLCBzdGF0dXMgKSB7XFxuXFx0XFx0XFx0c2VsZi5lYWNoKCBmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHRcXHRjYWxsYmFjay5hcHBseSggdGhpcywgcmVzcG9uc2UgfHwgWyBqcVhIUi5yZXNwb25zZVRleHQsIHN0YXR1cywganFYSFIgXSApO1xcblxcdFxcdFxcdH0gKTtcXG5cXHRcXHR9ICk7XFxuXFx0fVxcblxcblxcdHJldHVybiB0aGlzO1xcbn07XFxuXFxuXFxuXFxuXFxuLy8gQXR0YWNoIGEgYnVuY2ggb2YgZnVuY3Rpb25zIGZvciBoYW5kbGluZyBjb21tb24gQUpBWCBldmVudHNcXG5qUXVlcnkuZWFjaCggW1xcblxcdFxcXCJhamF4U3RhcnRcXFwiLFxcblxcdFxcXCJhamF4U3RvcFxcXCIsXFxuXFx0XFxcImFqYXhDb21wbGV0ZVxcXCIsXFxuXFx0XFxcImFqYXhFcnJvclxcXCIsXFxuXFx0XFxcImFqYXhTdWNjZXNzXFxcIixcXG5cXHRcXFwiYWpheFNlbmRcXFwiXFxuXSwgZnVuY3Rpb24oIGksIHR5cGUgKSB7XFxuXFx0alF1ZXJ5LmZuWyB0eXBlIF0gPSBmdW5jdGlvbiggZm4gKSB7XFxuXFx0XFx0cmV0dXJuIHRoaXMub24oIHR5cGUsIGZuICk7XFxuXFx0fTtcXG59ICk7XFxuXFxuXFxuXFxuXFxualF1ZXJ5LmV4cHIucHNldWRvcy5hbmltYXRlZCA9IGZ1bmN0aW9uKCBlbGVtICkge1xcblxcdHJldHVybiBqUXVlcnkuZ3JlcCggalF1ZXJ5LnRpbWVycywgZnVuY3Rpb24oIGZuICkge1xcblxcdFxcdHJldHVybiBlbGVtID09PSBmbi5lbGVtO1xcblxcdH0gKS5sZW5ndGg7XFxufTtcXG5cXG5cXG5cXG5cXG5qUXVlcnkub2Zmc2V0ID0ge1xcblxcdHNldE9mZnNldDogZnVuY3Rpb24oIGVsZW0sIG9wdGlvbnMsIGkgKSB7XFxuXFx0XFx0dmFyIGN1clBvc2l0aW9uLCBjdXJMZWZ0LCBjdXJDU1NUb3AsIGN1clRvcCwgY3VyT2Zmc2V0LCBjdXJDU1NMZWZ0LCBjYWxjdWxhdGVQb3NpdGlvbixcXG5cXHRcXHRcXHRwb3NpdGlvbiA9IGpRdWVyeS5jc3MoIGVsZW0sIFxcXCJwb3NpdGlvblxcXCIgKSxcXG5cXHRcXHRcXHRjdXJFbGVtID0galF1ZXJ5KCBlbGVtICksXFxuXFx0XFx0XFx0cHJvcHMgPSB7fTtcXG5cXG5cXHRcXHQvLyBTZXQgcG9zaXRpb24gZmlyc3QsIGluLWNhc2UgdG9wL2xlZnQgYXJlIHNldCBldmVuIG9uIHN0YXRpYyBlbGVtXFxuXFx0XFx0aWYgKCBwb3NpdGlvbiA9PT0gXFxcInN0YXRpY1xcXCIgKSB7XFxuXFx0XFx0XFx0ZWxlbS5zdHlsZS5wb3NpdGlvbiA9IFxcXCJyZWxhdGl2ZVxcXCI7XFxuXFx0XFx0fVxcblxcblxcdFxcdGN1ck9mZnNldCA9IGN1ckVsZW0ub2Zmc2V0KCk7XFxuXFx0XFx0Y3VyQ1NTVG9wID0galF1ZXJ5LmNzcyggZWxlbSwgXFxcInRvcFxcXCIgKTtcXG5cXHRcXHRjdXJDU1NMZWZ0ID0galF1ZXJ5LmNzcyggZWxlbSwgXFxcImxlZnRcXFwiICk7XFxuXFx0XFx0Y2FsY3VsYXRlUG9zaXRpb24gPSAoIHBvc2l0aW9uID09PSBcXFwiYWJzb2x1dGVcXFwiIHx8IHBvc2l0aW9uID09PSBcXFwiZml4ZWRcXFwiICkgJiZcXG5cXHRcXHRcXHQoIGN1ckNTU1RvcCArIGN1ckNTU0xlZnQgKS5pbmRleE9mKCBcXFwiYXV0b1xcXCIgKSA+IC0xO1xcblxcblxcdFxcdC8vIE5lZWQgdG8gYmUgYWJsZSB0byBjYWxjdWxhdGUgcG9zaXRpb24gaWYgZWl0aGVyXFxuXFx0XFx0Ly8gdG9wIG9yIGxlZnQgaXMgYXV0byBhbmQgcG9zaXRpb24gaXMgZWl0aGVyIGFic29sdXRlIG9yIGZpeGVkXFxuXFx0XFx0aWYgKCBjYWxjdWxhdGVQb3NpdGlvbiApIHtcXG5cXHRcXHRcXHRjdXJQb3NpdGlvbiA9IGN1ckVsZW0ucG9zaXRpb24oKTtcXG5cXHRcXHRcXHRjdXJUb3AgPSBjdXJQb3NpdGlvbi50b3A7XFxuXFx0XFx0XFx0Y3VyTGVmdCA9IGN1clBvc2l0aW9uLmxlZnQ7XFxuXFxuXFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRjdXJUb3AgPSBwYXJzZUZsb2F0KCBjdXJDU1NUb3AgKSB8fCAwO1xcblxcdFxcdFxcdGN1ckxlZnQgPSBwYXJzZUZsb2F0KCBjdXJDU1NMZWZ0ICkgfHwgMDtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0aWYgKCBpc0Z1bmN0aW9uKCBvcHRpb25zICkgKSB7XFxuXFxuXFx0XFx0XFx0Ly8gVXNlIGpRdWVyeS5leHRlbmQgaGVyZSB0byBhbGxvdyBtb2RpZmljYXRpb24gb2YgY29vcmRpbmF0ZXMgYXJndW1lbnQgKGdoLTE4NDgpXFxuXFx0XFx0XFx0b3B0aW9ucyA9IG9wdGlvbnMuY2FsbCggZWxlbSwgaSwgalF1ZXJ5LmV4dGVuZCgge30sIGN1ck9mZnNldCApICk7XFxuXFx0XFx0fVxcblxcblxcdFxcdGlmICggb3B0aW9ucy50b3AgIT0gbnVsbCApIHtcXG5cXHRcXHRcXHRwcm9wcy50b3AgPSAoIG9wdGlvbnMudG9wIC0gY3VyT2Zmc2V0LnRvcCApICsgY3VyVG9wO1xcblxcdFxcdH1cXG5cXHRcXHRpZiAoIG9wdGlvbnMubGVmdCAhPSBudWxsICkge1xcblxcdFxcdFxcdHByb3BzLmxlZnQgPSAoIG9wdGlvbnMubGVmdCAtIGN1ck9mZnNldC5sZWZ0ICkgKyBjdXJMZWZ0O1xcblxcdFxcdH1cXG5cXG5cXHRcXHRpZiAoIFxcXCJ1c2luZ1xcXCIgaW4gb3B0aW9ucyApIHtcXG5cXHRcXHRcXHRvcHRpb25zLnVzaW5nLmNhbGwoIGVsZW0sIHByb3BzICk7XFxuXFxuXFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRjdXJFbGVtLmNzcyggcHJvcHMgKTtcXG5cXHRcXHR9XFxuXFx0fVxcbn07XFxuXFxualF1ZXJ5LmZuLmV4dGVuZCgge1xcblxcblxcdC8vIG9mZnNldCgpIHJlbGF0ZXMgYW4gZWxlbWVudCdzIGJvcmRlciBib3ggdG8gdGhlIGRvY3VtZW50IG9yaWdpblxcblxcdG9mZnNldDogZnVuY3Rpb24oIG9wdGlvbnMgKSB7XFxuXFxuXFx0XFx0Ly8gUHJlc2VydmUgY2hhaW5pbmcgZm9yIHNldHRlclxcblxcdFxcdGlmICggYXJndW1lbnRzLmxlbmd0aCApIHtcXG5cXHRcXHRcXHRyZXR1cm4gb3B0aW9ucyA9PT0gdW5kZWZpbmVkID9cXG5cXHRcXHRcXHRcXHR0aGlzIDpcXG5cXHRcXHRcXHRcXHR0aGlzLmVhY2goIGZ1bmN0aW9uKCBpICkge1xcblxcdFxcdFxcdFxcdFxcdGpRdWVyeS5vZmZzZXQuc2V0T2Zmc2V0KCB0aGlzLCBvcHRpb25zLCBpICk7XFxuXFx0XFx0XFx0XFx0fSApO1xcblxcdFxcdH1cXG5cXG5cXHRcXHR2YXIgcmVjdCwgd2luLFxcblxcdFxcdFxcdGVsZW0gPSB0aGlzWyAwIF07XFxuXFxuXFx0XFx0aWYgKCAhZWxlbSApIHtcXG5cXHRcXHRcXHRyZXR1cm47XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIFJldHVybiB6ZXJvcyBmb3IgZGlzY29ubmVjdGVkIGFuZCBoaWRkZW4gKGRpc3BsYXk6IG5vbmUpIGVsZW1lbnRzIChnaC0yMzEwKVxcblxcdFxcdC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seVxcblxcdFxcdC8vIFJ1bm5pbmcgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IG9uIGFcXG5cXHRcXHQvLyBkaXNjb25uZWN0ZWQgbm9kZSBpbiBJRSB0aHJvd3MgYW4gZXJyb3JcXG5cXHRcXHRpZiAoICFlbGVtLmdldENsaWVudFJlY3RzKCkubGVuZ3RoICkge1xcblxcdFxcdFxcdHJldHVybiB7IHRvcDogMCwgbGVmdDogMCB9O1xcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBHZXQgZG9jdW1lbnQtcmVsYXRpdmUgcG9zaXRpb24gYnkgYWRkaW5nIHZpZXdwb3J0IHNjcm9sbCB0byB2aWV3cG9ydC1yZWxhdGl2ZSBnQkNSXFxuXFx0XFx0cmVjdCA9IGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XFxuXFx0XFx0d2luID0gZWxlbS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3O1xcblxcdFxcdHJldHVybiB7XFxuXFx0XFx0XFx0dG9wOiByZWN0LnRvcCArIHdpbi5wYWdlWU9mZnNldCxcXG5cXHRcXHRcXHRsZWZ0OiByZWN0LmxlZnQgKyB3aW4ucGFnZVhPZmZzZXRcXG5cXHRcXHR9O1xcblxcdH0sXFxuXFxuXFx0Ly8gcG9zaXRpb24oKSByZWxhdGVzIGFuIGVsZW1lbnQncyBtYXJnaW4gYm94IHRvIGl0cyBvZmZzZXQgcGFyZW50J3MgcGFkZGluZyBib3hcXG5cXHQvLyBUaGlzIGNvcnJlc3BvbmRzIHRvIHRoZSBiZWhhdmlvciBvZiBDU1MgYWJzb2x1dGUgcG9zaXRpb25pbmdcXG5cXHRwb3NpdGlvbjogZnVuY3Rpb24oKSB7XFxuXFx0XFx0aWYgKCAhdGhpc1sgMCBdICkge1xcblxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0dmFyIG9mZnNldFBhcmVudCwgb2Zmc2V0LCBkb2MsXFxuXFx0XFx0XFx0ZWxlbSA9IHRoaXNbIDAgXSxcXG5cXHRcXHRcXHRwYXJlbnRPZmZzZXQgPSB7IHRvcDogMCwgbGVmdDogMCB9O1xcblxcblxcdFxcdC8vIHBvc2l0aW9uOmZpeGVkIGVsZW1lbnRzIGFyZSBvZmZzZXQgZnJvbSB0aGUgdmlld3BvcnQsIHdoaWNoIGl0c2VsZiBhbHdheXMgaGFzIHplcm8gb2Zmc2V0XFxuXFx0XFx0aWYgKCBqUXVlcnkuY3NzKCBlbGVtLCBcXFwicG9zaXRpb25cXFwiICkgPT09IFxcXCJmaXhlZFxcXCIgKSB7XFxuXFxuXFx0XFx0XFx0Ly8gQXNzdW1lIHBvc2l0aW9uOmZpeGVkIGltcGxpZXMgYXZhaWxhYmlsaXR5IG9mIGdldEJvdW5kaW5nQ2xpZW50UmVjdFxcblxcdFxcdFxcdG9mZnNldCA9IGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XFxuXFxuXFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRvZmZzZXQgPSB0aGlzLm9mZnNldCgpO1xcblxcblxcdFxcdFxcdC8vIEFjY291bnQgZm9yIHRoZSAqcmVhbCogb2Zmc2V0IHBhcmVudCwgd2hpY2ggY2FuIGJlIHRoZSBkb2N1bWVudCBvciBpdHMgcm9vdCBlbGVtZW50XFxuXFx0XFx0XFx0Ly8gd2hlbiBhIHN0YXRpY2FsbHkgcG9zaXRpb25lZCBlbGVtZW50IGlzIGlkZW50aWZpZWRcXG5cXHRcXHRcXHRkb2MgPSBlbGVtLm93bmVyRG9jdW1lbnQ7XFxuXFx0XFx0XFx0b2Zmc2V0UGFyZW50ID0gZWxlbS5vZmZzZXRQYXJlbnQgfHwgZG9jLmRvY3VtZW50RWxlbWVudDtcXG5cXHRcXHRcXHR3aGlsZSAoIG9mZnNldFBhcmVudCAmJlxcblxcdFxcdFxcdFxcdCggb2Zmc2V0UGFyZW50ID09PSBkb2MuYm9keSB8fCBvZmZzZXRQYXJlbnQgPT09IGRvYy5kb2N1bWVudEVsZW1lbnQgKSAmJlxcblxcdFxcdFxcdFxcdGpRdWVyeS5jc3MoIG9mZnNldFBhcmVudCwgXFxcInBvc2l0aW9uXFxcIiApID09PSBcXFwic3RhdGljXFxcIiApIHtcXG5cXG5cXHRcXHRcXHRcXHRvZmZzZXRQYXJlbnQgPSBvZmZzZXRQYXJlbnQucGFyZW50Tm9kZTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0aWYgKCBvZmZzZXRQYXJlbnQgJiYgb2Zmc2V0UGFyZW50ICE9PSBlbGVtICYmIG9mZnNldFBhcmVudC5ub2RlVHlwZSA9PT0gMSApIHtcXG5cXG5cXHRcXHRcXHRcXHQvLyBJbmNvcnBvcmF0ZSBib3JkZXJzIGludG8gaXRzIG9mZnNldCwgc2luY2UgdGhleSBhcmUgb3V0c2lkZSBpdHMgY29udGVudCBvcmlnaW5cXG5cXHRcXHRcXHRcXHRwYXJlbnRPZmZzZXQgPSBqUXVlcnkoIG9mZnNldFBhcmVudCApLm9mZnNldCgpO1xcblxcdFxcdFxcdFxcdHBhcmVudE9mZnNldC50b3AgKz0galF1ZXJ5LmNzcyggb2Zmc2V0UGFyZW50LCBcXFwiYm9yZGVyVG9wV2lkdGhcXFwiLCB0cnVlICk7XFxuXFx0XFx0XFx0XFx0cGFyZW50T2Zmc2V0LmxlZnQgKz0galF1ZXJ5LmNzcyggb2Zmc2V0UGFyZW50LCBcXFwiYm9yZGVyTGVmdFdpZHRoXFxcIiwgdHJ1ZSApO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gU3VidHJhY3QgcGFyZW50IG9mZnNldHMgYW5kIGVsZW1lbnQgbWFyZ2luc1xcblxcdFxcdHJldHVybiB7XFxuXFx0XFx0XFx0dG9wOiBvZmZzZXQudG9wIC0gcGFyZW50T2Zmc2V0LnRvcCAtIGpRdWVyeS5jc3MoIGVsZW0sIFxcXCJtYXJnaW5Ub3BcXFwiLCB0cnVlICksXFxuXFx0XFx0XFx0bGVmdDogb2Zmc2V0LmxlZnQgLSBwYXJlbnRPZmZzZXQubGVmdCAtIGpRdWVyeS5jc3MoIGVsZW0sIFxcXCJtYXJnaW5MZWZ0XFxcIiwgdHJ1ZSApXFxuXFx0XFx0fTtcXG5cXHR9LFxcblxcblxcdC8vIFRoaXMgbWV0aG9kIHdpbGwgcmV0dXJuIGRvY3VtZW50RWxlbWVudCBpbiB0aGUgZm9sbG93aW5nIGNhc2VzOlxcblxcdC8vIDEpIEZvciB0aGUgZWxlbWVudCBpbnNpZGUgdGhlIGlmcmFtZSB3aXRob3V0IG9mZnNldFBhcmVudCwgdGhpcyBtZXRob2Qgd2lsbCByZXR1cm5cXG5cXHQvLyAgICBkb2N1bWVudEVsZW1lbnQgb2YgdGhlIHBhcmVudCB3aW5kb3dcXG5cXHQvLyAyKSBGb3IgdGhlIGhpZGRlbiBvciBkZXRhY2hlZCBlbGVtZW50XFxuXFx0Ly8gMykgRm9yIGJvZHkgb3IgaHRtbCBlbGVtZW50LCBpLmUuIGluIGNhc2Ugb2YgdGhlIGh0bWwgbm9kZSAtIGl0IHdpbGwgcmV0dXJuIGl0c2VsZlxcblxcdC8vXFxuXFx0Ly8gYnV0IHRob3NlIGV4Y2VwdGlvbnMgd2VyZSBuZXZlciBwcmVzZW50ZWQgYXMgYSByZWFsIGxpZmUgdXNlLWNhc2VzXFxuXFx0Ly8gYW5kIG1pZ2h0IGJlIGNvbnNpZGVyZWQgYXMgbW9yZSBwcmVmZXJhYmxlIHJlc3VsdHMuXFxuXFx0Ly9cXG5cXHQvLyBUaGlzIGxvZ2ljLCBob3dldmVyLCBpcyBub3QgZ3VhcmFudGVlZCBhbmQgY2FuIGNoYW5nZSBhdCBhbnkgcG9pbnQgaW4gdGhlIGZ1dHVyZVxcblxcdG9mZnNldFBhcmVudDogZnVuY3Rpb24oKSB7XFxuXFx0XFx0cmV0dXJuIHRoaXMubWFwKCBmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHR2YXIgb2Zmc2V0UGFyZW50ID0gdGhpcy5vZmZzZXRQYXJlbnQ7XFxuXFxuXFx0XFx0XFx0d2hpbGUgKCBvZmZzZXRQYXJlbnQgJiYgalF1ZXJ5LmNzcyggb2Zmc2V0UGFyZW50LCBcXFwicG9zaXRpb25cXFwiICkgPT09IFxcXCJzdGF0aWNcXFwiICkge1xcblxcdFxcdFxcdFxcdG9mZnNldFBhcmVudCA9IG9mZnNldFBhcmVudC5vZmZzZXRQYXJlbnQ7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHJldHVybiBvZmZzZXRQYXJlbnQgfHwgZG9jdW1lbnRFbGVtZW50O1xcblxcdFxcdH0gKTtcXG5cXHR9XFxufSApO1xcblxcbi8vIENyZWF0ZSBzY3JvbGxMZWZ0IGFuZCBzY3JvbGxUb3AgbWV0aG9kc1xcbmpRdWVyeS5lYWNoKCB7IHNjcm9sbExlZnQ6IFxcXCJwYWdlWE9mZnNldFxcXCIsIHNjcm9sbFRvcDogXFxcInBhZ2VZT2Zmc2V0XFxcIiB9LCBmdW5jdGlvbiggbWV0aG9kLCBwcm9wICkge1xcblxcdHZhciB0b3AgPSBcXFwicGFnZVlPZmZzZXRcXFwiID09PSBwcm9wO1xcblxcblxcdGpRdWVyeS5mblsgbWV0aG9kIF0gPSBmdW5jdGlvbiggdmFsICkge1xcblxcdFxcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCBlbGVtLCBtZXRob2QsIHZhbCApIHtcXG5cXG5cXHRcXHRcXHQvLyBDb2FsZXNjZSBkb2N1bWVudHMgYW5kIHdpbmRvd3NcXG5cXHRcXHRcXHR2YXIgd2luO1xcblxcdFxcdFxcdGlmICggaXNXaW5kb3coIGVsZW0gKSApIHtcXG5cXHRcXHRcXHRcXHR3aW4gPSBlbGVtO1xcblxcdFxcdFxcdH0gZWxzZSBpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDkgKSB7XFxuXFx0XFx0XFx0XFx0d2luID0gZWxlbS5kZWZhdWx0VmlldztcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKCB2YWwgPT09IHVuZGVmaW5lZCApIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gd2luID8gd2luWyBwcm9wIF0gOiBlbGVtWyBtZXRob2QgXTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKCB3aW4gKSB7XFxuXFx0XFx0XFx0XFx0d2luLnNjcm9sbFRvKFxcblxcdFxcdFxcdFxcdFxcdCF0b3AgPyB2YWwgOiB3aW4ucGFnZVhPZmZzZXQsXFxuXFx0XFx0XFx0XFx0XFx0dG9wID8gdmFsIDogd2luLnBhZ2VZT2Zmc2V0XFxuXFx0XFx0XFx0XFx0KTtcXG5cXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdGVsZW1bIG1ldGhvZCBdID0gdmFsO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9LCBtZXRob2QsIHZhbCwgYXJndW1lbnRzLmxlbmd0aCApO1xcblxcdH07XFxufSApO1xcblxcbi8vIFN1cHBvcnQ6IFNhZmFyaSA8PTcgLSA5LjEsIENocm9tZSA8PTM3IC0gNDlcXG4vLyBBZGQgdGhlIHRvcC9sZWZ0IGNzc0hvb2tzIHVzaW5nIGpRdWVyeS5mbi5wb3NpdGlvblxcbi8vIFdlYmtpdCBidWc6IGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0yOTA4NFxcbi8vIEJsaW5rIGJ1ZzogaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NTg5MzQ3XFxuLy8gZ2V0Q29tcHV0ZWRTdHlsZSByZXR1cm5zIHBlcmNlbnQgd2hlbiBzcGVjaWZpZWQgZm9yIHRvcC9sZWZ0L2JvdHRvbS9yaWdodDtcXG4vLyByYXRoZXIgdGhhbiBtYWtlIHRoZSBjc3MgbW9kdWxlIGRlcGVuZCBvbiB0aGUgb2Zmc2V0IG1vZHVsZSwganVzdCBjaGVjayBmb3IgaXQgaGVyZVxcbmpRdWVyeS5lYWNoKCBbIFxcXCJ0b3BcXFwiLCBcXFwibGVmdFxcXCIgXSwgZnVuY3Rpb24oIGksIHByb3AgKSB7XFxuXFx0alF1ZXJ5LmNzc0hvb2tzWyBwcm9wIF0gPSBhZGRHZXRIb29rSWYoIHN1cHBvcnQucGl4ZWxQb3NpdGlvbixcXG5cXHRcXHRmdW5jdGlvbiggZWxlbSwgY29tcHV0ZWQgKSB7XFxuXFx0XFx0XFx0aWYgKCBjb21wdXRlZCApIHtcXG5cXHRcXHRcXHRcXHRjb21wdXRlZCA9IGN1ckNTUyggZWxlbSwgcHJvcCApO1xcblxcblxcdFxcdFxcdFxcdC8vIElmIGN1ckNTUyByZXR1cm5zIHBlcmNlbnRhZ2UsIGZhbGxiYWNrIHRvIG9mZnNldFxcblxcdFxcdFxcdFxcdHJldHVybiBybnVtbm9ucHgudGVzdCggY29tcHV0ZWQgKSA/XFxuXFx0XFx0XFx0XFx0XFx0alF1ZXJ5KCBlbGVtICkucG9zaXRpb24oKVsgcHJvcCBdICsgXFxcInB4XFxcIiA6XFxuXFx0XFx0XFx0XFx0XFx0Y29tcHV0ZWQ7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXHQpO1xcbn0gKTtcXG5cXG5cXG4vLyBDcmVhdGUgaW5uZXJIZWlnaHQsIGlubmVyV2lkdGgsIGhlaWdodCwgd2lkdGgsIG91dGVySGVpZ2h0IGFuZCBvdXRlcldpZHRoIG1ldGhvZHNcXG5qUXVlcnkuZWFjaCggeyBIZWlnaHQ6IFxcXCJoZWlnaHRcXFwiLCBXaWR0aDogXFxcIndpZHRoXFxcIiB9LCBmdW5jdGlvbiggbmFtZSwgdHlwZSApIHtcXG5cXHRqUXVlcnkuZWFjaCggeyBwYWRkaW5nOiBcXFwiaW5uZXJcXFwiICsgbmFtZSwgY29udGVudDogdHlwZSwgXFxcIlxcXCI6IFxcXCJvdXRlclxcXCIgKyBuYW1lIH0sXFxuXFx0XFx0ZnVuY3Rpb24oIGRlZmF1bHRFeHRyYSwgZnVuY05hbWUgKSB7XFxuXFxuXFx0XFx0Ly8gTWFyZ2luIGlzIG9ubHkgZm9yIG91dGVySGVpZ2h0LCBvdXRlcldpZHRoXFxuXFx0XFx0alF1ZXJ5LmZuWyBmdW5jTmFtZSBdID0gZnVuY3Rpb24oIG1hcmdpbiwgdmFsdWUgKSB7XFxuXFx0XFx0XFx0dmFyIGNoYWluYWJsZSA9IGFyZ3VtZW50cy5sZW5ndGggJiYgKCBkZWZhdWx0RXh0cmEgfHwgdHlwZW9mIG1hcmdpbiAhPT0gXFxcImJvb2xlYW5cXFwiICksXFxuXFx0XFx0XFx0XFx0ZXh0cmEgPSBkZWZhdWx0RXh0cmEgfHwgKCBtYXJnaW4gPT09IHRydWUgfHwgdmFsdWUgPT09IHRydWUgPyBcXFwibWFyZ2luXFxcIiA6IFxcXCJib3JkZXJcXFwiICk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIGVsZW0sIHR5cGUsIHZhbHVlICkge1xcblxcdFxcdFxcdFxcdHZhciBkb2M7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBpc1dpbmRvdyggZWxlbSApICkge1xcblxcblxcdFxcdFxcdFxcdFxcdC8vICQoIHdpbmRvdyApLm91dGVyV2lkdGgvSGVpZ2h0IHJldHVybiB3L2ggaW5jbHVkaW5nIHNjcm9sbGJhcnMgKGdoLTE3MjkpXFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIGZ1bmNOYW1lLmluZGV4T2YoIFxcXCJvdXRlclxcXCIgKSA9PT0gMCA/XFxuXFx0XFx0XFx0XFx0XFx0XFx0ZWxlbVsgXFxcImlubmVyXFxcIiArIG5hbWUgXSA6XFxuXFx0XFx0XFx0XFx0XFx0XFx0ZWxlbS5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnRbIFxcXCJjbGllbnRcXFwiICsgbmFtZSBdO1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHQvLyBHZXQgZG9jdW1lbnQgd2lkdGggb3IgaGVpZ2h0XFxuXFx0XFx0XFx0XFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSA5ICkge1xcblxcdFxcdFxcdFxcdFxcdGRvYyA9IGVsZW0uZG9jdW1lbnRFbGVtZW50O1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIEVpdGhlciBzY3JvbGxbV2lkdGgvSGVpZ2h0XSBvciBvZmZzZXRbV2lkdGgvSGVpZ2h0XSBvciBjbGllbnRbV2lkdGgvSGVpZ2h0XSxcXG5cXHRcXHRcXHRcXHRcXHQvLyB3aGljaGV2ZXIgaXMgZ3JlYXRlc3RcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gTWF0aC5tYXgoXFxuXFx0XFx0XFx0XFx0XFx0XFx0ZWxlbS5ib2R5WyBcXFwic2Nyb2xsXFxcIiArIG5hbWUgXSwgZG9jWyBcXFwic2Nyb2xsXFxcIiArIG5hbWUgXSxcXG5cXHRcXHRcXHRcXHRcXHRcXHRlbGVtLmJvZHlbIFxcXCJvZmZzZXRcXFwiICsgbmFtZSBdLCBkb2NbIFxcXCJvZmZzZXRcXFwiICsgbmFtZSBdLFxcblxcdFxcdFxcdFxcdFxcdFxcdGRvY1sgXFxcImNsaWVudFxcXCIgKyBuYW1lIF1cXG5cXHRcXHRcXHRcXHRcXHQpO1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRyZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gR2V0IHdpZHRoIG9yIGhlaWdodCBvbiB0aGUgZWxlbWVudCwgcmVxdWVzdGluZyBidXQgbm90IGZvcmNpbmcgcGFyc2VGbG9hdFxcblxcdFxcdFxcdFxcdFxcdGpRdWVyeS5jc3MoIGVsZW0sIHR5cGUsIGV4dHJhICkgOlxcblxcblxcdFxcdFxcdFxcdFxcdC8vIFNldCB3aWR0aCBvciBoZWlnaHQgb24gdGhlIGVsZW1lbnRcXG5cXHRcXHRcXHRcXHRcXHRqUXVlcnkuc3R5bGUoIGVsZW0sIHR5cGUsIHZhbHVlLCBleHRyYSApO1xcblxcdFxcdFxcdH0sIHR5cGUsIGNoYWluYWJsZSA/IG1hcmdpbiA6IHVuZGVmaW5lZCwgY2hhaW5hYmxlICk7XFxuXFx0XFx0fTtcXG5cXHR9ICk7XFxufSApO1xcblxcblxcbmpRdWVyeS5lYWNoKCAoIFxcXCJibHVyIGZvY3VzIGZvY3VzaW4gZm9jdXNvdXQgcmVzaXplIHNjcm9sbCBjbGljayBkYmxjbGljayBcXFwiICtcXG5cXHRcXFwibW91c2Vkb3duIG1vdXNldXAgbW91c2Vtb3ZlIG1vdXNlb3ZlciBtb3VzZW91dCBtb3VzZWVudGVyIG1vdXNlbGVhdmUgXFxcIiArXFxuXFx0XFxcImNoYW5nZSBzZWxlY3Qgc3VibWl0IGtleWRvd24ga2V5cHJlc3Mga2V5dXAgY29udGV4dG1lbnVcXFwiICkuc3BsaXQoIFxcXCIgXFxcIiApLFxcblxcdGZ1bmN0aW9uKCBpLCBuYW1lICkge1xcblxcblxcdC8vIEhhbmRsZSBldmVudCBiaW5kaW5nXFxuXFx0alF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggZGF0YSwgZm4gKSB7XFxuXFx0XFx0cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPiAwID9cXG5cXHRcXHRcXHR0aGlzLm9uKCBuYW1lLCBudWxsLCBkYXRhLCBmbiApIDpcXG5cXHRcXHRcXHR0aGlzLnRyaWdnZXIoIG5hbWUgKTtcXG5cXHR9O1xcbn0gKTtcXG5cXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XFxuXFx0aG92ZXI6IGZ1bmN0aW9uKCBmbk92ZXIsIGZuT3V0ICkge1xcblxcdFxcdHJldHVybiB0aGlzLm1vdXNlZW50ZXIoIGZuT3ZlciApLm1vdXNlbGVhdmUoIGZuT3V0IHx8IGZuT3ZlciApO1xcblxcdH1cXG59ICk7XFxuXFxuXFxuXFxuXFxualF1ZXJ5LmZuLmV4dGVuZCgge1xcblxcblxcdGJpbmQ6IGZ1bmN0aW9uKCB0eXBlcywgZGF0YSwgZm4gKSB7XFxuXFx0XFx0cmV0dXJuIHRoaXMub24oIHR5cGVzLCBudWxsLCBkYXRhLCBmbiApO1xcblxcdH0sXFxuXFx0dW5iaW5kOiBmdW5jdGlvbiggdHlwZXMsIGZuICkge1xcblxcdFxcdHJldHVybiB0aGlzLm9mZiggdHlwZXMsIG51bGwsIGZuICk7XFxuXFx0fSxcXG5cXG5cXHRkZWxlZ2F0ZTogZnVuY3Rpb24oIHNlbGVjdG9yLCB0eXBlcywgZGF0YSwgZm4gKSB7XFxuXFx0XFx0cmV0dXJuIHRoaXMub24oIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4gKTtcXG5cXHR9LFxcblxcdHVuZGVsZWdhdGU6IGZ1bmN0aW9uKCBzZWxlY3RvciwgdHlwZXMsIGZuICkge1xcblxcblxcdFxcdC8vICggbmFtZXNwYWNlICkgb3IgKCBzZWxlY3RvciwgdHlwZXMgWywgZm5dIClcXG5cXHRcXHRyZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA9PT0gMSA/XFxuXFx0XFx0XFx0dGhpcy5vZmYoIHNlbGVjdG9yLCBcXFwiKipcXFwiICkgOlxcblxcdFxcdFxcdHRoaXMub2ZmKCB0eXBlcywgc2VsZWN0b3IgfHwgXFxcIioqXFxcIiwgZm4gKTtcXG5cXHR9XFxufSApO1xcblxcbi8vIEJpbmQgYSBmdW5jdGlvbiB0byBhIGNvbnRleHQsIG9wdGlvbmFsbHkgcGFydGlhbGx5IGFwcGx5aW5nIGFueVxcbi8vIGFyZ3VtZW50cy5cXG4vLyBqUXVlcnkucHJveHkgaXMgZGVwcmVjYXRlZCB0byBwcm9tb3RlIHN0YW5kYXJkcyAoc3BlY2lmaWNhbGx5IEZ1bmN0aW9uI2JpbmQpXFxuLy8gSG93ZXZlciwgaXQgaXMgbm90IHNsYXRlZCBmb3IgcmVtb3ZhbCBhbnkgdGltZSBzb29uXFxualF1ZXJ5LnByb3h5ID0gZnVuY3Rpb24oIGZuLCBjb250ZXh0ICkge1xcblxcdHZhciB0bXAsIGFyZ3MsIHByb3h5O1xcblxcblxcdGlmICggdHlwZW9mIGNvbnRleHQgPT09IFxcXCJzdHJpbmdcXFwiICkge1xcblxcdFxcdHRtcCA9IGZuWyBjb250ZXh0IF07XFxuXFx0XFx0Y29udGV4dCA9IGZuO1xcblxcdFxcdGZuID0gdG1wO1xcblxcdH1cXG5cXG5cXHQvLyBRdWljayBjaGVjayB0byBkZXRlcm1pbmUgaWYgdGFyZ2V0IGlzIGNhbGxhYmxlLCBpbiB0aGUgc3BlY1xcblxcdC8vIHRoaXMgdGhyb3dzIGEgVHlwZUVycm9yLCBidXQgd2Ugd2lsbCBqdXN0IHJldHVybiB1bmRlZmluZWQuXFxuXFx0aWYgKCAhaXNGdW5jdGlvbiggZm4gKSApIHtcXG5cXHRcXHRyZXR1cm4gdW5kZWZpbmVkO1xcblxcdH1cXG5cXG5cXHQvLyBTaW11bGF0ZWQgYmluZFxcblxcdGFyZ3MgPSBzbGljZS5jYWxsKCBhcmd1bWVudHMsIDIgKTtcXG5cXHRwcm94eSA9IGZ1bmN0aW9uKCkge1xcblxcdFxcdHJldHVybiBmbi5hcHBseSggY29udGV4dCB8fCB0aGlzLCBhcmdzLmNvbmNhdCggc2xpY2UuY2FsbCggYXJndW1lbnRzICkgKSApO1xcblxcdH07XFxuXFxuXFx0Ly8gU2V0IHRoZSBndWlkIG9mIHVuaXF1ZSBoYW5kbGVyIHRvIHRoZSBzYW1lIG9mIG9yaWdpbmFsIGhhbmRsZXIsIHNvIGl0IGNhbiBiZSByZW1vdmVkXFxuXFx0cHJveHkuZ3VpZCA9IGZuLmd1aWQgPSBmbi5ndWlkIHx8IGpRdWVyeS5ndWlkKys7XFxuXFxuXFx0cmV0dXJuIHByb3h5O1xcbn07XFxuXFxualF1ZXJ5LmhvbGRSZWFkeSA9IGZ1bmN0aW9uKCBob2xkICkge1xcblxcdGlmICggaG9sZCApIHtcXG5cXHRcXHRqUXVlcnkucmVhZHlXYWl0Kys7XFxuXFx0fSBlbHNlIHtcXG5cXHRcXHRqUXVlcnkucmVhZHkoIHRydWUgKTtcXG5cXHR9XFxufTtcXG5qUXVlcnkuaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XFxualF1ZXJ5LnBhcnNlSlNPTiA9IEpTT04ucGFyc2U7XFxualF1ZXJ5Lm5vZGVOYW1lID0gbm9kZU5hbWU7XFxualF1ZXJ5LmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xcbmpRdWVyeS5pc1dpbmRvdyA9IGlzV2luZG93O1xcbmpRdWVyeS5jYW1lbENhc2UgPSBjYW1lbENhc2U7XFxualF1ZXJ5LnR5cGUgPSB0b1R5cGU7XFxuXFxualF1ZXJ5Lm5vdyA9IERhdGUubm93O1xcblxcbmpRdWVyeS5pc051bWVyaWMgPSBmdW5jdGlvbiggb2JqICkge1xcblxcblxcdC8vIEFzIG9mIGpRdWVyeSAzLjAsIGlzTnVtZXJpYyBpcyBsaW1pdGVkIHRvXFxuXFx0Ly8gc3RyaW5ncyBhbmQgbnVtYmVycyAocHJpbWl0aXZlcyBvciBvYmplY3RzKVxcblxcdC8vIHRoYXQgY2FuIGJlIGNvZXJjZWQgdG8gZmluaXRlIG51bWJlcnMgKGdoLTI2NjIpXFxuXFx0dmFyIHR5cGUgPSBqUXVlcnkudHlwZSggb2JqICk7XFxuXFx0cmV0dXJuICggdHlwZSA9PT0gXFxcIm51bWJlclxcXCIgfHwgdHlwZSA9PT0gXFxcInN0cmluZ1xcXCIgKSAmJlxcblxcblxcdFxcdC8vIHBhcnNlRmxvYXQgTmFOcyBudW1lcmljLWNhc3QgZmFsc2UgcG9zaXRpdmVzIChcXFwiXFxcIilcXG5cXHRcXHQvLyAuLi5idXQgbWlzaW50ZXJwcmV0cyBsZWFkaW5nLW51bWJlciBzdHJpbmdzLCBwYXJ0aWN1bGFybHkgaGV4IGxpdGVyYWxzIChcXFwiMHguLi5cXFwiKVxcblxcdFxcdC8vIHN1YnRyYWN0aW9uIGZvcmNlcyBpbmZpbml0aWVzIHRvIE5hTlxcblxcdFxcdCFpc05hTiggb2JqIC0gcGFyc2VGbG9hdCggb2JqICkgKTtcXG59O1xcblxcblxcblxcblxcbi8vIFJlZ2lzdGVyIGFzIGEgbmFtZWQgQU1EIG1vZHVsZSwgc2luY2UgalF1ZXJ5IGNhbiBiZSBjb25jYXRlbmF0ZWQgd2l0aCBvdGhlclxcbi8vIGZpbGVzIHRoYXQgbWF5IHVzZSBkZWZpbmUsIGJ1dCBub3QgdmlhIGEgcHJvcGVyIGNvbmNhdGVuYXRpb24gc2NyaXB0IHRoYXRcXG4vLyB1bmRlcnN0YW5kcyBhbm9ueW1vdXMgQU1EIG1vZHVsZXMuIEEgbmFtZWQgQU1EIGlzIHNhZmVzdCBhbmQgbW9zdCByb2J1c3RcXG4vLyB3YXkgdG8gcmVnaXN0ZXIuIExvd2VyY2FzZSBqcXVlcnkgaXMgdXNlZCBiZWNhdXNlIEFNRCBtb2R1bGUgbmFtZXMgYXJlXFxuLy8gZGVyaXZlZCBmcm9tIGZpbGUgbmFtZXMsIGFuZCBqUXVlcnkgaXMgbm9ybWFsbHkgZGVsaXZlcmVkIGluIGEgbG93ZXJjYXNlXFxuLy8gZmlsZSBuYW1lLiBEbyB0aGlzIGFmdGVyIGNyZWF0aW5nIHRoZSBnbG9iYWwgc28gdGhhdCBpZiBhbiBBTUQgbW9kdWxlIHdhbnRzXFxuLy8gdG8gY2FsbCBub0NvbmZsaWN0IHRvIGhpZGUgdGhpcyB2ZXJzaW9uIG9mIGpRdWVyeSwgaXQgd2lsbCB3b3JrLlxcblxcbi8vIE5vdGUgdGhhdCBmb3IgbWF4aW11bSBwb3J0YWJpbGl0eSwgbGlicmFyaWVzIHRoYXQgYXJlIG5vdCBqUXVlcnkgc2hvdWxkXFxuLy8gZGVjbGFyZSB0aGVtc2VsdmVzIGFzIGFub255bW91cyBtb2R1bGVzLCBhbmQgYXZvaWQgc2V0dGluZyBhIGdsb2JhbCBpZiBhblxcbi8vIEFNRCBsb2FkZXIgaXMgcHJlc2VudC4galF1ZXJ5IGlzIGEgc3BlY2lhbCBjYXNlLiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgc2VlXFxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2pyYnVya2UvcmVxdWlyZWpzL3dpa2kvVXBkYXRpbmctZXhpc3RpbmctbGlicmFyaWVzI3dpa2ktYW5vblxcblxcbmlmICggdHJ1ZSApIHtcXG5cXHQhKF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18gPSBbXSwgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gPSBmdW5jdGlvbigpIHtcXG5cXHRcXHRyZXR1cm4galF1ZXJ5O1xcblxcdH0uYXBwbHkoZXhwb3J0cywgX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXyksXFxuXFx0XFx0XFx0XFx0X19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gIT09IHVuZGVmaW5lZCAmJiAobW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXykpO1xcbn1cXG5cXG5cXG5cXG5cXG52YXJcXG5cXG5cXHQvLyBNYXAgb3ZlciBqUXVlcnkgaW4gY2FzZSBvZiBvdmVyd3JpdGVcXG5cXHRfalF1ZXJ5ID0gd2luZG93LmpRdWVyeSxcXG5cXG5cXHQvLyBNYXAgb3ZlciB0aGUgJCBpbiBjYXNlIG9mIG92ZXJ3cml0ZVxcblxcdF8kID0gd2luZG93LiQ7XFxuXFxualF1ZXJ5Lm5vQ29uZmxpY3QgPSBmdW5jdGlvbiggZGVlcCApIHtcXG5cXHRpZiAoIHdpbmRvdy4kID09PSBqUXVlcnkgKSB7XFxuXFx0XFx0d2luZG93LiQgPSBfJDtcXG5cXHR9XFxuXFxuXFx0aWYgKCBkZWVwICYmIHdpbmRvdy5qUXVlcnkgPT09IGpRdWVyeSApIHtcXG5cXHRcXHR3aW5kb3cualF1ZXJ5ID0gX2pRdWVyeTtcXG5cXHR9XFxuXFxuXFx0cmV0dXJuIGpRdWVyeTtcXG59O1xcblxcbi8vIEV4cG9zZSBqUXVlcnkgYW5kICQgaWRlbnRpZmllcnMsIGV2ZW4gaW4gQU1EXFxuLy8gKCM3MTAyI2NvbW1lbnQ6MTAsIGh0dHBzOi8vZ2l0aHViLmNvbS9qcXVlcnkvanF1ZXJ5L3B1bGwvNTU3KVxcbi8vIGFuZCBDb21tb25KUyBmb3IgYnJvd3NlciBlbXVsYXRvcnMgKCMxMzU2NilcXG5pZiAoICFub0dsb2JhbCApIHtcXG5cXHR3aW5kb3cualF1ZXJ5ID0gd2luZG93LiQgPSBqUXVlcnk7XFxufVxcblxcblxcblxcblxcbnJldHVybiBqUXVlcnk7XFxufSApO1xcblxcblxcbi8vLy8vLy8vLy8vLy8vLy8vL1xcbi8vIFdFQlBBQ0sgRk9PVEVSXFxuLy8gLi9+L2pxdWVyeS9kaXN0L2pxdWVyeS5qc1xcbi8vIG1vZHVsZSBpZCA9IDFcXG4vLyBtb2R1bGUgY2h1bmtzID0gMFxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL34vanF1ZXJ5L2Rpc3QvanF1ZXJ5LmpzP1wiKTtcblxuLyoqKi8gfSksXG4vKiAyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuZXZhbChcIlxcblxcbi8qKlxcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxcbiAqXFxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXFxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxcbiAqXFxuICogXFxuICovXFxuXFxuZnVuY3Rpb24gbWFrZUVtcHR5RnVuY3Rpb24oYXJnKSB7XFxuICByZXR1cm4gZnVuY3Rpb24gKCkge1xcbiAgICByZXR1cm4gYXJnO1xcbiAgfTtcXG59XFxuXFxuLyoqXFxuICogVGhpcyBmdW5jdGlvbiBhY2NlcHRzIGFuZCBkaXNjYXJkcyBpbnB1dHM7IGl0IGhhcyBubyBzaWRlIGVmZmVjdHMuIFRoaXMgaXNcXG4gKiBwcmltYXJpbHkgdXNlZnVsIGlkaW9tYXRpY2FsbHkgZm9yIG92ZXJyaWRhYmxlIGZ1bmN0aW9uIGVuZHBvaW50cyB3aGljaFxcbiAqIGFsd2F5cyBuZWVkIHRvIGJlIGNhbGxhYmxlLCBzaW5jZSBKUyBsYWNrcyBhIG51bGwtY2FsbCBpZGlvbSBhbGEgQ29jb2EuXFxuICovXFxudmFyIGVtcHR5RnVuY3Rpb24gPSBmdW5jdGlvbiBlbXB0eUZ1bmN0aW9uKCkge307XFxuXFxuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJucyA9IG1ha2VFbXB0eUZ1bmN0aW9uO1xcbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNGYWxzZSA9IG1ha2VFbXB0eUZ1bmN0aW9uKGZhbHNlKTtcXG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zVHJ1ZSA9IG1ha2VFbXB0eUZ1bmN0aW9uKHRydWUpO1xcbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNOdWxsID0gbWFrZUVtcHR5RnVuY3Rpb24obnVsbCk7XFxuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc1RoaXMgPSBmdW5jdGlvbiAoKSB7XFxuICByZXR1cm4gdGhpcztcXG59O1xcbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNBcmd1bWVudCA9IGZ1bmN0aW9uIChhcmcpIHtcXG4gIHJldHVybiBhcmc7XFxufTtcXG5cXG5tb2R1bGUuZXhwb3J0cyA9IGVtcHR5RnVuY3Rpb247XFxuXFxuLy8vLy8vLy8vLy8vLy8vLy8vXFxuLy8gV0VCUEFDSyBGT09URVJcXG4vLyAuL34vZmJqcy9saWIvZW1wdHlGdW5jdGlvbi5qc1xcbi8vIG1vZHVsZSBpZCA9IDJcXG4vLyBtb2R1bGUgY2h1bmtzID0gMFxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL34vZmJqcy9saWIvZW1wdHlGdW5jdGlvbi5qcz9cIik7XG5cbi8qKiovIH0pLFxuLyogMyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbmV2YWwoXCIvKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi8oZnVuY3Rpb24ocHJvY2Vzcykgey8qKlxcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxcbiAqXFxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXFxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxcbiAqXFxuICovXFxuXFxuXFxuXFxuLyoqXFxuICogVXNlIGludmFyaWFudCgpIHRvIGFzc2VydCBzdGF0ZSB3aGljaCB5b3VyIHByb2dyYW0gYXNzdW1lcyB0byBiZSB0cnVlLlxcbiAqXFxuICogUHJvdmlkZSBzcHJpbnRmLXN0eWxlIGZvcm1hdCAob25seSAlcyBpcyBzdXBwb3J0ZWQpIGFuZCBhcmd1bWVudHNcXG4gKiB0byBwcm92aWRlIGluZm9ybWF0aW9uIGFib3V0IHdoYXQgYnJva2UgYW5kIHdoYXQgeW91IHdlcmVcXG4gKiBleHBlY3RpbmcuXFxuICpcXG4gKiBUaGUgaW52YXJpYW50IG1lc3NhZ2Ugd2lsbCBiZSBzdHJpcHBlZCBpbiBwcm9kdWN0aW9uLCBidXQgdGhlIGludmFyaWFudFxcbiAqIHdpbGwgcmVtYWluIHRvIGVuc3VyZSBsb2dpYyBkb2VzIG5vdCBkaWZmZXIgaW4gcHJvZHVjdGlvbi5cXG4gKi9cXG5cXG52YXIgdmFsaWRhdGVGb3JtYXQgPSBmdW5jdGlvbiB2YWxpZGF0ZUZvcm1hdChmb3JtYXQpIHt9O1xcblxcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XFxuICB2YWxpZGF0ZUZvcm1hdCA9IGZ1bmN0aW9uIHZhbGlkYXRlRm9ybWF0KGZvcm1hdCkge1xcbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFyaWFudCByZXF1aXJlcyBhbiBlcnJvciBtZXNzYWdlIGFyZ3VtZW50Jyk7XFxuICAgIH1cXG4gIH07XFxufVxcblxcbmZ1bmN0aW9uIGludmFyaWFudChjb25kaXRpb24sIGZvcm1hdCwgYSwgYiwgYywgZCwgZSwgZikge1xcbiAgdmFsaWRhdGVGb3JtYXQoZm9ybWF0KTtcXG5cXG4gIGlmICghY29uZGl0aW9uKSB7XFxuICAgIHZhciBlcnJvcjtcXG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XFxuICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoJ01pbmlmaWVkIGV4Y2VwdGlvbiBvY2N1cnJlZDsgdXNlIHRoZSBub24tbWluaWZpZWQgZGV2IGVudmlyb25tZW50ICcgKyAnZm9yIHRoZSBmdWxsIGVycm9yIG1lc3NhZ2UgYW5kIGFkZGl0aW9uYWwgaGVscGZ1bCB3YXJuaW5ncy4nKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICB2YXIgYXJncyA9IFthLCBiLCBjLCBkLCBlLCBmXTtcXG4gICAgICB2YXIgYXJnSW5kZXggPSAwO1xcbiAgICAgIGVycm9yID0gbmV3IEVycm9yKGZvcm1hdC5yZXBsYWNlKC8lcy9nLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICByZXR1cm4gYXJnc1thcmdJbmRleCsrXTtcXG4gICAgICB9KSk7XFxuICAgICAgZXJyb3IubmFtZSA9ICdJbnZhcmlhbnQgVmlvbGF0aW9uJztcXG4gICAgfVxcblxcbiAgICBlcnJvci5mcmFtZXNUb1BvcCA9IDE7IC8vIHdlIGRvbid0IGNhcmUgYWJvdXQgaW52YXJpYW50J3Mgb3duIGZyYW1lXFxuICAgIHRocm93IGVycm9yO1xcbiAgfVxcbn1cXG5cXG5tb2R1bGUuZXhwb3J0cyA9IGludmFyaWFudDtcXG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi99LmNhbGwoZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXygwKSkpXFxuXFxuLy8vLy8vLy8vLy8vLy8vLy8vXFxuLy8gV0VCUEFDSyBGT09URVJcXG4vLyAuL34vZmJqcy9saWIvaW52YXJpYW50LmpzXFxuLy8gbW9kdWxlIGlkID0gM1xcbi8vIG1vZHVsZSBjaHVua3MgPSAwXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vfi9mYmpzL2xpYi9pbnZhcmlhbnQuanM/XCIpO1xuXG4vKioqLyB9KSxcbi8qIDQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5ldmFsKFwiLyoqXFxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXFxuICpcXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXFxuICovXFxuXFxuXFxuXFxudmFyIFJlYWN0UHJvcFR5cGVzU2VjcmV0ID0gJ1NFQ1JFVF9ET19OT1RfUEFTU19USElTX09SX1lPVV9XSUxMX0JFX0ZJUkVEJztcXG5cXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0UHJvcFR5cGVzU2VjcmV0O1xcblxcblxcbi8vLy8vLy8vLy8vLy8vLy8vL1xcbi8vIFdFQlBBQ0sgRk9PVEVSXFxuLy8gLi9+L3Byb3AtdHlwZXMvbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0LmpzXFxuLy8gbW9kdWxlIGlkID0gNFxcbi8vIG1vZHVsZSBjaHVua3MgPSAwXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vfi9wcm9wLXR5cGVzL2xpYi9SZWFjdFByb3BUeXBlc1NlY3JldC5qcz9cIik7XG5cbi8qKiovIH0pLFxuLyogNSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5ldmFsKFwiLypcXG5cXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxcblxcdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcXG4qL1xcbi8vIGNzcyBiYXNlIGNvZGUsIGluamVjdGVkIGJ5IHRoZSBjc3MtbG9hZGVyXFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih1c2VTb3VyY2VNYXApIHtcXG5cXHR2YXIgbGlzdCA9IFtdO1xcblxcblxcdC8vIHJldHVybiB0aGUgbGlzdCBvZiBtb2R1bGVzIGFzIGNzcyBzdHJpbmdcXG5cXHRsaXN0LnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XFxuXFx0XFx0cmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uIChpdGVtKSB7XFxuXFx0XFx0XFx0dmFyIGNvbnRlbnQgPSBjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKGl0ZW0sIHVzZVNvdXJjZU1hcCk7XFxuXFx0XFx0XFx0aWYoaXRlbVsyXSkge1xcblxcdFxcdFxcdFxcdHJldHVybiBcXFwiQG1lZGlhIFxcXCIgKyBpdGVtWzJdICsgXFxcIntcXFwiICsgY29udGVudCArIFxcXCJ9XFxcIjtcXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdHJldHVybiBjb250ZW50O1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9KS5qb2luKFxcXCJcXFwiKTtcXG5cXHR9O1xcblxcblxcdC8vIGltcG9ydCBhIGxpc3Qgb2YgbW9kdWxlcyBpbnRvIHRoZSBsaXN0XFxuXFx0bGlzdC5pID0gZnVuY3Rpb24obW9kdWxlcywgbWVkaWFRdWVyeSkge1xcblxcdFxcdGlmKHR5cGVvZiBtb2R1bGVzID09PSBcXFwic3RyaW5nXFxcIilcXG5cXHRcXHRcXHRtb2R1bGVzID0gW1tudWxsLCBtb2R1bGVzLCBcXFwiXFxcIl1dO1xcblxcdFxcdHZhciBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzID0ge307XFxuXFx0XFx0Zm9yKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcXG5cXHRcXHRcXHR2YXIgaWQgPSB0aGlzW2ldWzBdO1xcblxcdFxcdFxcdGlmKHR5cGVvZiBpZCA9PT0gXFxcIm51bWJlclxcXCIpXFxuXFx0XFx0XFx0XFx0YWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpZF0gPSB0cnVlO1xcblxcdFxcdH1cXG5cXHRcXHRmb3IoaSA9IDA7IGkgPCBtb2R1bGVzLmxlbmd0aDsgaSsrKSB7XFxuXFx0XFx0XFx0dmFyIGl0ZW0gPSBtb2R1bGVzW2ldO1xcblxcdFxcdFxcdC8vIHNraXAgYWxyZWFkeSBpbXBvcnRlZCBtb2R1bGVcXG5cXHRcXHRcXHQvLyB0aGlzIGltcGxlbWVudGF0aW9uIGlzIG5vdCAxMDAlIHBlcmZlY3QgZm9yIHdlaXJkIG1lZGlhIHF1ZXJ5IGNvbWJpbmF0aW9uc1xcblxcdFxcdFxcdC8vICB3aGVuIGEgbW9kdWxlIGlzIGltcG9ydGVkIG11bHRpcGxlIHRpbWVzIHdpdGggZGlmZmVyZW50IG1lZGlhIHF1ZXJpZXMuXFxuXFx0XFx0XFx0Ly8gIEkgaG9wZSB0aGlzIHdpbGwgbmV2ZXIgb2NjdXIgKEhleSB0aGlzIHdheSB3ZSBoYXZlIHNtYWxsZXIgYnVuZGxlcylcXG5cXHRcXHRcXHRpZih0eXBlb2YgaXRlbVswXSAhPT0gXFxcIm51bWJlclxcXCIgfHwgIWFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaXRlbVswXV0pIHtcXG5cXHRcXHRcXHRcXHRpZihtZWRpYVF1ZXJ5ICYmICFpdGVtWzJdKSB7XFxuXFx0XFx0XFx0XFx0XFx0aXRlbVsyXSA9IG1lZGlhUXVlcnk7XFxuXFx0XFx0XFx0XFx0fSBlbHNlIGlmKG1lZGlhUXVlcnkpIHtcXG5cXHRcXHRcXHRcXHRcXHRpdGVtWzJdID0gXFxcIihcXFwiICsgaXRlbVsyXSArIFxcXCIpIGFuZCAoXFxcIiArIG1lZGlhUXVlcnkgKyBcXFwiKVxcXCI7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdGxpc3QucHVzaChpdGVtKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcdH07XFxuXFx0cmV0dXJuIGxpc3Q7XFxufTtcXG5cXG5mdW5jdGlvbiBjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKGl0ZW0sIHVzZVNvdXJjZU1hcCkge1xcblxcdHZhciBjb250ZW50ID0gaXRlbVsxXSB8fCAnJztcXG5cXHR2YXIgY3NzTWFwcGluZyA9IGl0ZW1bM107XFxuXFx0aWYgKCFjc3NNYXBwaW5nKSB7XFxuXFx0XFx0cmV0dXJuIGNvbnRlbnQ7XFxuXFx0fVxcblxcblxcdGlmICh1c2VTb3VyY2VNYXAgJiYgdHlwZW9mIGJ0b2EgPT09ICdmdW5jdGlvbicpIHtcXG5cXHRcXHR2YXIgc291cmNlTWFwcGluZyA9IHRvQ29tbWVudChjc3NNYXBwaW5nKTtcXG5cXHRcXHR2YXIgc291cmNlVVJMcyA9IGNzc01hcHBpbmcuc291cmNlcy5tYXAoZnVuY3Rpb24gKHNvdXJjZSkge1xcblxcdFxcdFxcdHJldHVybiAnLyojIHNvdXJjZVVSTD0nICsgY3NzTWFwcGluZy5zb3VyY2VSb290ICsgc291cmNlICsgJyAqLydcXG5cXHRcXHR9KTtcXG5cXG5cXHRcXHRyZXR1cm4gW2NvbnRlbnRdLmNvbmNhdChzb3VyY2VVUkxzKS5jb25jYXQoW3NvdXJjZU1hcHBpbmddKS5qb2luKCdcXFxcbicpO1xcblxcdH1cXG5cXG5cXHRyZXR1cm4gW2NvbnRlbnRdLmpvaW4oJ1xcXFxuJyk7XFxufVxcblxcbi8vIEFkYXB0ZWQgZnJvbSBjb252ZXJ0LXNvdXJjZS1tYXAgKE1JVClcXG5mdW5jdGlvbiB0b0NvbW1lbnQoc291cmNlTWFwKSB7XFxuXFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXFxuXFx0dmFyIGJhc2U2NCA9IGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHNvdXJjZU1hcCkpKSk7XFxuXFx0dmFyIGRhdGEgPSAnc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsJyArIGJhc2U2NDtcXG5cXG5cXHRyZXR1cm4gJy8qIyAnICsgZGF0YSArICcgKi8nO1xcbn1cXG5cXG5cXG4vLy8vLy8vLy8vLy8vLy8vLy9cXG4vLyBXRUJQQUNLIEZPT1RFUlxcbi8vIC4vfi9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1xcbi8vIG1vZHVsZSBpZCA9IDVcXG4vLyBtb2R1bGUgY2h1bmtzID0gMFxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL34vY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanM/XCIpO1xuXG4vKioqLyB9KSxcbi8qIDYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5ldmFsKFwiLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovKGZ1bmN0aW9uKHByb2Nlc3MpIHsvKipcXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cXG4gKlxcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cXG4gKlxcbiAqL1xcblxcblxcblxcbnZhciBlbXB0eUZ1bmN0aW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcXG5cXG4vKipcXG4gKiBTaW1pbGFyIHRvIGludmFyaWFudCBidXQgb25seSBsb2dzIGEgd2FybmluZyBpZiB0aGUgY29uZGl0aW9uIGlzIG5vdCBtZXQuXFxuICogVGhpcyBjYW4gYmUgdXNlZCB0byBsb2cgaXNzdWVzIGluIGRldmVsb3BtZW50IGVudmlyb25tZW50cyBpbiBjcml0aWNhbFxcbiAqIHBhdGhzLiBSZW1vdmluZyB0aGUgbG9nZ2luZyBjb2RlIGZvciBwcm9kdWN0aW9uIGVudmlyb25tZW50cyB3aWxsIGtlZXAgdGhlXFxuICogc2FtZSBsb2dpYyBhbmQgZm9sbG93IHRoZSBzYW1lIGNvZGUgcGF0aHMuXFxuICovXFxuXFxudmFyIHdhcm5pbmcgPSBlbXB0eUZ1bmN0aW9uO1xcblxcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XFxuICB2YXIgcHJpbnRXYXJuaW5nID0gZnVuY3Rpb24gcHJpbnRXYXJuaW5nKGZvcm1hdCkge1xcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcXG4gICAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcXG4gICAgfVxcblxcbiAgICB2YXIgYXJnSW5kZXggPSAwO1xcbiAgICB2YXIgbWVzc2FnZSA9ICdXYXJuaW5nOiAnICsgZm9ybWF0LnJlcGxhY2UoLyVzL2csIGZ1bmN0aW9uICgpIHtcXG4gICAgICByZXR1cm4gYXJnc1thcmdJbmRleCsrXTtcXG4gICAgfSk7XFxuICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcXG4gICAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UpO1xcbiAgICB9XFxuICAgIHRyeSB7XFxuICAgICAgLy8gLS0tIFdlbGNvbWUgdG8gZGVidWdnaW5nIFJlYWN0IC0tLVxcbiAgICAgIC8vIFRoaXMgZXJyb3Igd2FzIHRocm93biBhcyBhIGNvbnZlbmllbmNlIHNvIHRoYXQgeW91IGNhbiB1c2UgdGhpcyBzdGFja1xcbiAgICAgIC8vIHRvIGZpbmQgdGhlIGNhbGxzaXRlIHRoYXQgY2F1c2VkIHRoaXMgd2FybmluZyB0byBmaXJlLlxcbiAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcXG4gICAgfSBjYXRjaCAoeCkge31cXG4gIH07XFxuXFxuICB3YXJuaW5nID0gZnVuY3Rpb24gd2FybmluZyhjb25kaXRpb24sIGZvcm1hdCkge1xcbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2B3YXJuaW5nKGNvbmRpdGlvbiwgZm9ybWF0LCAuLi5hcmdzKWAgcmVxdWlyZXMgYSB3YXJuaW5nICcgKyAnbWVzc2FnZSBhcmd1bWVudCcpO1xcbiAgICB9XFxuXFxuICAgIGlmIChmb3JtYXQuaW5kZXhPZignRmFpbGVkIENvbXBvc2l0ZSBwcm9wVHlwZTogJykgPT09IDApIHtcXG4gICAgICByZXR1cm47IC8vIElnbm9yZSBDb21wb3NpdGVDb21wb25lbnQgcHJvcHR5cGUgY2hlY2suXFxuICAgIH1cXG5cXG4gICAgaWYgKCFjb25kaXRpb24pIHtcXG4gICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuMiA+IDIgPyBfbGVuMiAtIDIgOiAwKSwgX2tleTIgPSAyOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XFxuICAgICAgICBhcmdzW19rZXkyIC0gMl0gPSBhcmd1bWVudHNbX2tleTJdO1xcbiAgICAgIH1cXG5cXG4gICAgICBwcmludFdhcm5pbmcuYXBwbHkodW5kZWZpbmVkLCBbZm9ybWF0XS5jb25jYXQoYXJncykpO1xcbiAgICB9XFxuICB9O1xcbn1cXG5cXG5tb2R1bGUuZXhwb3J0cyA9IHdhcm5pbmc7XFxuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovfS5jYWxsKGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18oMCkpKVxcblxcbi8vLy8vLy8vLy8vLy8vLy8vL1xcbi8vIFdFQlBBQ0sgRk9PVEVSXFxuLy8gLi9+L2ZianMvbGliL3dhcm5pbmcuanNcXG4vLyBtb2R1bGUgaWQgPSA2XFxuLy8gbW9kdWxlIGNodW5rcyA9IDBcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9+L2ZianMvbGliL3dhcm5pbmcuanM/XCIpO1xuXG4vKioqLyB9KSxcbi8qIDcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuZXZhbChcIi8qXFxuXFx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcXG5cXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXFxuKi9cXG52YXIgc3R5bGVzSW5Eb20gPSB7fSxcXG5cXHRtZW1vaXplID0gZnVuY3Rpb24oZm4pIHtcXG5cXHRcXHR2YXIgbWVtbztcXG5cXHRcXHRyZXR1cm4gZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdGlmICh0eXBlb2YgbWVtbyA9PT0gXFxcInVuZGVmaW5lZFxcXCIpIG1lbW8gPSBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xcblxcdFxcdFxcdHJldHVybiBtZW1vO1xcblxcdFxcdH07XFxuXFx0fSxcXG5cXHRpc09sZElFID0gbWVtb2l6ZShmdW5jdGlvbigpIHtcXG5cXHRcXHQvLyBUZXN0IGZvciBJRSA8PSA5IGFzIHByb3Bvc2VkIGJ5IEJyb3dzZXJoYWNrc1xcblxcdFxcdC8vIEBzZWUgaHR0cDovL2Jyb3dzZXJoYWNrcy5jb20vI2hhY2stZTcxZDg2OTJmNjUzMzQxNzNmZWU3MTVjMjIyY2I4MDVcXG5cXHRcXHQvLyBUZXN0cyBmb3IgZXhpc3RlbmNlIG9mIHN0YW5kYXJkIGdsb2JhbHMgaXMgdG8gYWxsb3cgc3R5bGUtbG9hZGVyIFxcblxcdFxcdC8vIHRvIG9wZXJhdGUgY29ycmVjdGx5IGludG8gbm9uLXN0YW5kYXJkIGVudmlyb25tZW50c1xcblxcdFxcdC8vIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3dlYnBhY2stY29udHJpYi9zdHlsZS1sb2FkZXIvaXNzdWVzLzE3N1xcblxcdFxcdHJldHVybiB3aW5kb3cgJiYgZG9jdW1lbnQgJiYgZG9jdW1lbnQuYWxsICYmICF3aW5kb3cuYXRvYjtcXG5cXHR9KSxcXG5cXHRnZXRFbGVtZW50ID0gKGZ1bmN0aW9uKGZuKSB7XFxuXFx0XFx0dmFyIG1lbW8gPSB7fTtcXG5cXHRcXHRyZXR1cm4gZnVuY3Rpb24oc2VsZWN0b3IpIHtcXG5cXHRcXHRcXHRpZiAodHlwZW9mIG1lbW9bc2VsZWN0b3JdID09PSBcXFwidW5kZWZpbmVkXFxcIikge1xcblxcdFxcdFxcdFxcdG1lbW9bc2VsZWN0b3JdID0gZm4uY2FsbCh0aGlzLCBzZWxlY3Rvcik7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHJldHVybiBtZW1vW3NlbGVjdG9yXVxcblxcdFxcdH07XFxuXFx0fSkoZnVuY3Rpb24gKHN0eWxlVGFyZ2V0KSB7XFxuXFx0XFx0cmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3Ioc3R5bGVUYXJnZXQpXFxuXFx0fSksXFxuXFx0c2luZ2xldG9uRWxlbWVudCA9IG51bGwsXFxuXFx0c2luZ2xldG9uQ291bnRlciA9IDAsXFxuXFx0c3R5bGVFbGVtZW50c0luc2VydGVkQXRUb3AgPSBbXSxcXG5cXHRmaXhVcmxzID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMik7XFxuXFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihsaXN0LCBvcHRpb25zKSB7XFxuXFx0aWYodHlwZW9mIERFQlVHICE9PSBcXFwidW5kZWZpbmVkXFxcIiAmJiBERUJVRykge1xcblxcdFxcdGlmKHR5cGVvZiBkb2N1bWVudCAhPT0gXFxcIm9iamVjdFxcXCIpIHRocm93IG5ldyBFcnJvcihcXFwiVGhlIHN0eWxlLWxvYWRlciBjYW5ub3QgYmUgdXNlZCBpbiBhIG5vbi1icm93c2VyIGVudmlyb25tZW50XFxcIik7XFxuXFx0fVxcblxcblxcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xcblxcdG9wdGlvbnMuYXR0cnMgPSB0eXBlb2Ygb3B0aW9ucy5hdHRycyA9PT0gXFxcIm9iamVjdFxcXCIgPyBvcHRpb25zLmF0dHJzIDoge307XFxuXFxuXFx0Ly8gRm9yY2Ugc2luZ2xlLXRhZyBzb2x1dGlvbiBvbiBJRTYtOSwgd2hpY2ggaGFzIGEgaGFyZCBsaW1pdCBvbiB0aGUgIyBvZiA8c3R5bGU+XFxuXFx0Ly8gdGFncyBpdCB3aWxsIGFsbG93IG9uIGEgcGFnZVxcblxcdGlmICh0eXBlb2Ygb3B0aW9ucy5zaW5nbGV0b24gPT09IFxcXCJ1bmRlZmluZWRcXFwiKSBvcHRpb25zLnNpbmdsZXRvbiA9IGlzT2xkSUUoKTtcXG5cXG5cXHQvLyBCeSBkZWZhdWx0LCBhZGQgPHN0eWxlPiB0YWdzIHRvIHRoZSA8aGVhZD4gZWxlbWVudFxcblxcdGlmICh0eXBlb2Ygb3B0aW9ucy5pbnNlcnRJbnRvID09PSBcXFwidW5kZWZpbmVkXFxcIikgb3B0aW9ucy5pbnNlcnRJbnRvID0gXFxcImhlYWRcXFwiO1xcblxcblxcdC8vIEJ5IGRlZmF1bHQsIGFkZCA8c3R5bGU+IHRhZ3MgdG8gdGhlIGJvdHRvbSBvZiB0aGUgdGFyZ2V0XFxuXFx0aWYgKHR5cGVvZiBvcHRpb25zLmluc2VydEF0ID09PSBcXFwidW5kZWZpbmVkXFxcIikgb3B0aW9ucy5pbnNlcnRBdCA9IFxcXCJib3R0b21cXFwiO1xcblxcblxcdHZhciBzdHlsZXMgPSBsaXN0VG9TdHlsZXMobGlzdCwgb3B0aW9ucyk7XFxuXFx0YWRkU3R5bGVzVG9Eb20oc3R5bGVzLCBvcHRpb25zKTtcXG5cXG5cXHRyZXR1cm4gZnVuY3Rpb24gdXBkYXRlKG5ld0xpc3QpIHtcXG5cXHRcXHR2YXIgbWF5UmVtb3ZlID0gW107XFxuXFx0XFx0Zm9yKHZhciBpID0gMDsgaSA8IHN0eWxlcy5sZW5ndGg7IGkrKykge1xcblxcdFxcdFxcdHZhciBpdGVtID0gc3R5bGVzW2ldO1xcblxcdFxcdFxcdHZhciBkb21TdHlsZSA9IHN0eWxlc0luRG9tW2l0ZW0uaWRdO1xcblxcdFxcdFxcdGRvbVN0eWxlLnJlZnMtLTtcXG5cXHRcXHRcXHRtYXlSZW1vdmUucHVzaChkb21TdHlsZSk7XFxuXFx0XFx0fVxcblxcdFxcdGlmKG5ld0xpc3QpIHtcXG5cXHRcXHRcXHR2YXIgbmV3U3R5bGVzID0gbGlzdFRvU3R5bGVzKG5ld0xpc3QsIG9wdGlvbnMpO1xcblxcdFxcdFxcdGFkZFN0eWxlc1RvRG9tKG5ld1N0eWxlcywgb3B0aW9ucyk7XFxuXFx0XFx0fVxcblxcdFxcdGZvcih2YXIgaSA9IDA7IGkgPCBtYXlSZW1vdmUubGVuZ3RoOyBpKyspIHtcXG5cXHRcXHRcXHR2YXIgZG9tU3R5bGUgPSBtYXlSZW1vdmVbaV07XFxuXFx0XFx0XFx0aWYoZG9tU3R5bGUucmVmcyA9PT0gMCkge1xcblxcdFxcdFxcdFxcdGZvcih2YXIgaiA9IDA7IGogPCBkb21TdHlsZS5wYXJ0cy5sZW5ndGg7IGorKylcXG5cXHRcXHRcXHRcXHRcXHRkb21TdHlsZS5wYXJ0c1tqXSgpO1xcblxcdFxcdFxcdFxcdGRlbGV0ZSBzdHlsZXNJbkRvbVtkb21TdHlsZS5pZF07XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXHR9O1xcbn07XFxuXFxuZnVuY3Rpb24gYWRkU3R5bGVzVG9Eb20oc3R5bGVzLCBvcHRpb25zKSB7XFxuXFx0Zm9yKHZhciBpID0gMDsgaSA8IHN0eWxlcy5sZW5ndGg7IGkrKykge1xcblxcdFxcdHZhciBpdGVtID0gc3R5bGVzW2ldO1xcblxcdFxcdHZhciBkb21TdHlsZSA9IHN0eWxlc0luRG9tW2l0ZW0uaWRdO1xcblxcdFxcdGlmKGRvbVN0eWxlKSB7XFxuXFx0XFx0XFx0ZG9tU3R5bGUucmVmcysrO1xcblxcdFxcdFxcdGZvcih2YXIgaiA9IDA7IGogPCBkb21TdHlsZS5wYXJ0cy5sZW5ndGg7IGorKykge1xcblxcdFxcdFxcdFxcdGRvbVN0eWxlLnBhcnRzW2pdKGl0ZW0ucGFydHNbal0pO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRmb3IoOyBqIDwgaXRlbS5wYXJ0cy5sZW5ndGg7IGorKykge1xcblxcdFxcdFxcdFxcdGRvbVN0eWxlLnBhcnRzLnB1c2goYWRkU3R5bGUoaXRlbS5wYXJ0c1tqXSwgb3B0aW9ucykpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdHZhciBwYXJ0cyA9IFtdO1xcblxcdFxcdFxcdGZvcih2YXIgaiA9IDA7IGogPCBpdGVtLnBhcnRzLmxlbmd0aDsgaisrKSB7XFxuXFx0XFx0XFx0XFx0cGFydHMucHVzaChhZGRTdHlsZShpdGVtLnBhcnRzW2pdLCBvcHRpb25zKSk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHN0eWxlc0luRG9tW2l0ZW0uaWRdID0ge2lkOiBpdGVtLmlkLCByZWZzOiAxLCBwYXJ0czogcGFydHN9O1xcblxcdFxcdH1cXG5cXHR9XFxufVxcblxcbmZ1bmN0aW9uIGxpc3RUb1N0eWxlcyhsaXN0LCBvcHRpb25zKSB7XFxuXFx0dmFyIHN0eWxlcyA9IFtdO1xcblxcdHZhciBuZXdTdHlsZXMgPSB7fTtcXG5cXHRmb3IodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xcblxcdFxcdHZhciBpdGVtID0gbGlzdFtpXTtcXG5cXHRcXHR2YXIgaWQgPSBvcHRpb25zLmJhc2UgPyBpdGVtWzBdICsgb3B0aW9ucy5iYXNlIDogaXRlbVswXTtcXG5cXHRcXHR2YXIgY3NzID0gaXRlbVsxXTtcXG5cXHRcXHR2YXIgbWVkaWEgPSBpdGVtWzJdO1xcblxcdFxcdHZhciBzb3VyY2VNYXAgPSBpdGVtWzNdO1xcblxcdFxcdHZhciBwYXJ0ID0ge2NzczogY3NzLCBtZWRpYTogbWVkaWEsIHNvdXJjZU1hcDogc291cmNlTWFwfTtcXG5cXHRcXHRpZighbmV3U3R5bGVzW2lkXSlcXG5cXHRcXHRcXHRzdHlsZXMucHVzaChuZXdTdHlsZXNbaWRdID0ge2lkOiBpZCwgcGFydHM6IFtwYXJ0XX0pO1xcblxcdFxcdGVsc2VcXG5cXHRcXHRcXHRuZXdTdHlsZXNbaWRdLnBhcnRzLnB1c2gocGFydCk7XFxuXFx0fVxcblxcdHJldHVybiBzdHlsZXM7XFxufVxcblxcbmZ1bmN0aW9uIGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zLCBzdHlsZUVsZW1lbnQpIHtcXG5cXHR2YXIgc3R5bGVUYXJnZXQgPSBnZXRFbGVtZW50KG9wdGlvbnMuaW5zZXJ0SW50bylcXG5cXHRpZiAoIXN0eWxlVGFyZ2V0KSB7XFxuXFx0XFx0dGhyb3cgbmV3IEVycm9yKFxcXCJDb3VsZG4ndCBmaW5kIGEgc3R5bGUgdGFyZ2V0LiBUaGlzIHByb2JhYmx5IG1lYW5zIHRoYXQgdGhlIHZhbHVlIGZvciB0aGUgJ2luc2VydEludG8nIHBhcmFtZXRlciBpcyBpbnZhbGlkLlxcXCIpO1xcblxcdH1cXG5cXHR2YXIgbGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3AgPSBzdHlsZUVsZW1lbnRzSW5zZXJ0ZWRBdFRvcFtzdHlsZUVsZW1lbnRzSW5zZXJ0ZWRBdFRvcC5sZW5ndGggLSAxXTtcXG5cXHRpZiAob3B0aW9ucy5pbnNlcnRBdCA9PT0gXFxcInRvcFxcXCIpIHtcXG5cXHRcXHRpZighbGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3ApIHtcXG5cXHRcXHRcXHRzdHlsZVRhcmdldC5pbnNlcnRCZWZvcmUoc3R5bGVFbGVtZW50LCBzdHlsZVRhcmdldC5maXJzdENoaWxkKTtcXG5cXHRcXHR9IGVsc2UgaWYobGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3AubmV4dFNpYmxpbmcpIHtcXG5cXHRcXHRcXHRzdHlsZVRhcmdldC5pbnNlcnRCZWZvcmUoc3R5bGVFbGVtZW50LCBsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcC5uZXh0U2libGluZyk7XFxuXFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRzdHlsZVRhcmdldC5hcHBlbmRDaGlsZChzdHlsZUVsZW1lbnQpO1xcblxcdFxcdH1cXG5cXHRcXHRzdHlsZUVsZW1lbnRzSW5zZXJ0ZWRBdFRvcC5wdXNoKHN0eWxlRWxlbWVudCk7XFxuXFx0fSBlbHNlIGlmIChvcHRpb25zLmluc2VydEF0ID09PSBcXFwiYm90dG9tXFxcIikge1xcblxcdFxcdHN0eWxlVGFyZ2V0LmFwcGVuZENoaWxkKHN0eWxlRWxlbWVudCk7XFxuXFx0fSBlbHNlIHtcXG5cXHRcXHR0aHJvdyBuZXcgRXJyb3IoXFxcIkludmFsaWQgdmFsdWUgZm9yIHBhcmFtZXRlciAnaW5zZXJ0QXQnLiBNdXN0IGJlICd0b3AnIG9yICdib3R0b20nLlxcXCIpO1xcblxcdH1cXG59XFxuXFxuZnVuY3Rpb24gcmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlRWxlbWVudCkge1xcblxcdHN0eWxlRWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHN0eWxlRWxlbWVudCk7XFxuXFx0dmFyIGlkeCA9IHN0eWxlRWxlbWVudHNJbnNlcnRlZEF0VG9wLmluZGV4T2Yoc3R5bGVFbGVtZW50KTtcXG5cXHRpZihpZHggPj0gMCkge1xcblxcdFxcdHN0eWxlRWxlbWVudHNJbnNlcnRlZEF0VG9wLnNwbGljZShpZHgsIDEpO1xcblxcdH1cXG59XFxuXFxuZnVuY3Rpb24gY3JlYXRlU3R5bGVFbGVtZW50KG9wdGlvbnMpIHtcXG5cXHR2YXIgc3R5bGVFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcXFwic3R5bGVcXFwiKTtcXG5cXHRvcHRpb25zLmF0dHJzLnR5cGUgPSBcXFwidGV4dC9jc3NcXFwiO1xcblxcblxcdGF0dGFjaFRhZ0F0dHJzKHN0eWxlRWxlbWVudCwgb3B0aW9ucy5hdHRycyk7XFxuXFx0aW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMsIHN0eWxlRWxlbWVudCk7XFxuXFx0cmV0dXJuIHN0eWxlRWxlbWVudDtcXG59XFxuXFxuZnVuY3Rpb24gY3JlYXRlTGlua0VsZW1lbnQob3B0aW9ucykge1xcblxcdHZhciBsaW5rRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXFxcImxpbmtcXFwiKTtcXG5cXHRvcHRpb25zLmF0dHJzLnR5cGUgPSBcXFwidGV4dC9jc3NcXFwiO1xcblxcdG9wdGlvbnMuYXR0cnMucmVsID0gXFxcInN0eWxlc2hlZXRcXFwiO1xcblxcblxcdGF0dGFjaFRhZ0F0dHJzKGxpbmtFbGVtZW50LCBvcHRpb25zLmF0dHJzKTtcXG5cXHRpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucywgbGlua0VsZW1lbnQpO1xcblxcdHJldHVybiBsaW5rRWxlbWVudDtcXG59XFxuXFxuZnVuY3Rpb24gYXR0YWNoVGFnQXR0cnMoZWxlbWVudCwgYXR0cnMpIHtcXG5cXHRPYmplY3Qua2V5cyhhdHRycykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XFxuXFx0XFx0ZWxlbWVudC5zZXRBdHRyaWJ1dGUoa2V5LCBhdHRyc1trZXldKTtcXG5cXHR9KTtcXG59XFxuXFxuZnVuY3Rpb24gYWRkU3R5bGUob2JqLCBvcHRpb25zKSB7XFxuXFx0dmFyIHN0eWxlRWxlbWVudCwgdXBkYXRlLCByZW1vdmUsIHRyYW5zZm9ybVJlc3VsdDtcXG5cXG5cXHQvLyBJZiBhIHRyYW5zZm9ybSBmdW5jdGlvbiB3YXMgZGVmaW5lZCwgcnVuIGl0IG9uIHRoZSBjc3NcXG5cXHRpZiAob3B0aW9ucy50cmFuc2Zvcm0gJiYgb2JqLmNzcykge1xcblxcdCAgICB0cmFuc2Zvcm1SZXN1bHQgPSBvcHRpb25zLnRyYW5zZm9ybShvYmouY3NzKTtcXG5cXHQgICAgXFxuXFx0ICAgIGlmICh0cmFuc2Zvcm1SZXN1bHQpIHtcXG5cXHQgICAgXFx0Ly8gSWYgdHJhbnNmb3JtIHJldHVybnMgYSB2YWx1ZSwgdXNlIHRoYXQgaW5zdGVhZCBvZiB0aGUgb3JpZ2luYWwgY3NzLlxcblxcdCAgICBcXHQvLyBUaGlzIGFsbG93cyBydW5uaW5nIHJ1bnRpbWUgdHJhbnNmb3JtYXRpb25zIG9uIHRoZSBjc3MuXFxuXFx0ICAgIFxcdG9iai5jc3MgPSB0cmFuc2Zvcm1SZXN1bHQ7XFxuXFx0ICAgIH0gZWxzZSB7XFxuXFx0ICAgIFxcdC8vIElmIHRoZSB0cmFuc2Zvcm0gZnVuY3Rpb24gcmV0dXJucyBhIGZhbHN5IHZhbHVlLCBkb24ndCBhZGQgdGhpcyBjc3MuIFxcblxcdCAgICBcXHQvLyBUaGlzIGFsbG93cyBjb25kaXRpb25hbCBsb2FkaW5nIG9mIGNzc1xcblxcdCAgICBcXHRyZXR1cm4gZnVuY3Rpb24oKSB7XFxuXFx0ICAgIFxcdFxcdC8vIG5vb3BcXG5cXHQgICAgXFx0fTtcXG5cXHQgICAgfVxcblxcdH1cXG5cXG5cXHRpZiAob3B0aW9ucy5zaW5nbGV0b24pIHtcXG5cXHRcXHR2YXIgc3R5bGVJbmRleCA9IHNpbmdsZXRvbkNvdW50ZXIrKztcXG5cXHRcXHRzdHlsZUVsZW1lbnQgPSBzaW5nbGV0b25FbGVtZW50IHx8IChzaW5nbGV0b25FbGVtZW50ID0gY3JlYXRlU3R5bGVFbGVtZW50KG9wdGlvbnMpKTtcXG5cXHRcXHR1cGRhdGUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGVFbGVtZW50LCBzdHlsZUluZGV4LCBmYWxzZSk7XFxuXFx0XFx0cmVtb3ZlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlRWxlbWVudCwgc3R5bGVJbmRleCwgdHJ1ZSk7XFxuXFx0fSBlbHNlIGlmKG9iai5zb3VyY2VNYXAgJiZcXG5cXHRcXHR0eXBlb2YgVVJMID09PSBcXFwiZnVuY3Rpb25cXFwiICYmXFxuXFx0XFx0dHlwZW9mIFVSTC5jcmVhdGVPYmplY3RVUkwgPT09IFxcXCJmdW5jdGlvblxcXCIgJiZcXG5cXHRcXHR0eXBlb2YgVVJMLnJldm9rZU9iamVjdFVSTCA9PT0gXFxcImZ1bmN0aW9uXFxcIiAmJlxcblxcdFxcdHR5cGVvZiBCbG9iID09PSBcXFwiZnVuY3Rpb25cXFwiICYmXFxuXFx0XFx0dHlwZW9mIGJ0b2EgPT09IFxcXCJmdW5jdGlvblxcXCIpIHtcXG5cXHRcXHRzdHlsZUVsZW1lbnQgPSBjcmVhdGVMaW5rRWxlbWVudChvcHRpb25zKTtcXG5cXHRcXHR1cGRhdGUgPSB1cGRhdGVMaW5rLmJpbmQobnVsbCwgc3R5bGVFbGVtZW50LCBvcHRpb25zKTtcXG5cXHRcXHRyZW1vdmUgPSBmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHRyZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGVFbGVtZW50KTtcXG5cXHRcXHRcXHRpZihzdHlsZUVsZW1lbnQuaHJlZilcXG5cXHRcXHRcXHRcXHRVUkwucmV2b2tlT2JqZWN0VVJMKHN0eWxlRWxlbWVudC5ocmVmKTtcXG5cXHRcXHR9O1xcblxcdH0gZWxzZSB7XFxuXFx0XFx0c3R5bGVFbGVtZW50ID0gY3JlYXRlU3R5bGVFbGVtZW50KG9wdGlvbnMpO1xcblxcdFxcdHVwZGF0ZSA9IGFwcGx5VG9UYWcuYmluZChudWxsLCBzdHlsZUVsZW1lbnQpO1xcblxcdFxcdHJlbW92ZSA9IGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZUVsZW1lbnQpO1xcblxcdFxcdH07XFxuXFx0fVxcblxcblxcdHVwZGF0ZShvYmopO1xcblxcblxcdHJldHVybiBmdW5jdGlvbiB1cGRhdGVTdHlsZShuZXdPYmopIHtcXG5cXHRcXHRpZihuZXdPYmopIHtcXG5cXHRcXHRcXHRpZihuZXdPYmouY3NzID09PSBvYmouY3NzICYmIG5ld09iai5tZWRpYSA9PT0gb2JqLm1lZGlhICYmIG5ld09iai5zb3VyY2VNYXAgPT09IG9iai5zb3VyY2VNYXApXFxuXFx0XFx0XFx0XFx0cmV0dXJuO1xcblxcdFxcdFxcdHVwZGF0ZShvYmogPSBuZXdPYmopO1xcblxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0cmVtb3ZlKCk7XFxuXFx0XFx0fVxcblxcdH07XFxufVxcblxcbnZhciByZXBsYWNlVGV4dCA9IChmdW5jdGlvbiAoKSB7XFxuXFx0dmFyIHRleHRTdG9yZSA9IFtdO1xcblxcblxcdHJldHVybiBmdW5jdGlvbiAoaW5kZXgsIHJlcGxhY2VtZW50KSB7XFxuXFx0XFx0dGV4dFN0b3JlW2luZGV4XSA9IHJlcGxhY2VtZW50O1xcblxcdFxcdHJldHVybiB0ZXh0U3RvcmUuZmlsdGVyKEJvb2xlYW4pLmpvaW4oJ1xcXFxuJyk7XFxuXFx0fTtcXG59KSgpO1xcblxcbmZ1bmN0aW9uIGFwcGx5VG9TaW5nbGV0b25UYWcoc3R5bGVFbGVtZW50LCBpbmRleCwgcmVtb3ZlLCBvYmopIHtcXG5cXHR2YXIgY3NzID0gcmVtb3ZlID8gXFxcIlxcXCIgOiBvYmouY3NzO1xcblxcblxcdGlmIChzdHlsZUVsZW1lbnQuc3R5bGVTaGVldCkge1xcblxcdFxcdHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0LmNzc1RleHQgPSByZXBsYWNlVGV4dChpbmRleCwgY3NzKTtcXG5cXHR9IGVsc2Uge1xcblxcdFxcdHZhciBjc3NOb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKTtcXG5cXHRcXHR2YXIgY2hpbGROb2RlcyA9IHN0eWxlRWxlbWVudC5jaGlsZE5vZGVzO1xcblxcdFxcdGlmIChjaGlsZE5vZGVzW2luZGV4XSkgc3R5bGVFbGVtZW50LnJlbW92ZUNoaWxkKGNoaWxkTm9kZXNbaW5kZXhdKTtcXG5cXHRcXHRpZiAoY2hpbGROb2Rlcy5sZW5ndGgpIHtcXG5cXHRcXHRcXHRzdHlsZUVsZW1lbnQuaW5zZXJ0QmVmb3JlKGNzc05vZGUsIGNoaWxkTm9kZXNbaW5kZXhdKTtcXG5cXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdHN0eWxlRWxlbWVudC5hcHBlbmRDaGlsZChjc3NOb2RlKTtcXG5cXHRcXHR9XFxuXFx0fVxcbn1cXG5cXG5mdW5jdGlvbiBhcHBseVRvVGFnKHN0eWxlRWxlbWVudCwgb2JqKSB7XFxuXFx0dmFyIGNzcyA9IG9iai5jc3M7XFxuXFx0dmFyIG1lZGlhID0gb2JqLm1lZGlhO1xcblxcblxcdGlmKG1lZGlhKSB7XFxuXFx0XFx0c3R5bGVFbGVtZW50LnNldEF0dHJpYnV0ZShcXFwibWVkaWFcXFwiLCBtZWRpYSlcXG5cXHR9XFxuXFxuXFx0aWYoc3R5bGVFbGVtZW50LnN0eWxlU2hlZXQpIHtcXG5cXHRcXHRzdHlsZUVsZW1lbnQuc3R5bGVTaGVldC5jc3NUZXh0ID0gY3NzO1xcblxcdH0gZWxzZSB7XFxuXFx0XFx0d2hpbGUoc3R5bGVFbGVtZW50LmZpcnN0Q2hpbGQpIHtcXG5cXHRcXHRcXHRzdHlsZUVsZW1lbnQucmVtb3ZlQ2hpbGQoc3R5bGVFbGVtZW50LmZpcnN0Q2hpbGQpO1xcblxcdFxcdH1cXG5cXHRcXHRzdHlsZUVsZW1lbnQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKSk7XFxuXFx0fVxcbn1cXG5cXG5mdW5jdGlvbiB1cGRhdGVMaW5rKGxpbmtFbGVtZW50LCBvcHRpb25zLCBvYmopIHtcXG5cXHR2YXIgY3NzID0gb2JqLmNzcztcXG5cXHR2YXIgc291cmNlTWFwID0gb2JqLnNvdXJjZU1hcDtcXG5cXG5cXHQvKiBJZiBjb252ZXJ0VG9BYnNvbHV0ZVVybHMgaXNuJ3QgZGVmaW5lZCwgYnV0IHNvdXJjZW1hcHMgYXJlIGVuYWJsZWRcXG5cXHRhbmQgdGhlcmUgaXMgbm8gcHVibGljUGF0aCBkZWZpbmVkIHRoZW4gbGV0cyB0dXJuIGNvbnZlcnRUb0Fic29sdXRlVXJsc1xcblxcdG9uIGJ5IGRlZmF1bHQuICBPdGhlcndpc2UgZGVmYXVsdCB0byB0aGUgY29udmVydFRvQWJzb2x1dGVVcmxzIG9wdGlvblxcblxcdGRpcmVjdGx5XFxuXFx0Ki9cXG5cXHR2YXIgYXV0b0ZpeFVybHMgPSBvcHRpb25zLmNvbnZlcnRUb0Fic29sdXRlVXJscyA9PT0gdW5kZWZpbmVkICYmIHNvdXJjZU1hcDtcXG5cXG5cXHRpZiAob3B0aW9ucy5jb252ZXJ0VG9BYnNvbHV0ZVVybHMgfHwgYXV0b0ZpeFVybHMpe1xcblxcdFxcdGNzcyA9IGZpeFVybHMoY3NzKTtcXG5cXHR9XFxuXFxuXFx0aWYoc291cmNlTWFwKSB7XFxuXFx0XFx0Ly8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjY2MDM4NzVcXG5cXHRcXHRjc3MgKz0gXFxcIlxcXFxuLyojIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxcXFwiICsgYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoc291cmNlTWFwKSkpKSArIFxcXCIgKi9cXFwiO1xcblxcdH1cXG5cXG5cXHR2YXIgYmxvYiA9IG5ldyBCbG9iKFtjc3NdLCB7IHR5cGU6IFxcXCJ0ZXh0L2Nzc1xcXCIgfSk7XFxuXFxuXFx0dmFyIG9sZFNyYyA9IGxpbmtFbGVtZW50LmhyZWY7XFxuXFxuXFx0bGlua0VsZW1lbnQuaHJlZiA9IFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XFxuXFxuXFx0aWYob2xkU3JjKVxcblxcdFxcdFVSTC5yZXZva2VPYmplY3RVUkwob2xkU3JjKTtcXG59XFxuXFxuXFxuLy8vLy8vLy8vLy8vLy8vLy8vXFxuLy8gV0VCUEFDSyBGT09URVJcXG4vLyAuL34vc3R5bGUtbG9hZGVyL2FkZFN0eWxlcy5qc1xcbi8vIG1vZHVsZSBpZCA9IDdcXG4vLyBtb2R1bGUgY2h1bmtzID0gMFxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL34vc3R5bGUtbG9hZGVyL2FkZFN0eWxlcy5qcz9cIik7XG5cbi8qKiovIH0pLFxuLyogOCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5ldmFsKFwiLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovKGZ1bmN0aW9uKF9fd2VicGFja19wcm92aWRlZF93aW5kb3dfZG90X2pRdWVyeSwgalF1ZXJ5KSB7LyoqXFxuICogT3dsIENhcm91c2VsIHYyLjIuMFxcbiAqIENvcHlyaWdodCAyMDEzLTIwMTYgRGF2aWQgRGV1dHNjaFxcbiAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL093bENhcm91c2VsMi9Pd2xDYXJvdXNlbDIvYmxvYi9tYXN0ZXIvTElDRU5TRSlcXG4gKi9cXG4vKipcXG4gKiBPd2wgY2Fyb3VzZWxcXG4gKiBAdmVyc2lvbiAyLjEuNlxcbiAqIEBhdXRob3IgQmFydG9zeiBXb2pjaWVjaG93c2tpXFxuICogQGF1dGhvciBEYXZpZCBEZXV0c2NoXFxuICogQGxpY2Vuc2UgVGhlIE1JVCBMaWNlbnNlIChNSVQpXFxuICogQHRvZG8gTGF6eSBMb2FkIEljb25cXG4gKiBAdG9kbyBwcmV2ZW50IGFuaW1hdGlvbmVuZCBidWJsaW5nXFxuICogQHRvZG8gaXRlbXNTY2FsZVVwXFxuICogQHRvZG8gVGVzdCBaZXB0b1xcbiAqIEB0b2RvIHN0YWdlUGFkZGluZyBjYWxjdWxhdGUgd3JvbmcgYWN0aXZlIGNsYXNzZXNcXG4gKi9cXG47KGZ1bmN0aW9uKCQsIHdpbmRvdywgZG9jdW1lbnQsIHVuZGVmaW5lZCkge1xcblxcblxcdC8qKlxcblxcdCAqIENyZWF0ZXMgYSBjYXJvdXNlbC5cXG5cXHQgKiBAY2xhc3MgVGhlIE93bCBDYXJvdXNlbC5cXG5cXHQgKiBAcHVibGljXFxuXFx0ICogQHBhcmFtIHtIVE1MRWxlbWVudHxqUXVlcnl9IGVsZW1lbnQgLSBUaGUgZWxlbWVudCB0byBjcmVhdGUgdGhlIGNhcm91c2VsIGZvci5cXG5cXHQgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gVGhlIG9wdGlvbnNcXG5cXHQgKi9cXG5cXHRmdW5jdGlvbiBPd2woZWxlbWVudCwgb3B0aW9ucykge1xcblxcblxcdFxcdC8qKlxcblxcdFxcdCAqIEN1cnJlbnQgc2V0dGluZ3MgZm9yIHRoZSBjYXJvdXNlbC5cXG5cXHRcXHQgKiBAcHVibGljXFxuXFx0XFx0ICovXFxuXFx0XFx0dGhpcy5zZXR0aW5ncyA9IG51bGw7XFxuXFxuXFx0XFx0LyoqXFxuXFx0XFx0ICogQ3VycmVudCBvcHRpb25zIHNldCBieSB0aGUgY2FsbGVyIGluY2x1ZGluZyBkZWZhdWx0cy5cXG5cXHRcXHQgKiBAcHVibGljXFxuXFx0XFx0ICovXFxuXFx0XFx0dGhpcy5vcHRpb25zID0gJC5leHRlbmQoe30sIE93bC5EZWZhdWx0cywgb3B0aW9ucyk7XFxuXFxuXFx0XFx0LyoqXFxuXFx0XFx0ICogUGx1Z2luIGVsZW1lbnQuXFxuXFx0XFx0ICogQHB1YmxpY1xcblxcdFxcdCAqL1xcblxcdFxcdHRoaXMuJGVsZW1lbnQgPSAkKGVsZW1lbnQpO1xcblxcblxcdFxcdC8qKlxcblxcdFxcdCAqIFByb3hpZWQgZXZlbnQgaGFuZGxlcnMuXFxuXFx0XFx0ICogQHByb3RlY3RlZFxcblxcdFxcdCAqL1xcblxcdFxcdHRoaXMuX2hhbmRsZXJzID0ge307XFxuXFxuXFx0XFx0LyoqXFxuXFx0XFx0ICogUmVmZXJlbmNlcyB0byB0aGUgcnVubmluZyBwbHVnaW5zIG9mIHRoaXMgY2Fyb3VzZWwuXFxuXFx0XFx0ICogQHByb3RlY3RlZFxcblxcdFxcdCAqL1xcblxcdFxcdHRoaXMuX3BsdWdpbnMgPSB7fTtcXG5cXG5cXHRcXHQvKipcXG5cXHRcXHQgKiBDdXJyZW50bHkgc3VwcHJlc3NlZCBldmVudHMgdG8gcHJldmVudCB0aGVtIGZyb20gYmVlaW5nIHJldHJpZ2dlcmVkLlxcblxcdFxcdCAqIEBwcm90ZWN0ZWRcXG5cXHRcXHQgKi9cXG5cXHRcXHR0aGlzLl9zdXByZXNzID0ge307XFxuXFxuXFx0XFx0LyoqXFxuXFx0XFx0ICogQWJzb2x1dGUgY3VycmVudCBwb3NpdGlvbi5cXG5cXHRcXHQgKiBAcHJvdGVjdGVkXFxuXFx0XFx0ICovXFxuXFx0XFx0dGhpcy5fY3VycmVudCA9IG51bGw7XFxuXFxuXFx0XFx0LyoqXFxuXFx0XFx0ICogQW5pbWF0aW9uIHNwZWVkIGluIG1pbGxpc2Vjb25kcy5cXG5cXHRcXHQgKiBAcHJvdGVjdGVkXFxuXFx0XFx0ICovXFxuXFx0XFx0dGhpcy5fc3BlZWQgPSBudWxsO1xcblxcblxcdFxcdC8qKlxcblxcdFxcdCAqIENvb3JkaW5hdGVzIG9mIGFsbCBpdGVtcyBpbiBwaXhlbC5cXG5cXHRcXHQgKiBAdG9kbyBUaGUgbmFtZSBvZiB0aGlzIG1lbWJlciBpcyBtaXNzbGVhZGluZy5cXG5cXHRcXHQgKiBAcHJvdGVjdGVkXFxuXFx0XFx0ICovXFxuXFx0XFx0dGhpcy5fY29vcmRpbmF0ZXMgPSBbXTtcXG5cXG5cXHRcXHQvKipcXG5cXHRcXHQgKiBDdXJyZW50IGJyZWFrcG9pbnQuXFxuXFx0XFx0ICogQHRvZG8gUmVhbCBtZWRpYSBxdWVyaWVzIHdvdWxkIGJlIG5pY2UuXFxuXFx0XFx0ICogQHByb3RlY3RlZFxcblxcdFxcdCAqL1xcblxcdFxcdHRoaXMuX2JyZWFrcG9pbnQgPSBudWxsO1xcblxcblxcdFxcdC8qKlxcblxcdFxcdCAqIEN1cnJlbnQgd2lkdGggb2YgdGhlIHBsdWdpbiBlbGVtZW50LlxcblxcdFxcdCAqL1xcblxcdFxcdHRoaXMuX3dpZHRoID0gbnVsbDtcXG5cXG5cXHRcXHQvKipcXG5cXHRcXHQgKiBBbGwgcmVhbCBpdGVtcy5cXG5cXHRcXHQgKiBAcHJvdGVjdGVkXFxuXFx0XFx0ICovXFxuXFx0XFx0dGhpcy5faXRlbXMgPSBbXTtcXG5cXG5cXHRcXHQvKipcXG5cXHRcXHQgKiBBbGwgY2xvbmVkIGl0ZW1zLlxcblxcdFxcdCAqIEBwcm90ZWN0ZWRcXG5cXHRcXHQgKi9cXG5cXHRcXHR0aGlzLl9jbG9uZXMgPSBbXTtcXG5cXG5cXHRcXHQvKipcXG5cXHRcXHQgKiBNZXJnZSB2YWx1ZXMgb2YgYWxsIGl0ZW1zLlxcblxcdFxcdCAqIEB0b2RvIE1heWJlIHRoaXMgY291bGQgYmUgcGFydCBvZiBhIHBsdWdpbi5cXG5cXHRcXHQgKiBAcHJvdGVjdGVkXFxuXFx0XFx0ICovXFxuXFx0XFx0dGhpcy5fbWVyZ2VycyA9IFtdO1xcblxcblxcdFxcdC8qKlxcblxcdFxcdCAqIFdpZHRocyBvZiBhbGwgaXRlbXMuXFxuXFx0XFx0ICovXFxuXFx0XFx0dGhpcy5fd2lkdGhzID0gW107XFxuXFxuXFx0XFx0LyoqXFxuXFx0XFx0ICogSW52YWxpZGF0ZWQgcGFydHMgd2l0aGluIHRoZSB1cGRhdGUgcHJvY2Vzcy5cXG5cXHRcXHQgKiBAcHJvdGVjdGVkXFxuXFx0XFx0ICovXFxuXFx0XFx0dGhpcy5faW52YWxpZGF0ZWQgPSB7fTtcXG5cXG5cXHRcXHQvKipcXG5cXHRcXHQgKiBPcmRlcmVkIGxpc3Qgb2Ygd29ya2VycyBmb3IgdGhlIHVwZGF0ZSBwcm9jZXNzLlxcblxcdFxcdCAqIEBwcm90ZWN0ZWRcXG5cXHRcXHQgKi9cXG5cXHRcXHR0aGlzLl9waXBlID0gW107XFxuXFxuXFx0XFx0LyoqXFxuXFx0XFx0ICogQ3VycmVudCBzdGF0ZSBpbmZvcm1hdGlvbiBmb3IgdGhlIGRyYWcgb3BlcmF0aW9uLlxcblxcdFxcdCAqIEB0b2RvICMyNjFcXG5cXHRcXHQgKiBAcHJvdGVjdGVkXFxuXFx0XFx0ICovXFxuXFx0XFx0dGhpcy5fZHJhZyA9IHtcXG5cXHRcXHRcXHR0aW1lOiBudWxsLFxcblxcdFxcdFxcdHRhcmdldDogbnVsbCxcXG5cXHRcXHRcXHRwb2ludGVyOiBudWxsLFxcblxcdFxcdFxcdHN0YWdlOiB7XFxuXFx0XFx0XFx0XFx0c3RhcnQ6IG51bGwsXFxuXFx0XFx0XFx0XFx0Y3VycmVudDogbnVsbFxcblxcdFxcdFxcdH0sXFxuXFx0XFx0XFx0ZGlyZWN0aW9uOiBudWxsXFxuXFx0XFx0fTtcXG5cXG5cXHRcXHQvKipcXG5cXHRcXHQgKiBDdXJyZW50IHN0YXRlIGluZm9ybWF0aW9uIGFuZCB0aGVpciB0YWdzLlxcblxcdFxcdCAqIEB0eXBlIHtPYmplY3R9XFxuXFx0XFx0ICogQHByb3RlY3RlZFxcblxcdFxcdCAqL1xcblxcdFxcdHRoaXMuX3N0YXRlcyA9IHtcXG5cXHRcXHRcXHRjdXJyZW50OiB7fSxcXG5cXHRcXHRcXHR0YWdzOiB7XFxuXFx0XFx0XFx0XFx0J2luaXRpYWxpemluZyc6IFsgJ2J1c3knIF0sXFxuXFx0XFx0XFx0XFx0J2FuaW1hdGluZyc6IFsgJ2J1c3knIF0sXFxuXFx0XFx0XFx0XFx0J2RyYWdnaW5nJzogWyAnaW50ZXJhY3RpbmcnIF1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0fTtcXG5cXG5cXHRcXHQkLmVhY2goWyAnb25SZXNpemUnLCAnb25UaHJvdHRsZWRSZXNpemUnIF0sICQucHJveHkoZnVuY3Rpb24oaSwgaGFuZGxlcikge1xcblxcdFxcdFxcdHRoaXMuX2hhbmRsZXJzW2hhbmRsZXJdID0gJC5wcm94eSh0aGlzW2hhbmRsZXJdLCB0aGlzKTtcXG5cXHRcXHR9LCB0aGlzKSk7XFxuXFxuXFx0XFx0JC5lYWNoKE93bC5QbHVnaW5zLCAkLnByb3h5KGZ1bmN0aW9uKGtleSwgcGx1Z2luKSB7XFxuXFx0XFx0XFx0dGhpcy5fcGx1Z2luc1trZXkuY2hhckF0KDApLnRvTG93ZXJDYXNlKCkgKyBrZXkuc2xpY2UoMSldXFxuXFx0XFx0XFx0XFx0PSBuZXcgcGx1Z2luKHRoaXMpO1xcblxcdFxcdH0sIHRoaXMpKTtcXG5cXG5cXHRcXHQkLmVhY2goT3dsLldvcmtlcnMsICQucHJveHkoZnVuY3Rpb24ocHJpb3JpdHksIHdvcmtlcikge1xcblxcdFxcdFxcdHRoaXMuX3BpcGUucHVzaCh7XFxuXFx0XFx0XFx0XFx0J2ZpbHRlcic6IHdvcmtlci5maWx0ZXIsXFxuXFx0XFx0XFx0XFx0J3J1bic6ICQucHJveHkod29ya2VyLnJ1biwgdGhpcylcXG5cXHRcXHRcXHR9KTtcXG5cXHRcXHR9LCB0aGlzKSk7XFxuXFxuXFx0XFx0dGhpcy5zZXR1cCgpO1xcblxcdFxcdHRoaXMuaW5pdGlhbGl6ZSgpO1xcblxcdH1cXG5cXG5cXHQvKipcXG5cXHQgKiBEZWZhdWx0IG9wdGlvbnMgZm9yIHRoZSBjYXJvdXNlbC5cXG5cXHQgKiBAcHVibGljXFxuXFx0ICovXFxuXFx0T3dsLkRlZmF1bHRzID0ge1xcblxcdFxcdGl0ZW1zOiAzLFxcblxcdFxcdGxvb3A6IGZhbHNlLFxcblxcdFxcdGNlbnRlcjogZmFsc2UsXFxuXFx0XFx0cmV3aW5kOiBmYWxzZSxcXG5cXG5cXHRcXHRtb3VzZURyYWc6IHRydWUsXFxuXFx0XFx0dG91Y2hEcmFnOiB0cnVlLFxcblxcdFxcdHB1bGxEcmFnOiB0cnVlLFxcblxcdFxcdGZyZWVEcmFnOiBmYWxzZSxcXG5cXG5cXHRcXHRtYXJnaW46IDAsXFxuXFx0XFx0c3RhZ2VQYWRkaW5nOiAwLFxcblxcblxcdFxcdG1lcmdlOiBmYWxzZSxcXG5cXHRcXHRtZXJnZUZpdDogdHJ1ZSxcXG5cXHRcXHRhdXRvV2lkdGg6IGZhbHNlLFxcblxcblxcdFxcdHN0YXJ0UG9zaXRpb246IDAsXFxuXFx0XFx0cnRsOiBmYWxzZSxcXG5cXG5cXHRcXHRzbWFydFNwZWVkOiAyNTAsXFxuXFx0XFx0Zmx1aWRTcGVlZDogZmFsc2UsXFxuXFx0XFx0ZHJhZ0VuZFNwZWVkOiBmYWxzZSxcXG5cXG5cXHRcXHRyZXNwb25zaXZlOiB7fSxcXG5cXHRcXHRyZXNwb25zaXZlUmVmcmVzaFJhdGU6IDIwMCxcXG5cXHRcXHRyZXNwb25zaXZlQmFzZUVsZW1lbnQ6IHdpbmRvdyxcXG5cXG5cXHRcXHRmYWxsYmFja0Vhc2luZzogJ3N3aW5nJyxcXG5cXG5cXHRcXHRpbmZvOiBmYWxzZSxcXG5cXG5cXHRcXHRuZXN0ZWRJdGVtU2VsZWN0b3I6IGZhbHNlLFxcblxcdFxcdGl0ZW1FbGVtZW50OiAnZGl2JyxcXG5cXHRcXHRzdGFnZUVsZW1lbnQ6ICdkaXYnLFxcblxcblxcdFxcdHJlZnJlc2hDbGFzczogJ293bC1yZWZyZXNoJyxcXG5cXHRcXHRsb2FkZWRDbGFzczogJ293bC1sb2FkZWQnLFxcblxcdFxcdGxvYWRpbmdDbGFzczogJ293bC1sb2FkaW5nJyxcXG5cXHRcXHRydGxDbGFzczogJ293bC1ydGwnLFxcblxcdFxcdHJlc3BvbnNpdmVDbGFzczogJ293bC1yZXNwb25zaXZlJyxcXG5cXHRcXHRkcmFnQ2xhc3M6ICdvd2wtZHJhZycsXFxuXFx0XFx0aXRlbUNsYXNzOiAnb3dsLWl0ZW0nLFxcblxcdFxcdHN0YWdlQ2xhc3M6ICdvd2wtc3RhZ2UnLFxcblxcdFxcdHN0YWdlT3V0ZXJDbGFzczogJ293bC1zdGFnZS1vdXRlcicsXFxuXFx0XFx0Z3JhYkNsYXNzOiAnb3dsLWdyYWInXFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBFbnVtZXJhdGlvbiBmb3Igd2lkdGguXFxuXFx0ICogQHB1YmxpY1xcblxcdCAqIEByZWFkb25seVxcblxcdCAqIEBlbnVtIHtTdHJpbmd9XFxuXFx0ICovXFxuXFx0T3dsLldpZHRoID0ge1xcblxcdFxcdERlZmF1bHQ6ICdkZWZhdWx0JyxcXG5cXHRcXHRJbm5lcjogJ2lubmVyJyxcXG5cXHRcXHRPdXRlcjogJ291dGVyJ1xcblxcdH07XFxuXFxuXFx0LyoqXFxuXFx0ICogRW51bWVyYXRpb24gZm9yIHR5cGVzLlxcblxcdCAqIEBwdWJsaWNcXG5cXHQgKiBAcmVhZG9ubHlcXG5cXHQgKiBAZW51bSB7U3RyaW5nfVxcblxcdCAqL1xcblxcdE93bC5UeXBlID0ge1xcblxcdFxcdEV2ZW50OiAnZXZlbnQnLFxcblxcdFxcdFN0YXRlOiAnc3RhdGUnXFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBDb250YWlucyBhbGwgcmVnaXN0ZXJlZCBwbHVnaW5zLlxcblxcdCAqIEBwdWJsaWNcXG5cXHQgKi9cXG5cXHRPd2wuUGx1Z2lucyA9IHt9O1xcblxcblxcdC8qKlxcblxcdCAqIExpc3Qgb2Ygd29ya2VycyBpbnZvbHZlZCBpbiB0aGUgdXBkYXRlIHByb2Nlc3MuXFxuXFx0ICovXFxuXFx0T3dsLldvcmtlcnMgPSBbIHtcXG5cXHRcXHRmaWx0ZXI6IFsgJ3dpZHRoJywgJ3NldHRpbmdzJyBdLFxcblxcdFxcdHJ1bjogZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0dGhpcy5fd2lkdGggPSB0aGlzLiRlbGVtZW50LndpZHRoKCk7XFxuXFx0XFx0fVxcblxcdH0sIHtcXG5cXHRcXHRmaWx0ZXI6IFsgJ3dpZHRoJywgJ2l0ZW1zJywgJ3NldHRpbmdzJyBdLFxcblxcdFxcdHJ1bjogZnVuY3Rpb24oY2FjaGUpIHtcXG5cXHRcXHRcXHRjYWNoZS5jdXJyZW50ID0gdGhpcy5faXRlbXMgJiYgdGhpcy5faXRlbXNbdGhpcy5yZWxhdGl2ZSh0aGlzLl9jdXJyZW50KV07XFxuXFx0XFx0fVxcblxcdH0sIHtcXG5cXHRcXHRmaWx0ZXI6IFsgJ2l0ZW1zJywgJ3NldHRpbmdzJyBdLFxcblxcdFxcdHJ1bjogZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0dGhpcy4kc3RhZ2UuY2hpbGRyZW4oJy5jbG9uZWQnKS5yZW1vdmUoKTtcXG5cXHRcXHR9XFxuXFx0fSwge1xcblxcdFxcdGZpbHRlcjogWyAnd2lkdGgnLCAnaXRlbXMnLCAnc2V0dGluZ3MnIF0sXFxuXFx0XFx0cnVuOiBmdW5jdGlvbihjYWNoZSkge1xcblxcdFxcdFxcdHZhciBtYXJnaW4gPSB0aGlzLnNldHRpbmdzLm1hcmdpbiB8fCAnJyxcXG5cXHRcXHRcXHRcXHRncmlkID0gIXRoaXMuc2V0dGluZ3MuYXV0b1dpZHRoLFxcblxcdFxcdFxcdFxcdHJ0bCA9IHRoaXMuc2V0dGluZ3MucnRsLFxcblxcdFxcdFxcdFxcdGNzcyA9IHtcXG5cXHRcXHRcXHRcXHRcXHQnd2lkdGgnOiAnYXV0bycsXFxuXFx0XFx0XFx0XFx0XFx0J21hcmdpbi1sZWZ0JzogcnRsID8gbWFyZ2luIDogJycsXFxuXFx0XFx0XFx0XFx0XFx0J21hcmdpbi1yaWdodCc6IHJ0bCA/ICcnIDogbWFyZ2luXFxuXFx0XFx0XFx0XFx0fTtcXG5cXG5cXHRcXHRcXHQhZ3JpZCAmJiB0aGlzLiRzdGFnZS5jaGlsZHJlbigpLmNzcyhjc3MpO1xcblxcblxcdFxcdFxcdGNhY2hlLmNzcyA9IGNzcztcXG5cXHRcXHR9XFxuXFx0fSwge1xcblxcdFxcdGZpbHRlcjogWyAnd2lkdGgnLCAnaXRlbXMnLCAnc2V0dGluZ3MnIF0sXFxuXFx0XFx0cnVuOiBmdW5jdGlvbihjYWNoZSkge1xcblxcdFxcdFxcdHZhciB3aWR0aCA9ICh0aGlzLndpZHRoKCkgLyB0aGlzLnNldHRpbmdzLml0ZW1zKS50b0ZpeGVkKDMpIC0gdGhpcy5zZXR0aW5ncy5tYXJnaW4sXFxuXFx0XFx0XFx0XFx0bWVyZ2UgPSBudWxsLFxcblxcdFxcdFxcdFxcdGl0ZXJhdG9yID0gdGhpcy5faXRlbXMubGVuZ3RoLFxcblxcdFxcdFxcdFxcdGdyaWQgPSAhdGhpcy5zZXR0aW5ncy5hdXRvV2lkdGgsXFxuXFx0XFx0XFx0XFx0d2lkdGhzID0gW107XFxuXFxuXFx0XFx0XFx0Y2FjaGUuaXRlbXMgPSB7XFxuXFx0XFx0XFx0XFx0bWVyZ2U6IGZhbHNlLFxcblxcdFxcdFxcdFxcdHdpZHRoOiB3aWR0aFxcblxcdFxcdFxcdH07XFxuXFxuXFx0XFx0XFx0d2hpbGUgKGl0ZXJhdG9yLS0pIHtcXG5cXHRcXHRcXHRcXHRtZXJnZSA9IHRoaXMuX21lcmdlcnNbaXRlcmF0b3JdO1xcblxcdFxcdFxcdFxcdG1lcmdlID0gdGhpcy5zZXR0aW5ncy5tZXJnZUZpdCAmJiBNYXRoLm1pbihtZXJnZSwgdGhpcy5zZXR0aW5ncy5pdGVtcykgfHwgbWVyZ2U7XFxuXFxuXFx0XFx0XFx0XFx0Y2FjaGUuaXRlbXMubWVyZ2UgPSBtZXJnZSA+IDEgfHwgY2FjaGUuaXRlbXMubWVyZ2U7XFxuXFxuXFx0XFx0XFx0XFx0d2lkdGhzW2l0ZXJhdG9yXSA9ICFncmlkID8gdGhpcy5faXRlbXNbaXRlcmF0b3JdLndpZHRoKCkgOiB3aWR0aCAqIG1lcmdlO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR0aGlzLl93aWR0aHMgPSB3aWR0aHM7XFxuXFx0XFx0fVxcblxcdH0sIHtcXG5cXHRcXHRmaWx0ZXI6IFsgJ2l0ZW1zJywgJ3NldHRpbmdzJyBdLFxcblxcdFxcdHJ1bjogZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0dmFyIGNsb25lcyA9IFtdLFxcblxcdFxcdFxcdFxcdGl0ZW1zID0gdGhpcy5faXRlbXMsXFxuXFx0XFx0XFx0XFx0c2V0dGluZ3MgPSB0aGlzLnNldHRpbmdzLFxcblxcdFxcdFxcdFxcdHZpZXcgPSBNYXRoLm1heChzZXR0aW5ncy5pdGVtcyAqIDIsIDQpLFxcblxcdFxcdFxcdFxcdHNpemUgPSBNYXRoLmNlaWwoaXRlbXMubGVuZ3RoIC8gMikgKiAyLFxcblxcdFxcdFxcdFxcdHJlcGVhdCA9IHNldHRpbmdzLmxvb3AgJiYgaXRlbXMubGVuZ3RoID8gc2V0dGluZ3MucmV3aW5kID8gdmlldyA6IE1hdGgubWF4KHZpZXcsIHNpemUpIDogMCxcXG5cXHRcXHRcXHRcXHRhcHBlbmQgPSAnJyxcXG5cXHRcXHRcXHRcXHRwcmVwZW5kID0gJyc7XFxuXFxuXFx0XFx0XFx0cmVwZWF0IC89IDI7XFxuXFxuXFx0XFx0XFx0d2hpbGUgKHJlcGVhdC0tKSB7XFxuXFx0XFx0XFx0XFx0Y2xvbmVzLnB1c2godGhpcy5ub3JtYWxpemUoY2xvbmVzLmxlbmd0aCAvIDIsIHRydWUpKTtcXG5cXHRcXHRcXHRcXHRhcHBlbmQgPSBhcHBlbmQgKyBpdGVtc1tjbG9uZXNbY2xvbmVzLmxlbmd0aCAtIDFdXVswXS5vdXRlckhUTUw7XFxuXFx0XFx0XFx0XFx0Y2xvbmVzLnB1c2godGhpcy5ub3JtYWxpemUoaXRlbXMubGVuZ3RoIC0gMSAtIChjbG9uZXMubGVuZ3RoIC0gMSkgLyAyLCB0cnVlKSk7XFxuXFx0XFx0XFx0XFx0cHJlcGVuZCA9IGl0ZW1zW2Nsb25lc1tjbG9uZXMubGVuZ3RoIC0gMV1dWzBdLm91dGVySFRNTCArIHByZXBlbmQ7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHRoaXMuX2Nsb25lcyA9IGNsb25lcztcXG5cXG5cXHRcXHRcXHQkKGFwcGVuZCkuYWRkQ2xhc3MoJ2Nsb25lZCcpLmFwcGVuZFRvKHRoaXMuJHN0YWdlKTtcXG5cXHRcXHRcXHQkKHByZXBlbmQpLmFkZENsYXNzKCdjbG9uZWQnKS5wcmVwZW5kVG8odGhpcy4kc3RhZ2UpO1xcblxcdFxcdH1cXG5cXHR9LCB7XFxuXFx0XFx0ZmlsdGVyOiBbICd3aWR0aCcsICdpdGVtcycsICdzZXR0aW5ncycgXSxcXG5cXHRcXHRydW46IGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdHZhciBydGwgPSB0aGlzLnNldHRpbmdzLnJ0bCA/IDEgOiAtMSxcXG5cXHRcXHRcXHRcXHRzaXplID0gdGhpcy5fY2xvbmVzLmxlbmd0aCArIHRoaXMuX2l0ZW1zLmxlbmd0aCxcXG5cXHRcXHRcXHRcXHRpdGVyYXRvciA9IC0xLFxcblxcdFxcdFxcdFxcdHByZXZpb3VzID0gMCxcXG5cXHRcXHRcXHRcXHRjdXJyZW50ID0gMCxcXG5cXHRcXHRcXHRcXHRjb29yZGluYXRlcyA9IFtdO1xcblxcblxcdFxcdFxcdHdoaWxlICgrK2l0ZXJhdG9yIDwgc2l6ZSkge1xcblxcdFxcdFxcdFxcdHByZXZpb3VzID0gY29vcmRpbmF0ZXNbaXRlcmF0b3IgLSAxXSB8fCAwO1xcblxcdFxcdFxcdFxcdGN1cnJlbnQgPSB0aGlzLl93aWR0aHNbdGhpcy5yZWxhdGl2ZShpdGVyYXRvcildICsgdGhpcy5zZXR0aW5ncy5tYXJnaW47XFxuXFx0XFx0XFx0XFx0Y29vcmRpbmF0ZXMucHVzaChwcmV2aW91cyArIGN1cnJlbnQgKiBydGwpO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR0aGlzLl9jb29yZGluYXRlcyA9IGNvb3JkaW5hdGVzO1xcblxcdFxcdH1cXG5cXHR9LCB7XFxuXFx0XFx0ZmlsdGVyOiBbICd3aWR0aCcsICdpdGVtcycsICdzZXR0aW5ncycgXSxcXG5cXHRcXHRydW46IGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdHZhciBwYWRkaW5nID0gdGhpcy5zZXR0aW5ncy5zdGFnZVBhZGRpbmcsXFxuXFx0XFx0XFx0XFx0Y29vcmRpbmF0ZXMgPSB0aGlzLl9jb29yZGluYXRlcyxcXG5cXHRcXHRcXHRcXHRjc3MgPSB7XFxuXFx0XFx0XFx0XFx0XFx0J3dpZHRoJzogTWF0aC5jZWlsKE1hdGguYWJzKGNvb3JkaW5hdGVzW2Nvb3JkaW5hdGVzLmxlbmd0aCAtIDFdKSkgKyBwYWRkaW5nICogMixcXG5cXHRcXHRcXHRcXHRcXHQncGFkZGluZy1sZWZ0JzogcGFkZGluZyB8fCAnJyxcXG5cXHRcXHRcXHRcXHRcXHQncGFkZGluZy1yaWdodCc6IHBhZGRpbmcgfHwgJydcXG5cXHRcXHRcXHRcXHR9O1xcblxcblxcdFxcdFxcdHRoaXMuJHN0YWdlLmNzcyhjc3MpO1xcblxcdFxcdH1cXG5cXHR9LCB7XFxuXFx0XFx0ZmlsdGVyOiBbICd3aWR0aCcsICdpdGVtcycsICdzZXR0aW5ncycgXSxcXG5cXHRcXHRydW46IGZ1bmN0aW9uKGNhY2hlKSB7XFxuXFx0XFx0XFx0dmFyIGl0ZXJhdG9yID0gdGhpcy5fY29vcmRpbmF0ZXMubGVuZ3RoLFxcblxcdFxcdFxcdFxcdGdyaWQgPSAhdGhpcy5zZXR0aW5ncy5hdXRvV2lkdGgsXFxuXFx0XFx0XFx0XFx0aXRlbXMgPSB0aGlzLiRzdGFnZS5jaGlsZHJlbigpO1xcblxcblxcdFxcdFxcdGlmIChncmlkICYmIGNhY2hlLml0ZW1zLm1lcmdlKSB7XFxuXFx0XFx0XFx0XFx0d2hpbGUgKGl0ZXJhdG9yLS0pIHtcXG5cXHRcXHRcXHRcXHRcXHRjYWNoZS5jc3Mud2lkdGggPSB0aGlzLl93aWR0aHNbdGhpcy5yZWxhdGl2ZShpdGVyYXRvcildO1xcblxcdFxcdFxcdFxcdFxcdGl0ZW1zLmVxKGl0ZXJhdG9yKS5jc3MoY2FjaGUuY3NzKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fSBlbHNlIGlmIChncmlkKSB7XFxuXFx0XFx0XFx0XFx0Y2FjaGUuY3NzLndpZHRoID0gY2FjaGUuaXRlbXMud2lkdGg7XFxuXFx0XFx0XFx0XFx0aXRlbXMuY3NzKGNhY2hlLmNzcyk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXHR9LCB7XFxuXFx0XFx0ZmlsdGVyOiBbICdpdGVtcycgXSxcXG5cXHRcXHRydW46IGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdHRoaXMuX2Nvb3JkaW5hdGVzLmxlbmd0aCA8IDEgJiYgdGhpcy4kc3RhZ2UucmVtb3ZlQXR0cignc3R5bGUnKTtcXG5cXHRcXHR9XFxuXFx0fSwge1xcblxcdFxcdGZpbHRlcjogWyAnd2lkdGgnLCAnaXRlbXMnLCAnc2V0dGluZ3MnIF0sXFxuXFx0XFx0cnVuOiBmdW5jdGlvbihjYWNoZSkge1xcblxcdFxcdFxcdGNhY2hlLmN1cnJlbnQgPSBjYWNoZS5jdXJyZW50ID8gdGhpcy4kc3RhZ2UuY2hpbGRyZW4oKS5pbmRleChjYWNoZS5jdXJyZW50KSA6IDA7XFxuXFx0XFx0XFx0Y2FjaGUuY3VycmVudCA9IE1hdGgubWF4KHRoaXMubWluaW11bSgpLCBNYXRoLm1pbih0aGlzLm1heGltdW0oKSwgY2FjaGUuY3VycmVudCkpO1xcblxcdFxcdFxcdHRoaXMucmVzZXQoY2FjaGUuY3VycmVudCk7XFxuXFx0XFx0fVxcblxcdH0sIHtcXG5cXHRcXHRmaWx0ZXI6IFsgJ3Bvc2l0aW9uJyBdLFxcblxcdFxcdHJ1bjogZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0dGhpcy5hbmltYXRlKHRoaXMuY29vcmRpbmF0ZXModGhpcy5fY3VycmVudCkpO1xcblxcdFxcdH1cXG5cXHR9LCB7XFxuXFx0XFx0ZmlsdGVyOiBbICd3aWR0aCcsICdwb3NpdGlvbicsICdpdGVtcycsICdzZXR0aW5ncycgXSxcXG5cXHRcXHRydW46IGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdHZhciBydGwgPSB0aGlzLnNldHRpbmdzLnJ0bCA/IDEgOiAtMSxcXG5cXHRcXHRcXHRcXHRwYWRkaW5nID0gdGhpcy5zZXR0aW5ncy5zdGFnZVBhZGRpbmcgKiAyLFxcblxcdFxcdFxcdFxcdGJlZ2luID0gdGhpcy5jb29yZGluYXRlcyh0aGlzLmN1cnJlbnQoKSkgKyBwYWRkaW5nLFxcblxcdFxcdFxcdFxcdGVuZCA9IGJlZ2luICsgdGhpcy53aWR0aCgpICogcnRsLFxcblxcdFxcdFxcdFxcdGlubmVyLCBvdXRlciwgbWF0Y2hlcyA9IFtdLCBpLCBuO1xcblxcblxcdFxcdFxcdGZvciAoaSA9IDAsIG4gPSB0aGlzLl9jb29yZGluYXRlcy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcXG5cXHRcXHRcXHRcXHRpbm5lciA9IHRoaXMuX2Nvb3JkaW5hdGVzW2kgLSAxXSB8fCAwO1xcblxcdFxcdFxcdFxcdG91dGVyID0gTWF0aC5hYnModGhpcy5fY29vcmRpbmF0ZXNbaV0pICsgcGFkZGluZyAqIHJ0bDtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoKHRoaXMub3AoaW5uZXIsICc8PScsIGJlZ2luKSAmJiAodGhpcy5vcChpbm5lciwgJz4nLCBlbmQpKSlcXG5cXHRcXHRcXHRcXHRcXHR8fCAodGhpcy5vcChvdXRlciwgJzwnLCBiZWdpbikgJiYgdGhpcy5vcChvdXRlciwgJz4nLCBlbmQpKSkge1xcblxcdFxcdFxcdFxcdFxcdG1hdGNoZXMucHVzaChpKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHRoaXMuJHN0YWdlLmNoaWxkcmVuKCcuYWN0aXZlJykucmVtb3ZlQ2xhc3MoJ2FjdGl2ZScpO1xcblxcdFxcdFxcdHRoaXMuJHN0YWdlLmNoaWxkcmVuKCc6ZXEoJyArIG1hdGNoZXMuam9pbignKSwgOmVxKCcpICsgJyknKS5hZGRDbGFzcygnYWN0aXZlJyk7XFxuXFxuXFx0XFx0XFx0aWYgKHRoaXMuc2V0dGluZ3MuY2VudGVyKSB7XFxuXFx0XFx0XFx0XFx0dGhpcy4kc3RhZ2UuY2hpbGRyZW4oJy5jZW50ZXInKS5yZW1vdmVDbGFzcygnY2VudGVyJyk7XFxuXFx0XFx0XFx0XFx0dGhpcy4kc3RhZ2UuY2hpbGRyZW4oKS5lcSh0aGlzLmN1cnJlbnQoKSkuYWRkQ2xhc3MoJ2NlbnRlcicpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFx0fSBdO1xcblxcblxcdC8qKlxcblxcdCAqIEluaXRpYWxpemVzIHRoZSBjYXJvdXNlbC5cXG5cXHQgKiBAcHJvdGVjdGVkXFxuXFx0ICovXFxuXFx0T3dsLnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24oKSB7XFxuXFx0XFx0dGhpcy5lbnRlcignaW5pdGlhbGl6aW5nJyk7XFxuXFx0XFx0dGhpcy50cmlnZ2VyKCdpbml0aWFsaXplJyk7XFxuXFxuXFx0XFx0dGhpcy4kZWxlbWVudC50b2dnbGVDbGFzcyh0aGlzLnNldHRpbmdzLnJ0bENsYXNzLCB0aGlzLnNldHRpbmdzLnJ0bCk7XFxuXFxuXFx0XFx0aWYgKHRoaXMuc2V0dGluZ3MuYXV0b1dpZHRoICYmICF0aGlzLmlzKCdwcmUtbG9hZGluZycpKSB7XFxuXFx0XFx0XFx0dmFyIGltZ3MsIG5lc3RlZFNlbGVjdG9yLCB3aWR0aDtcXG5cXHRcXHRcXHRpbWdzID0gdGhpcy4kZWxlbWVudC5maW5kKCdpbWcnKTtcXG5cXHRcXHRcXHRuZXN0ZWRTZWxlY3RvciA9IHRoaXMuc2V0dGluZ3MubmVzdGVkSXRlbVNlbGVjdG9yID8gJy4nICsgdGhpcy5zZXR0aW5ncy5uZXN0ZWRJdGVtU2VsZWN0b3IgOiB1bmRlZmluZWQ7XFxuXFx0XFx0XFx0d2lkdGggPSB0aGlzLiRlbGVtZW50LmNoaWxkcmVuKG5lc3RlZFNlbGVjdG9yKS53aWR0aCgpO1xcblxcblxcdFxcdFxcdGlmIChpbWdzLmxlbmd0aCAmJiB3aWR0aCA8PSAwKSB7XFxuXFx0XFx0XFx0XFx0dGhpcy5wcmVsb2FkQXV0b1dpZHRoSW1hZ2VzKGltZ3MpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFxuXFx0XFx0dGhpcy4kZWxlbWVudC5hZGRDbGFzcyh0aGlzLm9wdGlvbnMubG9hZGluZ0NsYXNzKTtcXG5cXG5cXHRcXHQvLyBjcmVhdGUgc3RhZ2VcXG5cXHRcXHR0aGlzLiRzdGFnZSA9ICQoJzwnICsgdGhpcy5zZXR0aW5ncy5zdGFnZUVsZW1lbnQgKyAnIGNsYXNzPVxcXCInICsgdGhpcy5zZXR0aW5ncy5zdGFnZUNsYXNzICsgJ1xcXCIvPicpXFxuXFx0XFx0XFx0LndyYXAoJzxkaXYgY2xhc3M9XFxcIicgKyB0aGlzLnNldHRpbmdzLnN0YWdlT3V0ZXJDbGFzcyArICdcXFwiLz4nKTtcXG5cXG5cXHRcXHQvLyBhcHBlbmQgc3RhZ2VcXG5cXHRcXHR0aGlzLiRlbGVtZW50LmFwcGVuZCh0aGlzLiRzdGFnZS5wYXJlbnQoKSk7XFxuXFxuXFx0XFx0Ly8gYXBwZW5kIGNvbnRlbnRcXG5cXHRcXHR0aGlzLnJlcGxhY2UodGhpcy4kZWxlbWVudC5jaGlsZHJlbigpLm5vdCh0aGlzLiRzdGFnZS5wYXJlbnQoKSkpO1xcblxcblxcdFxcdC8vIGNoZWNrIHZpc2liaWxpdHlcXG5cXHRcXHRpZiAodGhpcy4kZWxlbWVudC5pcygnOnZpc2libGUnKSkge1xcblxcdFxcdFxcdC8vIHVwZGF0ZSB2aWV3XFxuXFx0XFx0XFx0dGhpcy5yZWZyZXNoKCk7XFxuXFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHQvLyBpbnZhbGlkYXRlIHdpZHRoXFxuXFx0XFx0XFx0dGhpcy5pbnZhbGlkYXRlKCd3aWR0aCcpO1xcblxcdFxcdH1cXG5cXG5cXHRcXHR0aGlzLiRlbGVtZW50XFxuXFx0XFx0XFx0LnJlbW92ZUNsYXNzKHRoaXMub3B0aW9ucy5sb2FkaW5nQ2xhc3MpXFxuXFx0XFx0XFx0LmFkZENsYXNzKHRoaXMub3B0aW9ucy5sb2FkZWRDbGFzcyk7XFxuXFxuXFx0XFx0Ly8gcmVnaXN0ZXIgZXZlbnQgaGFuZGxlcnNcXG5cXHRcXHR0aGlzLnJlZ2lzdGVyRXZlbnRIYW5kbGVycygpO1xcblxcblxcdFxcdHRoaXMubGVhdmUoJ2luaXRpYWxpemluZycpO1xcblxcdFxcdHRoaXMudHJpZ2dlcignaW5pdGlhbGl6ZWQnKTtcXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIFNldHVwcyB0aGUgY3VycmVudCBzZXR0aW5ncy5cXG5cXHQgKiBAdG9kbyBSZW1vdmUgcmVzcG9uc2l2ZSBjbGFzc2VzLiBXaHkgc2hvdWxkIGFkYXB0aXZlIGRlc2lnbnMgYmUgYnJvdWdodCBpbnRvIElFOD9cXG5cXHQgKiBAdG9kbyBTdXBwb3J0IGZvciBtZWRpYSBxdWVyaWVzIGJ5IHVzaW5nIGBtYXRjaE1lZGlhYCB3b3VsZCBiZSBuaWNlLlxcblxcdCAqIEBwdWJsaWNcXG5cXHQgKi9cXG5cXHRPd2wucHJvdG90eXBlLnNldHVwID0gZnVuY3Rpb24oKSB7XFxuXFx0XFx0dmFyIHZpZXdwb3J0ID0gdGhpcy52aWV3cG9ydCgpLFxcblxcdFxcdFxcdG92ZXJ3cml0ZXMgPSB0aGlzLm9wdGlvbnMucmVzcG9uc2l2ZSxcXG5cXHRcXHRcXHRtYXRjaCA9IC0xLFxcblxcdFxcdFxcdHNldHRpbmdzID0gbnVsbDtcXG5cXG5cXHRcXHRpZiAoIW92ZXJ3cml0ZXMpIHtcXG5cXHRcXHRcXHRzZXR0aW5ncyA9ICQuZXh0ZW5kKHt9LCB0aGlzLm9wdGlvbnMpO1xcblxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0JC5lYWNoKG92ZXJ3cml0ZXMsIGZ1bmN0aW9uKGJyZWFrcG9pbnQpIHtcXG5cXHRcXHRcXHRcXHRpZiAoYnJlYWtwb2ludCA8PSB2aWV3cG9ydCAmJiBicmVha3BvaW50ID4gbWF0Y2gpIHtcXG5cXHRcXHRcXHRcXHRcXHRtYXRjaCA9IE51bWJlcihicmVha3BvaW50KTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fSk7XFxuXFxuXFx0XFx0XFx0c2V0dGluZ3MgPSAkLmV4dGVuZCh7fSwgdGhpcy5vcHRpb25zLCBvdmVyd3JpdGVzW21hdGNoXSk7XFxuXFx0XFx0XFx0aWYgKHR5cGVvZiBzZXR0aW5ncy5zdGFnZVBhZGRpbmcgPT09ICdmdW5jdGlvbicpIHtcXG5cXHRcXHRcXHRcXHRzZXR0aW5ncy5zdGFnZVBhZGRpbmcgPSBzZXR0aW5ncy5zdGFnZVBhZGRpbmcoKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0ZGVsZXRlIHNldHRpbmdzLnJlc3BvbnNpdmU7XFxuXFxuXFx0XFx0XFx0Ly8gcmVzcG9uc2l2ZSBjbGFzc1xcblxcdFxcdFxcdGlmIChzZXR0aW5ncy5yZXNwb25zaXZlQ2xhc3MpIHtcXG5cXHRcXHRcXHRcXHR0aGlzLiRlbGVtZW50LmF0dHIoJ2NsYXNzJyxcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLiRlbGVtZW50LmF0dHIoJ2NsYXNzJykucmVwbGFjZShuZXcgUmVnRXhwKCcoJyArIHRoaXMub3B0aW9ucy5yZXNwb25zaXZlQ2xhc3MgKyAnLSlcXFxcXFxcXFMrXFxcXFxcXFxzJywgJ2cnKSwgJyQxJyArIG1hdGNoKVxcblxcdFxcdFxcdFxcdCk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXG5cXHRcXHR0aGlzLnRyaWdnZXIoJ2NoYW5nZScsIHsgcHJvcGVydHk6IHsgbmFtZTogJ3NldHRpbmdzJywgdmFsdWU6IHNldHRpbmdzIH0gfSk7XFxuXFx0XFx0dGhpcy5fYnJlYWtwb2ludCA9IG1hdGNoO1xcblxcdFxcdHRoaXMuc2V0dGluZ3MgPSBzZXR0aW5ncztcXG5cXHRcXHR0aGlzLmludmFsaWRhdGUoJ3NldHRpbmdzJyk7XFxuXFx0XFx0dGhpcy50cmlnZ2VyKCdjaGFuZ2VkJywgeyBwcm9wZXJ0eTogeyBuYW1lOiAnc2V0dGluZ3MnLCB2YWx1ZTogdGhpcy5zZXR0aW5ncyB9IH0pO1xcblxcdH07XFxuXFxuXFx0LyoqXFxuXFx0ICogVXBkYXRlcyBvcHRpb24gbG9naWMgaWYgbmVjZXNzZXJ5LlxcblxcdCAqIEBwcm90ZWN0ZWRcXG5cXHQgKi9cXG5cXHRPd2wucHJvdG90eXBlLm9wdGlvbnNMb2dpYyA9IGZ1bmN0aW9uKCkge1xcblxcdFxcdGlmICh0aGlzLnNldHRpbmdzLmF1dG9XaWR0aCkge1xcblxcdFxcdFxcdHRoaXMuc2V0dGluZ3Muc3RhZ2VQYWRkaW5nID0gZmFsc2U7XFxuXFx0XFx0XFx0dGhpcy5zZXR0aW5ncy5tZXJnZSA9IGZhbHNlO1xcblxcdFxcdH1cXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIFByZXBhcmVzIGFuIGl0ZW0gYmVmb3JlIGFkZC5cXG5cXHQgKiBAdG9kbyBSZW5hbWUgZXZlbnQgcGFyYW1ldGVyIGBjb250ZW50YCB0byBgaXRlbWAuXFxuXFx0ICogQHByb3RlY3RlZFxcblxcdCAqIEByZXR1cm5zIHtqUXVlcnl8SFRNTEVsZW1lbnR9IC0gVGhlIGl0ZW0gY29udGFpbmVyLlxcblxcdCAqL1xcblxcdE93bC5wcm90b3R5cGUucHJlcGFyZSA9IGZ1bmN0aW9uKGl0ZW0pIHtcXG5cXHRcXHR2YXIgZXZlbnQgPSB0aGlzLnRyaWdnZXIoJ3ByZXBhcmUnLCB7IGNvbnRlbnQ6IGl0ZW0gfSk7XFxuXFxuXFx0XFx0aWYgKCFldmVudC5kYXRhKSB7XFxuXFx0XFx0XFx0ZXZlbnQuZGF0YSA9ICQoJzwnICsgdGhpcy5zZXR0aW5ncy5pdGVtRWxlbWVudCArICcvPicpXFxuXFx0XFx0XFx0XFx0LmFkZENsYXNzKHRoaXMub3B0aW9ucy5pdGVtQ2xhc3MpLmFwcGVuZChpdGVtKVxcblxcdFxcdH1cXG5cXG5cXHRcXHR0aGlzLnRyaWdnZXIoJ3ByZXBhcmVkJywgeyBjb250ZW50OiBldmVudC5kYXRhIH0pO1xcblxcblxcdFxcdHJldHVybiBldmVudC5kYXRhO1xcblxcdH07XFxuXFxuXFx0LyoqXFxuXFx0ICogVXBkYXRlcyB0aGUgdmlldy5cXG5cXHQgKiBAcHVibGljXFxuXFx0ICovXFxuXFx0T3dsLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbigpIHtcXG5cXHRcXHR2YXIgaSA9IDAsXFxuXFx0XFx0XFx0biA9IHRoaXMuX3BpcGUubGVuZ3RoLFxcblxcdFxcdFxcdGZpbHRlciA9ICQucHJveHkoZnVuY3Rpb24ocCkgeyByZXR1cm4gdGhpc1twXSB9LCB0aGlzLl9pbnZhbGlkYXRlZCksXFxuXFx0XFx0XFx0Y2FjaGUgPSB7fTtcXG5cXG5cXHRcXHR3aGlsZSAoaSA8IG4pIHtcXG5cXHRcXHRcXHRpZiAodGhpcy5faW52YWxpZGF0ZWQuYWxsIHx8ICQuZ3JlcCh0aGlzLl9waXBlW2ldLmZpbHRlciwgZmlsdGVyKS5sZW5ndGggPiAwKSB7XFxuXFx0XFx0XFx0XFx0dGhpcy5fcGlwZVtpXS5ydW4oY2FjaGUpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpKys7XFxuXFx0XFx0fVxcblxcblxcdFxcdHRoaXMuX2ludmFsaWRhdGVkID0ge307XFxuXFxuXFx0XFx0IXRoaXMuaXMoJ3ZhbGlkJykgJiYgdGhpcy5lbnRlcigndmFsaWQnKTtcXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIEdldHMgdGhlIHdpZHRoIG9mIHRoZSB2aWV3LlxcblxcdCAqIEBwdWJsaWNcXG5cXHQgKiBAcGFyYW0ge093bC5XaWR0aH0gW2RpbWVuc2lvbj1Pd2wuV2lkdGguRGVmYXVsdF0gLSBUaGUgZGltZW5zaW9uIHRvIHJldHVybi5cXG5cXHQgKiBAcmV0dXJucyB7TnVtYmVyfSAtIFRoZSB3aWR0aCBvZiB0aGUgdmlldyBpbiBwaXhlbC5cXG5cXHQgKi9cXG5cXHRPd2wucHJvdG90eXBlLndpZHRoID0gZnVuY3Rpb24oZGltZW5zaW9uKSB7XFxuXFx0XFx0ZGltZW5zaW9uID0gZGltZW5zaW9uIHx8IE93bC5XaWR0aC5EZWZhdWx0O1xcblxcdFxcdHN3aXRjaCAoZGltZW5zaW9uKSB7XFxuXFx0XFx0XFx0Y2FzZSBPd2wuV2lkdGguSW5uZXI6XFxuXFx0XFx0XFx0Y2FzZSBPd2wuV2lkdGguT3V0ZXI6XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXMuX3dpZHRoO1xcblxcdFxcdFxcdGRlZmF1bHQ6XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXMuX3dpZHRoIC0gdGhpcy5zZXR0aW5ncy5zdGFnZVBhZGRpbmcgKiAyICsgdGhpcy5zZXR0aW5ncy5tYXJnaW47XFxuXFx0XFx0fVxcblxcdH07XFxuXFxuXFx0LyoqXFxuXFx0ICogUmVmcmVzaGVzIHRoZSBjYXJvdXNlbCBwcmltYXJpbHkgZm9yIGFkYXB0aXZlIHB1cnBvc2VzLlxcblxcdCAqIEBwdWJsaWNcXG5cXHQgKi9cXG5cXHRPd2wucHJvdG90eXBlLnJlZnJlc2ggPSBmdW5jdGlvbigpIHtcXG5cXHRcXHR0aGlzLmVudGVyKCdyZWZyZXNoaW5nJyk7XFxuXFx0XFx0dGhpcy50cmlnZ2VyKCdyZWZyZXNoJyk7XFxuXFxuXFx0XFx0dGhpcy5zZXR1cCgpO1xcblxcblxcdFxcdHRoaXMub3B0aW9uc0xvZ2ljKCk7XFxuXFxuXFx0XFx0dGhpcy4kZWxlbWVudC5hZGRDbGFzcyh0aGlzLm9wdGlvbnMucmVmcmVzaENsYXNzKTtcXG5cXG5cXHRcXHR0aGlzLnVwZGF0ZSgpO1xcblxcblxcdFxcdHRoaXMuJGVsZW1lbnQucmVtb3ZlQ2xhc3ModGhpcy5vcHRpb25zLnJlZnJlc2hDbGFzcyk7XFxuXFxuXFx0XFx0dGhpcy5sZWF2ZSgncmVmcmVzaGluZycpO1xcblxcdFxcdHRoaXMudHJpZ2dlcigncmVmcmVzaGVkJyk7XFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBDaGVja3Mgd2luZG93IGByZXNpemVgIGV2ZW50LlxcblxcdCAqIEBwcm90ZWN0ZWRcXG5cXHQgKi9cXG5cXHRPd2wucHJvdG90eXBlLm9uVGhyb3R0bGVkUmVzaXplID0gZnVuY3Rpb24oKSB7XFxuXFx0XFx0d2luZG93LmNsZWFyVGltZW91dCh0aGlzLnJlc2l6ZVRpbWVyKTtcXG5cXHRcXHR0aGlzLnJlc2l6ZVRpbWVyID0gd2luZG93LnNldFRpbWVvdXQodGhpcy5faGFuZGxlcnMub25SZXNpemUsIHRoaXMuc2V0dGluZ3MucmVzcG9uc2l2ZVJlZnJlc2hSYXRlKTtcXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIENoZWNrcyB3aW5kb3cgYHJlc2l6ZWAgZXZlbnQuXFxuXFx0ICogQHByb3RlY3RlZFxcblxcdCAqL1xcblxcdE93bC5wcm90b3R5cGUub25SZXNpemUgPSBmdW5jdGlvbigpIHtcXG5cXHRcXHRpZiAoIXRoaXMuX2l0ZW1zLmxlbmd0aCkge1xcblxcdFxcdFxcdHJldHVybiBmYWxzZTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0aWYgKHRoaXMuX3dpZHRoID09PSB0aGlzLiRlbGVtZW50LndpZHRoKCkpIHtcXG5cXHRcXHRcXHRyZXR1cm4gZmFsc2U7XFxuXFx0XFx0fVxcblxcblxcdFxcdGlmICghdGhpcy4kZWxlbWVudC5pcygnOnZpc2libGUnKSkge1xcblxcdFxcdFxcdHJldHVybiBmYWxzZTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0dGhpcy5lbnRlcigncmVzaXppbmcnKTtcXG5cXG5cXHRcXHRpZiAodGhpcy50cmlnZ2VyKCdyZXNpemUnKS5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkge1xcblxcdFxcdFxcdHRoaXMubGVhdmUoJ3Jlc2l6aW5nJyk7XFxuXFx0XFx0XFx0cmV0dXJuIGZhbHNlO1xcblxcdFxcdH1cXG5cXG5cXHRcXHR0aGlzLmludmFsaWRhdGUoJ3dpZHRoJyk7XFxuXFxuXFx0XFx0dGhpcy5yZWZyZXNoKCk7XFxuXFxuXFx0XFx0dGhpcy5sZWF2ZSgncmVzaXppbmcnKTtcXG5cXHRcXHR0aGlzLnRyaWdnZXIoJ3Jlc2l6ZWQnKTtcXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIFJlZ2lzdGVycyBldmVudCBoYW5kbGVycy5cXG5cXHQgKiBAdG9kbyBDaGVjayBgbXNQb2ludGVyRW5hYmxlZGBcXG5cXHQgKiBAdG9kbyAjMjYxXFxuXFx0ICogQHByb3RlY3RlZFxcblxcdCAqL1xcblxcdE93bC5wcm90b3R5cGUucmVnaXN0ZXJFdmVudEhhbmRsZXJzID0gZnVuY3Rpb24oKSB7XFxuXFx0XFx0aWYgKCQuc3VwcG9ydC50cmFuc2l0aW9uKSB7XFxuXFx0XFx0XFx0dGhpcy4kc3RhZ2Uub24oJC5zdXBwb3J0LnRyYW5zaXRpb24uZW5kICsgJy5vd2wuY29yZScsICQucHJveHkodGhpcy5vblRyYW5zaXRpb25FbmQsIHRoaXMpKTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0aWYgKHRoaXMuc2V0dGluZ3MucmVzcG9uc2l2ZSAhPT0gZmFsc2UpIHtcXG5cXHRcXHRcXHR0aGlzLm9uKHdpbmRvdywgJ3Jlc2l6ZScsIHRoaXMuX2hhbmRsZXJzLm9uVGhyb3R0bGVkUmVzaXplKTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0aWYgKHRoaXMuc2V0dGluZ3MubW91c2VEcmFnKSB7XFxuXFx0XFx0XFx0dGhpcy4kZWxlbWVudC5hZGRDbGFzcyh0aGlzLm9wdGlvbnMuZHJhZ0NsYXNzKTtcXG5cXHRcXHRcXHR0aGlzLiRzdGFnZS5vbignbW91c2Vkb3duLm93bC5jb3JlJywgJC5wcm94eSh0aGlzLm9uRHJhZ1N0YXJ0LCB0aGlzKSk7XFxuXFx0XFx0XFx0dGhpcy4kc3RhZ2Uub24oJ2RyYWdzdGFydC5vd2wuY29yZSBzZWxlY3RzdGFydC5vd2wuY29yZScsIGZ1bmN0aW9uKCkgeyByZXR1cm4gZmFsc2UgfSk7XFxuXFx0XFx0fVxcblxcblxcdFxcdGlmICh0aGlzLnNldHRpbmdzLnRvdWNoRHJhZyl7XFxuXFx0XFx0XFx0dGhpcy4kc3RhZ2Uub24oJ3RvdWNoc3RhcnQub3dsLmNvcmUnLCAkLnByb3h5KHRoaXMub25EcmFnU3RhcnQsIHRoaXMpKTtcXG5cXHRcXHRcXHR0aGlzLiRzdGFnZS5vbigndG91Y2hjYW5jZWwub3dsLmNvcmUnLCAkLnByb3h5KHRoaXMub25EcmFnRW5kLCB0aGlzKSk7XFxuXFx0XFx0fVxcblxcdH07XFxuXFxuXFx0LyoqXFxuXFx0ICogSGFuZGxlcyBgdG91Y2hzdGFydGAgYW5kIGBtb3VzZWRvd25gIGV2ZW50cy5cXG5cXHQgKiBAdG9kbyBIb3Jpem9udGFsIHN3aXBlIHRocmVzaG9sZCBhcyBvcHRpb25cXG5cXHQgKiBAdG9kbyAjMjYxXFxuXFx0ICogQHByb3RlY3RlZFxcblxcdCAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IC0gVGhlIGV2ZW50IGFyZ3VtZW50cy5cXG5cXHQgKi9cXG5cXHRPd2wucHJvdG90eXBlLm9uRHJhZ1N0YXJ0ID0gZnVuY3Rpb24oZXZlbnQpIHtcXG5cXHRcXHR2YXIgc3RhZ2UgPSBudWxsO1xcblxcblxcdFxcdGlmIChldmVudC53aGljaCA9PT0gMykge1xcblxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0aWYgKCQuc3VwcG9ydC50cmFuc2Zvcm0pIHtcXG5cXHRcXHRcXHRzdGFnZSA9IHRoaXMuJHN0YWdlLmNzcygndHJhbnNmb3JtJykucmVwbGFjZSgvLipcXFxcKHxcXFxcKXwgL2csICcnKS5zcGxpdCgnLCcpO1xcblxcdFxcdFxcdHN0YWdlID0ge1xcblxcdFxcdFxcdFxcdHg6IHN0YWdlW3N0YWdlLmxlbmd0aCA9PT0gMTYgPyAxMiA6IDRdLFxcblxcdFxcdFxcdFxcdHk6IHN0YWdlW3N0YWdlLmxlbmd0aCA9PT0gMTYgPyAxMyA6IDVdXFxuXFx0XFx0XFx0fTtcXG5cXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdHN0YWdlID0gdGhpcy4kc3RhZ2UucG9zaXRpb24oKTtcXG5cXHRcXHRcXHRzdGFnZSA9IHtcXG5cXHRcXHRcXHRcXHR4OiB0aGlzLnNldHRpbmdzLnJ0bCA/XFxuXFx0XFx0XFx0XFx0XFx0c3RhZ2UubGVmdCArIHRoaXMuJHN0YWdlLndpZHRoKCkgLSB0aGlzLndpZHRoKCkgKyB0aGlzLnNldHRpbmdzLm1hcmdpbiA6XFxuXFx0XFx0XFx0XFx0XFx0c3RhZ2UubGVmdCxcXG5cXHRcXHRcXHRcXHR5OiBzdGFnZS50b3BcXG5cXHRcXHRcXHR9O1xcblxcdFxcdH1cXG5cXG5cXHRcXHRpZiAodGhpcy5pcygnYW5pbWF0aW5nJykpIHtcXG5cXHRcXHRcXHQkLnN1cHBvcnQudHJhbnNmb3JtID8gdGhpcy5hbmltYXRlKHN0YWdlLngpIDogdGhpcy4kc3RhZ2Uuc3RvcCgpXFxuXFx0XFx0XFx0dGhpcy5pbnZhbGlkYXRlKCdwb3NpdGlvbicpO1xcblxcdFxcdH1cXG5cXG5cXHRcXHR0aGlzLiRlbGVtZW50LnRvZ2dsZUNsYXNzKHRoaXMub3B0aW9ucy5ncmFiQ2xhc3MsIGV2ZW50LnR5cGUgPT09ICdtb3VzZWRvd24nKTtcXG5cXG5cXHRcXHR0aGlzLnNwZWVkKDApO1xcblxcblxcdFxcdHRoaXMuX2RyYWcudGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xcblxcdFxcdHRoaXMuX2RyYWcudGFyZ2V0ID0gJChldmVudC50YXJnZXQpO1xcblxcdFxcdHRoaXMuX2RyYWcuc3RhZ2Uuc3RhcnQgPSBzdGFnZTtcXG5cXHRcXHR0aGlzLl9kcmFnLnN0YWdlLmN1cnJlbnQgPSBzdGFnZTtcXG5cXHRcXHR0aGlzLl9kcmFnLnBvaW50ZXIgPSB0aGlzLnBvaW50ZXIoZXZlbnQpO1xcblxcblxcdFxcdCQoZG9jdW1lbnQpLm9uKCdtb3VzZXVwLm93bC5jb3JlIHRvdWNoZW5kLm93bC5jb3JlJywgJC5wcm94eSh0aGlzLm9uRHJhZ0VuZCwgdGhpcykpO1xcblxcblxcdFxcdCQoZG9jdW1lbnQpLm9uZSgnbW91c2Vtb3ZlLm93bC5jb3JlIHRvdWNobW92ZS5vd2wuY29yZScsICQucHJveHkoZnVuY3Rpb24oZXZlbnQpIHtcXG5cXHRcXHRcXHR2YXIgZGVsdGEgPSB0aGlzLmRpZmZlcmVuY2UodGhpcy5fZHJhZy5wb2ludGVyLCB0aGlzLnBvaW50ZXIoZXZlbnQpKTtcXG5cXG5cXHRcXHRcXHQkKGRvY3VtZW50KS5vbignbW91c2Vtb3ZlLm93bC5jb3JlIHRvdWNobW92ZS5vd2wuY29yZScsICQucHJveHkodGhpcy5vbkRyYWdNb3ZlLCB0aGlzKSk7XFxuXFxuXFx0XFx0XFx0aWYgKE1hdGguYWJzKGRlbHRhLngpIDwgTWF0aC5hYnMoZGVsdGEueSkgJiYgdGhpcy5pcygndmFsaWQnKSkge1xcblxcdFxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcXG5cXG5cXHRcXHRcXHR0aGlzLmVudGVyKCdkcmFnZ2luZycpO1xcblxcdFxcdFxcdHRoaXMudHJpZ2dlcignZHJhZycpO1xcblxcdFxcdH0sIHRoaXMpKTtcXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIEhhbmRsZXMgdGhlIGB0b3VjaG1vdmVgIGFuZCBgbW91c2Vtb3ZlYCBldmVudHMuXFxuXFx0ICogQHRvZG8gIzI2MVxcblxcdCAqIEBwcm90ZWN0ZWRcXG5cXHQgKiBAcGFyYW0ge0V2ZW50fSBldmVudCAtIFRoZSBldmVudCBhcmd1bWVudHMuXFxuXFx0ICovXFxuXFx0T3dsLnByb3RvdHlwZS5vbkRyYWdNb3ZlID0gZnVuY3Rpb24oZXZlbnQpIHtcXG5cXHRcXHR2YXIgbWluaW11bSA9IG51bGwsXFxuXFx0XFx0XFx0bWF4aW11bSA9IG51bGwsXFxuXFx0XFx0XFx0cHVsbCA9IG51bGwsXFxuXFx0XFx0XFx0ZGVsdGEgPSB0aGlzLmRpZmZlcmVuY2UodGhpcy5fZHJhZy5wb2ludGVyLCB0aGlzLnBvaW50ZXIoZXZlbnQpKSxcXG5cXHRcXHRcXHRzdGFnZSA9IHRoaXMuZGlmZmVyZW5jZSh0aGlzLl9kcmFnLnN0YWdlLnN0YXJ0LCBkZWx0YSk7XFxuXFxuXFx0XFx0aWYgKCF0aGlzLmlzKCdkcmFnZ2luZycpKSB7XFxuXFx0XFx0XFx0cmV0dXJuO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xcblxcblxcdFxcdGlmICh0aGlzLnNldHRpbmdzLmxvb3ApIHtcXG5cXHRcXHRcXHRtaW5pbXVtID0gdGhpcy5jb29yZGluYXRlcyh0aGlzLm1pbmltdW0oKSk7XFxuXFx0XFx0XFx0bWF4aW11bSA9IHRoaXMuY29vcmRpbmF0ZXModGhpcy5tYXhpbXVtKCkgKyAxKSAtIG1pbmltdW07XFxuXFx0XFx0XFx0c3RhZ2UueCA9ICgoKHN0YWdlLnggLSBtaW5pbXVtKSAlIG1heGltdW0gKyBtYXhpbXVtKSAlIG1heGltdW0pICsgbWluaW11bTtcXG5cXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdG1pbmltdW0gPSB0aGlzLnNldHRpbmdzLnJ0bCA/IHRoaXMuY29vcmRpbmF0ZXModGhpcy5tYXhpbXVtKCkpIDogdGhpcy5jb29yZGluYXRlcyh0aGlzLm1pbmltdW0oKSk7XFxuXFx0XFx0XFx0bWF4aW11bSA9IHRoaXMuc2V0dGluZ3MucnRsID8gdGhpcy5jb29yZGluYXRlcyh0aGlzLm1pbmltdW0oKSkgOiB0aGlzLmNvb3JkaW5hdGVzKHRoaXMubWF4aW11bSgpKTtcXG5cXHRcXHRcXHRwdWxsID0gdGhpcy5zZXR0aW5ncy5wdWxsRHJhZyA/IC0xICogZGVsdGEueCAvIDUgOiAwO1xcblxcdFxcdFxcdHN0YWdlLnggPSBNYXRoLm1heChNYXRoLm1pbihzdGFnZS54LCBtaW5pbXVtICsgcHVsbCksIG1heGltdW0gKyBwdWxsKTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0dGhpcy5fZHJhZy5zdGFnZS5jdXJyZW50ID0gc3RhZ2U7XFxuXFxuXFx0XFx0dGhpcy5hbmltYXRlKHN0YWdlLngpO1xcblxcdH07XFxuXFxuXFx0LyoqXFxuXFx0ICogSGFuZGxlcyB0aGUgYHRvdWNoZW5kYCBhbmQgYG1vdXNldXBgIGV2ZW50cy5cXG5cXHQgKiBAdG9kbyAjMjYxXFxuXFx0ICogQHRvZG8gVGhyZXNob2xkIGZvciBjbGljayBldmVudFxcblxcdCAqIEBwcm90ZWN0ZWRcXG5cXHQgKiBAcGFyYW0ge0V2ZW50fSBldmVudCAtIFRoZSBldmVudCBhcmd1bWVudHMuXFxuXFx0ICovXFxuXFx0T3dsLnByb3RvdHlwZS5vbkRyYWdFbmQgPSBmdW5jdGlvbihldmVudCkge1xcblxcdFxcdHZhciBkZWx0YSA9IHRoaXMuZGlmZmVyZW5jZSh0aGlzLl9kcmFnLnBvaW50ZXIsIHRoaXMucG9pbnRlcihldmVudCkpLFxcblxcdFxcdFxcdHN0YWdlID0gdGhpcy5fZHJhZy5zdGFnZS5jdXJyZW50LFxcblxcdFxcdFxcdGRpcmVjdGlvbiA9IGRlbHRhLnggPiAwIF4gdGhpcy5zZXR0aW5ncy5ydGwgPyAnbGVmdCcgOiAncmlnaHQnO1xcblxcblxcdFxcdCQoZG9jdW1lbnQpLm9mZignLm93bC5jb3JlJyk7XFxuXFxuXFx0XFx0dGhpcy4kZWxlbWVudC5yZW1vdmVDbGFzcyh0aGlzLm9wdGlvbnMuZ3JhYkNsYXNzKTtcXG5cXG5cXHRcXHRpZiAoZGVsdGEueCAhPT0gMCAmJiB0aGlzLmlzKCdkcmFnZ2luZycpIHx8ICF0aGlzLmlzKCd2YWxpZCcpKSB7XFxuXFx0XFx0XFx0dGhpcy5zcGVlZCh0aGlzLnNldHRpbmdzLmRyYWdFbmRTcGVlZCB8fCB0aGlzLnNldHRpbmdzLnNtYXJ0U3BlZWQpO1xcblxcdFxcdFxcdHRoaXMuY3VycmVudCh0aGlzLmNsb3Nlc3Qoc3RhZ2UueCwgZGVsdGEueCAhPT0gMCA/IGRpcmVjdGlvbiA6IHRoaXMuX2RyYWcuZGlyZWN0aW9uKSk7XFxuXFx0XFx0XFx0dGhpcy5pbnZhbGlkYXRlKCdwb3NpdGlvbicpO1xcblxcdFxcdFxcdHRoaXMudXBkYXRlKCk7XFxuXFxuXFx0XFx0XFx0dGhpcy5fZHJhZy5kaXJlY3Rpb24gPSBkaXJlY3Rpb247XFxuXFxuXFx0XFx0XFx0aWYgKE1hdGguYWJzKGRlbHRhLngpID4gMyB8fCBuZXcgRGF0ZSgpLmdldFRpbWUoKSAtIHRoaXMuX2RyYWcudGltZSA+IDMwMCkge1xcblxcdFxcdFxcdFxcdHRoaXMuX2RyYWcudGFyZ2V0Lm9uZSgnY2xpY2sub3dsLmNvcmUnLCBmdW5jdGlvbigpIHsgcmV0dXJuIGZhbHNlOyB9KTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcblxcdFxcdGlmICghdGhpcy5pcygnZHJhZ2dpbmcnKSkge1xcblxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0dGhpcy5sZWF2ZSgnZHJhZ2dpbmcnKTtcXG5cXHRcXHR0aGlzLnRyaWdnZXIoJ2RyYWdnZWQnKTtcXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIEdldHMgYWJzb2x1dGUgcG9zaXRpb24gb2YgdGhlIGNsb3Nlc3QgaXRlbSBmb3IgYSBjb29yZGluYXRlLlxcblxcdCAqIEB0b2RvIFNldHRpbmcgYGZyZWVEcmFnYCBtYWtlcyBgY2xvc2VzdGAgbm90IHJldXNhYmxlLiBTZWUgIzE2NS5cXG5cXHQgKiBAcHJvdGVjdGVkXFxuXFx0ICogQHBhcmFtIHtOdW1iZXJ9IGNvb3JkaW5hdGUgLSBUaGUgY29vcmRpbmF0ZSBpbiBwaXhlbC5cXG5cXHQgKiBAcGFyYW0ge1N0cmluZ30gZGlyZWN0aW9uIC0gVGhlIGRpcmVjdGlvbiB0byBjaGVjayBmb3IgdGhlIGNsb3Nlc3QgaXRlbS4gRXRoZXIgYGxlZnRgIG9yIGByaWdodGAuXFxuXFx0ICogQHJldHVybiB7TnVtYmVyfSAtIFRoZSBhYnNvbHV0ZSBwb3NpdGlvbiBvZiB0aGUgY2xvc2VzdCBpdGVtLlxcblxcdCAqL1xcblxcdE93bC5wcm90b3R5cGUuY2xvc2VzdCA9IGZ1bmN0aW9uKGNvb3JkaW5hdGUsIGRpcmVjdGlvbikge1xcblxcdFxcdHZhciBwb3NpdGlvbiA9IC0xLFxcblxcdFxcdFxcdHB1bGwgPSAzMCxcXG5cXHRcXHRcXHR3aWR0aCA9IHRoaXMud2lkdGgoKSxcXG5cXHRcXHRcXHRjb29yZGluYXRlcyA9IHRoaXMuY29vcmRpbmF0ZXMoKTtcXG5cXG5cXHRcXHRpZiAoIXRoaXMuc2V0dGluZ3MuZnJlZURyYWcpIHtcXG5cXHRcXHRcXHQvLyBjaGVjayBjbG9zZXN0IGl0ZW1cXG5cXHRcXHRcXHQkLmVhY2goY29vcmRpbmF0ZXMsICQucHJveHkoZnVuY3Rpb24oaW5kZXgsIHZhbHVlKSB7XFxuXFx0XFx0XFx0XFx0Ly8gb24gYSBsZWZ0IHB1bGwsIGNoZWNrIG9uIGN1cnJlbnQgaW5kZXhcXG5cXHRcXHRcXHRcXHRpZiAoZGlyZWN0aW9uID09PSAnbGVmdCcgJiYgY29vcmRpbmF0ZSA+IHZhbHVlIC0gcHVsbCAmJiBjb29yZGluYXRlIDwgdmFsdWUgKyBwdWxsKSB7XFxuXFx0XFx0XFx0XFx0XFx0cG9zaXRpb24gPSBpbmRleDtcXG5cXHRcXHRcXHRcXHQvLyBvbiBhIHJpZ2h0IHB1bGwsIGNoZWNrIG9uIHByZXZpb3VzIGluZGV4XFxuXFx0XFx0XFx0XFx0Ly8gdG8gZG8gc28sIHN1YnRyYWN0IHdpZHRoIGZyb20gdmFsdWUgYW5kIHNldCBwb3NpdGlvbiA9IGluZGV4ICsgMVxcblxcdFxcdFxcdFxcdH0gZWxzZSBpZiAoZGlyZWN0aW9uID09PSAncmlnaHQnICYmIGNvb3JkaW5hdGUgPiB2YWx1ZSAtIHdpZHRoIC0gcHVsbCAmJiBjb29yZGluYXRlIDwgdmFsdWUgLSB3aWR0aCArIHB1bGwpIHtcXG5cXHRcXHRcXHRcXHRcXHRwb3NpdGlvbiA9IGluZGV4ICsgMTtcXG5cXHRcXHRcXHRcXHR9IGVsc2UgaWYgKHRoaXMub3AoY29vcmRpbmF0ZSwgJzwnLCB2YWx1ZSlcXG5cXHRcXHRcXHRcXHRcXHQmJiB0aGlzLm9wKGNvb3JkaW5hdGUsICc+JywgY29vcmRpbmF0ZXNbaW5kZXggKyAxXSB8fCB2YWx1ZSAtIHdpZHRoKSkge1xcblxcdFxcdFxcdFxcdFxcdHBvc2l0aW9uID0gZGlyZWN0aW9uID09PSAnbGVmdCcgPyBpbmRleCArIDEgOiBpbmRleDtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHBvc2l0aW9uID09PSAtMTtcXG5cXHRcXHRcXHR9LCB0aGlzKSk7XFxuXFx0XFx0fVxcblxcblxcdFxcdGlmICghdGhpcy5zZXR0aW5ncy5sb29wKSB7XFxuXFx0XFx0XFx0Ly8gbm9uIGxvb3AgYm91bmRyaWVzXFxuXFx0XFx0XFx0aWYgKHRoaXMub3AoY29vcmRpbmF0ZSwgJz4nLCBjb29yZGluYXRlc1t0aGlzLm1pbmltdW0oKV0pKSB7XFxuXFx0XFx0XFx0XFx0cG9zaXRpb24gPSBjb29yZGluYXRlID0gdGhpcy5taW5pbXVtKCk7XFxuXFx0XFx0XFx0fSBlbHNlIGlmICh0aGlzLm9wKGNvb3JkaW5hdGUsICc8JywgY29vcmRpbmF0ZXNbdGhpcy5tYXhpbXVtKCldKSkge1xcblxcdFxcdFxcdFxcdHBvc2l0aW9uID0gY29vcmRpbmF0ZSA9IHRoaXMubWF4aW11bSgpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFxuXFx0XFx0cmV0dXJuIHBvc2l0aW9uO1xcblxcdH07XFxuXFxuXFx0LyoqXFxuXFx0ICogQW5pbWF0ZXMgdGhlIHN0YWdlLlxcblxcdCAqIEB0b2RvICMyNzBcXG5cXHQgKiBAcHVibGljXFxuXFx0ICogQHBhcmFtIHtOdW1iZXJ9IGNvb3JkaW5hdGUgLSBUaGUgY29vcmRpbmF0ZSBpbiBwaXhlbHMuXFxuXFx0ICovXFxuXFx0T3dsLnByb3RvdHlwZS5hbmltYXRlID0gZnVuY3Rpb24oY29vcmRpbmF0ZSkge1xcblxcdFxcdHZhciBhbmltYXRlID0gdGhpcy5zcGVlZCgpID4gMDtcXG5cXG5cXHRcXHR0aGlzLmlzKCdhbmltYXRpbmcnKSAmJiB0aGlzLm9uVHJhbnNpdGlvbkVuZCgpO1xcblxcblxcdFxcdGlmIChhbmltYXRlKSB7XFxuXFx0XFx0XFx0dGhpcy5lbnRlcignYW5pbWF0aW5nJyk7XFxuXFx0XFx0XFx0dGhpcy50cmlnZ2VyKCd0cmFuc2xhdGUnKTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0aWYgKCQuc3VwcG9ydC50cmFuc2Zvcm0zZCAmJiAkLnN1cHBvcnQudHJhbnNpdGlvbikge1xcblxcdFxcdFxcdHRoaXMuJHN0YWdlLmNzcyh7XFxuXFx0XFx0XFx0XFx0dHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoJyArIGNvb3JkaW5hdGUgKyAncHgsMHB4LDBweCknLFxcblxcdFxcdFxcdFxcdHRyYW5zaXRpb246ICh0aGlzLnNwZWVkKCkgLyAxMDAwKSArICdzJ1xcblxcdFxcdFxcdH0pO1xcblxcdFxcdH0gZWxzZSBpZiAoYW5pbWF0ZSkge1xcblxcdFxcdFxcdHRoaXMuJHN0YWdlLmFuaW1hdGUoe1xcblxcdFxcdFxcdFxcdGxlZnQ6IGNvb3JkaW5hdGUgKyAncHgnXFxuXFx0XFx0XFx0fSwgdGhpcy5zcGVlZCgpLCB0aGlzLnNldHRpbmdzLmZhbGxiYWNrRWFzaW5nLCAkLnByb3h5KHRoaXMub25UcmFuc2l0aW9uRW5kLCB0aGlzKSk7XFxuXFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHR0aGlzLiRzdGFnZS5jc3Moe1xcblxcdFxcdFxcdFxcdGxlZnQ6IGNvb3JkaW5hdGUgKyAncHgnXFxuXFx0XFx0XFx0fSk7XFxuXFx0XFx0fVxcblxcdH07XFxuXFxuXFx0LyoqXFxuXFx0ICogQ2hlY2tzIHdoZXRoZXIgdGhlIGNhcm91c2VsIGlzIGluIGEgc3BlY2lmaWMgc3RhdGUgb3Igbm90LlxcblxcdCAqIEBwYXJhbSB7U3RyaW5nfSBzdGF0ZSAtIFRoZSBzdGF0ZSB0byBjaGVjay5cXG5cXHQgKiBAcmV0dXJucyB7Qm9vbGVhbn0gLSBUaGUgZmxhZyB3aGljaCBpbmRpY2F0ZXMgaWYgdGhlIGNhcm91c2VsIGlzIGJ1c3kuXFxuXFx0ICovXFxuXFx0T3dsLnByb3RvdHlwZS5pcyA9IGZ1bmN0aW9uKHN0YXRlKSB7XFxuXFx0XFx0cmV0dXJuIHRoaXMuX3N0YXRlcy5jdXJyZW50W3N0YXRlXSAmJiB0aGlzLl9zdGF0ZXMuY3VycmVudFtzdGF0ZV0gPiAwO1xcblxcdH07XFxuXFxuXFx0LyoqXFxuXFx0ICogU2V0cyB0aGUgYWJzb2x1dGUgcG9zaXRpb24gb2YgdGhlIGN1cnJlbnQgaXRlbS5cXG5cXHQgKiBAcHVibGljXFxuXFx0ICogQHBhcmFtIHtOdW1iZXJ9IFtwb3NpdGlvbl0gLSBUaGUgbmV3IGFic29sdXRlIHBvc2l0aW9uIG9yIG5vdGhpbmcgdG8gbGVhdmUgaXQgdW5jaGFuZ2VkLlxcblxcdCAqIEByZXR1cm5zIHtOdW1iZXJ9IC0gVGhlIGFic29sdXRlIHBvc2l0aW9uIG9mIHRoZSBjdXJyZW50IGl0ZW0uXFxuXFx0ICovXFxuXFx0T3dsLnByb3RvdHlwZS5jdXJyZW50ID0gZnVuY3Rpb24ocG9zaXRpb24pIHtcXG5cXHRcXHRpZiAocG9zaXRpb24gPT09IHVuZGVmaW5lZCkge1xcblxcdFxcdFxcdHJldHVybiB0aGlzLl9jdXJyZW50O1xcblxcdFxcdH1cXG5cXG5cXHRcXHRpZiAodGhpcy5faXRlbXMubGVuZ3RoID09PSAwKSB7XFxuXFx0XFx0XFx0cmV0dXJuIHVuZGVmaW5lZDtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0cG9zaXRpb24gPSB0aGlzLm5vcm1hbGl6ZShwb3NpdGlvbik7XFxuXFxuXFx0XFx0aWYgKHRoaXMuX2N1cnJlbnQgIT09IHBvc2l0aW9uKSB7XFxuXFx0XFx0XFx0dmFyIGV2ZW50ID0gdGhpcy50cmlnZ2VyKCdjaGFuZ2UnLCB7IHByb3BlcnR5OiB7IG5hbWU6ICdwb3NpdGlvbicsIHZhbHVlOiBwb3NpdGlvbiB9IH0pO1xcblxcblxcdFxcdFxcdGlmIChldmVudC5kYXRhICE9PSB1bmRlZmluZWQpIHtcXG5cXHRcXHRcXHRcXHRwb3NpdGlvbiA9IHRoaXMubm9ybWFsaXplKGV2ZW50LmRhdGEpO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR0aGlzLl9jdXJyZW50ID0gcG9zaXRpb247XFxuXFxuXFx0XFx0XFx0dGhpcy5pbnZhbGlkYXRlKCdwb3NpdGlvbicpO1xcblxcblxcdFxcdFxcdHRoaXMudHJpZ2dlcignY2hhbmdlZCcsIHsgcHJvcGVydHk6IHsgbmFtZTogJ3Bvc2l0aW9uJywgdmFsdWU6IHRoaXMuX2N1cnJlbnQgfSB9KTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0cmV0dXJuIHRoaXMuX2N1cnJlbnQ7XFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBJbnZhbGlkYXRlcyB0aGUgZ2l2ZW4gcGFydCBvZiB0aGUgdXBkYXRlIHJvdXRpbmUuXFxuXFx0ICogQHBhcmFtIHtTdHJpbmd9IFtwYXJ0XSAtIFRoZSBwYXJ0IHRvIGludmFsaWRhdGUuXFxuXFx0ICogQHJldHVybnMge0FycmF5LjxTdHJpbmc+fSAtIFRoZSBpbnZhbGlkYXRlZCBwYXJ0cy5cXG5cXHQgKi9cXG5cXHRPd2wucHJvdG90eXBlLmludmFsaWRhdGUgPSBmdW5jdGlvbihwYXJ0KSB7XFxuXFx0XFx0aWYgKCQudHlwZShwYXJ0KSA9PT0gJ3N0cmluZycpIHtcXG5cXHRcXHRcXHR0aGlzLl9pbnZhbGlkYXRlZFtwYXJ0XSA9IHRydWU7XFxuXFx0XFx0XFx0dGhpcy5pcygndmFsaWQnKSAmJiB0aGlzLmxlYXZlKCd2YWxpZCcpO1xcblxcdFxcdH1cXG5cXHRcXHRyZXR1cm4gJC5tYXAodGhpcy5faW52YWxpZGF0ZWQsIGZ1bmN0aW9uKHYsIGkpIHsgcmV0dXJuIGkgfSk7XFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBSZXNldHMgdGhlIGFic29sdXRlIHBvc2l0aW9uIG9mIHRoZSBjdXJyZW50IGl0ZW0uXFxuXFx0ICogQHB1YmxpY1xcblxcdCAqIEBwYXJhbSB7TnVtYmVyfSBwb3NpdGlvbiAtIFRoZSBhYnNvbHV0ZSBwb3NpdGlvbiBvZiB0aGUgbmV3IGl0ZW0uXFxuXFx0ICovXFxuXFx0T3dsLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uKHBvc2l0aW9uKSB7XFxuXFx0XFx0cG9zaXRpb24gPSB0aGlzLm5vcm1hbGl6ZShwb3NpdGlvbik7XFxuXFxuXFx0XFx0aWYgKHBvc2l0aW9uID09PSB1bmRlZmluZWQpIHtcXG5cXHRcXHRcXHRyZXR1cm47XFxuXFx0XFx0fVxcblxcblxcdFxcdHRoaXMuX3NwZWVkID0gMDtcXG5cXHRcXHR0aGlzLl9jdXJyZW50ID0gcG9zaXRpb247XFxuXFxuXFx0XFx0dGhpcy5zdXBwcmVzcyhbICd0cmFuc2xhdGUnLCAndHJhbnNsYXRlZCcgXSk7XFxuXFxuXFx0XFx0dGhpcy5hbmltYXRlKHRoaXMuY29vcmRpbmF0ZXMocG9zaXRpb24pKTtcXG5cXG5cXHRcXHR0aGlzLnJlbGVhc2UoWyAndHJhbnNsYXRlJywgJ3RyYW5zbGF0ZWQnIF0pO1xcblxcdH07XFxuXFxuXFx0LyoqXFxuXFx0ICogTm9ybWFsaXplcyBhbiBhYnNvbHV0ZSBvciBhIHJlbGF0aXZlIHBvc2l0aW9uIG9mIGFuIGl0ZW0uXFxuXFx0ICogQHB1YmxpY1xcblxcdCAqIEBwYXJhbSB7TnVtYmVyfSBwb3NpdGlvbiAtIFRoZSBhYnNvbHV0ZSBvciByZWxhdGl2ZSBwb3NpdGlvbiB0byBub3JtYWxpemUuXFxuXFx0ICogQHBhcmFtIHtCb29sZWFufSBbcmVsYXRpdmU9ZmFsc2VdIC0gV2hldGhlciB0aGUgZ2l2ZW4gcG9zaXRpb24gaXMgcmVsYXRpdmUgb3Igbm90LlxcblxcdCAqIEByZXR1cm5zIHtOdW1iZXJ9IC0gVGhlIG5vcm1hbGl6ZWQgcG9zaXRpb24uXFxuXFx0ICovXFxuXFx0T3dsLnByb3RvdHlwZS5ub3JtYWxpemUgPSBmdW5jdGlvbihwb3NpdGlvbiwgcmVsYXRpdmUpIHtcXG5cXHRcXHR2YXIgbiA9IHRoaXMuX2l0ZW1zLmxlbmd0aCxcXG5cXHRcXHRcXHRtID0gcmVsYXRpdmUgPyAwIDogdGhpcy5fY2xvbmVzLmxlbmd0aDtcXG5cXG5cXHRcXHRpZiAoIXRoaXMuaXNOdW1lcmljKHBvc2l0aW9uKSB8fCBuIDwgMSkge1xcblxcdFxcdFxcdHBvc2l0aW9uID0gdW5kZWZpbmVkO1xcblxcdFxcdH0gZWxzZSBpZiAocG9zaXRpb24gPCAwIHx8IHBvc2l0aW9uID49IG4gKyBtKSB7XFxuXFx0XFx0XFx0cG9zaXRpb24gPSAoKHBvc2l0aW9uIC0gbSAvIDIpICUgbiArIG4pICUgbiArIG0gLyAyO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRyZXR1cm4gcG9zaXRpb247XFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBDb252ZXJ0cyBhbiBhYnNvbHV0ZSBwb3NpdGlvbiBvZiBhbiBpdGVtIGludG8gYSByZWxhdGl2ZSBvbmUuXFxuXFx0ICogQHB1YmxpY1xcblxcdCAqIEBwYXJhbSB7TnVtYmVyfSBwb3NpdGlvbiAtIFRoZSBhYnNvbHV0ZSBwb3NpdGlvbiB0byBjb252ZXJ0LlxcblxcdCAqIEByZXR1cm5zIHtOdW1iZXJ9IC0gVGhlIGNvbnZlcnRlZCBwb3NpdGlvbi5cXG5cXHQgKi9cXG5cXHRPd2wucHJvdG90eXBlLnJlbGF0aXZlID0gZnVuY3Rpb24ocG9zaXRpb24pIHtcXG5cXHRcXHRwb3NpdGlvbiAtPSB0aGlzLl9jbG9uZXMubGVuZ3RoIC8gMjtcXG5cXHRcXHRyZXR1cm4gdGhpcy5ub3JtYWxpemUocG9zaXRpb24sIHRydWUpO1xcblxcdH07XFxuXFxuXFx0LyoqXFxuXFx0ICogR2V0cyB0aGUgbWF4aW11bSBwb3NpdGlvbiBmb3IgdGhlIGN1cnJlbnQgaXRlbS5cXG5cXHQgKiBAcHVibGljXFxuXFx0ICogQHBhcmFtIHtCb29sZWFufSBbcmVsYXRpdmU9ZmFsc2VdIC0gV2hldGhlciB0byByZXR1cm4gYW4gYWJzb2x1dGUgcG9zaXRpb24gb3IgYSByZWxhdGl2ZSBwb3NpdGlvbi5cXG5cXHQgKiBAcmV0dXJucyB7TnVtYmVyfVxcblxcdCAqL1xcblxcdE93bC5wcm90b3R5cGUubWF4aW11bSA9IGZ1bmN0aW9uKHJlbGF0aXZlKSB7XFxuXFx0XFx0dmFyIHNldHRpbmdzID0gdGhpcy5zZXR0aW5ncyxcXG5cXHRcXHRcXHRtYXhpbXVtID0gdGhpcy5fY29vcmRpbmF0ZXMubGVuZ3RoLFxcblxcdFxcdFxcdGl0ZXJhdG9yLFxcblxcdFxcdFxcdHJlY2lwcm9jYWxJdGVtc1dpZHRoLFxcblxcdFxcdFxcdGVsZW1lbnRXaWR0aDtcXG5cXG5cXHRcXHRpZiAoc2V0dGluZ3MubG9vcCkge1xcblxcdFxcdFxcdG1heGltdW0gPSB0aGlzLl9jbG9uZXMubGVuZ3RoIC8gMiArIHRoaXMuX2l0ZW1zLmxlbmd0aCAtIDE7XFxuXFx0XFx0fSBlbHNlIGlmIChzZXR0aW5ncy5hdXRvV2lkdGggfHwgc2V0dGluZ3MubWVyZ2UpIHtcXG5cXHRcXHRcXHRpdGVyYXRvciA9IHRoaXMuX2l0ZW1zLmxlbmd0aDtcXG5cXHRcXHRcXHRyZWNpcHJvY2FsSXRlbXNXaWR0aCA9IHRoaXMuX2l0ZW1zWy0taXRlcmF0b3JdLndpZHRoKCk7XFxuXFx0XFx0XFx0ZWxlbWVudFdpZHRoID0gdGhpcy4kZWxlbWVudC53aWR0aCgpO1xcblxcdFxcdFxcdHdoaWxlIChpdGVyYXRvci0tKSB7XFxuXFx0XFx0XFx0XFx0cmVjaXByb2NhbEl0ZW1zV2lkdGggKz0gdGhpcy5faXRlbXNbaXRlcmF0b3JdLndpZHRoKCkgKyB0aGlzLnNldHRpbmdzLm1hcmdpbjtcXG5cXHRcXHRcXHRcXHRpZiAocmVjaXByb2NhbEl0ZW1zV2lkdGggPiBlbGVtZW50V2lkdGgpIHtcXG5cXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdG1heGltdW0gPSBpdGVyYXRvciArIDE7XFxuXFx0XFx0fSBlbHNlIGlmIChzZXR0aW5ncy5jZW50ZXIpIHtcXG5cXHRcXHRcXHRtYXhpbXVtID0gdGhpcy5faXRlbXMubGVuZ3RoIC0gMTtcXG5cXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdG1heGltdW0gPSB0aGlzLl9pdGVtcy5sZW5ndGggLSBzZXR0aW5ncy5pdGVtcztcXG5cXHRcXHR9XFxuXFxuXFx0XFx0aWYgKHJlbGF0aXZlKSB7XFxuXFx0XFx0XFx0bWF4aW11bSAtPSB0aGlzLl9jbG9uZXMubGVuZ3RoIC8gMjtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0cmV0dXJuIE1hdGgubWF4KG1heGltdW0sIDApO1xcblxcdH07XFxuXFxuXFx0LyoqXFxuXFx0ICogR2V0cyB0aGUgbWluaW11bSBwb3NpdGlvbiBmb3IgdGhlIGN1cnJlbnQgaXRlbS5cXG5cXHQgKiBAcHVibGljXFxuXFx0ICogQHBhcmFtIHtCb29sZWFufSBbcmVsYXRpdmU9ZmFsc2VdIC0gV2hldGhlciB0byByZXR1cm4gYW4gYWJzb2x1dGUgcG9zaXRpb24gb3IgYSByZWxhdGl2ZSBwb3NpdGlvbi5cXG5cXHQgKiBAcmV0dXJucyB7TnVtYmVyfVxcblxcdCAqL1xcblxcdE93bC5wcm90b3R5cGUubWluaW11bSA9IGZ1bmN0aW9uKHJlbGF0aXZlKSB7XFxuXFx0XFx0cmV0dXJuIHJlbGF0aXZlID8gMCA6IHRoaXMuX2Nsb25lcy5sZW5ndGggLyAyO1xcblxcdH07XFxuXFxuXFx0LyoqXFxuXFx0ICogR2V0cyBhbiBpdGVtIGF0IHRoZSBzcGVjaWZpZWQgcmVsYXRpdmUgcG9zaXRpb24uXFxuXFx0ICogQHB1YmxpY1xcblxcdCAqIEBwYXJhbSB7TnVtYmVyfSBbcG9zaXRpb25dIC0gVGhlIHJlbGF0aXZlIHBvc2l0aW9uIG9mIHRoZSBpdGVtLlxcblxcdCAqIEByZXR1cm4ge2pRdWVyeXxBcnJheS48alF1ZXJ5Pn0gLSBUaGUgaXRlbSBhdCB0aGUgZ2l2ZW4gcG9zaXRpb24gb3IgYWxsIGl0ZW1zIGlmIG5vIHBvc2l0aW9uIHdhcyBnaXZlbi5cXG5cXHQgKi9cXG5cXHRPd2wucHJvdG90eXBlLml0ZW1zID0gZnVuY3Rpb24ocG9zaXRpb24pIHtcXG5cXHRcXHRpZiAocG9zaXRpb24gPT09IHVuZGVmaW5lZCkge1xcblxcdFxcdFxcdHJldHVybiB0aGlzLl9pdGVtcy5zbGljZSgpO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRwb3NpdGlvbiA9IHRoaXMubm9ybWFsaXplKHBvc2l0aW9uLCB0cnVlKTtcXG5cXHRcXHRyZXR1cm4gdGhpcy5faXRlbXNbcG9zaXRpb25dO1xcblxcdH07XFxuXFxuXFx0LyoqXFxuXFx0ICogR2V0cyBhbiBpdGVtIGF0IHRoZSBzcGVjaWZpZWQgcmVsYXRpdmUgcG9zaXRpb24uXFxuXFx0ICogQHB1YmxpY1xcblxcdCAqIEBwYXJhbSB7TnVtYmVyfSBbcG9zaXRpb25dIC0gVGhlIHJlbGF0aXZlIHBvc2l0aW9uIG9mIHRoZSBpdGVtLlxcblxcdCAqIEByZXR1cm4ge2pRdWVyeXxBcnJheS48alF1ZXJ5Pn0gLSBUaGUgaXRlbSBhdCB0aGUgZ2l2ZW4gcG9zaXRpb24gb3IgYWxsIGl0ZW1zIGlmIG5vIHBvc2l0aW9uIHdhcyBnaXZlbi5cXG5cXHQgKi9cXG5cXHRPd2wucHJvdG90eXBlLm1lcmdlcnMgPSBmdW5jdGlvbihwb3NpdGlvbikge1xcblxcdFxcdGlmIChwb3NpdGlvbiA9PT0gdW5kZWZpbmVkKSB7XFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMuX21lcmdlcnMuc2xpY2UoKTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0cG9zaXRpb24gPSB0aGlzLm5vcm1hbGl6ZShwb3NpdGlvbiwgdHJ1ZSk7XFxuXFx0XFx0cmV0dXJuIHRoaXMuX21lcmdlcnNbcG9zaXRpb25dO1xcblxcdH07XFxuXFxuXFx0LyoqXFxuXFx0ICogR2V0cyB0aGUgYWJzb2x1dGUgcG9zaXRpb25zIG9mIGNsb25lcyBmb3IgYW4gaXRlbS5cXG5cXHQgKiBAcHVibGljXFxuXFx0ICogQHBhcmFtIHtOdW1iZXJ9IFtwb3NpdGlvbl0gLSBUaGUgcmVsYXRpdmUgcG9zaXRpb24gb2YgdGhlIGl0ZW0uXFxuXFx0ICogQHJldHVybnMge0FycmF5LjxOdW1iZXI+fSAtIFRoZSBhYnNvbHV0ZSBwb3NpdGlvbnMgb2YgY2xvbmVzIGZvciB0aGUgaXRlbSBvciBhbGwgaWYgbm8gcG9zaXRpb24gd2FzIGdpdmVuLlxcblxcdCAqL1xcblxcdE93bC5wcm90b3R5cGUuY2xvbmVzID0gZnVuY3Rpb24ocG9zaXRpb24pIHtcXG5cXHRcXHR2YXIgb2RkID0gdGhpcy5fY2xvbmVzLmxlbmd0aCAvIDIsXFxuXFx0XFx0XFx0ZXZlbiA9IG9kZCArIHRoaXMuX2l0ZW1zLmxlbmd0aCxcXG5cXHRcXHRcXHRtYXAgPSBmdW5jdGlvbihpbmRleCkgeyByZXR1cm4gaW5kZXggJSAyID09PSAwID8gZXZlbiArIGluZGV4IC8gMiA6IG9kZCAtIChpbmRleCArIDEpIC8gMiB9O1xcblxcblxcdFxcdGlmIChwb3NpdGlvbiA9PT0gdW5kZWZpbmVkKSB7XFxuXFx0XFx0XFx0cmV0dXJuICQubWFwKHRoaXMuX2Nsb25lcywgZnVuY3Rpb24odiwgaSkgeyByZXR1cm4gbWFwKGkpIH0pO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRyZXR1cm4gJC5tYXAodGhpcy5fY2xvbmVzLCBmdW5jdGlvbih2LCBpKSB7IHJldHVybiB2ID09PSBwb3NpdGlvbiA/IG1hcChpKSA6IG51bGwgfSk7XFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBTZXRzIHRoZSBjdXJyZW50IGFuaW1hdGlvbiBzcGVlZC5cXG5cXHQgKiBAcHVibGljXFxuXFx0ICogQHBhcmFtIHtOdW1iZXJ9IFtzcGVlZF0gLSBUaGUgYW5pbWF0aW9uIHNwZWVkIGluIG1pbGxpc2Vjb25kcyBvciBub3RoaW5nIHRvIGxlYXZlIGl0IHVuY2hhbmdlZC5cXG5cXHQgKiBAcmV0dXJucyB7TnVtYmVyfSAtIFRoZSBjdXJyZW50IGFuaW1hdGlvbiBzcGVlZCBpbiBtaWxsaXNlY29uZHMuXFxuXFx0ICovXFxuXFx0T3dsLnByb3RvdHlwZS5zcGVlZCA9IGZ1bmN0aW9uKHNwZWVkKSB7XFxuXFx0XFx0aWYgKHNwZWVkICE9PSB1bmRlZmluZWQpIHtcXG5cXHRcXHRcXHR0aGlzLl9zcGVlZCA9IHNwZWVkO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRyZXR1cm4gdGhpcy5fc3BlZWQ7XFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBHZXRzIHRoZSBjb29yZGluYXRlIG9mIGFuIGl0ZW0uXFxuXFx0ICogQHRvZG8gVGhlIG5hbWUgb2YgdGhpcyBtZXRob2QgaXMgbWlzc2xlYW5kaW5nLlxcblxcdCAqIEBwdWJsaWNcXG5cXHQgKiBAcGFyYW0ge051bWJlcn0gcG9zaXRpb24gLSBUaGUgYWJzb2x1dGUgcG9zaXRpb24gb2YgdGhlIGl0ZW0gd2l0aGluIGBtaW5pbXVtKClgIGFuZCBgbWF4aW11bSgpYC5cXG5cXHQgKiBAcmV0dXJucyB7TnVtYmVyfEFycmF5LjxOdW1iZXI+fSAtIFRoZSBjb29yZGluYXRlIG9mIHRoZSBpdGVtIGluIHBpeGVsIG9yIGFsbCBjb29yZGluYXRlcy5cXG5cXHQgKi9cXG5cXHRPd2wucHJvdG90eXBlLmNvb3JkaW5hdGVzID0gZnVuY3Rpb24ocG9zaXRpb24pIHtcXG5cXHRcXHR2YXIgbXVsdGlwbGllciA9IDEsXFxuXFx0XFx0XFx0bmV3UG9zaXRpb24gPSBwb3NpdGlvbiAtIDEsXFxuXFx0XFx0XFx0Y29vcmRpbmF0ZTtcXG5cXG5cXHRcXHRpZiAocG9zaXRpb24gPT09IHVuZGVmaW5lZCkge1xcblxcdFxcdFxcdHJldHVybiAkLm1hcCh0aGlzLl9jb29yZGluYXRlcywgJC5wcm94eShmdW5jdGlvbihjb29yZGluYXRlLCBpbmRleCkge1xcblxcdFxcdFxcdFxcdHJldHVybiB0aGlzLmNvb3JkaW5hdGVzKGluZGV4KTtcXG5cXHRcXHRcXHR9LCB0aGlzKSk7XFxuXFx0XFx0fVxcblxcblxcdFxcdGlmICh0aGlzLnNldHRpbmdzLmNlbnRlcikge1xcblxcdFxcdFxcdGlmICh0aGlzLnNldHRpbmdzLnJ0bCkge1xcblxcdFxcdFxcdFxcdG11bHRpcGxpZXIgPSAtMTtcXG5cXHRcXHRcXHRcXHRuZXdQb3NpdGlvbiA9IHBvc2l0aW9uICsgMTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Y29vcmRpbmF0ZSA9IHRoaXMuX2Nvb3JkaW5hdGVzW3Bvc2l0aW9uXTtcXG5cXHRcXHRcXHRjb29yZGluYXRlICs9ICh0aGlzLndpZHRoKCkgLSBjb29yZGluYXRlICsgKHRoaXMuX2Nvb3JkaW5hdGVzW25ld1Bvc2l0aW9uXSB8fCAwKSkgLyAyICogbXVsdGlwbGllcjtcXG5cXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdGNvb3JkaW5hdGUgPSB0aGlzLl9jb29yZGluYXRlc1tuZXdQb3NpdGlvbl0gfHwgMDtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0Y29vcmRpbmF0ZSA9IE1hdGguY2VpbChjb29yZGluYXRlKTtcXG5cXG5cXHRcXHRyZXR1cm4gY29vcmRpbmF0ZTtcXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIENhbGN1bGF0ZXMgdGhlIHNwZWVkIGZvciBhIHRyYW5zbGF0aW9uLlxcblxcdCAqIEBwcm90ZWN0ZWRcXG5cXHQgKiBAcGFyYW0ge051bWJlcn0gZnJvbSAtIFRoZSBhYnNvbHV0ZSBwb3NpdGlvbiBvZiB0aGUgc3RhcnQgaXRlbS5cXG5cXHQgKiBAcGFyYW0ge051bWJlcn0gdG8gLSBUaGUgYWJzb2x1dGUgcG9zaXRpb24gb2YgdGhlIHRhcmdldCBpdGVtLlxcblxcdCAqIEBwYXJhbSB7TnVtYmVyfSBbZmFjdG9yPXVuZGVmaW5lZF0gLSBUaGUgdGltZSBmYWN0b3IgaW4gbWlsbGlzZWNvbmRzLlxcblxcdCAqIEByZXR1cm5zIHtOdW1iZXJ9IC0gVGhlIHRpbWUgaW4gbWlsbGlzZWNvbmRzIGZvciB0aGUgdHJhbnNsYXRpb24uXFxuXFx0ICovXFxuXFx0T3dsLnByb3RvdHlwZS5kdXJhdGlvbiA9IGZ1bmN0aW9uKGZyb20sIHRvLCBmYWN0b3IpIHtcXG5cXHRcXHRpZiAoZmFjdG9yID09PSAwKSB7XFxuXFx0XFx0XFx0cmV0dXJuIDA7XFxuXFx0XFx0fVxcblxcblxcdFxcdHJldHVybiBNYXRoLm1pbihNYXRoLm1heChNYXRoLmFicyh0byAtIGZyb20pLCAxKSwgNikgKiBNYXRoLmFicygoZmFjdG9yIHx8IHRoaXMuc2V0dGluZ3Muc21hcnRTcGVlZCkpO1xcblxcdH07XFxuXFxuXFx0LyoqXFxuXFx0ICogU2xpZGVzIHRvIHRoZSBzcGVjaWZpZWQgaXRlbS5cXG5cXHQgKiBAcHVibGljXFxuXFx0ICogQHBhcmFtIHtOdW1iZXJ9IHBvc2l0aW9uIC0gVGhlIHBvc2l0aW9uIG9mIHRoZSBpdGVtLlxcblxcdCAqIEBwYXJhbSB7TnVtYmVyfSBbc3BlZWRdIC0gVGhlIHRpbWUgaW4gbWlsbGlzZWNvbmRzIGZvciB0aGUgdHJhbnNpdGlvbi5cXG5cXHQgKi9cXG5cXHRPd2wucHJvdG90eXBlLnRvID0gZnVuY3Rpb24ocG9zaXRpb24sIHNwZWVkKSB7XFxuXFx0XFx0dmFyIGN1cnJlbnQgPSB0aGlzLmN1cnJlbnQoKSxcXG5cXHRcXHRcXHRyZXZlcnQgPSBudWxsLFxcblxcdFxcdFxcdGRpc3RhbmNlID0gcG9zaXRpb24gLSB0aGlzLnJlbGF0aXZlKGN1cnJlbnQpLFxcblxcdFxcdFxcdGRpcmVjdGlvbiA9IChkaXN0YW5jZSA+IDApIC0gKGRpc3RhbmNlIDwgMCksXFxuXFx0XFx0XFx0aXRlbXMgPSB0aGlzLl9pdGVtcy5sZW5ndGgsXFxuXFx0XFx0XFx0bWluaW11bSA9IHRoaXMubWluaW11bSgpLFxcblxcdFxcdFxcdG1heGltdW0gPSB0aGlzLm1heGltdW0oKTtcXG5cXG5cXHRcXHRpZiAodGhpcy5zZXR0aW5ncy5sb29wKSB7XFxuXFx0XFx0XFx0aWYgKCF0aGlzLnNldHRpbmdzLnJld2luZCAmJiBNYXRoLmFicyhkaXN0YW5jZSkgPiBpdGVtcyAvIDIpIHtcXG5cXHRcXHRcXHRcXHRkaXN0YW5jZSArPSBkaXJlY3Rpb24gKiAtMSAqIGl0ZW1zO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRwb3NpdGlvbiA9IGN1cnJlbnQgKyBkaXN0YW5jZTtcXG5cXHRcXHRcXHRyZXZlcnQgPSAoKHBvc2l0aW9uIC0gbWluaW11bSkgJSBpdGVtcyArIGl0ZW1zKSAlIGl0ZW1zICsgbWluaW11bTtcXG5cXG5cXHRcXHRcXHRpZiAocmV2ZXJ0ICE9PSBwb3NpdGlvbiAmJiByZXZlcnQgLSBkaXN0YW5jZSA8PSBtYXhpbXVtICYmIHJldmVydCAtIGRpc3RhbmNlID4gMCkge1xcblxcdFxcdFxcdFxcdGN1cnJlbnQgPSByZXZlcnQgLSBkaXN0YW5jZTtcXG5cXHRcXHRcXHRcXHRwb3NpdGlvbiA9IHJldmVydDtcXG5cXHRcXHRcXHRcXHR0aGlzLnJlc2V0KGN1cnJlbnQpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9IGVsc2UgaWYgKHRoaXMuc2V0dGluZ3MucmV3aW5kKSB7XFxuXFx0XFx0XFx0bWF4aW11bSArPSAxO1xcblxcdFxcdFxcdHBvc2l0aW9uID0gKHBvc2l0aW9uICUgbWF4aW11bSArIG1heGltdW0pICUgbWF4aW11bTtcXG5cXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdHBvc2l0aW9uID0gTWF0aC5tYXgobWluaW11bSwgTWF0aC5taW4obWF4aW11bSwgcG9zaXRpb24pKTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0dGhpcy5zcGVlZCh0aGlzLmR1cmF0aW9uKGN1cnJlbnQsIHBvc2l0aW9uLCBzcGVlZCkpO1xcblxcdFxcdHRoaXMuY3VycmVudChwb3NpdGlvbik7XFxuXFxuXFx0XFx0aWYgKHRoaXMuJGVsZW1lbnQuaXMoJzp2aXNpYmxlJykpIHtcXG5cXHRcXHRcXHR0aGlzLnVwZGF0ZSgpO1xcblxcdFxcdH1cXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIFNsaWRlcyB0byB0aGUgbmV4dCBpdGVtLlxcblxcdCAqIEBwdWJsaWNcXG5cXHQgKiBAcGFyYW0ge051bWJlcn0gW3NwZWVkXSAtIFRoZSB0aW1lIGluIG1pbGxpc2Vjb25kcyBmb3IgdGhlIHRyYW5zaXRpb24uXFxuXFx0ICovXFxuXFx0T3dsLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24oc3BlZWQpIHtcXG5cXHRcXHRzcGVlZCA9IHNwZWVkIHx8IGZhbHNlO1xcblxcdFxcdHRoaXMudG8odGhpcy5yZWxhdGl2ZSh0aGlzLmN1cnJlbnQoKSkgKyAxLCBzcGVlZCk7XFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBTbGlkZXMgdG8gdGhlIHByZXZpb3VzIGl0ZW0uXFxuXFx0ICogQHB1YmxpY1xcblxcdCAqIEBwYXJhbSB7TnVtYmVyfSBbc3BlZWRdIC0gVGhlIHRpbWUgaW4gbWlsbGlzZWNvbmRzIGZvciB0aGUgdHJhbnNpdGlvbi5cXG5cXHQgKi9cXG5cXHRPd2wucHJvdG90eXBlLnByZXYgPSBmdW5jdGlvbihzcGVlZCkge1xcblxcdFxcdHNwZWVkID0gc3BlZWQgfHwgZmFsc2U7XFxuXFx0XFx0dGhpcy50byh0aGlzLnJlbGF0aXZlKHRoaXMuY3VycmVudCgpKSAtIDEsIHNwZWVkKTtcXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIEhhbmRsZXMgdGhlIGVuZCBvZiBhbiBhbmltYXRpb24uXFxuXFx0ICogQHByb3RlY3RlZFxcblxcdCAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IC0gVGhlIGV2ZW50IGFyZ3VtZW50cy5cXG5cXHQgKi9cXG5cXHRPd2wucHJvdG90eXBlLm9uVHJhbnNpdGlvbkVuZCA9IGZ1bmN0aW9uKGV2ZW50KSB7XFxuXFxuXFx0XFx0Ly8gaWYgY3NzMiBhbmltYXRpb24gdGhlbiBldmVudCBvYmplY3QgaXMgdW5kZWZpbmVkXFxuXFx0XFx0aWYgKGV2ZW50ICE9PSB1bmRlZmluZWQpIHtcXG5cXHRcXHRcXHRldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcXG5cXG5cXHRcXHRcXHQvLyBDYXRjaCBvbmx5IG93bC1zdGFnZSB0cmFuc2l0aW9uRW5kIGV2ZW50XFxuXFx0XFx0XFx0aWYgKChldmVudC50YXJnZXQgfHwgZXZlbnQuc3JjRWxlbWVudCB8fCBldmVudC5vcmlnaW5hbFRhcmdldCkgIT09IHRoaXMuJHN0YWdlLmdldCgwKSkge1xcblxcdFxcdFxcdFxcdHJldHVybiBmYWxzZTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcblxcdFxcdHRoaXMubGVhdmUoJ2FuaW1hdGluZycpO1xcblxcdFxcdHRoaXMudHJpZ2dlcigndHJhbnNsYXRlZCcpO1xcblxcdH07XFxuXFxuXFx0LyoqXFxuXFx0ICogR2V0cyB2aWV3cG9ydCB3aWR0aC5cXG5cXHQgKiBAcHJvdGVjdGVkXFxuXFx0ICogQHJldHVybiB7TnVtYmVyfSAtIFRoZSB3aWR0aCBpbiBwaXhlbC5cXG5cXHQgKi9cXG5cXHRPd2wucHJvdG90eXBlLnZpZXdwb3J0ID0gZnVuY3Rpb24oKSB7XFxuXFx0XFx0dmFyIHdpZHRoO1xcblxcdFxcdGlmICh0aGlzLm9wdGlvbnMucmVzcG9uc2l2ZUJhc2VFbGVtZW50ICE9PSB3aW5kb3cpIHtcXG5cXHRcXHRcXHR3aWR0aCA9ICQodGhpcy5vcHRpb25zLnJlc3BvbnNpdmVCYXNlRWxlbWVudCkud2lkdGgoKTtcXG5cXHRcXHR9IGVsc2UgaWYgKHdpbmRvdy5pbm5lcldpZHRoKSB7XFxuXFx0XFx0XFx0d2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aDtcXG5cXHRcXHR9IGVsc2UgaWYgKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGgpIHtcXG5cXHRcXHRcXHR3aWR0aCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aDtcXG5cXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdHRocm93ICdDYW4gbm90IGRldGVjdCB2aWV3cG9ydCB3aWR0aC4nO1xcblxcdFxcdH1cXG5cXHRcXHRyZXR1cm4gd2lkdGg7XFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBSZXBsYWNlcyB0aGUgY3VycmVudCBjb250ZW50LlxcblxcdCAqIEBwdWJsaWNcXG5cXHQgKiBAcGFyYW0ge0hUTUxFbGVtZW50fGpRdWVyeXxTdHJpbmd9IGNvbnRlbnQgLSBUaGUgbmV3IGNvbnRlbnQuXFxuXFx0ICovXFxuXFx0T3dsLnByb3RvdHlwZS5yZXBsYWNlID0gZnVuY3Rpb24oY29udGVudCkge1xcblxcdFxcdHRoaXMuJHN0YWdlLmVtcHR5KCk7XFxuXFx0XFx0dGhpcy5faXRlbXMgPSBbXTtcXG5cXG5cXHRcXHRpZiAoY29udGVudCkge1xcblxcdFxcdFxcdGNvbnRlbnQgPSAoY29udGVudCBpbnN0YW5jZW9mIGpRdWVyeSkgPyBjb250ZW50IDogJChjb250ZW50KTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0aWYgKHRoaXMuc2V0dGluZ3MubmVzdGVkSXRlbVNlbGVjdG9yKSB7XFxuXFx0XFx0XFx0Y29udGVudCA9IGNvbnRlbnQuZmluZCgnLicgKyB0aGlzLnNldHRpbmdzLm5lc3RlZEl0ZW1TZWxlY3Rvcik7XFxuXFx0XFx0fVxcblxcblxcdFxcdGNvbnRlbnQuZmlsdGVyKGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdHJldHVybiB0aGlzLm5vZGVUeXBlID09PSAxO1xcblxcdFxcdH0pLmVhY2goJC5wcm94eShmdW5jdGlvbihpbmRleCwgaXRlbSkge1xcblxcdFxcdFxcdGl0ZW0gPSB0aGlzLnByZXBhcmUoaXRlbSk7XFxuXFx0XFx0XFx0dGhpcy4kc3RhZ2UuYXBwZW5kKGl0ZW0pO1xcblxcdFxcdFxcdHRoaXMuX2l0ZW1zLnB1c2goaXRlbSk7XFxuXFx0XFx0XFx0dGhpcy5fbWVyZ2Vycy5wdXNoKGl0ZW0uZmluZCgnW2RhdGEtbWVyZ2VdJykuYWRkQmFjaygnW2RhdGEtbWVyZ2VdJykuYXR0cignZGF0YS1tZXJnZScpICogMSB8fCAxKTtcXG5cXHRcXHR9LCB0aGlzKSk7XFxuXFxuXFx0XFx0dGhpcy5yZXNldCh0aGlzLmlzTnVtZXJpYyh0aGlzLnNldHRpbmdzLnN0YXJ0UG9zaXRpb24pID8gdGhpcy5zZXR0aW5ncy5zdGFydFBvc2l0aW9uIDogMCk7XFxuXFxuXFx0XFx0dGhpcy5pbnZhbGlkYXRlKCdpdGVtcycpO1xcblxcdH07XFxuXFxuXFx0LyoqXFxuXFx0ICogQWRkcyBhbiBpdGVtLlxcblxcdCAqIEB0b2RvIFVzZSBgaXRlbWAgaW5zdGVhZCBvZiBgY29udGVudGAgZm9yIHRoZSBldmVudCBhcmd1bWVudHMuXFxuXFx0ICogQHB1YmxpY1xcblxcdCAqIEBwYXJhbSB7SFRNTEVsZW1lbnR8alF1ZXJ5fFN0cmluZ30gY29udGVudCAtIFRoZSBpdGVtIGNvbnRlbnQgdG8gYWRkLlxcblxcdCAqIEBwYXJhbSB7TnVtYmVyfSBbcG9zaXRpb25dIC0gVGhlIHJlbGF0aXZlIHBvc2l0aW9uIGF0IHdoaWNoIHRvIGluc2VydCB0aGUgaXRlbSBvdGhlcndpc2UgdGhlIGl0ZW0gd2lsbCBiZSBhZGRlZCB0byB0aGUgZW5kLlxcblxcdCAqL1xcblxcdE93bC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24oY29udGVudCwgcG9zaXRpb24pIHtcXG5cXHRcXHR2YXIgY3VycmVudCA9IHRoaXMucmVsYXRpdmUodGhpcy5fY3VycmVudCk7XFxuXFxuXFx0XFx0cG9zaXRpb24gPSBwb3NpdGlvbiA9PT0gdW5kZWZpbmVkID8gdGhpcy5faXRlbXMubGVuZ3RoIDogdGhpcy5ub3JtYWxpemUocG9zaXRpb24sIHRydWUpO1xcblxcdFxcdGNvbnRlbnQgPSBjb250ZW50IGluc3RhbmNlb2YgalF1ZXJ5ID8gY29udGVudCA6ICQoY29udGVudCk7XFxuXFxuXFx0XFx0dGhpcy50cmlnZ2VyKCdhZGQnLCB7IGNvbnRlbnQ6IGNvbnRlbnQsIHBvc2l0aW9uOiBwb3NpdGlvbiB9KTtcXG5cXG5cXHRcXHRjb250ZW50ID0gdGhpcy5wcmVwYXJlKGNvbnRlbnQpO1xcblxcblxcdFxcdGlmICh0aGlzLl9pdGVtcy5sZW5ndGggPT09IDAgfHwgcG9zaXRpb24gPT09IHRoaXMuX2l0ZW1zLmxlbmd0aCkge1xcblxcdFxcdFxcdHRoaXMuX2l0ZW1zLmxlbmd0aCA9PT0gMCAmJiB0aGlzLiRzdGFnZS5hcHBlbmQoY29udGVudCk7XFxuXFx0XFx0XFx0dGhpcy5faXRlbXMubGVuZ3RoICE9PSAwICYmIHRoaXMuX2l0ZW1zW3Bvc2l0aW9uIC0gMV0uYWZ0ZXIoY29udGVudCk7XFxuXFx0XFx0XFx0dGhpcy5faXRlbXMucHVzaChjb250ZW50KTtcXG5cXHRcXHRcXHR0aGlzLl9tZXJnZXJzLnB1c2goY29udGVudC5maW5kKCdbZGF0YS1tZXJnZV0nKS5hZGRCYWNrKCdbZGF0YS1tZXJnZV0nKS5hdHRyKCdkYXRhLW1lcmdlJykgKiAxIHx8IDEpO1xcblxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0dGhpcy5faXRlbXNbcG9zaXRpb25dLmJlZm9yZShjb250ZW50KTtcXG5cXHRcXHRcXHR0aGlzLl9pdGVtcy5zcGxpY2UocG9zaXRpb24sIDAsIGNvbnRlbnQpO1xcblxcdFxcdFxcdHRoaXMuX21lcmdlcnMuc3BsaWNlKHBvc2l0aW9uLCAwLCBjb250ZW50LmZpbmQoJ1tkYXRhLW1lcmdlXScpLmFkZEJhY2soJ1tkYXRhLW1lcmdlXScpLmF0dHIoJ2RhdGEtbWVyZ2UnKSAqIDEgfHwgMSk7XFxuXFx0XFx0fVxcblxcblxcdFxcdHRoaXMuX2l0ZW1zW2N1cnJlbnRdICYmIHRoaXMucmVzZXQodGhpcy5faXRlbXNbY3VycmVudF0uaW5kZXgoKSk7XFxuXFxuXFx0XFx0dGhpcy5pbnZhbGlkYXRlKCdpdGVtcycpO1xcblxcblxcdFxcdHRoaXMudHJpZ2dlcignYWRkZWQnLCB7IGNvbnRlbnQ6IGNvbnRlbnQsIHBvc2l0aW9uOiBwb3NpdGlvbiB9KTtcXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIFJlbW92ZXMgYW4gaXRlbSBieSBpdHMgcG9zaXRpb24uXFxuXFx0ICogQHRvZG8gVXNlIGBpdGVtYCBpbnN0ZWFkIG9mIGBjb250ZW50YCBmb3IgdGhlIGV2ZW50IGFyZ3VtZW50cy5cXG5cXHQgKiBAcHVibGljXFxuXFx0ICogQHBhcmFtIHtOdW1iZXJ9IHBvc2l0aW9uIC0gVGhlIHJlbGF0aXZlIHBvc2l0aW9uIG9mIHRoZSBpdGVtIHRvIHJlbW92ZS5cXG5cXHQgKi9cXG5cXHRPd2wucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uKHBvc2l0aW9uKSB7XFxuXFx0XFx0cG9zaXRpb24gPSB0aGlzLm5vcm1hbGl6ZShwb3NpdGlvbiwgdHJ1ZSk7XFxuXFxuXFx0XFx0aWYgKHBvc2l0aW9uID09PSB1bmRlZmluZWQpIHtcXG5cXHRcXHRcXHRyZXR1cm47XFxuXFx0XFx0fVxcblxcblxcdFxcdHRoaXMudHJpZ2dlcigncmVtb3ZlJywgeyBjb250ZW50OiB0aGlzLl9pdGVtc1twb3NpdGlvbl0sIHBvc2l0aW9uOiBwb3NpdGlvbiB9KTtcXG5cXG5cXHRcXHR0aGlzLl9pdGVtc1twb3NpdGlvbl0ucmVtb3ZlKCk7XFxuXFx0XFx0dGhpcy5faXRlbXMuc3BsaWNlKHBvc2l0aW9uLCAxKTtcXG5cXHRcXHR0aGlzLl9tZXJnZXJzLnNwbGljZShwb3NpdGlvbiwgMSk7XFxuXFxuXFx0XFx0dGhpcy5pbnZhbGlkYXRlKCdpdGVtcycpO1xcblxcblxcdFxcdHRoaXMudHJpZ2dlcigncmVtb3ZlZCcsIHsgY29udGVudDogbnVsbCwgcG9zaXRpb246IHBvc2l0aW9uIH0pO1xcblxcdH07XFxuXFxuXFx0LyoqXFxuXFx0ICogUHJlbG9hZHMgaW1hZ2VzIHdpdGggYXV0byB3aWR0aC5cXG5cXHQgKiBAdG9kbyBSZXBsYWNlIGJ5IGEgbW9yZSBnZW5lcmljIGFwcHJvYWNoXFxuXFx0ICogQHByb3RlY3RlZFxcblxcdCAqL1xcblxcdE93bC5wcm90b3R5cGUucHJlbG9hZEF1dG9XaWR0aEltYWdlcyA9IGZ1bmN0aW9uKGltYWdlcykge1xcblxcdFxcdGltYWdlcy5lYWNoKCQucHJveHkoZnVuY3Rpb24oaSwgZWxlbWVudCkge1xcblxcdFxcdFxcdHRoaXMuZW50ZXIoJ3ByZS1sb2FkaW5nJyk7XFxuXFx0XFx0XFx0ZWxlbWVudCA9ICQoZWxlbWVudCk7XFxuXFx0XFx0XFx0JChuZXcgSW1hZ2UoKSkub25lKCdsb2FkJywgJC5wcm94eShmdW5jdGlvbihlKSB7XFxuXFx0XFx0XFx0XFx0ZWxlbWVudC5hdHRyKCdzcmMnLCBlLnRhcmdldC5zcmMpO1xcblxcdFxcdFxcdFxcdGVsZW1lbnQuY3NzKCdvcGFjaXR5JywgMSk7XFxuXFx0XFx0XFx0XFx0dGhpcy5sZWF2ZSgncHJlLWxvYWRpbmcnKTtcXG5cXHRcXHRcXHRcXHQhdGhpcy5pcygncHJlLWxvYWRpbmcnKSAmJiAhdGhpcy5pcygnaW5pdGlhbGl6aW5nJykgJiYgdGhpcy5yZWZyZXNoKCk7XFxuXFx0XFx0XFx0fSwgdGhpcykpLmF0dHIoJ3NyYycsIGVsZW1lbnQuYXR0cignc3JjJykgfHwgZWxlbWVudC5hdHRyKCdkYXRhLXNyYycpIHx8IGVsZW1lbnQuYXR0cignZGF0YS1zcmMtcmV0aW5hJykpO1xcblxcdFxcdH0sIHRoaXMpKTtcXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIERlc3Ryb3lzIHRoZSBjYXJvdXNlbC5cXG5cXHQgKiBAcHVibGljXFxuXFx0ICovXFxuXFx0T3dsLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XFxuXFxuXFx0XFx0dGhpcy4kZWxlbWVudC5vZmYoJy5vd2wuY29yZScpO1xcblxcdFxcdHRoaXMuJHN0YWdlLm9mZignLm93bC5jb3JlJyk7XFxuXFx0XFx0JChkb2N1bWVudCkub2ZmKCcub3dsLmNvcmUnKTtcXG5cXG5cXHRcXHRpZiAodGhpcy5zZXR0aW5ncy5yZXNwb25zaXZlICE9PSBmYWxzZSkge1xcblxcdFxcdFxcdHdpbmRvdy5jbGVhclRpbWVvdXQodGhpcy5yZXNpemVUaW1lcik7XFxuXFx0XFx0XFx0dGhpcy5vZmYod2luZG93LCAncmVzaXplJywgdGhpcy5faGFuZGxlcnMub25UaHJvdHRsZWRSZXNpemUpO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRmb3IgKHZhciBpIGluIHRoaXMuX3BsdWdpbnMpIHtcXG5cXHRcXHRcXHR0aGlzLl9wbHVnaW5zW2ldLmRlc3Ryb3koKTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0dGhpcy4kc3RhZ2UuY2hpbGRyZW4oJy5jbG9uZWQnKS5yZW1vdmUoKTtcXG5cXG5cXHRcXHR0aGlzLiRzdGFnZS51bndyYXAoKTtcXG5cXHRcXHR0aGlzLiRzdGFnZS5jaGlsZHJlbigpLmNvbnRlbnRzKCkudW53cmFwKCk7XFxuXFx0XFx0dGhpcy4kc3RhZ2UuY2hpbGRyZW4oKS51bndyYXAoKTtcXG5cXG5cXHRcXHR0aGlzLiRlbGVtZW50XFxuXFx0XFx0XFx0LnJlbW92ZUNsYXNzKHRoaXMub3B0aW9ucy5yZWZyZXNoQ2xhc3MpXFxuXFx0XFx0XFx0LnJlbW92ZUNsYXNzKHRoaXMub3B0aW9ucy5sb2FkaW5nQ2xhc3MpXFxuXFx0XFx0XFx0LnJlbW92ZUNsYXNzKHRoaXMub3B0aW9ucy5sb2FkZWRDbGFzcylcXG5cXHRcXHRcXHQucmVtb3ZlQ2xhc3ModGhpcy5vcHRpb25zLnJ0bENsYXNzKVxcblxcdFxcdFxcdC5yZW1vdmVDbGFzcyh0aGlzLm9wdGlvbnMuZHJhZ0NsYXNzKVxcblxcdFxcdFxcdC5yZW1vdmVDbGFzcyh0aGlzLm9wdGlvbnMuZ3JhYkNsYXNzKVxcblxcdFxcdFxcdC5hdHRyKCdjbGFzcycsIHRoaXMuJGVsZW1lbnQuYXR0cignY2xhc3MnKS5yZXBsYWNlKG5ldyBSZWdFeHAodGhpcy5vcHRpb25zLnJlc3BvbnNpdmVDbGFzcyArICctXFxcXFxcXFxTK1xcXFxcXFxccycsICdnJyksICcnKSlcXG5cXHRcXHRcXHQucmVtb3ZlRGF0YSgnb3dsLmNhcm91c2VsJyk7XFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBPcGVyYXRvcnMgdG8gY2FsY3VsYXRlIHJpZ2h0LXRvLWxlZnQgYW5kIGxlZnQtdG8tcmlnaHQuXFxuXFx0ICogQHByb3RlY3RlZFxcblxcdCAqIEBwYXJhbSB7TnVtYmVyfSBbYV0gLSBUaGUgbGVmdCBzaWRlIG9wZXJhbmQuXFxuXFx0ICogQHBhcmFtIHtTdHJpbmd9IFtvXSAtIFRoZSBvcGVyYXRvci5cXG5cXHQgKiBAcGFyYW0ge051bWJlcn0gW2JdIC0gVGhlIHJpZ2h0IHNpZGUgb3BlcmFuZC5cXG5cXHQgKi9cXG5cXHRPd2wucHJvdG90eXBlLm9wID0gZnVuY3Rpb24oYSwgbywgYikge1xcblxcdFxcdHZhciBydGwgPSB0aGlzLnNldHRpbmdzLnJ0bDtcXG5cXHRcXHRzd2l0Y2ggKG8pIHtcXG5cXHRcXHRcXHRjYXNlICc8JzpcXG5cXHRcXHRcXHRcXHRyZXR1cm4gcnRsID8gYSA+IGIgOiBhIDwgYjtcXG5cXHRcXHRcXHRjYXNlICc+JzpcXG5cXHRcXHRcXHRcXHRyZXR1cm4gcnRsID8gYSA8IGIgOiBhID4gYjtcXG5cXHRcXHRcXHRjYXNlICc+PSc6XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHJ0bCA/IGEgPD0gYiA6IGEgPj0gYjtcXG5cXHRcXHRcXHRjYXNlICc8PSc6XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHJ0bCA/IGEgPj0gYiA6IGEgPD0gYjtcXG5cXHRcXHRcXHRkZWZhdWx0OlxcblxcdFxcdFxcdFxcdGJyZWFrO1xcblxcdFxcdH1cXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIEF0dGFjaGVzIHRvIGFuIGludGVybmFsIGV2ZW50LlxcblxcdCAqIEBwcm90ZWN0ZWRcXG5cXHQgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50IC0gVGhlIGV2ZW50IHNvdXJjZS5cXG5cXHQgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnQgLSBUaGUgZXZlbnQgbmFtZS5cXG5cXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBsaXN0ZW5lciAtIFRoZSBldmVudCBoYW5kbGVyIHRvIGF0dGFjaC5cXG5cXHQgKiBAcGFyYW0ge0Jvb2xlYW59IGNhcHR1cmUgLSBXZXRoZXIgdGhlIGV2ZW50IHNob3VsZCBiZSBoYW5kbGVkIGF0IHRoZSBjYXB0dXJpbmcgcGhhc2Ugb3Igbm90LlxcblxcdCAqL1xcblxcdE93bC5wcm90b3R5cGUub24gPSBmdW5jdGlvbihlbGVtZW50LCBldmVudCwgbGlzdGVuZXIsIGNhcHR1cmUpIHtcXG5cXHRcXHRpZiAoZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKSB7XFxuXFx0XFx0XFx0ZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lciwgY2FwdHVyZSk7XFxuXFx0XFx0fSBlbHNlIGlmIChlbGVtZW50LmF0dGFjaEV2ZW50KSB7XFxuXFx0XFx0XFx0ZWxlbWVudC5hdHRhY2hFdmVudCgnb24nICsgZXZlbnQsIGxpc3RlbmVyKTtcXG5cXHRcXHR9XFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBEZXRhY2hlcyBmcm9tIGFuIGludGVybmFsIGV2ZW50LlxcblxcdCAqIEBwcm90ZWN0ZWRcXG5cXHQgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50IC0gVGhlIGV2ZW50IHNvdXJjZS5cXG5cXHQgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnQgLSBUaGUgZXZlbnQgbmFtZS5cXG5cXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBsaXN0ZW5lciAtIFRoZSBhdHRhY2hlZCBldmVudCBoYW5kbGVyIHRvIGRldGFjaC5cXG5cXHQgKiBAcGFyYW0ge0Jvb2xlYW59IGNhcHR1cmUgLSBXZXRoZXIgdGhlIGF0dGFjaGVkIGV2ZW50IGhhbmRsZXIgd2FzIHJlZ2lzdGVyZWQgYXMgYSBjYXB0dXJpbmcgbGlzdGVuZXIgb3Igbm90LlxcblxcdCAqL1xcblxcdE93bC5wcm90b3R5cGUub2ZmID0gZnVuY3Rpb24oZWxlbWVudCwgZXZlbnQsIGxpc3RlbmVyLCBjYXB0dXJlKSB7XFxuXFx0XFx0aWYgKGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcikge1xcblxcdFxcdFxcdGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgbGlzdGVuZXIsIGNhcHR1cmUpO1xcblxcdFxcdH0gZWxzZSBpZiAoZWxlbWVudC5kZXRhY2hFdmVudCkge1xcblxcdFxcdFxcdGVsZW1lbnQuZGV0YWNoRXZlbnQoJ29uJyArIGV2ZW50LCBsaXN0ZW5lcik7XFxuXFx0XFx0fVxcblxcdH07XFxuXFxuXFx0LyoqXFxuXFx0ICogVHJpZ2dlcnMgYSBwdWJsaWMgZXZlbnQuXFxuXFx0ICogQHRvZG8gUmVtb3ZlIGBzdGF0dXNgLCBgcmVsYXRlZFRhcmdldGAgc2hvdWxkIGJlIHVzZWQgaW5zdGVhZC5cXG5cXHQgKiBAcHJvdGVjdGVkXFxuXFx0ICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgLSBUaGUgZXZlbnQgbmFtZS5cXG5cXHQgKiBAcGFyYW0geyp9IFtkYXRhPW51bGxdIC0gVGhlIGV2ZW50IGRhdGEuXFxuXFx0ICogQHBhcmFtIHtTdHJpbmd9IFtuYW1lc3BhY2U9Y2Fyb3VzZWxdIC0gVGhlIGV2ZW50IG5hbWVzcGFjZS5cXG5cXHQgKiBAcGFyYW0ge1N0cmluZ30gW3N0YXRlXSAtIFRoZSBzdGF0ZSB3aGljaCBpcyBhc3NvY2lhdGVkIHdpdGggdGhlIGV2ZW50LlxcblxcdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW2VudGVyPWZhbHNlXSAtIEluZGljYXRlcyBpZiB0aGUgY2FsbCBlbnRlcnMgdGhlIHNwZWNpZmllZCBzdGF0ZSBvciBub3QuXFxuXFx0ICogQHJldHVybnMge0V2ZW50fSAtIFRoZSBldmVudCBhcmd1bWVudHMuXFxuXFx0ICovXFxuXFx0T3dsLnByb3RvdHlwZS50cmlnZ2VyID0gZnVuY3Rpb24obmFtZSwgZGF0YSwgbmFtZXNwYWNlLCBzdGF0ZSwgZW50ZXIpIHtcXG5cXHRcXHR2YXIgc3RhdHVzID0ge1xcblxcdFxcdFxcdGl0ZW06IHsgY291bnQ6IHRoaXMuX2l0ZW1zLmxlbmd0aCwgaW5kZXg6IHRoaXMuY3VycmVudCgpIH1cXG5cXHRcXHR9LCBoYW5kbGVyID0gJC5jYW1lbENhc2UoXFxuXFx0XFx0XFx0JC5ncmVwKFsgJ29uJywgbmFtZSwgbmFtZXNwYWNlIF0sIGZ1bmN0aW9uKHYpIHsgcmV0dXJuIHYgfSlcXG5cXHRcXHRcXHRcXHQuam9pbignLScpLnRvTG93ZXJDYXNlKClcXG5cXHRcXHQpLCBldmVudCA9ICQuRXZlbnQoXFxuXFx0XFx0XFx0WyBuYW1lLCAnb3dsJywgbmFtZXNwYWNlIHx8ICdjYXJvdXNlbCcgXS5qb2luKCcuJykudG9Mb3dlckNhc2UoKSxcXG5cXHRcXHRcXHQkLmV4dGVuZCh7IHJlbGF0ZWRUYXJnZXQ6IHRoaXMgfSwgc3RhdHVzLCBkYXRhKVxcblxcdFxcdCk7XFxuXFxuXFx0XFx0aWYgKCF0aGlzLl9zdXByZXNzW25hbWVdKSB7XFxuXFx0XFx0XFx0JC5lYWNoKHRoaXMuX3BsdWdpbnMsIGZ1bmN0aW9uKG5hbWUsIHBsdWdpbikge1xcblxcdFxcdFxcdFxcdGlmIChwbHVnaW4ub25UcmlnZ2VyKSB7XFxuXFx0XFx0XFx0XFx0XFx0cGx1Z2luLm9uVHJpZ2dlcihldmVudCk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH0pO1xcblxcblxcdFxcdFxcdHRoaXMucmVnaXN0ZXIoeyB0eXBlOiBPd2wuVHlwZS5FdmVudCwgbmFtZTogbmFtZSB9KTtcXG5cXHRcXHRcXHR0aGlzLiRlbGVtZW50LnRyaWdnZXIoZXZlbnQpO1xcblxcblxcdFxcdFxcdGlmICh0aGlzLnNldHRpbmdzICYmIHR5cGVvZiB0aGlzLnNldHRpbmdzW2hhbmRsZXJdID09PSAnZnVuY3Rpb24nKSB7XFxuXFx0XFx0XFx0XFx0dGhpcy5zZXR0aW5nc1toYW5kbGVyXS5jYWxsKHRoaXMsIGV2ZW50KTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcblxcdFxcdHJldHVybiBldmVudDtcXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIEVudGVycyBhIHN0YXRlLlxcblxcdCAqIEBwYXJhbSBuYW1lIC0gVGhlIHN0YXRlIG5hbWUuXFxuXFx0ICovXFxuXFx0T3dsLnByb3RvdHlwZS5lbnRlciA9IGZ1bmN0aW9uKG5hbWUpIHtcXG5cXHRcXHQkLmVhY2goWyBuYW1lIF0uY29uY2F0KHRoaXMuX3N0YXRlcy50YWdzW25hbWVdIHx8IFtdKSwgJC5wcm94eShmdW5jdGlvbihpLCBuYW1lKSB7XFxuXFx0XFx0XFx0aWYgKHRoaXMuX3N0YXRlcy5jdXJyZW50W25hbWVdID09PSB1bmRlZmluZWQpIHtcXG5cXHRcXHRcXHRcXHR0aGlzLl9zdGF0ZXMuY3VycmVudFtuYW1lXSA9IDA7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHRoaXMuX3N0YXRlcy5jdXJyZW50W25hbWVdKys7XFxuXFx0XFx0fSwgdGhpcykpO1xcblxcdH07XFxuXFxuXFx0LyoqXFxuXFx0ICogTGVhdmVzIGEgc3RhdGUuXFxuXFx0ICogQHBhcmFtIG5hbWUgLSBUaGUgc3RhdGUgbmFtZS5cXG5cXHQgKi9cXG5cXHRPd2wucHJvdG90eXBlLmxlYXZlID0gZnVuY3Rpb24obmFtZSkge1xcblxcdFxcdCQuZWFjaChbIG5hbWUgXS5jb25jYXQodGhpcy5fc3RhdGVzLnRhZ3NbbmFtZV0gfHwgW10pLCAkLnByb3h5KGZ1bmN0aW9uKGksIG5hbWUpIHtcXG5cXHRcXHRcXHR0aGlzLl9zdGF0ZXMuY3VycmVudFtuYW1lXS0tO1xcblxcdFxcdH0sIHRoaXMpKTtcXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIFJlZ2lzdGVycyBhbiBldmVudCBvciBzdGF0ZS5cXG5cXHQgKiBAcHVibGljXFxuXFx0ICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCAtIFRoZSBldmVudCBvciBzdGF0ZSB0byByZWdpc3Rlci5cXG5cXHQgKi9cXG5cXHRPd2wucHJvdG90eXBlLnJlZ2lzdGVyID0gZnVuY3Rpb24ob2JqZWN0KSB7XFxuXFx0XFx0aWYgKG9iamVjdC50eXBlID09PSBPd2wuVHlwZS5FdmVudCkge1xcblxcdFxcdFxcdGlmICghJC5ldmVudC5zcGVjaWFsW29iamVjdC5uYW1lXSkge1xcblxcdFxcdFxcdFxcdCQuZXZlbnQuc3BlY2lhbFtvYmplY3QubmFtZV0gPSB7fTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKCEkLmV2ZW50LnNwZWNpYWxbb2JqZWN0Lm5hbWVdLm93bCkge1xcblxcdFxcdFxcdFxcdHZhciBfZGVmYXVsdCA9ICQuZXZlbnQuc3BlY2lhbFtvYmplY3QubmFtZV0uX2RlZmF1bHQ7XFxuXFx0XFx0XFx0XFx0JC5ldmVudC5zcGVjaWFsW29iamVjdC5uYW1lXS5fZGVmYXVsdCA9IGZ1bmN0aW9uKGUpIHtcXG5cXHRcXHRcXHRcXHRcXHRpZiAoX2RlZmF1bHQgJiYgX2RlZmF1bHQuYXBwbHkgJiYgKCFlLm5hbWVzcGFjZSB8fCBlLm5hbWVzcGFjZS5pbmRleE9mKCdvd2wnKSA9PT0gLTEpKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIF9kZWZhdWx0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdHJldHVybiBlLm5hbWVzcGFjZSAmJiBlLm5hbWVzcGFjZS5pbmRleE9mKCdvd2wnKSA+IC0xO1xcblxcdFxcdFxcdFxcdH07XFxuXFx0XFx0XFx0XFx0JC5ldmVudC5zcGVjaWFsW29iamVjdC5uYW1lXS5vd2wgPSB0cnVlO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9IGVsc2UgaWYgKG9iamVjdC50eXBlID09PSBPd2wuVHlwZS5TdGF0ZSkge1xcblxcdFxcdFxcdGlmICghdGhpcy5fc3RhdGVzLnRhZ3Nbb2JqZWN0Lm5hbWVdKSB7XFxuXFx0XFx0XFx0XFx0dGhpcy5fc3RhdGVzLnRhZ3Nbb2JqZWN0Lm5hbWVdID0gb2JqZWN0LnRhZ3M7XFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHR0aGlzLl9zdGF0ZXMudGFnc1tvYmplY3QubmFtZV0gPSB0aGlzLl9zdGF0ZXMudGFnc1tvYmplY3QubmFtZV0uY29uY2F0KG9iamVjdC50YWdzKTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0dGhpcy5fc3RhdGVzLnRhZ3Nbb2JqZWN0Lm5hbWVdID0gJC5ncmVwKHRoaXMuX3N0YXRlcy50YWdzW29iamVjdC5uYW1lXSwgJC5wcm94eShmdW5jdGlvbih0YWcsIGkpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gJC5pbkFycmF5KHRhZywgdGhpcy5fc3RhdGVzLnRhZ3Nbb2JqZWN0Lm5hbWVdKSA9PT0gaTtcXG5cXHRcXHRcXHR9LCB0aGlzKSk7XFxuXFx0XFx0fVxcblxcdH07XFxuXFxuXFx0LyoqXFxuXFx0ICogU3VwcHJlc3NlcyBldmVudHMuXFxuXFx0ICogQHByb3RlY3RlZFxcblxcdCAqIEBwYXJhbSB7QXJyYXkuPFN0cmluZz59IGV2ZW50cyAtIFRoZSBldmVudHMgdG8gc3VwcHJlc3MuXFxuXFx0ICovXFxuXFx0T3dsLnByb3RvdHlwZS5zdXBwcmVzcyA9IGZ1bmN0aW9uKGV2ZW50cykge1xcblxcdFxcdCQuZWFjaChldmVudHMsICQucHJveHkoZnVuY3Rpb24oaW5kZXgsIGV2ZW50KSB7XFxuXFx0XFx0XFx0dGhpcy5fc3VwcmVzc1tldmVudF0gPSB0cnVlO1xcblxcdFxcdH0sIHRoaXMpKTtcXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIFJlbGVhc2VzIHN1cHByZXNzZWQgZXZlbnRzLlxcblxcdCAqIEBwcm90ZWN0ZWRcXG5cXHQgKiBAcGFyYW0ge0FycmF5LjxTdHJpbmc+fSBldmVudHMgLSBUaGUgZXZlbnRzIHRvIHJlbGVhc2UuXFxuXFx0ICovXFxuXFx0T3dsLnByb3RvdHlwZS5yZWxlYXNlID0gZnVuY3Rpb24oZXZlbnRzKSB7XFxuXFx0XFx0JC5lYWNoKGV2ZW50cywgJC5wcm94eShmdW5jdGlvbihpbmRleCwgZXZlbnQpIHtcXG5cXHRcXHRcXHRkZWxldGUgdGhpcy5fc3VwcmVzc1tldmVudF07XFxuXFx0XFx0fSwgdGhpcykpO1xcblxcdH07XFxuXFxuXFx0LyoqXFxuXFx0ICogR2V0cyB1bmlmaWVkIHBvaW50ZXIgY29vcmRpbmF0ZXMgZnJvbSBldmVudC5cXG5cXHQgKiBAdG9kbyAjMjYxXFxuXFx0ICogQHByb3RlY3RlZFxcblxcdCAqIEBwYXJhbSB7RXZlbnR9IC0gVGhlIGBtb3VzZWRvd25gIG9yIGB0b3VjaHN0YXJ0YCBldmVudC5cXG5cXHQgKiBAcmV0dXJucyB7T2JqZWN0fSAtIENvbnRhaW5zIGB4YCBhbmQgYHlgIGNvb3JkaW5hdGVzIG9mIGN1cnJlbnQgcG9pbnRlciBwb3NpdGlvbi5cXG5cXHQgKi9cXG5cXHRPd2wucHJvdG90eXBlLnBvaW50ZXIgPSBmdW5jdGlvbihldmVudCkge1xcblxcdFxcdHZhciByZXN1bHQgPSB7IHg6IG51bGwsIHk6IG51bGwgfTtcXG5cXG5cXHRcXHRldmVudCA9IGV2ZW50Lm9yaWdpbmFsRXZlbnQgfHwgZXZlbnQgfHwgd2luZG93LmV2ZW50O1xcblxcblxcdFxcdGV2ZW50ID0gZXZlbnQudG91Y2hlcyAmJiBldmVudC50b3VjaGVzLmxlbmd0aCA/XFxuXFx0XFx0XFx0ZXZlbnQudG91Y2hlc1swXSA6IGV2ZW50LmNoYW5nZWRUb3VjaGVzICYmIGV2ZW50LmNoYW5nZWRUb3VjaGVzLmxlbmd0aCA/XFxuXFx0XFx0XFx0XFx0ZXZlbnQuY2hhbmdlZFRvdWNoZXNbMF0gOiBldmVudDtcXG5cXG5cXHRcXHRpZiAoZXZlbnQucGFnZVgpIHtcXG5cXHRcXHRcXHRyZXN1bHQueCA9IGV2ZW50LnBhZ2VYO1xcblxcdFxcdFxcdHJlc3VsdC55ID0gZXZlbnQucGFnZVk7XFxuXFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRyZXN1bHQueCA9IGV2ZW50LmNsaWVudFg7XFxuXFx0XFx0XFx0cmVzdWx0LnkgPSBldmVudC5jbGllbnRZO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRyZXR1cm4gcmVzdWx0O1xcblxcdH07XFxuXFxuXFx0LyoqXFxuXFx0ICogRGV0ZXJtaW5lcyBpZiB0aGUgaW5wdXQgaXMgYSBOdW1iZXIgb3Igc29tZXRoaW5nIHRoYXQgY2FuIGJlIGNvZXJjZWQgdG8gYSBOdW1iZXJcXG5cXHQgKiBAcHJvdGVjdGVkXFxuXFx0ICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfE9iamVjdHxBcnJheXxCb29sZWFufFJlZ0V4cHxGdW5jdGlvbnxTeW1ib2x9IC0gVGhlIGlucHV0IHRvIGJlIHRlc3RlZFxcblxcdCAqIEByZXR1cm5zIHtCb29sZWFufSAtIEFuIGluZGljYXRpb24gaWYgdGhlIGlucHV0IGlzIGEgTnVtYmVyIG9yIGNhbiBiZSBjb2VyY2VkIHRvIGEgTnVtYmVyXFxuXFx0ICovXFxuXFx0T3dsLnByb3RvdHlwZS5pc051bWVyaWMgPSBmdW5jdGlvbihudW1iZXIpIHtcXG5cXHRcXHRyZXR1cm4gIWlzTmFOKHBhcnNlRmxvYXQobnVtYmVyKSk7XFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBHZXRzIHRoZSBkaWZmZXJlbmNlIG9mIHR3byB2ZWN0b3JzLlxcblxcdCAqIEB0b2RvICMyNjFcXG5cXHQgKiBAcHJvdGVjdGVkXFxuXFx0ICogQHBhcmFtIHtPYmplY3R9IC0gVGhlIGZpcnN0IHZlY3Rvci5cXG5cXHQgKiBAcGFyYW0ge09iamVjdH0gLSBUaGUgc2Vjb25kIHZlY3Rvci5cXG5cXHQgKiBAcmV0dXJucyB7T2JqZWN0fSAtIFRoZSBkaWZmZXJlbmNlLlxcblxcdCAqL1xcblxcdE93bC5wcm90b3R5cGUuZGlmZmVyZW5jZSA9IGZ1bmN0aW9uKGZpcnN0LCBzZWNvbmQpIHtcXG5cXHRcXHRyZXR1cm4ge1xcblxcdFxcdFxcdHg6IGZpcnN0LnggLSBzZWNvbmQueCxcXG5cXHRcXHRcXHR5OiBmaXJzdC55IC0gc2Vjb25kLnlcXG5cXHRcXHR9O1xcblxcdH07XFxuXFxuXFx0LyoqXFxuXFx0ICogVGhlIGpRdWVyeSBQbHVnaW4gZm9yIHRoZSBPd2wgQ2Fyb3VzZWxcXG5cXHQgKiBAdG9kbyBOYXZpZ2F0aW9uIHBsdWdpbiBgbmV4dGAgYW5kIGBwcmV2YFxcblxcdCAqIEBwdWJsaWNcXG5cXHQgKi9cXG5cXHQkLmZuLm93bENhcm91c2VsID0gZnVuY3Rpb24ob3B0aW9uKSB7XFxuXFx0XFx0dmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xcblxcblxcdFxcdHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0dmFyICR0aGlzID0gJCh0aGlzKSxcXG5cXHRcXHRcXHRcXHRkYXRhID0gJHRoaXMuZGF0YSgnb3dsLmNhcm91c2VsJyk7XFxuXFxuXFx0XFx0XFx0aWYgKCFkYXRhKSB7XFxuXFx0XFx0XFx0XFx0ZGF0YSA9IG5ldyBPd2wodGhpcywgdHlwZW9mIG9wdGlvbiA9PSAnb2JqZWN0JyAmJiBvcHRpb24pO1xcblxcdFxcdFxcdFxcdCR0aGlzLmRhdGEoJ293bC5jYXJvdXNlbCcsIGRhdGEpO1xcblxcblxcdFxcdFxcdFxcdCQuZWFjaChbXFxuXFx0XFx0XFx0XFx0XFx0J25leHQnLCAncHJldicsICd0bycsICdkZXN0cm95JywgJ3JlZnJlc2gnLCAncmVwbGFjZScsICdhZGQnLCAncmVtb3ZlJ1xcblxcdFxcdFxcdFxcdF0sIGZ1bmN0aW9uKGksIGV2ZW50KSB7XFxuXFx0XFx0XFx0XFx0XFx0ZGF0YS5yZWdpc3Rlcih7IHR5cGU6IE93bC5UeXBlLkV2ZW50LCBuYW1lOiBldmVudCB9KTtcXG5cXHRcXHRcXHRcXHRcXHRkYXRhLiRlbGVtZW50Lm9uKGV2ZW50ICsgJy5vd2wuY2Fyb3VzZWwuY29yZScsICQucHJveHkoZnVuY3Rpb24oZSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGlmIChlLm5hbWVzcGFjZSAmJiBlLnJlbGF0ZWRUYXJnZXQgIT09IHRoaXMpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR0aGlzLnN1cHByZXNzKFsgZXZlbnQgXSk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0ZGF0YVtldmVudF0uYXBwbHkodGhpcywgW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR0aGlzLnJlbGVhc2UoWyBldmVudCBdKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0fSwgZGF0YSkpO1xcblxcdFxcdFxcdFxcdH0pO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpZiAodHlwZW9mIG9wdGlvbiA9PSAnc3RyaW5nJyAmJiBvcHRpb24uY2hhckF0KDApICE9PSAnXycpIHtcXG5cXHRcXHRcXHRcXHRkYXRhW29wdGlvbl0uYXBwbHkoZGF0YSwgYXJncyk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH0pO1xcblxcdH07XFxuXFxuXFx0LyoqXFxuXFx0ICogVGhlIGNvbnN0cnVjdG9yIGZvciB0aGUgalF1ZXJ5IFBsdWdpblxcblxcdCAqIEBwdWJsaWNcXG5cXHQgKi9cXG5cXHQkLmZuLm93bENhcm91c2VsLkNvbnN0cnVjdG9yID0gT3dsO1xcblxcbn0pKHdpbmRvdy5aZXB0byB8fCBfX3dlYnBhY2tfcHJvdmlkZWRfd2luZG93X2RvdF9qUXVlcnksIHdpbmRvdywgZG9jdW1lbnQpO1xcblxcbi8qKlxcbiAqIEF1dG9SZWZyZXNoIFBsdWdpblxcbiAqIEB2ZXJzaW9uIDIuMS4wXFxuICogQGF1dGhvciBBcnR1cyBLb2xhbm93c2tpXFxuICogQGF1dGhvciBEYXZpZCBEZXV0c2NoXFxuICogQGxpY2Vuc2UgVGhlIE1JVCBMaWNlbnNlIChNSVQpXFxuICovXFxuOyhmdW5jdGlvbigkLCB3aW5kb3csIGRvY3VtZW50LCB1bmRlZmluZWQpIHtcXG5cXG5cXHQvKipcXG5cXHQgKiBDcmVhdGVzIHRoZSBhdXRvIHJlZnJlc2ggcGx1Z2luLlxcblxcdCAqIEBjbGFzcyBUaGUgQXV0byBSZWZyZXNoIFBsdWdpblxcblxcdCAqIEBwYXJhbSB7T3dsfSBjYXJvdXNlbCAtIFRoZSBPd2wgQ2Fyb3VzZWxcXG5cXHQgKi9cXG5cXHR2YXIgQXV0b1JlZnJlc2ggPSBmdW5jdGlvbihjYXJvdXNlbCkge1xcblxcdFxcdC8qKlxcblxcdFxcdCAqIFJlZmVyZW5jZSB0byB0aGUgY29yZS5cXG5cXHRcXHQgKiBAcHJvdGVjdGVkXFxuXFx0XFx0ICogQHR5cGUge093bH1cXG5cXHRcXHQgKi9cXG5cXHRcXHR0aGlzLl9jb3JlID0gY2Fyb3VzZWw7XFxuXFxuXFx0XFx0LyoqXFxuXFx0XFx0ICogUmVmcmVzaCBpbnRlcnZhbC5cXG5cXHRcXHQgKiBAcHJvdGVjdGVkXFxuXFx0XFx0ICogQHR5cGUge251bWJlcn1cXG5cXHRcXHQgKi9cXG5cXHRcXHR0aGlzLl9pbnRlcnZhbCA9IG51bGw7XFxuXFxuXFx0XFx0LyoqXFxuXFx0XFx0ICogV2hldGhlciB0aGUgZWxlbWVudCBpcyBjdXJyZW50bHkgdmlzaWJsZSBvciBub3QuXFxuXFx0XFx0ICogQHByb3RlY3RlZFxcblxcdFxcdCAqIEB0eXBlIHtCb29sZWFufVxcblxcdFxcdCAqL1xcblxcdFxcdHRoaXMuX3Zpc2libGUgPSBudWxsO1xcblxcblxcdFxcdC8qKlxcblxcdFxcdCAqIEFsbCBldmVudCBoYW5kbGVycy5cXG5cXHRcXHQgKiBAcHJvdGVjdGVkXFxuXFx0XFx0ICogQHR5cGUge09iamVjdH1cXG5cXHRcXHQgKi9cXG5cXHRcXHR0aGlzLl9oYW5kbGVycyA9IHtcXG5cXHRcXHRcXHQnaW5pdGlhbGl6ZWQub3dsLmNhcm91c2VsJzogJC5wcm94eShmdW5jdGlvbihlKSB7XFxuXFx0XFx0XFx0XFx0aWYgKGUubmFtZXNwYWNlICYmIHRoaXMuX2NvcmUuc2V0dGluZ3MuYXV0b1JlZnJlc2gpIHtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLndhdGNoKCk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH0sIHRoaXMpXFxuXFx0XFx0fTtcXG5cXG5cXHRcXHQvLyBzZXQgZGVmYXVsdCBvcHRpb25zXFxuXFx0XFx0dGhpcy5fY29yZS5vcHRpb25zID0gJC5leHRlbmQoe30sIEF1dG9SZWZyZXNoLkRlZmF1bHRzLCB0aGlzLl9jb3JlLm9wdGlvbnMpO1xcblxcblxcdFxcdC8vIHJlZ2lzdGVyIGV2ZW50IGhhbmRsZXJzXFxuXFx0XFx0dGhpcy5fY29yZS4kZWxlbWVudC5vbih0aGlzLl9oYW5kbGVycyk7XFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBEZWZhdWx0IG9wdGlvbnMuXFxuXFx0ICogQHB1YmxpY1xcblxcdCAqL1xcblxcdEF1dG9SZWZyZXNoLkRlZmF1bHRzID0ge1xcblxcdFxcdGF1dG9SZWZyZXNoOiB0cnVlLFxcblxcdFxcdGF1dG9SZWZyZXNoSW50ZXJ2YWw6IDUwMFxcblxcdH07XFxuXFxuXFx0LyoqXFxuXFx0ICogV2F0Y2hlcyB0aGUgZWxlbWVudC5cXG5cXHQgKi9cXG5cXHRBdXRvUmVmcmVzaC5wcm90b3R5cGUud2F0Y2ggPSBmdW5jdGlvbigpIHtcXG5cXHRcXHRpZiAodGhpcy5faW50ZXJ2YWwpIHtcXG5cXHRcXHRcXHRyZXR1cm47XFxuXFx0XFx0fVxcblxcblxcdFxcdHRoaXMuX3Zpc2libGUgPSB0aGlzLl9jb3JlLiRlbGVtZW50LmlzKCc6dmlzaWJsZScpO1xcblxcdFxcdHRoaXMuX2ludGVydmFsID0gd2luZG93LnNldEludGVydmFsKCQucHJveHkodGhpcy5yZWZyZXNoLCB0aGlzKSwgdGhpcy5fY29yZS5zZXR0aW5ncy5hdXRvUmVmcmVzaEludGVydmFsKTtcXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIFJlZnJlc2hlcyB0aGUgZWxlbWVudC5cXG5cXHQgKi9cXG5cXHRBdXRvUmVmcmVzaC5wcm90b3R5cGUucmVmcmVzaCA9IGZ1bmN0aW9uKCkge1xcblxcdFxcdGlmICh0aGlzLl9jb3JlLiRlbGVtZW50LmlzKCc6dmlzaWJsZScpID09PSB0aGlzLl92aXNpYmxlKSB7XFxuXFx0XFx0XFx0cmV0dXJuO1xcblxcdFxcdH1cXG5cXG5cXHRcXHR0aGlzLl92aXNpYmxlID0gIXRoaXMuX3Zpc2libGU7XFxuXFxuXFx0XFx0dGhpcy5fY29yZS4kZWxlbWVudC50b2dnbGVDbGFzcygnb3dsLWhpZGRlbicsICF0aGlzLl92aXNpYmxlKTtcXG5cXG5cXHRcXHR0aGlzLl92aXNpYmxlICYmICh0aGlzLl9jb3JlLmludmFsaWRhdGUoJ3dpZHRoJykgJiYgdGhpcy5fY29yZS5yZWZyZXNoKCkpO1xcblxcdH07XFxuXFxuXFx0LyoqXFxuXFx0ICogRGVzdHJveXMgdGhlIHBsdWdpbi5cXG5cXHQgKi9cXG5cXHRBdXRvUmVmcmVzaC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xcblxcdFxcdHZhciBoYW5kbGVyLCBwcm9wZXJ0eTtcXG5cXG5cXHRcXHR3aW5kb3cuY2xlYXJJbnRlcnZhbCh0aGlzLl9pbnRlcnZhbCk7XFxuXFxuXFx0XFx0Zm9yIChoYW5kbGVyIGluIHRoaXMuX2hhbmRsZXJzKSB7XFxuXFx0XFx0XFx0dGhpcy5fY29yZS4kZWxlbWVudC5vZmYoaGFuZGxlciwgdGhpcy5faGFuZGxlcnNbaGFuZGxlcl0pO1xcblxcdFxcdH1cXG5cXHRcXHRmb3IgKHByb3BlcnR5IGluIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRoaXMpKSB7XFxuXFx0XFx0XFx0dHlwZW9mIHRoaXNbcHJvcGVydHldICE9ICdmdW5jdGlvbicgJiYgKHRoaXNbcHJvcGVydHldID0gbnVsbCk7XFxuXFx0XFx0fVxcblxcdH07XFxuXFxuXFx0JC5mbi5vd2xDYXJvdXNlbC5Db25zdHJ1Y3Rvci5QbHVnaW5zLkF1dG9SZWZyZXNoID0gQXV0b1JlZnJlc2g7XFxuXFxufSkod2luZG93LlplcHRvIHx8IF9fd2VicGFja19wcm92aWRlZF93aW5kb3dfZG90X2pRdWVyeSwgd2luZG93LCBkb2N1bWVudCk7XFxuXFxuLyoqXFxuICogTGF6eSBQbHVnaW5cXG4gKiBAdmVyc2lvbiAyLjEuMFxcbiAqIEBhdXRob3IgQmFydG9zeiBXb2pjaWVjaG93c2tpXFxuICogQGF1dGhvciBEYXZpZCBEZXV0c2NoXFxuICogQGxpY2Vuc2UgVGhlIE1JVCBMaWNlbnNlIChNSVQpXFxuICovXFxuOyhmdW5jdGlvbigkLCB3aW5kb3csIGRvY3VtZW50LCB1bmRlZmluZWQpIHtcXG5cXG5cXHQvKipcXG5cXHQgKiBDcmVhdGVzIHRoZSBsYXp5IHBsdWdpbi5cXG5cXHQgKiBAY2xhc3MgVGhlIExhenkgUGx1Z2luXFxuXFx0ICogQHBhcmFtIHtPd2x9IGNhcm91c2VsIC0gVGhlIE93bCBDYXJvdXNlbFxcblxcdCAqL1xcblxcdHZhciBMYXp5ID0gZnVuY3Rpb24oY2Fyb3VzZWwpIHtcXG5cXG5cXHRcXHQvKipcXG5cXHRcXHQgKiBSZWZlcmVuY2UgdG8gdGhlIGNvcmUuXFxuXFx0XFx0ICogQHByb3RlY3RlZFxcblxcdFxcdCAqIEB0eXBlIHtPd2x9XFxuXFx0XFx0ICovXFxuXFx0XFx0dGhpcy5fY29yZSA9IGNhcm91c2VsO1xcblxcblxcdFxcdC8qKlxcblxcdFxcdCAqIEFscmVhZHkgbG9hZGVkIGl0ZW1zLlxcblxcdFxcdCAqIEBwcm90ZWN0ZWRcXG5cXHRcXHQgKiBAdHlwZSB7QXJyYXkuPGpRdWVyeT59XFxuXFx0XFx0ICovXFxuXFx0XFx0dGhpcy5fbG9hZGVkID0gW107XFxuXFxuXFx0XFx0LyoqXFxuXFx0XFx0ICogRXZlbnQgaGFuZGxlcnMuXFxuXFx0XFx0ICogQHByb3RlY3RlZFxcblxcdFxcdCAqIEB0eXBlIHtPYmplY3R9XFxuXFx0XFx0ICovXFxuXFx0XFx0dGhpcy5faGFuZGxlcnMgPSB7XFxuXFx0XFx0XFx0J2luaXRpYWxpemVkLm93bC5jYXJvdXNlbCBjaGFuZ2Uub3dsLmNhcm91c2VsIHJlc2l6ZWQub3dsLmNhcm91c2VsJzogJC5wcm94eShmdW5jdGlvbihlKSB7XFxuXFx0XFx0XFx0XFx0aWYgKCFlLm5hbWVzcGFjZSkge1xcblxcdFxcdFxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCF0aGlzLl9jb3JlLnNldHRpbmdzIHx8ICF0aGlzLl9jb3JlLnNldHRpbmdzLmxhenlMb2FkKSB7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuO1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRpZiAoKGUucHJvcGVydHkgJiYgZS5wcm9wZXJ0eS5uYW1lID09ICdwb3NpdGlvbicpIHx8IGUudHlwZSA9PSAnaW5pdGlhbGl6ZWQnKSB7XFxuXFx0XFx0XFx0XFx0XFx0dmFyIHNldHRpbmdzID0gdGhpcy5fY29yZS5zZXR0aW5ncyxcXG5cXHRcXHRcXHRcXHRcXHRcXHRuID0gKHNldHRpbmdzLmNlbnRlciAmJiBNYXRoLmNlaWwoc2V0dGluZ3MuaXRlbXMgLyAyKSB8fCBzZXR0aW5ncy5pdGVtcyksXFxuXFx0XFx0XFx0XFx0XFx0XFx0aSA9ICgoc2V0dGluZ3MuY2VudGVyICYmIG4gKiAtMSkgfHwgMCksXFxuXFx0XFx0XFx0XFx0XFx0XFx0cG9zaXRpb24gPSAoZS5wcm9wZXJ0eSAmJiBlLnByb3BlcnR5LnZhbHVlICE9PSB1bmRlZmluZWQgPyBlLnByb3BlcnR5LnZhbHVlIDogdGhpcy5fY29yZS5jdXJyZW50KCkpICsgaSxcXG5cXHRcXHRcXHRcXHRcXHRcXHRjbG9uZXMgPSB0aGlzLl9jb3JlLmNsb25lcygpLmxlbmd0aCxcXG5cXHRcXHRcXHRcXHRcXHRcXHRsb2FkID0gJC5wcm94eShmdW5jdGlvbihpLCB2KSB7IHRoaXMubG9hZCh2KSB9LCB0aGlzKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHR3aGlsZSAoaSsrIDwgbikge1xcblxcdFxcdFxcdFxcdFxcdFxcdHRoaXMubG9hZChjbG9uZXMgLyAyICsgdGhpcy5fY29yZS5yZWxhdGl2ZShwb3NpdGlvbikpO1xcblxcdFxcdFxcdFxcdFxcdFxcdGNsb25lcyAmJiAkLmVhY2godGhpcy5fY29yZS5jbG9uZXModGhpcy5fY29yZS5yZWxhdGl2ZShwb3NpdGlvbikpLCBsb2FkKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRwb3NpdGlvbisrO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fSwgdGhpcylcXG5cXHRcXHR9O1xcblxcblxcdFxcdC8vIHNldCB0aGUgZGVmYXVsdCBvcHRpb25zXFxuXFx0XFx0dGhpcy5fY29yZS5vcHRpb25zID0gJC5leHRlbmQoe30sIExhenkuRGVmYXVsdHMsIHRoaXMuX2NvcmUub3B0aW9ucyk7XFxuXFxuXFx0XFx0Ly8gcmVnaXN0ZXIgZXZlbnQgaGFuZGxlclxcblxcdFxcdHRoaXMuX2NvcmUuJGVsZW1lbnQub24odGhpcy5faGFuZGxlcnMpO1xcblxcdH07XFxuXFxuXFx0LyoqXFxuXFx0ICogRGVmYXVsdCBvcHRpb25zLlxcblxcdCAqIEBwdWJsaWNcXG5cXHQgKi9cXG5cXHRMYXp5LkRlZmF1bHRzID0ge1xcblxcdFxcdGxhenlMb2FkOiBmYWxzZVxcblxcdH07XFxuXFxuXFx0LyoqXFxuXFx0ICogTG9hZHMgYWxsIHJlc291cmNlcyBvZiBhbiBpdGVtIGF0IHRoZSBzcGVjaWZpZWQgcG9zaXRpb24uXFxuXFx0ICogQHBhcmFtIHtOdW1iZXJ9IHBvc2l0aW9uIC0gVGhlIGFic29sdXRlIHBvc2l0aW9uIG9mIHRoZSBpdGVtLlxcblxcdCAqIEBwcm90ZWN0ZWRcXG5cXHQgKi9cXG5cXHRMYXp5LnByb3RvdHlwZS5sb2FkID0gZnVuY3Rpb24ocG9zaXRpb24pIHtcXG5cXHRcXHR2YXIgJGl0ZW0gPSB0aGlzLl9jb3JlLiRzdGFnZS5jaGlsZHJlbigpLmVxKHBvc2l0aW9uKSxcXG5cXHRcXHRcXHQkZWxlbWVudHMgPSAkaXRlbSAmJiAkaXRlbS5maW5kKCcub3dsLWxhenknKTtcXG5cXG5cXHRcXHRpZiAoISRlbGVtZW50cyB8fCAkLmluQXJyYXkoJGl0ZW0uZ2V0KDApLCB0aGlzLl9sb2FkZWQpID4gLTEpIHtcXG5cXHRcXHRcXHRyZXR1cm47XFxuXFx0XFx0fVxcblxcblxcdFxcdCRlbGVtZW50cy5lYWNoKCQucHJveHkoZnVuY3Rpb24oaW5kZXgsIGVsZW1lbnQpIHtcXG5cXHRcXHRcXHR2YXIgJGVsZW1lbnQgPSAkKGVsZW1lbnQpLCBpbWFnZSxcXG5cXHRcXHRcXHRcXHR1cmwgPSAod2luZG93LmRldmljZVBpeGVsUmF0aW8gPiAxICYmICRlbGVtZW50LmF0dHIoJ2RhdGEtc3JjLXJldGluYScpKSB8fCAkZWxlbWVudC5hdHRyKCdkYXRhLXNyYycpO1xcblxcblxcdFxcdFxcdHRoaXMuX2NvcmUudHJpZ2dlcignbG9hZCcsIHsgZWxlbWVudDogJGVsZW1lbnQsIHVybDogdXJsIH0sICdsYXp5Jyk7XFxuXFxuXFx0XFx0XFx0aWYgKCRlbGVtZW50LmlzKCdpbWcnKSkge1xcblxcdFxcdFxcdFxcdCRlbGVtZW50Lm9uZSgnbG9hZC5vd2wubGF6eScsICQucHJveHkoZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0XFx0XFx0JGVsZW1lbnQuY3NzKCdvcGFjaXR5JywgMSk7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5fY29yZS50cmlnZ2VyKCdsb2FkZWQnLCB7IGVsZW1lbnQ6ICRlbGVtZW50LCB1cmw6IHVybCB9LCAnbGF6eScpO1xcblxcdFxcdFxcdFxcdH0sIHRoaXMpKS5hdHRyKCdzcmMnLCB1cmwpO1xcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0aW1hZ2UgPSBuZXcgSW1hZ2UoKTtcXG5cXHRcXHRcXHRcXHRpbWFnZS5vbmxvYWQgPSAkLnByb3h5KGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdFxcdFxcdCRlbGVtZW50LmNzcyh7XFxuXFx0XFx0XFx0XFx0XFx0XFx0J2JhY2tncm91bmQtaW1hZ2UnOiAndXJsKCcgKyB1cmwgKyAnKScsXFxuXFx0XFx0XFx0XFx0XFx0XFx0J29wYWNpdHknOiAnMSdcXG5cXHRcXHRcXHRcXHRcXHR9KTtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLl9jb3JlLnRyaWdnZXIoJ2xvYWRlZCcsIHsgZWxlbWVudDogJGVsZW1lbnQsIHVybDogdXJsIH0sICdsYXp5Jyk7XFxuXFx0XFx0XFx0XFx0fSwgdGhpcyk7XFxuXFx0XFx0XFx0XFx0aW1hZ2Uuc3JjID0gdXJsO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9LCB0aGlzKSk7XFxuXFxuXFx0XFx0dGhpcy5fbG9hZGVkLnB1c2goJGl0ZW0uZ2V0KDApKTtcXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIERlc3Ryb3lzIHRoZSBwbHVnaW4uXFxuXFx0ICogQHB1YmxpY1xcblxcdCAqL1xcblxcdExhenkucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcXG5cXHRcXHR2YXIgaGFuZGxlciwgcHJvcGVydHk7XFxuXFxuXFx0XFx0Zm9yIChoYW5kbGVyIGluIHRoaXMuaGFuZGxlcnMpIHtcXG5cXHRcXHRcXHR0aGlzLl9jb3JlLiRlbGVtZW50Lm9mZihoYW5kbGVyLCB0aGlzLmhhbmRsZXJzW2hhbmRsZXJdKTtcXG5cXHRcXHR9XFxuXFx0XFx0Zm9yIChwcm9wZXJ0eSBpbiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0aGlzKSkge1xcblxcdFxcdFxcdHR5cGVvZiB0aGlzW3Byb3BlcnR5XSAhPSAnZnVuY3Rpb24nICYmICh0aGlzW3Byb3BlcnR5XSA9IG51bGwpO1xcblxcdFxcdH1cXG5cXHR9O1xcblxcblxcdCQuZm4ub3dsQ2Fyb3VzZWwuQ29uc3RydWN0b3IuUGx1Z2lucy5MYXp5ID0gTGF6eTtcXG5cXG59KSh3aW5kb3cuWmVwdG8gfHwgX193ZWJwYWNrX3Byb3ZpZGVkX3dpbmRvd19kb3RfalF1ZXJ5LCB3aW5kb3csIGRvY3VtZW50KTtcXG5cXG4vKipcXG4gKiBBdXRvSGVpZ2h0IFBsdWdpblxcbiAqIEB2ZXJzaW9uIDIuMS4wXFxuICogQGF1dGhvciBCYXJ0b3N6IFdvamNpZWNob3dza2lcXG4gKiBAYXV0aG9yIERhdmlkIERldXRzY2hcXG4gKiBAbGljZW5zZSBUaGUgTUlUIExpY2Vuc2UgKE1JVClcXG4gKi9cXG47KGZ1bmN0aW9uKCQsIHdpbmRvdywgZG9jdW1lbnQsIHVuZGVmaW5lZCkge1xcblxcblxcdC8qKlxcblxcdCAqIENyZWF0ZXMgdGhlIGF1dG8gaGVpZ2h0IHBsdWdpbi5cXG5cXHQgKiBAY2xhc3MgVGhlIEF1dG8gSGVpZ2h0IFBsdWdpblxcblxcdCAqIEBwYXJhbSB7T3dsfSBjYXJvdXNlbCAtIFRoZSBPd2wgQ2Fyb3VzZWxcXG5cXHQgKi9cXG5cXHR2YXIgQXV0b0hlaWdodCA9IGZ1bmN0aW9uKGNhcm91c2VsKSB7XFxuXFx0XFx0LyoqXFxuXFx0XFx0ICogUmVmZXJlbmNlIHRvIHRoZSBjb3JlLlxcblxcdFxcdCAqIEBwcm90ZWN0ZWRcXG5cXHRcXHQgKiBAdHlwZSB7T3dsfVxcblxcdFxcdCAqL1xcblxcdFxcdHRoaXMuX2NvcmUgPSBjYXJvdXNlbDtcXG5cXG5cXHRcXHQvKipcXG5cXHRcXHQgKiBBbGwgZXZlbnQgaGFuZGxlcnMuXFxuXFx0XFx0ICogQHByb3RlY3RlZFxcblxcdFxcdCAqIEB0eXBlIHtPYmplY3R9XFxuXFx0XFx0ICovXFxuXFx0XFx0dGhpcy5faGFuZGxlcnMgPSB7XFxuXFx0XFx0XFx0J2luaXRpYWxpemVkLm93bC5jYXJvdXNlbCByZWZyZXNoZWQub3dsLmNhcm91c2VsJzogJC5wcm94eShmdW5jdGlvbihlKSB7XFxuXFx0XFx0XFx0XFx0aWYgKGUubmFtZXNwYWNlICYmIHRoaXMuX2NvcmUuc2V0dGluZ3MuYXV0b0hlaWdodCkge1xcblxcdFxcdFxcdFxcdFxcdHRoaXMudXBkYXRlKCk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH0sIHRoaXMpLFxcblxcdFxcdFxcdCdjaGFuZ2VkLm93bC5jYXJvdXNlbCc6ICQucHJveHkoZnVuY3Rpb24oZSkge1xcblxcdFxcdFxcdFxcdGlmIChlLm5hbWVzcGFjZSAmJiB0aGlzLl9jb3JlLnNldHRpbmdzLmF1dG9IZWlnaHQgJiYgZS5wcm9wZXJ0eS5uYW1lID09ICdwb3NpdGlvbicpe1xcblxcdFxcdFxcdFxcdFxcdHRoaXMudXBkYXRlKCk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH0sIHRoaXMpLFxcblxcdFxcdFxcdCdsb2FkZWQub3dsLmxhenknOiAkLnByb3h5KGZ1bmN0aW9uKGUpIHtcXG5cXHRcXHRcXHRcXHRpZiAoZS5uYW1lc3BhY2UgJiYgdGhpcy5fY29yZS5zZXR0aW5ncy5hdXRvSGVpZ2h0XFxuXFx0XFx0XFx0XFx0XFx0JiYgZS5lbGVtZW50LmNsb3Nlc3QoJy4nICsgdGhpcy5fY29yZS5zZXR0aW5ncy5pdGVtQ2xhc3MpLmluZGV4KCkgPT09IHRoaXMuX2NvcmUuY3VycmVudCgpKSB7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy51cGRhdGUoKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fSwgdGhpcylcXG5cXHRcXHR9O1xcblxcblxcdFxcdC8vIHNldCBkZWZhdWx0IG9wdGlvbnNcXG5cXHRcXHR0aGlzLl9jb3JlLm9wdGlvbnMgPSAkLmV4dGVuZCh7fSwgQXV0b0hlaWdodC5EZWZhdWx0cywgdGhpcy5fY29yZS5vcHRpb25zKTtcXG5cXG5cXHRcXHQvLyByZWdpc3RlciBldmVudCBoYW5kbGVyc1xcblxcdFxcdHRoaXMuX2NvcmUuJGVsZW1lbnQub24odGhpcy5faGFuZGxlcnMpO1xcblxcdH07XFxuXFxuXFx0LyoqXFxuXFx0ICogRGVmYXVsdCBvcHRpb25zLlxcblxcdCAqIEBwdWJsaWNcXG5cXHQgKi9cXG5cXHRBdXRvSGVpZ2h0LkRlZmF1bHRzID0ge1xcblxcdFxcdGF1dG9IZWlnaHQ6IGZhbHNlLFxcblxcdFxcdGF1dG9IZWlnaHRDbGFzczogJ293bC1oZWlnaHQnXFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBVcGRhdGVzIHRoZSB2aWV3LlxcblxcdCAqL1xcblxcdEF1dG9IZWlnaHQucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKCkge1xcblxcdFxcdHZhciBzdGFydCA9IHRoaXMuX2NvcmUuX2N1cnJlbnQsXFxuXFx0XFx0XFx0ZW5kID0gc3RhcnQgKyB0aGlzLl9jb3JlLnNldHRpbmdzLml0ZW1zLFxcblxcdFxcdFxcdHZpc2libGUgPSB0aGlzLl9jb3JlLiRzdGFnZS5jaGlsZHJlbigpLnRvQXJyYXkoKS5zbGljZShzdGFydCwgZW5kKSxcXG5cXHRcXHRcXHRoZWlnaHRzID0gW10sXFxuXFx0XFx0XFx0bWF4aGVpZ2h0ID0gMDtcXG5cXG5cXHRcXHQkLmVhY2godmlzaWJsZSwgZnVuY3Rpb24oaW5kZXgsIGl0ZW0pIHtcXG5cXHRcXHRcXHRoZWlnaHRzLnB1c2goJChpdGVtKS5oZWlnaHQoKSk7XFxuXFx0XFx0fSk7XFxuXFxuXFx0XFx0bWF4aGVpZ2h0ID0gTWF0aC5tYXguYXBwbHkobnVsbCwgaGVpZ2h0cyk7XFxuXFxuXFx0XFx0dGhpcy5fY29yZS4kc3RhZ2UucGFyZW50KClcXG5cXHRcXHRcXHQuaGVpZ2h0KG1heGhlaWdodClcXG5cXHRcXHRcXHQuYWRkQ2xhc3ModGhpcy5fY29yZS5zZXR0aW5ncy5hdXRvSGVpZ2h0Q2xhc3MpO1xcblxcdH07XFxuXFxuXFx0QXV0b0hlaWdodC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xcblxcdFxcdHZhciBoYW5kbGVyLCBwcm9wZXJ0eTtcXG5cXG5cXHRcXHRmb3IgKGhhbmRsZXIgaW4gdGhpcy5faGFuZGxlcnMpIHtcXG5cXHRcXHRcXHR0aGlzLl9jb3JlLiRlbGVtZW50Lm9mZihoYW5kbGVyLCB0aGlzLl9oYW5kbGVyc1toYW5kbGVyXSk7XFxuXFx0XFx0fVxcblxcdFxcdGZvciAocHJvcGVydHkgaW4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGhpcykpIHtcXG5cXHRcXHRcXHR0eXBlb2YgdGhpc1twcm9wZXJ0eV0gIT0gJ2Z1bmN0aW9uJyAmJiAodGhpc1twcm9wZXJ0eV0gPSBudWxsKTtcXG5cXHRcXHR9XFxuXFx0fTtcXG5cXG5cXHQkLmZuLm93bENhcm91c2VsLkNvbnN0cnVjdG9yLlBsdWdpbnMuQXV0b0hlaWdodCA9IEF1dG9IZWlnaHQ7XFxuXFxufSkod2luZG93LlplcHRvIHx8IF9fd2VicGFja19wcm92aWRlZF93aW5kb3dfZG90X2pRdWVyeSwgd2luZG93LCBkb2N1bWVudCk7XFxuXFxuLyoqXFxuICogVmlkZW8gUGx1Z2luXFxuICogQHZlcnNpb24gMi4xLjBcXG4gKiBAYXV0aG9yIEJhcnRvc3ogV29qY2llY2hvd3NraVxcbiAqIEBhdXRob3IgRGF2aWQgRGV1dHNjaFxcbiAqIEBsaWNlbnNlIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxcbiAqL1xcbjsoZnVuY3Rpb24oJCwgd2luZG93LCBkb2N1bWVudCwgdW5kZWZpbmVkKSB7XFxuXFxuXFx0LyoqXFxuXFx0ICogQ3JlYXRlcyB0aGUgdmlkZW8gcGx1Z2luLlxcblxcdCAqIEBjbGFzcyBUaGUgVmlkZW8gUGx1Z2luXFxuXFx0ICogQHBhcmFtIHtPd2x9IGNhcm91c2VsIC0gVGhlIE93bCBDYXJvdXNlbFxcblxcdCAqL1xcblxcdHZhciBWaWRlbyA9IGZ1bmN0aW9uKGNhcm91c2VsKSB7XFxuXFx0XFx0LyoqXFxuXFx0XFx0ICogUmVmZXJlbmNlIHRvIHRoZSBjb3JlLlxcblxcdFxcdCAqIEBwcm90ZWN0ZWRcXG5cXHRcXHQgKiBAdHlwZSB7T3dsfVxcblxcdFxcdCAqL1xcblxcdFxcdHRoaXMuX2NvcmUgPSBjYXJvdXNlbDtcXG5cXG5cXHRcXHQvKipcXG5cXHRcXHQgKiBDYWNoZSBhbGwgdmlkZW8gVVJMcy5cXG5cXHRcXHQgKiBAcHJvdGVjdGVkXFxuXFx0XFx0ICogQHR5cGUge09iamVjdH1cXG5cXHRcXHQgKi9cXG5cXHRcXHR0aGlzLl92aWRlb3MgPSB7fTtcXG5cXG5cXHRcXHQvKipcXG5cXHRcXHQgKiBDdXJyZW50IHBsYXlpbmcgaXRlbS5cXG5cXHRcXHQgKiBAcHJvdGVjdGVkXFxuXFx0XFx0ICogQHR5cGUge2pRdWVyeX1cXG5cXHRcXHQgKi9cXG5cXHRcXHR0aGlzLl9wbGF5aW5nID0gbnVsbDtcXG5cXG5cXHRcXHQvKipcXG5cXHRcXHQgKiBBbGwgZXZlbnQgaGFuZGxlcnMuXFxuXFx0XFx0ICogQHRvZG8gVGhlIGNsb25lZCBjb250ZW50IHJlbW92YWxlIGlzIHRvbyBsYXRlXFxuXFx0XFx0ICogQHByb3RlY3RlZFxcblxcdFxcdCAqIEB0eXBlIHtPYmplY3R9XFxuXFx0XFx0ICovXFxuXFx0XFx0dGhpcy5faGFuZGxlcnMgPSB7XFxuXFx0XFx0XFx0J2luaXRpYWxpemVkLm93bC5jYXJvdXNlbCc6ICQucHJveHkoZnVuY3Rpb24oZSkge1xcblxcdFxcdFxcdFxcdGlmIChlLm5hbWVzcGFjZSkge1xcblxcdFxcdFxcdFxcdFxcdHRoaXMuX2NvcmUucmVnaXN0ZXIoeyB0eXBlOiAnc3RhdGUnLCBuYW1lOiAncGxheWluZycsIHRhZ3M6IFsgJ2ludGVyYWN0aW5nJyBdIH0pO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9LCB0aGlzKSxcXG5cXHRcXHRcXHQncmVzaXplLm93bC5jYXJvdXNlbCc6ICQucHJveHkoZnVuY3Rpb24oZSkge1xcblxcdFxcdFxcdFxcdGlmIChlLm5hbWVzcGFjZSAmJiB0aGlzLl9jb3JlLnNldHRpbmdzLnZpZGVvICYmIHRoaXMuaXNJbkZ1bGxTY3JlZW4oKSkge1xcblxcdFxcdFxcdFxcdFxcdGUucHJldmVudERlZmF1bHQoKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fSwgdGhpcyksXFxuXFx0XFx0XFx0J3JlZnJlc2hlZC5vd2wuY2Fyb3VzZWwnOiAkLnByb3h5KGZ1bmN0aW9uKGUpIHtcXG5cXHRcXHRcXHRcXHRpZiAoZS5uYW1lc3BhY2UgJiYgdGhpcy5fY29yZS5pcygncmVzaXppbmcnKSkge1xcblxcdFxcdFxcdFxcdFxcdHRoaXMuX2NvcmUuJHN0YWdlLmZpbmQoJy5jbG9uZWQgLm93bC12aWRlby1mcmFtZScpLnJlbW92ZSgpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9LCB0aGlzKSxcXG5cXHRcXHRcXHQnY2hhbmdlZC5vd2wuY2Fyb3VzZWwnOiAkLnByb3h5KGZ1bmN0aW9uKGUpIHtcXG5cXHRcXHRcXHRcXHRpZiAoZS5uYW1lc3BhY2UgJiYgZS5wcm9wZXJ0eS5uYW1lID09PSAncG9zaXRpb24nICYmIHRoaXMuX3BsYXlpbmcpIHtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLnN0b3AoKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fSwgdGhpcyksXFxuXFx0XFx0XFx0J3ByZXBhcmVkLm93bC5jYXJvdXNlbCc6ICQucHJveHkoZnVuY3Rpb24oZSkge1xcblxcdFxcdFxcdFxcdGlmICghZS5uYW1lc3BhY2UpIHtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm47XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdHZhciAkZWxlbWVudCA9ICQoZS5jb250ZW50KS5maW5kKCcub3dsLXZpZGVvJyk7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCRlbGVtZW50Lmxlbmd0aCkge1xcblxcdFxcdFxcdFxcdFxcdCRlbGVtZW50LmNzcygnZGlzcGxheScsICdub25lJyk7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5mZXRjaCgkZWxlbWVudCwgJChlLmNvbnRlbnQpKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fSwgdGhpcylcXG5cXHRcXHR9O1xcblxcblxcdFxcdC8vIHNldCBkZWZhdWx0IG9wdGlvbnNcXG5cXHRcXHR0aGlzLl9jb3JlLm9wdGlvbnMgPSAkLmV4dGVuZCh7fSwgVmlkZW8uRGVmYXVsdHMsIHRoaXMuX2NvcmUub3B0aW9ucyk7XFxuXFxuXFx0XFx0Ly8gcmVnaXN0ZXIgZXZlbnQgaGFuZGxlcnNcXG5cXHRcXHR0aGlzLl9jb3JlLiRlbGVtZW50Lm9uKHRoaXMuX2hhbmRsZXJzKTtcXG5cXG5cXHRcXHR0aGlzLl9jb3JlLiRlbGVtZW50Lm9uKCdjbGljay5vd2wudmlkZW8nLCAnLm93bC12aWRlby1wbGF5LWljb24nLCAkLnByb3h5KGZ1bmN0aW9uKGUpIHtcXG5cXHRcXHRcXHR0aGlzLnBsYXkoZSk7XFxuXFx0XFx0fSwgdGhpcykpO1xcblxcdH07XFxuXFxuXFx0LyoqXFxuXFx0ICogRGVmYXVsdCBvcHRpb25zLlxcblxcdCAqIEBwdWJsaWNcXG5cXHQgKi9cXG5cXHRWaWRlby5EZWZhdWx0cyA9IHtcXG5cXHRcXHR2aWRlbzogZmFsc2UsXFxuXFx0XFx0dmlkZW9IZWlnaHQ6IGZhbHNlLFxcblxcdFxcdHZpZGVvV2lkdGg6IGZhbHNlXFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBHZXRzIHRoZSB2aWRlbyBJRCBhbmQgdGhlIHR5cGUgKFlvdVR1YmUvVmltZW8vdnphYXIgb25seSkuXFxuXFx0ICogQHByb3RlY3RlZFxcblxcdCAqIEBwYXJhbSB7alF1ZXJ5fSB0YXJnZXQgLSBUaGUgdGFyZ2V0IGNvbnRhaW5pbmcgdGhlIHZpZGVvIGRhdGEuXFxuXFx0ICogQHBhcmFtIHtqUXVlcnl9IGl0ZW0gLSBUaGUgaXRlbSBjb250YWluaW5nIHRoZSB2aWRlby5cXG5cXHQgKi9cXG5cXHRWaWRlby5wcm90b3R5cGUuZmV0Y2ggPSBmdW5jdGlvbih0YXJnZXQsIGl0ZW0pIHtcXG5cXHRcXHRcXHR2YXIgdHlwZSA9IChmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHRcXHRcXHRpZiAodGFyZ2V0LmF0dHIoJ2RhdGEtdmltZW8taWQnKSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiAndmltZW8nO1xcblxcdFxcdFxcdFxcdFxcdH0gZWxzZSBpZiAodGFyZ2V0LmF0dHIoJ2RhdGEtdnphYXItaWQnKSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiAndnphYXInXFxuXFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gJ3lvdXR1YmUnO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9KSgpLFxcblxcdFxcdFxcdFxcdGlkID0gdGFyZ2V0LmF0dHIoJ2RhdGEtdmltZW8taWQnKSB8fCB0YXJnZXQuYXR0cignZGF0YS15b3V0dWJlLWlkJykgfHwgdGFyZ2V0LmF0dHIoJ2RhdGEtdnphYXItaWQnKSxcXG5cXHRcXHRcXHRcXHR3aWR0aCA9IHRhcmdldC5hdHRyKCdkYXRhLXdpZHRoJykgfHwgdGhpcy5fY29yZS5zZXR0aW5ncy52aWRlb1dpZHRoLFxcblxcdFxcdFxcdFxcdGhlaWdodCA9IHRhcmdldC5hdHRyKCdkYXRhLWhlaWdodCcpIHx8IHRoaXMuX2NvcmUuc2V0dGluZ3MudmlkZW9IZWlnaHQsXFxuXFx0XFx0XFx0XFx0dXJsID0gdGFyZ2V0LmF0dHIoJ2hyZWYnKTtcXG5cXG5cXHRcXHRpZiAodXJsKSB7XFxuXFxuXFx0XFx0XFx0LypcXG5cXHRcXHRcXHRcXHRcXHRQYXJzZXMgdGhlIGlkJ3Mgb3V0IG9mIHRoZSBmb2xsb3dpbmcgdXJscyAoYW5kIHByb2JhYmx5IG1vcmUpOlxcblxcdFxcdFxcdFxcdFxcdGh0dHBzOi8vd3d3LnlvdXR1YmUuY29tL3dhdGNoP3Y9OmlkXFxuXFx0XFx0XFx0XFx0XFx0aHR0cHM6Ly95b3V0dS5iZS86aWRcXG5cXHRcXHRcXHRcXHRcXHRodHRwczovL3ZpbWVvLmNvbS86aWRcXG5cXHRcXHRcXHRcXHRcXHRodHRwczovL3ZpbWVvLmNvbS9jaGFubmVscy86Y2hhbm5lbC86aWRcXG5cXHRcXHRcXHRcXHRcXHRodHRwczovL3ZpbWVvLmNvbS9ncm91cHMvOmdyb3VwL3ZpZGVvcy86aWRcXG5cXHRcXHRcXHRcXHRcXHRodHRwczovL2FwcC52emFhci5jb20vdmlkZW9zLzppZFxcblxcblxcdFxcdFxcdFxcdFxcdFZpc3VhbCBleGFtcGxlOiBodHRwczovL3JlZ2V4cGVyLmNvbS8jKGh0dHAlM0ElN0NodHRwcyUzQSU3QyklNUMlMkYlNUMlMkYocGxheWVyLiU3Q3d3dy4lN0NhcHAuKSUzRih2aW1lbyU1Qy5jb20lN0N5b3V0dShiZSU1Qy5jb20lN0MlNUMuYmUlN0NiZSU1Qy5nb29nbGVhcGlzJTVDLmNvbSklN0N2emFhciU1Qy5jb20pJTVDJTJGKHZpZGVvJTVDJTJGJTdDdmlkZW9zJTVDJTJGJTdDZW1iZWQlNUMlMkYlN0NjaGFubmVscyU1QyUyRi4lMkIlNUMlMkYlN0Nncm91cHMlNUMlMkYuJTJCJTVDJTJGJTdDd2F0Y2glNUMlM0Z2JTNEJTdDdiU1QyUyRiklM0YoJTVCQS1aYS16MC05Ll8lMjUtJTVEKikoJTVDJTI2JTVDUyUyQiklM0ZcXG5cXHRcXHRcXHQqL1xcblxcblxcdFxcdFxcdGlkID0gdXJsLm1hdGNoKC8oaHR0cDp8aHR0cHM6fClcXFxcL1xcXFwvKHBsYXllci58d3d3LnxhcHAuKT8odmltZW9cXFxcLmNvbXx5b3V0dShiZVxcXFwuY29tfFxcXFwuYmV8YmVcXFxcLmdvb2dsZWFwaXNcXFxcLmNvbSl8dnphYXJcXFxcLmNvbSlcXFxcLyh2aWRlb1xcXFwvfHZpZGVvc1xcXFwvfGVtYmVkXFxcXC98Y2hhbm5lbHNcXFxcLy4rXFxcXC98Z3JvdXBzXFxcXC8uK1xcXFwvfHdhdGNoXFxcXD92PXx2XFxcXC8pPyhbQS1aYS16MC05Ll8lLV0qKShcXFxcJlxcXFxTKyk/Lyk7XFxuXFxuXFx0XFx0XFx0aWYgKGlkWzNdLmluZGV4T2YoJ3lvdXR1JykgPiAtMSkge1xcblxcdFxcdFxcdFxcdHR5cGUgPSAneW91dHViZSc7XFxuXFx0XFx0XFx0fSBlbHNlIGlmIChpZFszXS5pbmRleE9mKCd2aW1lbycpID4gLTEpIHtcXG5cXHRcXHRcXHRcXHR0eXBlID0gJ3ZpbWVvJztcXG5cXHRcXHRcXHR9IGVsc2UgaWYgKGlkWzNdLmluZGV4T2YoJ3Z6YWFyJykgPiAtMSkge1xcblxcdFxcdFxcdFxcdHR5cGUgPSAndnphYXInO1xcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0dGhyb3cgbmV3IEVycm9yKCdWaWRlbyBVUkwgbm90IHN1cHBvcnRlZC4nKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0aWQgPSBpZFs2XTtcXG5cXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdHRocm93IG5ldyBFcnJvcignTWlzc2luZyB2aWRlbyBVUkwuJyk7XFxuXFx0XFx0fVxcblxcblxcdFxcdHRoaXMuX3ZpZGVvc1t1cmxdID0ge1xcblxcdFxcdFxcdHR5cGU6IHR5cGUsXFxuXFx0XFx0XFx0aWQ6IGlkLFxcblxcdFxcdFxcdHdpZHRoOiB3aWR0aCxcXG5cXHRcXHRcXHRoZWlnaHQ6IGhlaWdodFxcblxcdFxcdH07XFxuXFxuXFx0XFx0aXRlbS5hdHRyKCdkYXRhLXZpZGVvJywgdXJsKTtcXG5cXG5cXHRcXHR0aGlzLnRodW1ibmFpbCh0YXJnZXQsIHRoaXMuX3ZpZGVvc1t1cmxdKTtcXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIENyZWF0ZXMgdmlkZW8gdGh1bWJuYWlsLlxcblxcdCAqIEBwcm90ZWN0ZWRcXG5cXHQgKiBAcGFyYW0ge2pRdWVyeX0gdGFyZ2V0IC0gVGhlIHRhcmdldCBjb250YWluaW5nIHRoZSB2aWRlbyBkYXRhLlxcblxcdCAqIEBwYXJhbSB7T2JqZWN0fSBpbmZvIC0gVGhlIHZpZGVvIGluZm8gb2JqZWN0LlxcblxcdCAqIEBzZWUgYGZldGNoYFxcblxcdCAqL1xcblxcdFZpZGVvLnByb3RvdHlwZS50aHVtYm5haWwgPSBmdW5jdGlvbih0YXJnZXQsIHZpZGVvKSB7XFxuXFx0XFx0dmFyIHRuTGluayxcXG5cXHRcXHRcXHRpY29uLFxcblxcdFxcdFxcdHBhdGgsXFxuXFx0XFx0XFx0ZGltZW5zaW9ucyA9IHZpZGVvLndpZHRoICYmIHZpZGVvLmhlaWdodCA/ICdzdHlsZT1cXFwid2lkdGg6JyArIHZpZGVvLndpZHRoICsgJ3B4O2hlaWdodDonICsgdmlkZW8uaGVpZ2h0ICsgJ3B4O1xcXCInIDogJycsXFxuXFx0XFx0XFx0Y3VzdG9tVG4gPSB0YXJnZXQuZmluZCgnaW1nJyksXFxuXFx0XFx0XFx0c3JjVHlwZSA9ICdzcmMnLFxcblxcdFxcdFxcdGxhenlDbGFzcyA9ICcnLFxcblxcdFxcdFxcdHNldHRpbmdzID0gdGhpcy5fY29yZS5zZXR0aW5ncyxcXG5cXHRcXHRcXHRjcmVhdGUgPSBmdW5jdGlvbihwYXRoKSB7XFxuXFx0XFx0XFx0XFx0aWNvbiA9ICc8ZGl2IGNsYXNzPVxcXCJvd2wtdmlkZW8tcGxheS1pY29uXFxcIj48L2Rpdj4nO1xcblxcblxcdFxcdFxcdFxcdGlmIChzZXR0aW5ncy5sYXp5TG9hZCkge1xcblxcdFxcdFxcdFxcdFxcdHRuTGluayA9ICc8ZGl2IGNsYXNzPVxcXCJvd2wtdmlkZW8tdG4gJyArIGxhenlDbGFzcyArICdcXFwiICcgKyBzcmNUeXBlICsgJz1cXFwiJyArIHBhdGggKyAnXFxcIj48L2Rpdj4nO1xcblxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0dG5MaW5rID0gJzxkaXYgY2xhc3M9XFxcIm93bC12aWRlby10blxcXCIgc3R5bGU9XFxcIm9wYWNpdHk6MTtiYWNrZ3JvdW5kLWltYWdlOnVybCgnICsgcGF0aCArICcpXFxcIj48L2Rpdj4nO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR0YXJnZXQuYWZ0ZXIodG5MaW5rKTtcXG5cXHRcXHRcXHRcXHR0YXJnZXQuYWZ0ZXIoaWNvbik7XFxuXFx0XFx0XFx0fTtcXG5cXG5cXHRcXHQvLyB3cmFwIHZpZGVvIGNvbnRlbnQgaW50byBvd2wtdmlkZW8td3JhcHBlciBkaXZcXG5cXHRcXHR0YXJnZXQud3JhcCgnPGRpdiBjbGFzcz1cXFwib3dsLXZpZGVvLXdyYXBwZXJcXFwiJyArIGRpbWVuc2lvbnMgKyAnPjwvZGl2PicpO1xcblxcblxcdFxcdGlmICh0aGlzLl9jb3JlLnNldHRpbmdzLmxhenlMb2FkKSB7XFxuXFx0XFx0XFx0c3JjVHlwZSA9ICdkYXRhLXNyYyc7XFxuXFx0XFx0XFx0bGF6eUNsYXNzID0gJ293bC1sYXp5JztcXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gY3VzdG9tIHRodW1ibmFpbFxcblxcdFxcdGlmIChjdXN0b21Ubi5sZW5ndGgpIHtcXG5cXHRcXHRcXHRjcmVhdGUoY3VzdG9tVG4uYXR0cihzcmNUeXBlKSk7XFxuXFx0XFx0XFx0Y3VzdG9tVG4ucmVtb3ZlKCk7XFxuXFx0XFx0XFx0cmV0dXJuIGZhbHNlO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRpZiAodmlkZW8udHlwZSA9PT0gJ3lvdXR1YmUnKSB7XFxuXFx0XFx0XFx0cGF0aCA9IFxcXCIvL2ltZy55b3V0dWJlLmNvbS92aS9cXFwiICsgdmlkZW8uaWQgKyBcXFwiL2hxZGVmYXVsdC5qcGdcXFwiO1xcblxcdFxcdFxcdGNyZWF0ZShwYXRoKTtcXG5cXHRcXHR9IGVsc2UgaWYgKHZpZGVvLnR5cGUgPT09ICd2aW1lbycpIHtcXG5cXHRcXHRcXHQkLmFqYXgoe1xcblxcdFxcdFxcdFxcdHR5cGU6ICdHRVQnLFxcblxcdFxcdFxcdFxcdHVybDogJy8vdmltZW8uY29tL2FwaS92Mi92aWRlby8nICsgdmlkZW8uaWQgKyAnLmpzb24nLFxcblxcdFxcdFxcdFxcdGpzb25wOiAnY2FsbGJhY2snLFxcblxcdFxcdFxcdFxcdGRhdGFUeXBlOiAnanNvbnAnLFxcblxcdFxcdFxcdFxcdHN1Y2Nlc3M6IGZ1bmN0aW9uKGRhdGEpIHtcXG5cXHRcXHRcXHRcXHRcXHRwYXRoID0gZGF0YVswXS50aHVtYm5haWxfbGFyZ2U7XFxuXFx0XFx0XFx0XFx0XFx0Y3JlYXRlKHBhdGgpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9KTtcXG5cXHRcXHR9IGVsc2UgaWYgKHZpZGVvLnR5cGUgPT09ICd2emFhcicpIHtcXG5cXHRcXHRcXHQkLmFqYXgoe1xcblxcdFxcdFxcdFxcdHR5cGU6ICdHRVQnLFxcblxcdFxcdFxcdFxcdHVybDogJy8vdnphYXIuY29tL2FwaS92aWRlb3MvJyArIHZpZGVvLmlkICsgJy5qc29uJyxcXG5cXHRcXHRcXHRcXHRqc29ucDogJ2NhbGxiYWNrJyxcXG5cXHRcXHRcXHRcXHRkYXRhVHlwZTogJ2pzb25wJyxcXG5cXHRcXHRcXHRcXHRzdWNjZXNzOiBmdW5jdGlvbihkYXRhKSB7XFxuXFx0XFx0XFx0XFx0XFx0cGF0aCA9IGRhdGEuZnJhbWVncmFiX3VybDtcXG5cXHRcXHRcXHRcXHRcXHRjcmVhdGUocGF0aCk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH0pO1xcblxcdFxcdH1cXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIFN0b3BzIHRoZSBjdXJyZW50IHZpZGVvLlxcblxcdCAqIEBwdWJsaWNcXG5cXHQgKi9cXG5cXHRWaWRlby5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uKCkge1xcblxcdFxcdHRoaXMuX2NvcmUudHJpZ2dlcignc3RvcCcsIG51bGwsICd2aWRlbycpO1xcblxcdFxcdHRoaXMuX3BsYXlpbmcuZmluZCgnLm93bC12aWRlby1mcmFtZScpLnJlbW92ZSgpO1xcblxcdFxcdHRoaXMuX3BsYXlpbmcucmVtb3ZlQ2xhc3MoJ293bC12aWRlby1wbGF5aW5nJyk7XFxuXFx0XFx0dGhpcy5fcGxheWluZyA9IG51bGw7XFxuXFx0XFx0dGhpcy5fY29yZS5sZWF2ZSgncGxheWluZycpO1xcblxcdFxcdHRoaXMuX2NvcmUudHJpZ2dlcignc3RvcHBlZCcsIG51bGwsICd2aWRlbycpO1xcblxcdH07XFxuXFxuXFx0LyoqXFxuXFx0ICogU3RhcnRzIHRoZSBjdXJyZW50IHZpZGVvLlxcblxcdCAqIEBwdWJsaWNcXG5cXHQgKiBAcGFyYW0ge0V2ZW50fSBldmVudCAtIFRoZSBldmVudCBhcmd1bWVudHMuXFxuXFx0ICovXFxuXFx0VmlkZW8ucHJvdG90eXBlLnBsYXkgPSBmdW5jdGlvbihldmVudCkge1xcblxcdFxcdHZhciB0YXJnZXQgPSAkKGV2ZW50LnRhcmdldCksXFxuXFx0XFx0XFx0aXRlbSA9IHRhcmdldC5jbG9zZXN0KCcuJyArIHRoaXMuX2NvcmUuc2V0dGluZ3MuaXRlbUNsYXNzKSxcXG5cXHRcXHRcXHR2aWRlbyA9IHRoaXMuX3ZpZGVvc1tpdGVtLmF0dHIoJ2RhdGEtdmlkZW8nKV0sXFxuXFx0XFx0XFx0d2lkdGggPSB2aWRlby53aWR0aCB8fCAnMTAwJScsXFxuXFx0XFx0XFx0aGVpZ2h0ID0gdmlkZW8uaGVpZ2h0IHx8IHRoaXMuX2NvcmUuJHN0YWdlLmhlaWdodCgpLFxcblxcdFxcdFxcdGh0bWw7XFxuXFxuXFx0XFx0aWYgKHRoaXMuX3BsYXlpbmcpIHtcXG5cXHRcXHRcXHRyZXR1cm47XFxuXFx0XFx0fVxcblxcblxcdFxcdHRoaXMuX2NvcmUuZW50ZXIoJ3BsYXlpbmcnKTtcXG5cXHRcXHR0aGlzLl9jb3JlLnRyaWdnZXIoJ3BsYXknLCBudWxsLCAndmlkZW8nKTtcXG5cXG5cXHRcXHRpdGVtID0gdGhpcy5fY29yZS5pdGVtcyh0aGlzLl9jb3JlLnJlbGF0aXZlKGl0ZW0uaW5kZXgoKSkpO1xcblxcblxcdFxcdHRoaXMuX2NvcmUucmVzZXQoaXRlbS5pbmRleCgpKTtcXG5cXG5cXHRcXHRpZiAodmlkZW8udHlwZSA9PT0gJ3lvdXR1YmUnKSB7XFxuXFx0XFx0XFx0aHRtbCA9ICc8aWZyYW1lIHdpZHRoPVxcXCInICsgd2lkdGggKyAnXFxcIiBoZWlnaHQ9XFxcIicgKyBoZWlnaHQgKyAnXFxcIiBzcmM9XFxcIi8vd3d3LnlvdXR1YmUuY29tL2VtYmVkLycgK1xcblxcdFxcdFxcdFxcdHZpZGVvLmlkICsgJz9hdXRvcGxheT0xJnY9JyArIHZpZGVvLmlkICsgJ1xcXCIgZnJhbWVib3JkZXI9XFxcIjBcXFwiIGFsbG93ZnVsbHNjcmVlbj48L2lmcmFtZT4nO1xcblxcdFxcdH0gZWxzZSBpZiAodmlkZW8udHlwZSA9PT0gJ3ZpbWVvJykge1xcblxcdFxcdFxcdGh0bWwgPSAnPGlmcmFtZSBzcmM9XFxcIi8vcGxheWVyLnZpbWVvLmNvbS92aWRlby8nICsgdmlkZW8uaWQgK1xcblxcdFxcdFxcdFxcdCc/YXV0b3BsYXk9MVxcXCIgd2lkdGg9XFxcIicgKyB3aWR0aCArICdcXFwiIGhlaWdodD1cXFwiJyArIGhlaWdodCArXFxuXFx0XFx0XFx0XFx0J1xcXCIgZnJhbWVib3JkZXI9XFxcIjBcXFwiIHdlYmtpdGFsbG93ZnVsbHNjcmVlbiBtb3phbGxvd2Z1bGxzY3JlZW4gYWxsb3dmdWxsc2NyZWVuPjwvaWZyYW1lPic7XFxuXFx0XFx0fSBlbHNlIGlmICh2aWRlby50eXBlID09PSAndnphYXInKSB7XFxuXFx0XFx0XFx0aHRtbCA9ICc8aWZyYW1lIGZyYW1lYm9yZGVyPVxcXCIwXFxcIicgKyAnaGVpZ2h0PVxcXCInICsgaGVpZ2h0ICsgJ1xcXCInICsgJ3dpZHRoPVxcXCInICsgd2lkdGggK1xcblxcdFxcdFxcdFxcdCdcXFwiIGFsbG93ZnVsbHNjcmVlbiBtb3phbGxvd2Z1bGxzY3JlZW4gd2Via2l0QWxsb3dGdWxsU2NyZWVuICcgK1xcblxcdFxcdFxcdFxcdCdzcmM9XFxcIi8vdmlldy52emFhci5jb20vJyArIHZpZGVvLmlkICsgJy9wbGF5ZXI/YXV0b3BsYXk9dHJ1ZVxcXCI+PC9pZnJhbWU+JztcXG5cXHRcXHR9XFxuXFxuXFx0XFx0JCgnPGRpdiBjbGFzcz1cXFwib3dsLXZpZGVvLWZyYW1lXFxcIj4nICsgaHRtbCArICc8L2Rpdj4nKS5pbnNlcnRBZnRlcihpdGVtLmZpbmQoJy5vd2wtdmlkZW8nKSk7XFxuXFxuXFx0XFx0dGhpcy5fcGxheWluZyA9IGl0ZW0uYWRkQ2xhc3MoJ293bC12aWRlby1wbGF5aW5nJyk7XFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBDaGVja3Mgd2hldGhlciBhbiB2aWRlbyBpcyBjdXJyZW50bHkgaW4gZnVsbCBzY3JlZW4gbW9kZSBvciBub3QuXFxuXFx0ICogQHRvZG8gQmFkIHN0eWxlIGJlY2F1c2UgbG9va3MgbGlrZSBhIHJlYWRvbmx5IG1ldGhvZCBidXQgY2hhbmdlcyBtZW1iZXJzLlxcblxcdCAqIEBwcm90ZWN0ZWRcXG5cXHQgKiBAcmV0dXJucyB7Qm9vbGVhbn1cXG5cXHQgKi9cXG5cXHRWaWRlby5wcm90b3R5cGUuaXNJbkZ1bGxTY3JlZW4gPSBmdW5jdGlvbigpIHtcXG5cXHRcXHR2YXIgZWxlbWVudCA9IGRvY3VtZW50LmZ1bGxzY3JlZW5FbGVtZW50IHx8IGRvY3VtZW50Lm1vekZ1bGxTY3JlZW5FbGVtZW50IHx8XFxuXFx0XFx0XFx0XFx0ZG9jdW1lbnQud2Via2l0RnVsbHNjcmVlbkVsZW1lbnQ7XFxuXFxuXFx0XFx0cmV0dXJuIGVsZW1lbnQgJiYgJChlbGVtZW50KS5wYXJlbnQoKS5oYXNDbGFzcygnb3dsLXZpZGVvLWZyYW1lJyk7XFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBEZXN0cm95cyB0aGUgcGx1Z2luLlxcblxcdCAqL1xcblxcdFZpZGVvLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XFxuXFx0XFx0dmFyIGhhbmRsZXIsIHByb3BlcnR5O1xcblxcblxcdFxcdHRoaXMuX2NvcmUuJGVsZW1lbnQub2ZmKCdjbGljay5vd2wudmlkZW8nKTtcXG5cXG5cXHRcXHRmb3IgKGhhbmRsZXIgaW4gdGhpcy5faGFuZGxlcnMpIHtcXG5cXHRcXHRcXHR0aGlzLl9jb3JlLiRlbGVtZW50Lm9mZihoYW5kbGVyLCB0aGlzLl9oYW5kbGVyc1toYW5kbGVyXSk7XFxuXFx0XFx0fVxcblxcdFxcdGZvciAocHJvcGVydHkgaW4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGhpcykpIHtcXG5cXHRcXHRcXHR0eXBlb2YgdGhpc1twcm9wZXJ0eV0gIT0gJ2Z1bmN0aW9uJyAmJiAodGhpc1twcm9wZXJ0eV0gPSBudWxsKTtcXG5cXHRcXHR9XFxuXFx0fTtcXG5cXG5cXHQkLmZuLm93bENhcm91c2VsLkNvbnN0cnVjdG9yLlBsdWdpbnMuVmlkZW8gPSBWaWRlbztcXG5cXG59KSh3aW5kb3cuWmVwdG8gfHwgX193ZWJwYWNrX3Byb3ZpZGVkX3dpbmRvd19kb3RfalF1ZXJ5LCB3aW5kb3csIGRvY3VtZW50KTtcXG5cXG4vKipcXG4gKiBBbmltYXRlIFBsdWdpblxcbiAqIEB2ZXJzaW9uIDIuMS4wXFxuICogQGF1dGhvciBCYXJ0b3N6IFdvamNpZWNob3dza2lcXG4gKiBAYXV0aG9yIERhdmlkIERldXRzY2hcXG4gKiBAbGljZW5zZSBUaGUgTUlUIExpY2Vuc2UgKE1JVClcXG4gKi9cXG47KGZ1bmN0aW9uKCQsIHdpbmRvdywgZG9jdW1lbnQsIHVuZGVmaW5lZCkge1xcblxcblxcdC8qKlxcblxcdCAqIENyZWF0ZXMgdGhlIGFuaW1hdGUgcGx1Z2luLlxcblxcdCAqIEBjbGFzcyBUaGUgTmF2aWdhdGlvbiBQbHVnaW5cXG5cXHQgKiBAcGFyYW0ge093bH0gc2NvcGUgLSBUaGUgT3dsIENhcm91c2VsXFxuXFx0ICovXFxuXFx0dmFyIEFuaW1hdGUgPSBmdW5jdGlvbihzY29wZSkge1xcblxcdFxcdHRoaXMuY29yZSA9IHNjb3BlO1xcblxcdFxcdHRoaXMuY29yZS5vcHRpb25zID0gJC5leHRlbmQoe30sIEFuaW1hdGUuRGVmYXVsdHMsIHRoaXMuY29yZS5vcHRpb25zKTtcXG5cXHRcXHR0aGlzLnN3YXBwaW5nID0gdHJ1ZTtcXG5cXHRcXHR0aGlzLnByZXZpb3VzID0gdW5kZWZpbmVkO1xcblxcdFxcdHRoaXMubmV4dCA9IHVuZGVmaW5lZDtcXG5cXG5cXHRcXHR0aGlzLmhhbmRsZXJzID0ge1xcblxcdFxcdFxcdCdjaGFuZ2Uub3dsLmNhcm91c2VsJzogJC5wcm94eShmdW5jdGlvbihlKSB7XFxuXFx0XFx0XFx0XFx0aWYgKGUubmFtZXNwYWNlICYmIGUucHJvcGVydHkubmFtZSA9PSAncG9zaXRpb24nKSB7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5wcmV2aW91cyA9IHRoaXMuY29yZS5jdXJyZW50KCk7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5uZXh0ID0gZS5wcm9wZXJ0eS52YWx1ZTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fSwgdGhpcyksXFxuXFx0XFx0XFx0J2RyYWcub3dsLmNhcm91c2VsIGRyYWdnZWQub3dsLmNhcm91c2VsIHRyYW5zbGF0ZWQub3dsLmNhcm91c2VsJzogJC5wcm94eShmdW5jdGlvbihlKSB7XFxuXFx0XFx0XFx0XFx0aWYgKGUubmFtZXNwYWNlKSB7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5zd2FwcGluZyA9IGUudHlwZSA9PSAndHJhbnNsYXRlZCc7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH0sIHRoaXMpLFxcblxcdFxcdFxcdCd0cmFuc2xhdGUub3dsLmNhcm91c2VsJzogJC5wcm94eShmdW5jdGlvbihlKSB7XFxuXFx0XFx0XFx0XFx0aWYgKGUubmFtZXNwYWNlICYmIHRoaXMuc3dhcHBpbmcgJiYgKHRoaXMuY29yZS5vcHRpb25zLmFuaW1hdGVPdXQgfHwgdGhpcy5jb3JlLm9wdGlvbnMuYW5pbWF0ZUluKSkge1xcblxcdFxcdFxcdFxcdFxcdHRoaXMuc3dhcCgpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9LCB0aGlzKVxcblxcdFxcdH07XFxuXFxuXFx0XFx0dGhpcy5jb3JlLiRlbGVtZW50Lm9uKHRoaXMuaGFuZGxlcnMpO1xcblxcdH07XFxuXFxuXFx0LyoqXFxuXFx0ICogRGVmYXVsdCBvcHRpb25zLlxcblxcdCAqIEBwdWJsaWNcXG5cXHQgKi9cXG5cXHRBbmltYXRlLkRlZmF1bHRzID0ge1xcblxcdFxcdGFuaW1hdGVPdXQ6IGZhbHNlLFxcblxcdFxcdGFuaW1hdGVJbjogZmFsc2VcXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIFRvZ2dsZXMgdGhlIGFuaW1hdGlvbiBjbGFzc2VzIHdoZW5ldmVyIGFuIHRyYW5zbGF0aW9ucyBzdGFydHMuXFxuXFx0ICogQHByb3RlY3RlZFxcblxcdCAqIEByZXR1cm5zIHtCb29sZWFufHVuZGVmaW5lZH1cXG5cXHQgKi9cXG5cXHRBbmltYXRlLnByb3RvdHlwZS5zd2FwID0gZnVuY3Rpb24oKSB7XFxuXFxuXFx0XFx0aWYgKHRoaXMuY29yZS5zZXR0aW5ncy5pdGVtcyAhPT0gMSkge1xcblxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0aWYgKCEkLnN1cHBvcnQuYW5pbWF0aW9uIHx8ICEkLnN1cHBvcnQudHJhbnNpdGlvbikge1xcblxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0dGhpcy5jb3JlLnNwZWVkKDApO1xcblxcblxcdFxcdHZhciBsZWZ0LFxcblxcdFxcdFxcdGNsZWFyID0gJC5wcm94eSh0aGlzLmNsZWFyLCB0aGlzKSxcXG5cXHRcXHRcXHRwcmV2aW91cyA9IHRoaXMuY29yZS4kc3RhZ2UuY2hpbGRyZW4oKS5lcSh0aGlzLnByZXZpb3VzKSxcXG5cXHRcXHRcXHRuZXh0ID0gdGhpcy5jb3JlLiRzdGFnZS5jaGlsZHJlbigpLmVxKHRoaXMubmV4dCksXFxuXFx0XFx0XFx0aW5jb21pbmcgPSB0aGlzLmNvcmUuc2V0dGluZ3MuYW5pbWF0ZUluLFxcblxcdFxcdFxcdG91dGdvaW5nID0gdGhpcy5jb3JlLnNldHRpbmdzLmFuaW1hdGVPdXQ7XFxuXFxuXFx0XFx0aWYgKHRoaXMuY29yZS5jdXJyZW50KCkgPT09IHRoaXMucHJldmlvdXMpIHtcXG5cXHRcXHRcXHRyZXR1cm47XFxuXFx0XFx0fVxcblxcblxcdFxcdGlmIChvdXRnb2luZykge1xcblxcdFxcdFxcdGxlZnQgPSB0aGlzLmNvcmUuY29vcmRpbmF0ZXModGhpcy5wcmV2aW91cykgLSB0aGlzLmNvcmUuY29vcmRpbmF0ZXModGhpcy5uZXh0KTtcXG5cXHRcXHRcXHRwcmV2aW91cy5vbmUoJC5zdXBwb3J0LmFuaW1hdGlvbi5lbmQsIGNsZWFyKVxcblxcdFxcdFxcdFxcdC5jc3MoIHsgJ2xlZnQnOiBsZWZ0ICsgJ3B4JyB9IClcXG5cXHRcXHRcXHRcXHQuYWRkQ2xhc3MoJ2FuaW1hdGVkIG93bC1hbmltYXRlZC1vdXQnKVxcblxcdFxcdFxcdFxcdC5hZGRDbGFzcyhvdXRnb2luZyk7XFxuXFx0XFx0fVxcblxcblxcdFxcdGlmIChpbmNvbWluZykge1xcblxcdFxcdFxcdG5leHQub25lKCQuc3VwcG9ydC5hbmltYXRpb24uZW5kLCBjbGVhcilcXG5cXHRcXHRcXHRcXHQuYWRkQ2xhc3MoJ2FuaW1hdGVkIG93bC1hbmltYXRlZC1pbicpXFxuXFx0XFx0XFx0XFx0LmFkZENsYXNzKGluY29taW5nKTtcXG5cXHRcXHR9XFxuXFx0fTtcXG5cXG5cXHRBbmltYXRlLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uKGUpIHtcXG5cXHRcXHQkKGUudGFyZ2V0KS5jc3MoIHsgJ2xlZnQnOiAnJyB9IClcXG5cXHRcXHRcXHQucmVtb3ZlQ2xhc3MoJ2FuaW1hdGVkIG93bC1hbmltYXRlZC1vdXQgb3dsLWFuaW1hdGVkLWluJylcXG5cXHRcXHRcXHQucmVtb3ZlQ2xhc3ModGhpcy5jb3JlLnNldHRpbmdzLmFuaW1hdGVJbilcXG5cXHRcXHRcXHQucmVtb3ZlQ2xhc3ModGhpcy5jb3JlLnNldHRpbmdzLmFuaW1hdGVPdXQpO1xcblxcdFxcdHRoaXMuY29yZS5vblRyYW5zaXRpb25FbmQoKTtcXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIERlc3Ryb3lzIHRoZSBwbHVnaW4uXFxuXFx0ICogQHB1YmxpY1xcblxcdCAqL1xcblxcdEFuaW1hdGUucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcXG5cXHRcXHR2YXIgaGFuZGxlciwgcHJvcGVydHk7XFxuXFxuXFx0XFx0Zm9yIChoYW5kbGVyIGluIHRoaXMuaGFuZGxlcnMpIHtcXG5cXHRcXHRcXHR0aGlzLmNvcmUuJGVsZW1lbnQub2ZmKGhhbmRsZXIsIHRoaXMuaGFuZGxlcnNbaGFuZGxlcl0pO1xcblxcdFxcdH1cXG5cXHRcXHRmb3IgKHByb3BlcnR5IGluIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRoaXMpKSB7XFxuXFx0XFx0XFx0dHlwZW9mIHRoaXNbcHJvcGVydHldICE9ICdmdW5jdGlvbicgJiYgKHRoaXNbcHJvcGVydHldID0gbnVsbCk7XFxuXFx0XFx0fVxcblxcdH07XFxuXFxuXFx0JC5mbi5vd2xDYXJvdXNlbC5Db25zdHJ1Y3Rvci5QbHVnaW5zLkFuaW1hdGUgPSBBbmltYXRlO1xcblxcbn0pKHdpbmRvdy5aZXB0byB8fCBfX3dlYnBhY2tfcHJvdmlkZWRfd2luZG93X2RvdF9qUXVlcnksIHdpbmRvdywgZG9jdW1lbnQpO1xcblxcbi8qKlxcbiAqIEF1dG9wbGF5IFBsdWdpblxcbiAqIEB2ZXJzaW9uIDIuMS4wXFxuICogQGF1dGhvciBCYXJ0b3N6IFdvamNpZWNob3dza2lcXG4gKiBAYXV0aG9yIEFydHVzIEtvbGFub3dza2lcXG4gKiBAYXV0aG9yIERhdmlkIERldXRzY2hcXG4gKiBAbGljZW5zZSBUaGUgTUlUIExpY2Vuc2UgKE1JVClcXG4gKi9cXG47KGZ1bmN0aW9uKCQsIHdpbmRvdywgZG9jdW1lbnQsIHVuZGVmaW5lZCkge1xcblxcblxcdC8qKlxcblxcdCAqIENyZWF0ZXMgdGhlIGF1dG9wbGF5IHBsdWdpbi5cXG5cXHQgKiBAY2xhc3MgVGhlIEF1dG9wbGF5IFBsdWdpblxcblxcdCAqIEBwYXJhbSB7T3dsfSBzY29wZSAtIFRoZSBPd2wgQ2Fyb3VzZWxcXG5cXHQgKi9cXG5cXHR2YXIgQXV0b3BsYXkgPSBmdW5jdGlvbihjYXJvdXNlbCkge1xcblxcdFxcdC8qKlxcblxcdFxcdCAqIFJlZmVyZW5jZSB0byB0aGUgY29yZS5cXG5cXHRcXHQgKiBAcHJvdGVjdGVkXFxuXFx0XFx0ICogQHR5cGUge093bH1cXG5cXHRcXHQgKi9cXG5cXHRcXHR0aGlzLl9jb3JlID0gY2Fyb3VzZWw7XFxuXFxuXFx0XFx0LyoqXFxuXFx0XFx0ICogVGhlIGF1dG9wbGF5IHRpbWVvdXQuXFxuXFx0XFx0ICogQHR5cGUge1RpbWVvdXR9XFxuXFx0XFx0ICovXFxuXFx0XFx0dGhpcy5fdGltZW91dCA9IG51bGw7XFxuXFxuXFx0XFx0LyoqXFxuXFx0XFx0ICogSW5kaWNhdGVzIHdoZW5ldmVyIHRoZSBhdXRvcGxheSBpcyBwYXVzZWQuXFxuXFx0XFx0ICogQHR5cGUge0Jvb2xlYW59XFxuXFx0XFx0ICovXFxuXFx0XFx0dGhpcy5fcGF1c2VkID0gZmFsc2U7XFxuXFxuXFx0XFx0LyoqXFxuXFx0XFx0ICogQWxsIGV2ZW50IGhhbmRsZXJzLlxcblxcdFxcdCAqIEBwcm90ZWN0ZWRcXG5cXHRcXHQgKiBAdHlwZSB7T2JqZWN0fVxcblxcdFxcdCAqL1xcblxcdFxcdHRoaXMuX2hhbmRsZXJzID0ge1xcblxcdFxcdFxcdCdjaGFuZ2VkLm93bC5jYXJvdXNlbCc6ICQucHJveHkoZnVuY3Rpb24oZSkge1xcblxcdFxcdFxcdFxcdGlmIChlLm5hbWVzcGFjZSAmJiBlLnByb3BlcnR5Lm5hbWUgPT09ICdzZXR0aW5ncycpIHtcXG5cXHRcXHRcXHRcXHRcXHRpZiAodGhpcy5fY29yZS5zZXR0aW5ncy5hdXRvcGxheSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHRoaXMucGxheSgpO1xcblxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dGhpcy5zdG9wKCk7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH0gZWxzZSBpZiAoZS5uYW1lc3BhY2UgJiYgZS5wcm9wZXJ0eS5uYW1lID09PSAncG9zaXRpb24nKSB7XFxuXFx0XFx0XFx0XFx0XFx0Ly9jb25zb2xlLmxvZygncGxheT8nLCBlKTtcXG5cXHRcXHRcXHRcXHRcXHRpZiAodGhpcy5fY29yZS5zZXR0aW5ncy5hdXRvcGxheSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHRoaXMuX3NldEF1dG9QbGF5SW50ZXJ2YWwoKTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH0sIHRoaXMpLFxcblxcdFxcdFxcdCdpbml0aWFsaXplZC5vd2wuY2Fyb3VzZWwnOiAkLnByb3h5KGZ1bmN0aW9uKGUpIHtcXG5cXHRcXHRcXHRcXHRpZiAoZS5uYW1lc3BhY2UgJiYgdGhpcy5fY29yZS5zZXR0aW5ncy5hdXRvcGxheSkge1xcblxcdFxcdFxcdFxcdFxcdHRoaXMucGxheSgpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9LCB0aGlzKSxcXG5cXHRcXHRcXHQncGxheS5vd2wuYXV0b3BsYXknOiAkLnByb3h5KGZ1bmN0aW9uKGUsIHQsIHMpIHtcXG5cXHRcXHRcXHRcXHRpZiAoZS5uYW1lc3BhY2UpIHtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLnBsYXkodCwgcyk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH0sIHRoaXMpLFxcblxcdFxcdFxcdCdzdG9wLm93bC5hdXRvcGxheSc6ICQucHJveHkoZnVuY3Rpb24oZSkge1xcblxcdFxcdFxcdFxcdGlmIChlLm5hbWVzcGFjZSkge1xcblxcdFxcdFxcdFxcdFxcdHRoaXMuc3RvcCgpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9LCB0aGlzKSxcXG5cXHRcXHRcXHQnbW91c2VvdmVyLm93bC5hdXRvcGxheSc6ICQucHJveHkoZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0XFx0aWYgKHRoaXMuX2NvcmUuc2V0dGluZ3MuYXV0b3BsYXlIb3ZlclBhdXNlICYmIHRoaXMuX2NvcmUuaXMoJ3JvdGF0aW5nJykpIHtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLnBhdXNlKCk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH0sIHRoaXMpLFxcblxcdFxcdFxcdCdtb3VzZWxlYXZlLm93bC5hdXRvcGxheSc6ICQucHJveHkoZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0XFx0aWYgKHRoaXMuX2NvcmUuc2V0dGluZ3MuYXV0b3BsYXlIb3ZlclBhdXNlICYmIHRoaXMuX2NvcmUuaXMoJ3JvdGF0aW5nJykpIHtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLnBsYXkoKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fSwgdGhpcyksXFxuXFx0XFx0XFx0J3RvdWNoc3RhcnQub3dsLmNvcmUnOiAkLnByb3h5KGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdFxcdGlmICh0aGlzLl9jb3JlLnNldHRpbmdzLmF1dG9wbGF5SG92ZXJQYXVzZSAmJiB0aGlzLl9jb3JlLmlzKCdyb3RhdGluZycpKSB7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5wYXVzZSgpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9LCB0aGlzKSxcXG5cXHRcXHRcXHQndG91Y2hlbmQub3dsLmNvcmUnOiAkLnByb3h5KGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdFxcdGlmICh0aGlzLl9jb3JlLnNldHRpbmdzLmF1dG9wbGF5SG92ZXJQYXVzZSkge1xcblxcdFxcdFxcdFxcdFxcdHRoaXMucGxheSgpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9LCB0aGlzKVxcblxcdFxcdH07XFxuXFxuXFx0XFx0Ly8gcmVnaXN0ZXIgZXZlbnQgaGFuZGxlcnNcXG5cXHRcXHR0aGlzLl9jb3JlLiRlbGVtZW50Lm9uKHRoaXMuX2hhbmRsZXJzKTtcXG5cXG5cXHRcXHQvLyBzZXQgZGVmYXVsdCBvcHRpb25zXFxuXFx0XFx0dGhpcy5fY29yZS5vcHRpb25zID0gJC5leHRlbmQoe30sIEF1dG9wbGF5LkRlZmF1bHRzLCB0aGlzLl9jb3JlLm9wdGlvbnMpO1xcblxcdH07XFxuXFxuXFx0LyoqXFxuXFx0ICogRGVmYXVsdCBvcHRpb25zLlxcblxcdCAqIEBwdWJsaWNcXG5cXHQgKi9cXG5cXHRBdXRvcGxheS5EZWZhdWx0cyA9IHtcXG5cXHRcXHRhdXRvcGxheTogZmFsc2UsXFxuXFx0XFx0YXV0b3BsYXlUaW1lb3V0OiA1MDAwLFxcblxcdFxcdGF1dG9wbGF5SG92ZXJQYXVzZTogZmFsc2UsXFxuXFx0XFx0YXV0b3BsYXlTcGVlZDogZmFsc2VcXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIFN0YXJ0cyB0aGUgYXV0b3BsYXkuXFxuXFx0ICogQHB1YmxpY1xcblxcdCAqIEBwYXJhbSB7TnVtYmVyfSBbdGltZW91dF0gLSBUaGUgaW50ZXJ2YWwgYmVmb3JlIHRoZSBuZXh0IGFuaW1hdGlvbiBzdGFydHMuXFxuXFx0ICogQHBhcmFtIHtOdW1iZXJ9IFtzcGVlZF0gLSBUaGUgYW5pbWF0aW9uIHNwZWVkIGZvciB0aGUgYW5pbWF0aW9ucy5cXG5cXHQgKi9cXG5cXHRBdXRvcGxheS5wcm90b3R5cGUucGxheSA9IGZ1bmN0aW9uKHRpbWVvdXQsIHNwZWVkKSB7XFxuXFx0XFx0dGhpcy5fcGF1c2VkID0gZmFsc2U7XFxuXFxuXFx0XFx0aWYgKHRoaXMuX2NvcmUuaXMoJ3JvdGF0aW5nJykpIHtcXG5cXHRcXHRcXHRyZXR1cm47XFxuXFx0XFx0fVxcblxcblxcdFxcdHRoaXMuX2NvcmUuZW50ZXIoJ3JvdGF0aW5nJyk7XFxuXFxuXFx0XFx0dGhpcy5fc2V0QXV0b1BsYXlJbnRlcnZhbCgpO1xcblxcdH07XFxuXFxuXFx0LyoqXFxuXFx0ICogR2V0cyBhIG5ldyB0aW1lb3V0XFxuXFx0ICogQHByaXZhdGVcXG5cXHQgKiBAcGFyYW0ge051bWJlcn0gW3RpbWVvdXRdIC0gVGhlIGludGVydmFsIGJlZm9yZSB0aGUgbmV4dCBhbmltYXRpb24gc3RhcnRzLlxcblxcdCAqIEBwYXJhbSB7TnVtYmVyfSBbc3BlZWRdIC0gVGhlIGFuaW1hdGlvbiBzcGVlZCBmb3IgdGhlIGFuaW1hdGlvbnMuXFxuXFx0ICogQHJldHVybiB7VGltZW91dH1cXG5cXHQgKi9cXG5cXHRBdXRvcGxheS5wcm90b3R5cGUuX2dldE5leHRUaW1lb3V0ID0gZnVuY3Rpb24odGltZW91dCwgc3BlZWQpIHtcXG5cXHRcXHRpZiAoIHRoaXMuX3RpbWVvdXQgKSB7XFxuXFx0XFx0XFx0d2luZG93LmNsZWFyVGltZW91dCh0aGlzLl90aW1lb3V0KTtcXG5cXHRcXHR9XFxuXFx0XFx0cmV0dXJuIHdpbmRvdy5zZXRUaW1lb3V0KCQucHJveHkoZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0aWYgKHRoaXMuX3BhdXNlZCB8fCB0aGlzLl9jb3JlLmlzKCdidXN5JykgfHwgdGhpcy5fY29yZS5pcygnaW50ZXJhY3RpbmcnKSB8fCBkb2N1bWVudC5oaWRkZW4pIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm47XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHRoaXMuX2NvcmUubmV4dChzcGVlZCB8fCB0aGlzLl9jb3JlLnNldHRpbmdzLmF1dG9wbGF5U3BlZWQpO1xcblxcdFxcdH0sIHRoaXMpLCB0aW1lb3V0IHx8IHRoaXMuX2NvcmUuc2V0dGluZ3MuYXV0b3BsYXlUaW1lb3V0KTtcXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIFNldHMgYXV0b3BsYXkgaW4gbW90aW9uLlxcblxcdCAqIEBwcml2YXRlXFxuXFx0ICovXFxuXFx0QXV0b3BsYXkucHJvdG90eXBlLl9zZXRBdXRvUGxheUludGVydmFsID0gZnVuY3Rpb24oKSB7XFxuXFx0XFx0dGhpcy5fdGltZW91dCA9IHRoaXMuX2dldE5leHRUaW1lb3V0KCk7XFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBTdG9wcyB0aGUgYXV0b3BsYXkuXFxuXFx0ICogQHB1YmxpY1xcblxcdCAqL1xcblxcdEF1dG9wbGF5LnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24oKSB7XFxuXFx0XFx0aWYgKCF0aGlzLl9jb3JlLmlzKCdyb3RhdGluZycpKSB7XFxuXFx0XFx0XFx0cmV0dXJuO1xcblxcdFxcdH1cXG5cXG5cXHRcXHR3aW5kb3cuY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVvdXQpO1xcblxcdFxcdHRoaXMuX2NvcmUubGVhdmUoJ3JvdGF0aW5nJyk7XFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBTdG9wcyB0aGUgYXV0b3BsYXkuXFxuXFx0ICogQHB1YmxpY1xcblxcdCAqL1xcblxcdEF1dG9wbGF5LnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uKCkge1xcblxcdFxcdGlmICghdGhpcy5fY29yZS5pcygncm90YXRpbmcnKSkge1xcblxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0dGhpcy5fcGF1c2VkID0gdHJ1ZTtcXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIERlc3Ryb3lzIHRoZSBwbHVnaW4uXFxuXFx0ICovXFxuXFx0QXV0b3BsYXkucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcXG5cXHRcXHR2YXIgaGFuZGxlciwgcHJvcGVydHk7XFxuXFxuXFx0XFx0dGhpcy5zdG9wKCk7XFxuXFxuXFx0XFx0Zm9yIChoYW5kbGVyIGluIHRoaXMuX2hhbmRsZXJzKSB7XFxuXFx0XFx0XFx0dGhpcy5fY29yZS4kZWxlbWVudC5vZmYoaGFuZGxlciwgdGhpcy5faGFuZGxlcnNbaGFuZGxlcl0pO1xcblxcdFxcdH1cXG5cXHRcXHRmb3IgKHByb3BlcnR5IGluIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRoaXMpKSB7XFxuXFx0XFx0XFx0dHlwZW9mIHRoaXNbcHJvcGVydHldICE9ICdmdW5jdGlvbicgJiYgKHRoaXNbcHJvcGVydHldID0gbnVsbCk7XFxuXFx0XFx0fVxcblxcdH07XFxuXFxuXFx0JC5mbi5vd2xDYXJvdXNlbC5Db25zdHJ1Y3Rvci5QbHVnaW5zLmF1dG9wbGF5ID0gQXV0b3BsYXk7XFxuXFxufSkod2luZG93LlplcHRvIHx8IF9fd2VicGFja19wcm92aWRlZF93aW5kb3dfZG90X2pRdWVyeSwgd2luZG93LCBkb2N1bWVudCk7XFxuXFxuLyoqXFxuICogTmF2aWdhdGlvbiBQbHVnaW5cXG4gKiBAdmVyc2lvbiAyLjEuMFxcbiAqIEBhdXRob3IgQXJ0dXMgS29sYW5vd3NraVxcbiAqIEBhdXRob3IgRGF2aWQgRGV1dHNjaFxcbiAqIEBsaWNlbnNlIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxcbiAqL1xcbjsoZnVuY3Rpb24oJCwgd2luZG93LCBkb2N1bWVudCwgdW5kZWZpbmVkKSB7XFxuXFx0J3VzZSBzdHJpY3QnO1xcblxcblxcdC8qKlxcblxcdCAqIENyZWF0ZXMgdGhlIG5hdmlnYXRpb24gcGx1Z2luLlxcblxcdCAqIEBjbGFzcyBUaGUgTmF2aWdhdGlvbiBQbHVnaW5cXG5cXHQgKiBAcGFyYW0ge093bH0gY2Fyb3VzZWwgLSBUaGUgT3dsIENhcm91c2VsLlxcblxcdCAqL1xcblxcdHZhciBOYXZpZ2F0aW9uID0gZnVuY3Rpb24oY2Fyb3VzZWwpIHtcXG5cXHRcXHQvKipcXG5cXHRcXHQgKiBSZWZlcmVuY2UgdG8gdGhlIGNvcmUuXFxuXFx0XFx0ICogQHByb3RlY3RlZFxcblxcdFxcdCAqIEB0eXBlIHtPd2x9XFxuXFx0XFx0ICovXFxuXFx0XFx0dGhpcy5fY29yZSA9IGNhcm91c2VsO1xcblxcblxcdFxcdC8qKlxcblxcdFxcdCAqIEluZGljYXRlcyB3aGV0aGVyIHRoZSBwbHVnaW4gaXMgaW5pdGlhbGl6ZWQgb3Igbm90LlxcblxcdFxcdCAqIEBwcm90ZWN0ZWRcXG5cXHRcXHQgKiBAdHlwZSB7Qm9vbGVhbn1cXG5cXHRcXHQgKi9cXG5cXHRcXHR0aGlzLl9pbml0aWFsaXplZCA9IGZhbHNlO1xcblxcblxcdFxcdC8qKlxcblxcdFxcdCAqIFRoZSBjdXJyZW50IHBhZ2luZyBpbmRleGVzLlxcblxcdFxcdCAqIEBwcm90ZWN0ZWRcXG5cXHRcXHQgKiBAdHlwZSB7QXJyYXl9XFxuXFx0XFx0ICovXFxuXFx0XFx0dGhpcy5fcGFnZXMgPSBbXTtcXG5cXG5cXHRcXHQvKipcXG5cXHRcXHQgKiBBbGwgRE9NIGVsZW1lbnRzIG9mIHRoZSB1c2VyIGludGVyZmFjZS5cXG5cXHRcXHQgKiBAcHJvdGVjdGVkXFxuXFx0XFx0ICogQHR5cGUge09iamVjdH1cXG5cXHRcXHQgKi9cXG5cXHRcXHR0aGlzLl9jb250cm9scyA9IHt9O1xcblxcblxcdFxcdC8qKlxcblxcdFxcdCAqIE1hcmt1cCBmb3IgYW4gaW5kaWNhdG9yLlxcblxcdFxcdCAqIEBwcm90ZWN0ZWRcXG5cXHRcXHQgKiBAdHlwZSB7QXJyYXkuPFN0cmluZz59XFxuXFx0XFx0ICovXFxuXFx0XFx0dGhpcy5fdGVtcGxhdGVzID0gW107XFxuXFxuXFx0XFx0LyoqXFxuXFx0XFx0ICogVGhlIGNhcm91c2VsIGVsZW1lbnQuXFxuXFx0XFx0ICogQHR5cGUge2pRdWVyeX1cXG5cXHRcXHQgKi9cXG5cXHRcXHR0aGlzLiRlbGVtZW50ID0gdGhpcy5fY29yZS4kZWxlbWVudDtcXG5cXG5cXHRcXHQvKipcXG5cXHRcXHQgKiBPdmVycmlkZGVuIG1ldGhvZHMgb2YgdGhlIGNhcm91c2VsLlxcblxcdFxcdCAqIEBwcm90ZWN0ZWRcXG5cXHRcXHQgKiBAdHlwZSB7T2JqZWN0fVxcblxcdFxcdCAqL1xcblxcdFxcdHRoaXMuX292ZXJyaWRlcyA9IHtcXG5cXHRcXHRcXHRuZXh0OiB0aGlzLl9jb3JlLm5leHQsXFxuXFx0XFx0XFx0cHJldjogdGhpcy5fY29yZS5wcmV2LFxcblxcdFxcdFxcdHRvOiB0aGlzLl9jb3JlLnRvXFxuXFx0XFx0fTtcXG5cXG5cXHRcXHQvKipcXG5cXHRcXHQgKiBBbGwgZXZlbnQgaGFuZGxlcnMuXFxuXFx0XFx0ICogQHByb3RlY3RlZFxcblxcdFxcdCAqIEB0eXBlIHtPYmplY3R9XFxuXFx0XFx0ICovXFxuXFx0XFx0dGhpcy5faGFuZGxlcnMgPSB7XFxuXFx0XFx0XFx0J3ByZXBhcmVkLm93bC5jYXJvdXNlbCc6ICQucHJveHkoZnVuY3Rpb24oZSkge1xcblxcdFxcdFxcdFxcdGlmIChlLm5hbWVzcGFjZSAmJiB0aGlzLl9jb3JlLnNldHRpbmdzLmRvdHNEYXRhKSB7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5fdGVtcGxhdGVzLnB1c2goJzxkaXYgY2xhc3M9XFxcIicgKyB0aGlzLl9jb3JlLnNldHRpbmdzLmRvdENsYXNzICsgJ1xcXCI+JyArXFxuXFx0XFx0XFx0XFx0XFx0XFx0JChlLmNvbnRlbnQpLmZpbmQoJ1tkYXRhLWRvdF0nKS5hZGRCYWNrKCdbZGF0YS1kb3RdJykuYXR0cignZGF0YS1kb3QnKSArICc8L2Rpdj4nKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fSwgdGhpcyksXFxuXFx0XFx0XFx0J2FkZGVkLm93bC5jYXJvdXNlbCc6ICQucHJveHkoZnVuY3Rpb24oZSkge1xcblxcdFxcdFxcdFxcdGlmIChlLm5hbWVzcGFjZSAmJiB0aGlzLl9jb3JlLnNldHRpbmdzLmRvdHNEYXRhKSB7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5fdGVtcGxhdGVzLnNwbGljZShlLnBvc2l0aW9uLCAwLCB0aGlzLl90ZW1wbGF0ZXMucG9wKCkpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9LCB0aGlzKSxcXG5cXHRcXHRcXHQncmVtb3ZlLm93bC5jYXJvdXNlbCc6ICQucHJveHkoZnVuY3Rpb24oZSkge1xcblxcdFxcdFxcdFxcdGlmIChlLm5hbWVzcGFjZSAmJiB0aGlzLl9jb3JlLnNldHRpbmdzLmRvdHNEYXRhKSB7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5fdGVtcGxhdGVzLnNwbGljZShlLnBvc2l0aW9uLCAxKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fSwgdGhpcyksXFxuXFx0XFx0XFx0J2NoYW5nZWQub3dsLmNhcm91c2VsJzogJC5wcm94eShmdW5jdGlvbihlKSB7XFxuXFx0XFx0XFx0XFx0aWYgKGUubmFtZXNwYWNlICYmIGUucHJvcGVydHkubmFtZSA9PSAncG9zaXRpb24nKSB7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5kcmF3KCk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH0sIHRoaXMpLFxcblxcdFxcdFxcdCdpbml0aWFsaXplZC5vd2wuY2Fyb3VzZWwnOiAkLnByb3h5KGZ1bmN0aW9uKGUpIHtcXG5cXHRcXHRcXHRcXHRpZiAoZS5uYW1lc3BhY2UgJiYgIXRoaXMuX2luaXRpYWxpemVkKSB7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5fY29yZS50cmlnZ2VyKCdpbml0aWFsaXplJywgbnVsbCwgJ25hdmlnYXRpb24nKTtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLmluaXRpYWxpemUoKTtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLnVwZGF0ZSgpO1xcblxcdFxcdFxcdFxcdFxcdHRoaXMuZHJhdygpO1xcblxcdFxcdFxcdFxcdFxcdHRoaXMuX2luaXRpYWxpemVkID0gdHJ1ZTtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLl9jb3JlLnRyaWdnZXIoJ2luaXRpYWxpemVkJywgbnVsbCwgJ25hdmlnYXRpb24nKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fSwgdGhpcyksXFxuXFx0XFx0XFx0J3JlZnJlc2hlZC5vd2wuY2Fyb3VzZWwnOiAkLnByb3h5KGZ1bmN0aW9uKGUpIHtcXG5cXHRcXHRcXHRcXHRpZiAoZS5uYW1lc3BhY2UgJiYgdGhpcy5faW5pdGlhbGl6ZWQpIHtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLl9jb3JlLnRyaWdnZXIoJ3JlZnJlc2gnLCBudWxsLCAnbmF2aWdhdGlvbicpO1xcblxcdFxcdFxcdFxcdFxcdHRoaXMudXBkYXRlKCk7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5kcmF3KCk7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5fY29yZS50cmlnZ2VyKCdyZWZyZXNoZWQnLCBudWxsLCAnbmF2aWdhdGlvbicpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9LCB0aGlzKVxcblxcdFxcdH07XFxuXFxuXFx0XFx0Ly8gc2V0IGRlZmF1bHQgb3B0aW9uc1xcblxcdFxcdHRoaXMuX2NvcmUub3B0aW9ucyA9ICQuZXh0ZW5kKHt9LCBOYXZpZ2F0aW9uLkRlZmF1bHRzLCB0aGlzLl9jb3JlLm9wdGlvbnMpO1xcblxcblxcdFxcdC8vIHJlZ2lzdGVyIGV2ZW50IGhhbmRsZXJzXFxuXFx0XFx0dGhpcy4kZWxlbWVudC5vbih0aGlzLl9oYW5kbGVycyk7XFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBEZWZhdWx0IG9wdGlvbnMuXFxuXFx0ICogQHB1YmxpY1xcblxcdCAqIEB0b2RvIFJlbmFtZSBgc2xpZGVCeWAgdG8gYG5hdkJ5YFxcblxcdCAqL1xcblxcdE5hdmlnYXRpb24uRGVmYXVsdHMgPSB7XFxuXFx0XFx0bmF2OiBmYWxzZSxcXG5cXHRcXHRuYXZUZXh0OiBbICdwcmV2JywgJ25leHQnIF0sXFxuXFx0XFx0bmF2U3BlZWQ6IGZhbHNlLFxcblxcdFxcdG5hdkVsZW1lbnQ6ICdkaXYnLFxcblxcdFxcdG5hdkNvbnRhaW5lcjogZmFsc2UsXFxuXFx0XFx0bmF2Q29udGFpbmVyQ2xhc3M6ICdvd2wtbmF2JyxcXG5cXHRcXHRuYXZDbGFzczogWyAnb3dsLXByZXYnLCAnb3dsLW5leHQnIF0sXFxuXFx0XFx0c2xpZGVCeTogMSxcXG5cXHRcXHRkb3RDbGFzczogJ293bC1kb3QnLFxcblxcdFxcdGRvdHNDbGFzczogJ293bC1kb3RzJyxcXG5cXHRcXHRkb3RzOiB0cnVlLFxcblxcdFxcdGRvdHNFYWNoOiBmYWxzZSxcXG5cXHRcXHRkb3RzRGF0YTogZmFsc2UsXFxuXFx0XFx0ZG90c1NwZWVkOiBmYWxzZSxcXG5cXHRcXHRkb3RzQ29udGFpbmVyOiBmYWxzZVxcblxcdH07XFxuXFxuXFx0LyoqXFxuXFx0ICogSW5pdGlhbGl6ZXMgdGhlIGxheW91dCBvZiB0aGUgcGx1Z2luIGFuZCBleHRlbmRzIHRoZSBjYXJvdXNlbC5cXG5cXHQgKiBAcHJvdGVjdGVkXFxuXFx0ICovXFxuXFx0TmF2aWdhdGlvbi5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uKCkge1xcblxcdFxcdHZhciBvdmVycmlkZSxcXG5cXHRcXHRcXHRzZXR0aW5ncyA9IHRoaXMuX2NvcmUuc2V0dGluZ3M7XFxuXFxuXFx0XFx0Ly8gY3JlYXRlIERPTSBzdHJ1Y3R1cmUgZm9yIHJlbGF0aXZlIG5hdmlnYXRpb25cXG5cXHRcXHR0aGlzLl9jb250cm9scy4kcmVsYXRpdmUgPSAoc2V0dGluZ3MubmF2Q29udGFpbmVyID8gJChzZXR0aW5ncy5uYXZDb250YWluZXIpXFxuXFx0XFx0XFx0OiAkKCc8ZGl2PicpLmFkZENsYXNzKHNldHRpbmdzLm5hdkNvbnRhaW5lckNsYXNzKS5hcHBlbmRUbyh0aGlzLiRlbGVtZW50KSkuYWRkQ2xhc3MoJ2Rpc2FibGVkJyk7XFxuXFxuXFx0XFx0dGhpcy5fY29udHJvbHMuJHByZXZpb3VzID0gJCgnPCcgKyBzZXR0aW5ncy5uYXZFbGVtZW50ICsgJz4nKVxcblxcdFxcdFxcdC5hZGRDbGFzcyhzZXR0aW5ncy5uYXZDbGFzc1swXSlcXG5cXHRcXHRcXHQuaHRtbChzZXR0aW5ncy5uYXZUZXh0WzBdKVxcblxcdFxcdFxcdC5wcmVwZW5kVG8odGhpcy5fY29udHJvbHMuJHJlbGF0aXZlKVxcblxcdFxcdFxcdC5vbignY2xpY2snLCAkLnByb3h5KGZ1bmN0aW9uKGUpIHtcXG5cXHRcXHRcXHRcXHR0aGlzLnByZXYoc2V0dGluZ3MubmF2U3BlZWQpO1xcblxcdFxcdFxcdH0sIHRoaXMpKTtcXG5cXHRcXHR0aGlzLl9jb250cm9scy4kbmV4dCA9ICQoJzwnICsgc2V0dGluZ3MubmF2RWxlbWVudCArICc+JylcXG5cXHRcXHRcXHQuYWRkQ2xhc3Moc2V0dGluZ3MubmF2Q2xhc3NbMV0pXFxuXFx0XFx0XFx0Lmh0bWwoc2V0dGluZ3MubmF2VGV4dFsxXSlcXG5cXHRcXHRcXHQuYXBwZW5kVG8odGhpcy5fY29udHJvbHMuJHJlbGF0aXZlKVxcblxcdFxcdFxcdC5vbignY2xpY2snLCAkLnByb3h5KGZ1bmN0aW9uKGUpIHtcXG5cXHRcXHRcXHRcXHR0aGlzLm5leHQoc2V0dGluZ3MubmF2U3BlZWQpO1xcblxcdFxcdFxcdH0sIHRoaXMpKTtcXG5cXG5cXHRcXHQvLyBjcmVhdGUgRE9NIHN0cnVjdHVyZSBmb3IgYWJzb2x1dGUgbmF2aWdhdGlvblxcblxcdFxcdGlmICghc2V0dGluZ3MuZG90c0RhdGEpIHtcXG5cXHRcXHRcXHR0aGlzLl90ZW1wbGF0ZXMgPSBbICQoJzxkaXY+JylcXG5cXHRcXHRcXHRcXHQuYWRkQ2xhc3Moc2V0dGluZ3MuZG90Q2xhc3MpXFxuXFx0XFx0XFx0XFx0LmFwcGVuZCgkKCc8c3Bhbj4nKSlcXG5cXHRcXHRcXHRcXHQucHJvcCgnb3V0ZXJIVE1MJykgXTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0dGhpcy5fY29udHJvbHMuJGFic29sdXRlID0gKHNldHRpbmdzLmRvdHNDb250YWluZXIgPyAkKHNldHRpbmdzLmRvdHNDb250YWluZXIpXFxuXFx0XFx0XFx0OiAkKCc8ZGl2PicpLmFkZENsYXNzKHNldHRpbmdzLmRvdHNDbGFzcykuYXBwZW5kVG8odGhpcy4kZWxlbWVudCkpLmFkZENsYXNzKCdkaXNhYmxlZCcpO1xcblxcblxcdFxcdHRoaXMuX2NvbnRyb2xzLiRhYnNvbHV0ZS5vbignY2xpY2snLCAnZGl2JywgJC5wcm94eShmdW5jdGlvbihlKSB7XFxuXFx0XFx0XFx0dmFyIGluZGV4ID0gJChlLnRhcmdldCkucGFyZW50KCkuaXModGhpcy5fY29udHJvbHMuJGFic29sdXRlKVxcblxcdFxcdFxcdFxcdD8gJChlLnRhcmdldCkuaW5kZXgoKSA6ICQoZS50YXJnZXQpLnBhcmVudCgpLmluZGV4KCk7XFxuXFxuXFx0XFx0XFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xcblxcblxcdFxcdFxcdHRoaXMudG8oaW5kZXgsIHNldHRpbmdzLmRvdHNTcGVlZCk7XFxuXFx0XFx0fSwgdGhpcykpO1xcblxcblxcdFxcdC8vIG92ZXJyaWRlIHB1YmxpYyBtZXRob2RzIG9mIHRoZSBjYXJvdXNlbFxcblxcdFxcdGZvciAob3ZlcnJpZGUgaW4gdGhpcy5fb3ZlcnJpZGVzKSB7XFxuXFx0XFx0XFx0dGhpcy5fY29yZVtvdmVycmlkZV0gPSAkLnByb3h5KHRoaXNbb3ZlcnJpZGVdLCB0aGlzKTtcXG5cXHRcXHR9XFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBEZXN0cm95cyB0aGUgcGx1Z2luLlxcblxcdCAqIEBwcm90ZWN0ZWRcXG5cXHQgKi9cXG5cXHROYXZpZ2F0aW9uLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XFxuXFx0XFx0dmFyIGhhbmRsZXIsIGNvbnRyb2wsIHByb3BlcnR5LCBvdmVycmlkZTtcXG5cXG5cXHRcXHRmb3IgKGhhbmRsZXIgaW4gdGhpcy5faGFuZGxlcnMpIHtcXG5cXHRcXHRcXHR0aGlzLiRlbGVtZW50Lm9mZihoYW5kbGVyLCB0aGlzLl9oYW5kbGVyc1toYW5kbGVyXSk7XFxuXFx0XFx0fVxcblxcdFxcdGZvciAoY29udHJvbCBpbiB0aGlzLl9jb250cm9scykge1xcblxcdFxcdFxcdHRoaXMuX2NvbnRyb2xzW2NvbnRyb2xdLnJlbW92ZSgpO1xcblxcdFxcdH1cXG5cXHRcXHRmb3IgKG92ZXJyaWRlIGluIHRoaXMub3ZlcmlkZXMpIHtcXG5cXHRcXHRcXHR0aGlzLl9jb3JlW292ZXJyaWRlXSA9IHRoaXMuX292ZXJyaWRlc1tvdmVycmlkZV07XFxuXFx0XFx0fVxcblxcdFxcdGZvciAocHJvcGVydHkgaW4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGhpcykpIHtcXG5cXHRcXHRcXHR0eXBlb2YgdGhpc1twcm9wZXJ0eV0gIT0gJ2Z1bmN0aW9uJyAmJiAodGhpc1twcm9wZXJ0eV0gPSBudWxsKTtcXG5cXHRcXHR9XFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBVcGRhdGVzIHRoZSBpbnRlcm5hbCBzdGF0ZS5cXG5cXHQgKiBAcHJvdGVjdGVkXFxuXFx0ICovXFxuXFx0TmF2aWdhdGlvbi5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24oKSB7XFxuXFx0XFx0dmFyIGksIGosIGssXFxuXFx0XFx0XFx0bG93ZXIgPSB0aGlzLl9jb3JlLmNsb25lcygpLmxlbmd0aCAvIDIsXFxuXFx0XFx0XFx0dXBwZXIgPSBsb3dlciArIHRoaXMuX2NvcmUuaXRlbXMoKS5sZW5ndGgsXFxuXFx0XFx0XFx0bWF4aW11bSA9IHRoaXMuX2NvcmUubWF4aW11bSh0cnVlKSxcXG5cXHRcXHRcXHRzZXR0aW5ncyA9IHRoaXMuX2NvcmUuc2V0dGluZ3MsXFxuXFx0XFx0XFx0c2l6ZSA9IHNldHRpbmdzLmNlbnRlciB8fCBzZXR0aW5ncy5hdXRvV2lkdGggfHwgc2V0dGluZ3MuZG90c0RhdGFcXG5cXHRcXHRcXHRcXHQ/IDEgOiBzZXR0aW5ncy5kb3RzRWFjaCB8fCBzZXR0aW5ncy5pdGVtcztcXG5cXG5cXHRcXHRpZiAoc2V0dGluZ3Muc2xpZGVCeSAhPT0gJ3BhZ2UnKSB7XFxuXFx0XFx0XFx0c2V0dGluZ3Muc2xpZGVCeSA9IE1hdGgubWluKHNldHRpbmdzLnNsaWRlQnksIHNldHRpbmdzLml0ZW1zKTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0aWYgKHNldHRpbmdzLmRvdHMgfHwgc2V0dGluZ3Muc2xpZGVCeSA9PSAncGFnZScpIHtcXG5cXHRcXHRcXHR0aGlzLl9wYWdlcyA9IFtdO1xcblxcblxcdFxcdFxcdGZvciAoaSA9IGxvd2VyLCBqID0gMCwgayA9IDA7IGkgPCB1cHBlcjsgaSsrKSB7XFxuXFx0XFx0XFx0XFx0aWYgKGogPj0gc2l6ZSB8fCBqID09PSAwKSB7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5fcGFnZXMucHVzaCh7XFxuXFx0XFx0XFx0XFx0XFx0XFx0c3RhcnQ6IE1hdGgubWluKG1heGltdW0sIGkgLSBsb3dlciksXFxuXFx0XFx0XFx0XFx0XFx0XFx0ZW5kOiBpIC0gbG93ZXIgKyBzaXplIC0gMVxcblxcdFxcdFxcdFxcdFxcdH0pO1xcblxcdFxcdFxcdFxcdFxcdGlmIChNYXRoLm1pbihtYXhpbXVtLCBpIC0gbG93ZXIpID09PSBtYXhpbXVtKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdGogPSAwLCArK2s7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdGogKz0gdGhpcy5fY29yZS5tZXJnZXJzKHRoaXMuX2NvcmUucmVsYXRpdmUoaSkpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBEcmF3cyB0aGUgdXNlciBpbnRlcmZhY2UuXFxuXFx0ICogQHRvZG8gVGhlIG9wdGlvbiBgZG90c0RhdGFgIHdvbnQgd29yay5cXG5cXHQgKiBAcHJvdGVjdGVkXFxuXFx0ICovXFxuXFx0TmF2aWdhdGlvbi5wcm90b3R5cGUuZHJhdyA9IGZ1bmN0aW9uKCkge1xcblxcdFxcdHZhciBkaWZmZXJlbmNlLFxcblxcdFxcdFxcdHNldHRpbmdzID0gdGhpcy5fY29yZS5zZXR0aW5ncyxcXG5cXHRcXHRcXHRkaXNhYmxlZCA9IHRoaXMuX2NvcmUuaXRlbXMoKS5sZW5ndGggPD0gc2V0dGluZ3MuaXRlbXMsXFxuXFx0XFx0XFx0aW5kZXggPSB0aGlzLl9jb3JlLnJlbGF0aXZlKHRoaXMuX2NvcmUuY3VycmVudCgpKSxcXG5cXHRcXHRcXHRsb29wID0gc2V0dGluZ3MubG9vcCB8fCBzZXR0aW5ncy5yZXdpbmQ7XFxuXFxuXFx0XFx0dGhpcy5fY29udHJvbHMuJHJlbGF0aXZlLnRvZ2dsZUNsYXNzKCdkaXNhYmxlZCcsICFzZXR0aW5ncy5uYXYgfHwgZGlzYWJsZWQpO1xcblxcblxcdFxcdGlmIChzZXR0aW5ncy5uYXYpIHtcXG5cXHRcXHRcXHR0aGlzLl9jb250cm9scy4kcHJldmlvdXMudG9nZ2xlQ2xhc3MoJ2Rpc2FibGVkJywgIWxvb3AgJiYgaW5kZXggPD0gdGhpcy5fY29yZS5taW5pbXVtKHRydWUpKTtcXG5cXHRcXHRcXHR0aGlzLl9jb250cm9scy4kbmV4dC50b2dnbGVDbGFzcygnZGlzYWJsZWQnLCAhbG9vcCAmJiBpbmRleCA+PSB0aGlzLl9jb3JlLm1heGltdW0odHJ1ZSkpO1xcblxcdFxcdH1cXG5cXG5cXHRcXHR0aGlzLl9jb250cm9scy4kYWJzb2x1dGUudG9nZ2xlQ2xhc3MoJ2Rpc2FibGVkJywgIXNldHRpbmdzLmRvdHMgfHwgZGlzYWJsZWQpO1xcblxcblxcdFxcdGlmIChzZXR0aW5ncy5kb3RzKSB7XFxuXFx0XFx0XFx0ZGlmZmVyZW5jZSA9IHRoaXMuX3BhZ2VzLmxlbmd0aCAtIHRoaXMuX2NvbnRyb2xzLiRhYnNvbHV0ZS5jaGlsZHJlbigpLmxlbmd0aDtcXG5cXG5cXHRcXHRcXHRpZiAoc2V0dGluZ3MuZG90c0RhdGEgJiYgZGlmZmVyZW5jZSAhPT0gMCkge1xcblxcdFxcdFxcdFxcdHRoaXMuX2NvbnRyb2xzLiRhYnNvbHV0ZS5odG1sKHRoaXMuX3RlbXBsYXRlcy5qb2luKCcnKSk7XFxuXFx0XFx0XFx0fSBlbHNlIGlmIChkaWZmZXJlbmNlID4gMCkge1xcblxcdFxcdFxcdFxcdHRoaXMuX2NvbnRyb2xzLiRhYnNvbHV0ZS5hcHBlbmQobmV3IEFycmF5KGRpZmZlcmVuY2UgKyAxKS5qb2luKHRoaXMuX3RlbXBsYXRlc1swXSkpO1xcblxcdFxcdFxcdH0gZWxzZSBpZiAoZGlmZmVyZW5jZSA8IDApIHtcXG5cXHRcXHRcXHRcXHR0aGlzLl9jb250cm9scy4kYWJzb2x1dGUuY2hpbGRyZW4oKS5zbGljZShkaWZmZXJlbmNlKS5yZW1vdmUoKTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0dGhpcy5fY29udHJvbHMuJGFic29sdXRlLmZpbmQoJy5hY3RpdmUnKS5yZW1vdmVDbGFzcygnYWN0aXZlJyk7XFxuXFx0XFx0XFx0dGhpcy5fY29udHJvbHMuJGFic29sdXRlLmNoaWxkcmVuKCkuZXEoJC5pbkFycmF5KHRoaXMuY3VycmVudCgpLCB0aGlzLl9wYWdlcykpLmFkZENsYXNzKCdhY3RpdmUnKTtcXG5cXHRcXHR9XFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBFeHRlbmRzIGV2ZW50IGRhdGEuXFxuXFx0ICogQHByb3RlY3RlZFxcblxcdCAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IC0gVGhlIGV2ZW50IG9iamVjdCB3aGljaCBnZXRzIHRocm93bi5cXG5cXHQgKi9cXG5cXHROYXZpZ2F0aW9uLnByb3RvdHlwZS5vblRyaWdnZXIgPSBmdW5jdGlvbihldmVudCkge1xcblxcdFxcdHZhciBzZXR0aW5ncyA9IHRoaXMuX2NvcmUuc2V0dGluZ3M7XFxuXFxuXFx0XFx0ZXZlbnQucGFnZSA9IHtcXG5cXHRcXHRcXHRpbmRleDogJC5pbkFycmF5KHRoaXMuY3VycmVudCgpLCB0aGlzLl9wYWdlcyksXFxuXFx0XFx0XFx0Y291bnQ6IHRoaXMuX3BhZ2VzLmxlbmd0aCxcXG5cXHRcXHRcXHRzaXplOiBzZXR0aW5ncyAmJiAoc2V0dGluZ3MuY2VudGVyIHx8IHNldHRpbmdzLmF1dG9XaWR0aCB8fCBzZXR0aW5ncy5kb3RzRGF0YVxcblxcdFxcdFxcdFxcdD8gMSA6IHNldHRpbmdzLmRvdHNFYWNoIHx8IHNldHRpbmdzLml0ZW1zKVxcblxcdFxcdH07XFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBHZXRzIHRoZSBjdXJyZW50IHBhZ2UgcG9zaXRpb24gb2YgdGhlIGNhcm91c2VsLlxcblxcdCAqIEBwcm90ZWN0ZWRcXG5cXHQgKiBAcmV0dXJucyB7TnVtYmVyfVxcblxcdCAqL1xcblxcdE5hdmlnYXRpb24ucHJvdG90eXBlLmN1cnJlbnQgPSBmdW5jdGlvbigpIHtcXG5cXHRcXHR2YXIgY3VycmVudCA9IHRoaXMuX2NvcmUucmVsYXRpdmUodGhpcy5fY29yZS5jdXJyZW50KCkpO1xcblxcdFxcdHJldHVybiAkLmdyZXAodGhpcy5fcGFnZXMsICQucHJveHkoZnVuY3Rpb24ocGFnZSwgaW5kZXgpIHtcXG5cXHRcXHRcXHRyZXR1cm4gcGFnZS5zdGFydCA8PSBjdXJyZW50ICYmIHBhZ2UuZW5kID49IGN1cnJlbnQ7XFxuXFx0XFx0fSwgdGhpcykpLnBvcCgpO1xcblxcdH07XFxuXFxuXFx0LyoqXFxuXFx0ICogR2V0cyB0aGUgY3VycmVudCBzdWNjZXNvci9wcmVkZWNlc3NvciBwb3NpdGlvbi5cXG5cXHQgKiBAcHJvdGVjdGVkXFxuXFx0ICogQHJldHVybnMge051bWJlcn1cXG5cXHQgKi9cXG5cXHROYXZpZ2F0aW9uLnByb3RvdHlwZS5nZXRQb3NpdGlvbiA9IGZ1bmN0aW9uKHN1Y2Nlc3Nvcikge1xcblxcdFxcdHZhciBwb3NpdGlvbiwgbGVuZ3RoLFxcblxcdFxcdFxcdHNldHRpbmdzID0gdGhpcy5fY29yZS5zZXR0aW5ncztcXG5cXG5cXHRcXHRpZiAoc2V0dGluZ3Muc2xpZGVCeSA9PSAncGFnZScpIHtcXG5cXHRcXHRcXHRwb3NpdGlvbiA9ICQuaW5BcnJheSh0aGlzLmN1cnJlbnQoKSwgdGhpcy5fcGFnZXMpO1xcblxcdFxcdFxcdGxlbmd0aCA9IHRoaXMuX3BhZ2VzLmxlbmd0aDtcXG5cXHRcXHRcXHRzdWNjZXNzb3IgPyArK3Bvc2l0aW9uIDogLS1wb3NpdGlvbjtcXG5cXHRcXHRcXHRwb3NpdGlvbiA9IHRoaXMuX3BhZ2VzWygocG9zaXRpb24gJSBsZW5ndGgpICsgbGVuZ3RoKSAlIGxlbmd0aF0uc3RhcnQ7XFxuXFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRwb3NpdGlvbiA9IHRoaXMuX2NvcmUucmVsYXRpdmUodGhpcy5fY29yZS5jdXJyZW50KCkpO1xcblxcdFxcdFxcdGxlbmd0aCA9IHRoaXMuX2NvcmUuaXRlbXMoKS5sZW5ndGg7XFxuXFx0XFx0XFx0c3VjY2Vzc29yID8gcG9zaXRpb24gKz0gc2V0dGluZ3Muc2xpZGVCeSA6IHBvc2l0aW9uIC09IHNldHRpbmdzLnNsaWRlQnk7XFxuXFx0XFx0fVxcblxcblxcdFxcdHJldHVybiBwb3NpdGlvbjtcXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIFNsaWRlcyB0byB0aGUgbmV4dCBpdGVtIG9yIHBhZ2UuXFxuXFx0ICogQHB1YmxpY1xcblxcdCAqIEBwYXJhbSB7TnVtYmVyfSBbc3BlZWQ9ZmFsc2VdIC0gVGhlIHRpbWUgaW4gbWlsbGlzZWNvbmRzIGZvciB0aGUgdHJhbnNpdGlvbi5cXG5cXHQgKi9cXG5cXHROYXZpZ2F0aW9uLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24oc3BlZWQpIHtcXG5cXHRcXHQkLnByb3h5KHRoaXMuX292ZXJyaWRlcy50bywgdGhpcy5fY29yZSkodGhpcy5nZXRQb3NpdGlvbih0cnVlKSwgc3BlZWQpO1xcblxcdH07XFxuXFxuXFx0LyoqXFxuXFx0ICogU2xpZGVzIHRvIHRoZSBwcmV2aW91cyBpdGVtIG9yIHBhZ2UuXFxuXFx0ICogQHB1YmxpY1xcblxcdCAqIEBwYXJhbSB7TnVtYmVyfSBbc3BlZWQ9ZmFsc2VdIC0gVGhlIHRpbWUgaW4gbWlsbGlzZWNvbmRzIGZvciB0aGUgdHJhbnNpdGlvbi5cXG5cXHQgKi9cXG5cXHROYXZpZ2F0aW9uLnByb3RvdHlwZS5wcmV2ID0gZnVuY3Rpb24oc3BlZWQpIHtcXG5cXHRcXHQkLnByb3h5KHRoaXMuX292ZXJyaWRlcy50bywgdGhpcy5fY29yZSkodGhpcy5nZXRQb3NpdGlvbihmYWxzZSksIHNwZWVkKTtcXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIFNsaWRlcyB0byB0aGUgc3BlY2lmaWVkIGl0ZW0gb3IgcGFnZS5cXG5cXHQgKiBAcHVibGljXFxuXFx0ICogQHBhcmFtIHtOdW1iZXJ9IHBvc2l0aW9uIC0gVGhlIHBvc2l0aW9uIG9mIHRoZSBpdGVtIG9yIHBhZ2UuXFxuXFx0ICogQHBhcmFtIHtOdW1iZXJ9IFtzcGVlZF0gLSBUaGUgdGltZSBpbiBtaWxsaXNlY29uZHMgZm9yIHRoZSB0cmFuc2l0aW9uLlxcblxcdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW3N0YW5kYXJkPWZhbHNlXSAtIFdoZXRoZXIgdG8gdXNlIHRoZSBzdGFuZGFyZCBiZWhhdmlvdXIgb3Igbm90LlxcblxcdCAqL1xcblxcdE5hdmlnYXRpb24ucHJvdG90eXBlLnRvID0gZnVuY3Rpb24ocG9zaXRpb24sIHNwZWVkLCBzdGFuZGFyZCkge1xcblxcdFxcdHZhciBsZW5ndGg7XFxuXFxuXFx0XFx0aWYgKCFzdGFuZGFyZCAmJiB0aGlzLl9wYWdlcy5sZW5ndGgpIHtcXG5cXHRcXHRcXHRsZW5ndGggPSB0aGlzLl9wYWdlcy5sZW5ndGg7XFxuXFx0XFx0XFx0JC5wcm94eSh0aGlzLl9vdmVycmlkZXMudG8sIHRoaXMuX2NvcmUpKHRoaXMuX3BhZ2VzWygocG9zaXRpb24gJSBsZW5ndGgpICsgbGVuZ3RoKSAlIGxlbmd0aF0uc3RhcnQsIHNwZWVkKTtcXG5cXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdCQucHJveHkodGhpcy5fb3ZlcnJpZGVzLnRvLCB0aGlzLl9jb3JlKShwb3NpdGlvbiwgc3BlZWQpO1xcblxcdFxcdH1cXG5cXHR9O1xcblxcblxcdCQuZm4ub3dsQ2Fyb3VzZWwuQ29uc3RydWN0b3IuUGx1Z2lucy5OYXZpZ2F0aW9uID0gTmF2aWdhdGlvbjtcXG5cXG59KSh3aW5kb3cuWmVwdG8gfHwgX193ZWJwYWNrX3Byb3ZpZGVkX3dpbmRvd19kb3RfalF1ZXJ5LCB3aW5kb3csIGRvY3VtZW50KTtcXG5cXG4vKipcXG4gKiBIYXNoIFBsdWdpblxcbiAqIEB2ZXJzaW9uIDIuMS4wXFxuICogQGF1dGhvciBBcnR1cyBLb2xhbm93c2tpXFxuICogQGF1dGhvciBEYXZpZCBEZXV0c2NoXFxuICogQGxpY2Vuc2UgVGhlIE1JVCBMaWNlbnNlIChNSVQpXFxuICovXFxuOyhmdW5jdGlvbigkLCB3aW5kb3csIGRvY3VtZW50LCB1bmRlZmluZWQpIHtcXG5cXHQndXNlIHN0cmljdCc7XFxuXFxuXFx0LyoqXFxuXFx0ICogQ3JlYXRlcyB0aGUgaGFzaCBwbHVnaW4uXFxuXFx0ICogQGNsYXNzIFRoZSBIYXNoIFBsdWdpblxcblxcdCAqIEBwYXJhbSB7T3dsfSBjYXJvdXNlbCAtIFRoZSBPd2wgQ2Fyb3VzZWxcXG5cXHQgKi9cXG5cXHR2YXIgSGFzaCA9IGZ1bmN0aW9uKGNhcm91c2VsKSB7XFxuXFx0XFx0LyoqXFxuXFx0XFx0ICogUmVmZXJlbmNlIHRvIHRoZSBjb3JlLlxcblxcdFxcdCAqIEBwcm90ZWN0ZWRcXG5cXHRcXHQgKiBAdHlwZSB7T3dsfVxcblxcdFxcdCAqL1xcblxcdFxcdHRoaXMuX2NvcmUgPSBjYXJvdXNlbDtcXG5cXG5cXHRcXHQvKipcXG5cXHRcXHQgKiBIYXNoIGluZGV4IGZvciB0aGUgaXRlbXMuXFxuXFx0XFx0ICogQHByb3RlY3RlZFxcblxcdFxcdCAqIEB0eXBlIHtPYmplY3R9XFxuXFx0XFx0ICovXFxuXFx0XFx0dGhpcy5faGFzaGVzID0ge307XFxuXFxuXFx0XFx0LyoqXFxuXFx0XFx0ICogVGhlIGNhcm91c2VsIGVsZW1lbnQuXFxuXFx0XFx0ICogQHR5cGUge2pRdWVyeX1cXG5cXHRcXHQgKi9cXG5cXHRcXHR0aGlzLiRlbGVtZW50ID0gdGhpcy5fY29yZS4kZWxlbWVudDtcXG5cXG5cXHRcXHQvKipcXG5cXHRcXHQgKiBBbGwgZXZlbnQgaGFuZGxlcnMuXFxuXFx0XFx0ICogQHByb3RlY3RlZFxcblxcdFxcdCAqIEB0eXBlIHtPYmplY3R9XFxuXFx0XFx0ICovXFxuXFx0XFx0dGhpcy5faGFuZGxlcnMgPSB7XFxuXFx0XFx0XFx0J2luaXRpYWxpemVkLm93bC5jYXJvdXNlbCc6ICQucHJveHkoZnVuY3Rpb24oZSkge1xcblxcdFxcdFxcdFxcdGlmIChlLm5hbWVzcGFjZSAmJiB0aGlzLl9jb3JlLnNldHRpbmdzLnN0YXJ0UG9zaXRpb24gPT09ICdVUkxIYXNoJykge1xcblxcdFxcdFxcdFxcdFxcdCQod2luZG93KS50cmlnZ2VyKCdoYXNoY2hhbmdlLm93bC5uYXZpZ2F0aW9uJyk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH0sIHRoaXMpLFxcblxcdFxcdFxcdCdwcmVwYXJlZC5vd2wuY2Fyb3VzZWwnOiAkLnByb3h5KGZ1bmN0aW9uKGUpIHtcXG5cXHRcXHRcXHRcXHRpZiAoZS5uYW1lc3BhY2UpIHtcXG5cXHRcXHRcXHRcXHRcXHR2YXIgaGFzaCA9ICQoZS5jb250ZW50KS5maW5kKCdbZGF0YS1oYXNoXScpLmFkZEJhY2soJ1tkYXRhLWhhc2hdJykuYXR0cignZGF0YS1oYXNoJyk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCFoYXNoKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHR0aGlzLl9oYXNoZXNbaGFzaF0gPSBlLmNvbnRlbnQ7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH0sIHRoaXMpLFxcblxcdFxcdFxcdCdjaGFuZ2VkLm93bC5jYXJvdXNlbCc6ICQucHJveHkoZnVuY3Rpb24oZSkge1xcblxcdFxcdFxcdFxcdGlmIChlLm5hbWVzcGFjZSAmJiBlLnByb3BlcnR5Lm5hbWUgPT09ICdwb3NpdGlvbicpIHtcXG5cXHRcXHRcXHRcXHRcXHR2YXIgY3VycmVudCA9IHRoaXMuX2NvcmUuaXRlbXModGhpcy5fY29yZS5yZWxhdGl2ZSh0aGlzLl9jb3JlLmN1cnJlbnQoKSkpLFxcblxcdFxcdFxcdFxcdFxcdFxcdGhhc2ggPSAkLm1hcCh0aGlzLl9oYXNoZXMsIGZ1bmN0aW9uKGl0ZW0sIGhhc2gpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gaXRlbSA9PT0gY3VycmVudCA/IGhhc2ggOiBudWxsO1xcblxcdFxcdFxcdFxcdFxcdFxcdH0pLmpvaW4oKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRpZiAoIWhhc2ggfHwgd2luZG93LmxvY2F0aW9uLmhhc2guc2xpY2UoMSkgPT09IGhhc2gpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm47XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdHdpbmRvdy5sb2NhdGlvbi5oYXNoID0gaGFzaDtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fSwgdGhpcylcXG5cXHRcXHR9O1xcblxcblxcdFxcdC8vIHNldCBkZWZhdWx0IG9wdGlvbnNcXG5cXHRcXHR0aGlzLl9jb3JlLm9wdGlvbnMgPSAkLmV4dGVuZCh7fSwgSGFzaC5EZWZhdWx0cywgdGhpcy5fY29yZS5vcHRpb25zKTtcXG5cXG5cXHRcXHQvLyByZWdpc3RlciB0aGUgZXZlbnQgaGFuZGxlcnNcXG5cXHRcXHR0aGlzLiRlbGVtZW50Lm9uKHRoaXMuX2hhbmRsZXJzKTtcXG5cXG5cXHRcXHQvLyByZWdpc3RlciBldmVudCBsaXN0ZW5lciBmb3IgaGFzaCBuYXZpZ2F0aW9uXFxuXFx0XFx0JCh3aW5kb3cpLm9uKCdoYXNoY2hhbmdlLm93bC5uYXZpZ2F0aW9uJywgJC5wcm94eShmdW5jdGlvbihlKSB7XFxuXFx0XFx0XFx0dmFyIGhhc2ggPSB3aW5kb3cubG9jYXRpb24uaGFzaC5zdWJzdHJpbmcoMSksXFxuXFx0XFx0XFx0XFx0aXRlbXMgPSB0aGlzLl9jb3JlLiRzdGFnZS5jaGlsZHJlbigpLFxcblxcdFxcdFxcdFxcdHBvc2l0aW9uID0gdGhpcy5faGFzaGVzW2hhc2hdICYmIGl0ZW1zLmluZGV4KHRoaXMuX2hhc2hlc1toYXNoXSk7XFxuXFxuXFx0XFx0XFx0aWYgKHBvc2l0aW9uID09PSB1bmRlZmluZWQgfHwgcG9zaXRpb24gPT09IHRoaXMuX2NvcmUuY3VycmVudCgpKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR0aGlzLl9jb3JlLnRvKHRoaXMuX2NvcmUucmVsYXRpdmUocG9zaXRpb24pLCBmYWxzZSwgdHJ1ZSk7XFxuXFx0XFx0fSwgdGhpcykpO1xcblxcdH07XFxuXFxuXFx0LyoqXFxuXFx0ICogRGVmYXVsdCBvcHRpb25zLlxcblxcdCAqIEBwdWJsaWNcXG5cXHQgKi9cXG5cXHRIYXNoLkRlZmF1bHRzID0ge1xcblxcdFxcdFVSTGhhc2hMaXN0ZW5lcjogZmFsc2VcXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIERlc3Ryb3lzIHRoZSBwbHVnaW4uXFxuXFx0ICogQHB1YmxpY1xcblxcdCAqL1xcblxcdEhhc2gucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcXG5cXHRcXHR2YXIgaGFuZGxlciwgcHJvcGVydHk7XFxuXFxuXFx0XFx0JCh3aW5kb3cpLm9mZignaGFzaGNoYW5nZS5vd2wubmF2aWdhdGlvbicpO1xcblxcblxcdFxcdGZvciAoaGFuZGxlciBpbiB0aGlzLl9oYW5kbGVycykge1xcblxcdFxcdFxcdHRoaXMuX2NvcmUuJGVsZW1lbnQub2ZmKGhhbmRsZXIsIHRoaXMuX2hhbmRsZXJzW2hhbmRsZXJdKTtcXG5cXHRcXHR9XFxuXFx0XFx0Zm9yIChwcm9wZXJ0eSBpbiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0aGlzKSkge1xcblxcdFxcdFxcdHR5cGVvZiB0aGlzW3Byb3BlcnR5XSAhPSAnZnVuY3Rpb24nICYmICh0aGlzW3Byb3BlcnR5XSA9IG51bGwpO1xcblxcdFxcdH1cXG5cXHR9O1xcblxcblxcdCQuZm4ub3dsQ2Fyb3VzZWwuQ29uc3RydWN0b3IuUGx1Z2lucy5IYXNoID0gSGFzaDtcXG5cXG59KSh3aW5kb3cuWmVwdG8gfHwgX193ZWJwYWNrX3Byb3ZpZGVkX3dpbmRvd19kb3RfalF1ZXJ5LCB3aW5kb3csIGRvY3VtZW50KTtcXG5cXG4vKipcXG4gKiBTdXBwb3J0IFBsdWdpblxcbiAqXFxuICogQHZlcnNpb24gMi4xLjBcXG4gKiBAYXV0aG9yIFZpdmlkIFBsYW5ldCBTb2Z0d2FyZSBHbWJIXFxuICogQGF1dGhvciBBcnR1cyBLb2xhbm93c2tpXFxuICogQGF1dGhvciBEYXZpZCBEZXV0c2NoXFxuICogQGxpY2Vuc2UgVGhlIE1JVCBMaWNlbnNlIChNSVQpXFxuICovXFxuOyhmdW5jdGlvbigkLCB3aW5kb3csIGRvY3VtZW50LCB1bmRlZmluZWQpIHtcXG5cXG5cXHR2YXIgc3R5bGUgPSAkKCc8c3VwcG9ydD4nKS5nZXQoMCkuc3R5bGUsXFxuXFx0XFx0cHJlZml4ZXMgPSAnV2Via2l0IE1veiBPIG1zJy5zcGxpdCgnICcpLFxcblxcdFxcdGV2ZW50cyA9IHtcXG5cXHRcXHRcXHR0cmFuc2l0aW9uOiB7XFxuXFx0XFx0XFx0XFx0ZW5kOiB7XFxuXFx0XFx0XFx0XFx0XFx0V2Via2l0VHJhbnNpdGlvbjogJ3dlYmtpdFRyYW5zaXRpb25FbmQnLFxcblxcdFxcdFxcdFxcdFxcdE1velRyYW5zaXRpb246ICd0cmFuc2l0aW9uZW5kJyxcXG5cXHRcXHRcXHRcXHRcXHRPVHJhbnNpdGlvbjogJ29UcmFuc2l0aW9uRW5kJyxcXG5cXHRcXHRcXHRcXHRcXHR0cmFuc2l0aW9uOiAndHJhbnNpdGlvbmVuZCdcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fSxcXG5cXHRcXHRcXHRhbmltYXRpb246IHtcXG5cXHRcXHRcXHRcXHRlbmQ6IHtcXG5cXHRcXHRcXHRcXHRcXHRXZWJraXRBbmltYXRpb246ICd3ZWJraXRBbmltYXRpb25FbmQnLFxcblxcdFxcdFxcdFxcdFxcdE1vekFuaW1hdGlvbjogJ2FuaW1hdGlvbmVuZCcsXFxuXFx0XFx0XFx0XFx0XFx0T0FuaW1hdGlvbjogJ29BbmltYXRpb25FbmQnLFxcblxcdFxcdFxcdFxcdFxcdGFuaW1hdGlvbjogJ2FuaW1hdGlvbmVuZCdcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcdFxcdH0sXFxuXFx0XFx0dGVzdHMgPSB7XFxuXFx0XFx0XFx0Y3NzdHJhbnNmb3JtczogZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuICEhdGVzdCgndHJhbnNmb3JtJyk7XFxuXFx0XFx0XFx0fSxcXG5cXHRcXHRcXHRjc3N0cmFuc2Zvcm1zM2Q6IGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdFxcdHJldHVybiAhIXRlc3QoJ3BlcnNwZWN0aXZlJyk7XFxuXFx0XFx0XFx0fSxcXG5cXHRcXHRcXHRjc3N0cmFuc2l0aW9uczogZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuICEhdGVzdCgndHJhbnNpdGlvbicpO1xcblxcdFxcdFxcdH0sXFxuXFx0XFx0XFx0Y3NzYW5pbWF0aW9uczogZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuICEhdGVzdCgnYW5pbWF0aW9uJyk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH07XFxuXFxuXFx0ZnVuY3Rpb24gdGVzdChwcm9wZXJ0eSwgcHJlZml4ZWQpIHtcXG5cXHRcXHR2YXIgcmVzdWx0ID0gZmFsc2UsXFxuXFx0XFx0XFx0dXBwZXIgPSBwcm9wZXJ0eS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHByb3BlcnR5LnNsaWNlKDEpO1xcblxcblxcdFxcdCQuZWFjaCgocHJvcGVydHkgKyAnICcgKyBwcmVmaXhlcy5qb2luKHVwcGVyICsgJyAnKSArIHVwcGVyKS5zcGxpdCgnICcpLCBmdW5jdGlvbihpLCBwcm9wZXJ0eSkge1xcblxcdFxcdFxcdGlmIChzdHlsZVtwcm9wZXJ0eV0gIT09IHVuZGVmaW5lZCkge1xcblxcdFxcdFxcdFxcdHJlc3VsdCA9IHByZWZpeGVkID8gcHJvcGVydHkgOiB0cnVlO1xcblxcdFxcdFxcdFxcdHJldHVybiBmYWxzZTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSk7XFxuXFxuXFx0XFx0cmV0dXJuIHJlc3VsdDtcXG5cXHR9XFxuXFxuXFx0ZnVuY3Rpb24gcHJlZml4ZWQocHJvcGVydHkpIHtcXG5cXHRcXHRyZXR1cm4gdGVzdChwcm9wZXJ0eSwgdHJ1ZSk7XFxuXFx0fVxcblxcblxcdGlmICh0ZXN0cy5jc3N0cmFuc2l0aW9ucygpKSB7XFxuXFx0XFx0LyoganNoaW50IC1XMDUzICovXFxuXFx0XFx0JC5zdXBwb3J0LnRyYW5zaXRpb24gPSBuZXcgU3RyaW5nKHByZWZpeGVkKCd0cmFuc2l0aW9uJykpXFxuXFx0XFx0JC5zdXBwb3J0LnRyYW5zaXRpb24uZW5kID0gZXZlbnRzLnRyYW5zaXRpb24uZW5kWyAkLnN1cHBvcnQudHJhbnNpdGlvbiBdO1xcblxcdH1cXG5cXG5cXHRpZiAodGVzdHMuY3NzYW5pbWF0aW9ucygpKSB7XFxuXFx0XFx0LyoganNoaW50IC1XMDUzICovXFxuXFx0XFx0JC5zdXBwb3J0LmFuaW1hdGlvbiA9IG5ldyBTdHJpbmcocHJlZml4ZWQoJ2FuaW1hdGlvbicpKVxcblxcdFxcdCQuc3VwcG9ydC5hbmltYXRpb24uZW5kID0gZXZlbnRzLmFuaW1hdGlvbi5lbmRbICQuc3VwcG9ydC5hbmltYXRpb24gXTtcXG5cXHR9XFxuXFxuXFx0aWYgKHRlc3RzLmNzc3RyYW5zZm9ybXMoKSkge1xcblxcdFxcdC8qIGpzaGludCAtVzA1MyAqL1xcblxcdFxcdCQuc3VwcG9ydC50cmFuc2Zvcm0gPSBuZXcgU3RyaW5nKHByZWZpeGVkKCd0cmFuc2Zvcm0nKSk7XFxuXFx0XFx0JC5zdXBwb3J0LnRyYW5zZm9ybTNkID0gdGVzdHMuY3NzdHJhbnNmb3JtczNkKCk7XFxuXFx0fVxcblxcbn0pKHdpbmRvdy5aZXB0byB8fCBfX3dlYnBhY2tfcHJvdmlkZWRfd2luZG93X2RvdF9qUXVlcnksIHdpbmRvdywgZG9jdW1lbnQpO1xcblxcbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqL30uY2FsbChleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpKSlcXG5cXG4vLy8vLy8vLy8vLy8vLy8vLy9cXG4vLyBXRUJQQUNLIEZPT1RFUlxcbi8vIC4vfi9vd2wuY2Fyb3VzZWwvZGlzdC9vd2wuY2Fyb3VzZWwuanNcXG4vLyBtb2R1bGUgaWQgPSA4XFxuLy8gbW9kdWxlIGNodW5rcyA9IDBcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9+L293bC5jYXJvdXNlbC9kaXN0L293bC5jYXJvdXNlbC5qcz9cIik7XG5cbi8qKiovIH0pLFxuLyogOSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5ldmFsKFwiLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovKGZ1bmN0aW9uKHByb2Nlc3MpIHsvKipcXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cXG4gKlxcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cXG4gKi9cXG5cXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xcbiAgdmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9ICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmXFxuICAgIFN5bWJvbC5mb3IgJiZcXG4gICAgU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpKSB8fFxcbiAgICAweGVhYzc7XFxuXFxuICB2YXIgaXNWYWxpZEVsZW1lbnQgPSBmdW5jdGlvbihvYmplY3QpIHtcXG4gICAgcmV0dXJuIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmXFxuICAgICAgb2JqZWN0ICE9PSBudWxsICYmXFxuICAgICAgb2JqZWN0LiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEU7XFxuICB9O1xcblxcbiAgLy8gQnkgZXhwbGljaXRseSB1c2luZyBgcHJvcC10eXBlc2AgeW91IGFyZSBvcHRpbmcgaW50byBuZXcgZGV2ZWxvcG1lbnQgYmVoYXZpb3IuXFxuICAvLyBodHRwOi8vZmIubWUvcHJvcC10eXBlcy1pbi1wcm9kXFxuICB2YXIgdGhyb3dPbkRpcmVjdEFjY2VzcyA9IHRydWU7XFxuICBtb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19yZXF1aXJlX18oMjEpKGlzVmFsaWRFbGVtZW50LCB0aHJvd09uRGlyZWN0QWNjZXNzKTtcXG59IGVsc2Uge1xcbiAgLy8gQnkgZXhwbGljaXRseSB1c2luZyBgcHJvcC10eXBlc2AgeW91IGFyZSBvcHRpbmcgaW50byBuZXcgcHJvZHVjdGlvbiBiZWhhdmlvci5cXG4gIC8vIGh0dHA6Ly9mYi5tZS9wcm9wLXR5cGVzLWluLXByb2RcXG4gIG1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMCkoKTtcXG59XFxuXFxuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovfS5jYWxsKGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18oMCkpKVxcblxcbi8vLy8vLy8vLy8vLy8vLy8vL1xcbi8vIFdFQlBBQ0sgRk9PVEVSXFxuLy8gLi9+L3Byb3AtdHlwZXMvaW5kZXguanNcXG4vLyBtb2R1bGUgaWQgPSA5XFxuLy8gbW9kdWxlIGNodW5rcyA9IDBcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9+L3Byb3AtdHlwZXMvaW5kZXguanM/XCIpO1xuXG4vKioqLyB9KSxcbi8qIDEwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbmV2YWwoXCIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xcblxcbi8vIGxvYWQgdGhlIHN0eWxlc1xcbnZhciBjb250ZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNCk7XFxuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaSwgY29udGVudCwgJyddXTtcXG4vLyBQcmVwYXJlIGNzc1RyYW5zZm9ybWF0aW9uXFxudmFyIHRyYW5zZm9ybTtcXG5cXG52YXIgb3B0aW9ucyA9IHt9XFxub3B0aW9ucy50cmFuc2Zvcm0gPSB0cmFuc2Zvcm1cXG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXFxudmFyIHVwZGF0ZSA9IF9fd2VicGFja19yZXF1aXJlX18oNykoY29udGVudCwgb3B0aW9ucyk7XFxuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XFxuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxcbmlmKGZhbHNlKSB7XFxuXFx0Ly8gV2hlbiB0aGUgc3R5bGVzIGNoYW5nZSwgdXBkYXRlIHRoZSA8c3R5bGU+IHRhZ3NcXG5cXHRpZighY29udGVudC5sb2NhbHMpIHtcXG5cXHRcXHRtb2R1bGUuaG90LmFjY2VwdChcXFwiISEuLi8uLi8uLi9jc3MtbG9hZGVyL2luZGV4LmpzIS4vb3dsLmNhcm91c2VsLm1pbi5jc3NcXFwiLCBmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHR2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXFxcIiEhLi4vLi4vLi4vY3NzLWxvYWRlci9pbmRleC5qcyEuL293bC5jYXJvdXNlbC5taW4uY3NzXFxcIik7XFxuXFx0XFx0XFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XFxuXFx0XFx0XFx0dXBkYXRlKG5ld0NvbnRlbnQpO1xcblxcdFxcdH0pO1xcblxcdH1cXG5cXHQvLyBXaGVuIHRoZSBtb2R1bGUgaXMgZGlzcG9zZWQsIHJlbW92ZSB0aGUgPHN0eWxlPiB0YWdzXFxuXFx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XFxufVxcblxcbi8vLy8vLy8vLy8vLy8vLy8vL1xcbi8vIFdFQlBBQ0sgRk9PVEVSXFxuLy8gLi9+L293bC5jYXJvdXNlbC9kaXN0L2Fzc2V0cy9vd2wuY2Fyb3VzZWwubWluLmNzc1xcbi8vIG1vZHVsZSBpZCA9IDEwXFxuLy8gbW9kdWxlIGNodW5rcyA9IDBcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9+L293bC5jYXJvdXNlbC9kaXN0L2Fzc2V0cy9vd2wuY2Fyb3VzZWwubWluLmNzcz9cIik7XG5cbi8qKiovIH0pLFxuLyogMTEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuZXZhbChcIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXFxuXFxuLy8gbG9hZCB0aGUgc3R5bGVzXFxudmFyIGNvbnRlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE1KTtcXG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pLCBjb250ZW50LCAnJ11dO1xcbi8vIFByZXBhcmUgY3NzVHJhbnNmb3JtYXRpb25cXG52YXIgdHJhbnNmb3JtO1xcblxcbnZhciBvcHRpb25zID0ge31cXG5vcHRpb25zLnRyYW5zZm9ybSA9IHRyYW5zZm9ybVxcbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cXG52YXIgdXBkYXRlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KShjb250ZW50LCBvcHRpb25zKTtcXG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2FscztcXG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XFxuaWYoZmFsc2UpIHtcXG5cXHQvLyBXaGVuIHRoZSBzdHlsZXMgY2hhbmdlLCB1cGRhdGUgdGhlIDxzdHlsZT4gdGFnc1xcblxcdGlmKCFjb250ZW50LmxvY2Fscykge1xcblxcdFxcdG1vZHVsZS5ob3QuYWNjZXB0KFxcXCIhIS4uLy4uLy4uL2Nzcy1sb2FkZXIvaW5kZXguanMhLi9vd2wudGhlbWUuZGVmYXVsdC5taW4uY3NzXFxcIiwgZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFxcXCIhIS4uLy4uLy4uL2Nzcy1sb2FkZXIvaW5kZXguanMhLi9vd2wudGhlbWUuZGVmYXVsdC5taW4uY3NzXFxcIik7XFxuXFx0XFx0XFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XFxuXFx0XFx0XFx0dXBkYXRlKG5ld0NvbnRlbnQpO1xcblxcdFxcdH0pO1xcblxcdH1cXG5cXHQvLyBXaGVuIHRoZSBtb2R1bGUgaXMgZGlzcG9zZWQsIHJlbW92ZSB0aGUgPHN0eWxlPiB0YWdzXFxuXFx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XFxufVxcblxcbi8vLy8vLy8vLy8vLy8vLy8vL1xcbi8vIFdFQlBBQ0sgRk9PVEVSXFxuLy8gLi9+L293bC5jYXJvdXNlbC9kaXN0L2Fzc2V0cy9vd2wudGhlbWUuZGVmYXVsdC5taW4uY3NzXFxuLy8gbW9kdWxlIGlkID0gMTFcXG4vLyBtb2R1bGUgY2h1bmtzID0gMFxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL34vb3dsLmNhcm91c2VsL2Rpc3QvYXNzZXRzL293bC50aGVtZS5kZWZhdWx0Lm1pbi5jc3M/XCIpO1xuXG4vKioqLyB9KSxcbi8qIDEyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbmV2YWwoXCJtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfMTJfXztcXG5cXG4vLy8vLy8vLy8vLy8vLy8vLy9cXG4vLyBXRUJQQUNLIEZPT1RFUlxcbi8vIGV4dGVybmFsIHtcXFwicm9vdFxcXCI6XFxcIlJlYWN0XFxcIixcXFwiY29tbW9uanMyXFxcIjpcXFwicmVhY3RcXFwiLFxcXCJjb21tb25qc1xcXCI6XFxcInJlYWN0XFxcIixcXFwiYW1kXFxcIjpcXFwicmVhY3RcXFwifVxcbi8vIG1vZHVsZSBpZCA9IDEyXFxuLy8gbW9kdWxlIGNodW5rcyA9IDBcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vZXh0ZXJuYWxfJTdCJTIycm9vdCUyMjolMjJSZWFjdCUyMiwlMjJjb21tb25qczIlMjI6JTIycmVhY3QlMjIsJTIyY29tbW9uanMlMjI6JTIycmVhY3QlMjIsJTIyYW1kJTIyOiUyMnJlYWN0JTIyJTdEP1wiKTtcblxuLyoqKi8gfSksXG4vKiAxMyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbmV2YWwoXCJPYmplY3QuZGVmaW5lUHJvcGVydHkoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcIl9fZXNNb2R1bGVcXFwiLCB7IHZhbHVlOiB0cnVlIH0pO1xcbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbigkKSB7LyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9yZWFjdF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9yZWFjdF9fX2RlZmF1bHQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fLm4oX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX3JlYWN0X18pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfcHJvcF90eXBlc19fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX3Byb3BfdHlwZXNfX19kZWZhdWx0ID0gX193ZWJwYWNrX3JlcXVpcmVfXy5uKF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9wcm9wX3R5cGVzX18pO1xcblxcblxcbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XFxuXFxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcXFwidmFsdWVcXFwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XFxuXFxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKG9iaiwga2V5cykgeyB2YXIgdGFyZ2V0ID0ge307IGZvciAodmFyIGkgaW4gb2JqKSB7IGlmIChrZXlzLmluZGV4T2YoaSkgPj0gMCkgY29udGludWU7IGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgaSkpIGNvbnRpbnVlOyB0YXJnZXRbaV0gPSBvYmpbaV07IH0gcmV0dXJuIHRhcmdldDsgfVxcblxcbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXFxcIik7IH0gfVxcblxcbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcXFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXFxcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcXFwib2JqZWN0XFxcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXFxcImZ1bmN0aW9uXFxcIikgPyBjYWxsIDogc2VsZjsgfVxcblxcbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFxcXCJmdW5jdGlvblxcXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFxcXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFxcXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XFxuXFxuXFxuXFxuXFxudmFyIE93bF9DYXJvdXNlbF9PcHRpb25zID0ge1xcblxcbiAgICAvLyBvcHRpb25zXFxuICAgIGl0ZW1zOiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfcHJvcF90eXBlc19fX2RlZmF1bHQuYS5udW1iZXIsXFxuICAgIG1hcmdpbjogX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX3Byb3BfdHlwZXNfX19kZWZhdWx0LmEubnVtYmVyLFxcbiAgICBsb29wOiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfcHJvcF90eXBlc19fX2RlZmF1bHQuYS5ib29sLFxcbiAgICBjZW50ZXI6IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9wcm9wX3R5cGVzX19fZGVmYXVsdC5hLmJvb2wsXFxuICAgIG1vdXNlRHJhZzogX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX3Byb3BfdHlwZXNfX19kZWZhdWx0LmEuYm9vbCxcXG4gICAgdG91Y2hEcmFnOiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfcHJvcF90eXBlc19fX2RlZmF1bHQuYS5ib29sLFxcbiAgICBwdWxsRHJhZzogX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX3Byb3BfdHlwZXNfX19kZWZhdWx0LmEuYm9vbCxcXG4gICAgZnJlZURyYWc6IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9wcm9wX3R5cGVzX19fZGVmYXVsdC5hLmJvb2wsXFxuICAgIHN0YWdlUGFkZGluZzogX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX3Byb3BfdHlwZXNfX19kZWZhdWx0LmEubnVtYmVyLFxcbiAgICBtZXJnZTogX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX3Byb3BfdHlwZXNfX19kZWZhdWx0LmEuYm9vbCxcXG4gICAgbWVyZ2VGaXQ6IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9wcm9wX3R5cGVzX19fZGVmYXVsdC5hLmJvb2wsXFxuICAgIGF1dG9XaWR0aDogX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX3Byb3BfdHlwZXNfX19kZWZhdWx0LmEuYm9vbCxcXG4gICAgc3RhcnRQb3NpdGlvbjogX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX3Byb3BfdHlwZXNfX19kZWZhdWx0LmEub25lT2ZUeXBlKFtfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfcHJvcF90eXBlc19fX2RlZmF1bHQuYS5udW1iZXIsIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9wcm9wX3R5cGVzX19fZGVmYXVsdC5hLnN0cmluZ10pLFxcbiAgICBVUkxoYXNoTGlzdGVuZXI6IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9wcm9wX3R5cGVzX19fZGVmYXVsdC5hLmJvb2wsXFxuICAgIG5hdjogX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX3Byb3BfdHlwZXNfX19kZWZhdWx0LmEuYm9vbCxcXG4gICAgcmV3aW5kOiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfcHJvcF90eXBlc19fX2RlZmF1bHQuYS5ib29sLFxcbiAgICBuYXZUZXh0OiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfcHJvcF90eXBlc19fX2RlZmF1bHQuYS5vbmVPZlR5cGUoW19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9wcm9wX3R5cGVzX19fZGVmYXVsdC5hLmFycmF5T2YoX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX3Byb3BfdHlwZXNfX19kZWZhdWx0LmEuc3RyaW5nKSwgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX3Byb3BfdHlwZXNfX19kZWZhdWx0LmEuYXJyYXlPZihfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfcHJvcF90eXBlc19fX2RlZmF1bHQuYS5lbGVtZW50KV0pLFxcbiAgICBuYXZFbGVtZW50OiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfcHJvcF90eXBlc19fX2RlZmF1bHQuYS5zdHJpbmcsXFxuICAgIHNsaWRlQnk6IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9wcm9wX3R5cGVzX19fZGVmYXVsdC5hLm9uZU9mVHlwZShbX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX3Byb3BfdHlwZXNfX19kZWZhdWx0LmEubnVtYmVyLCBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfcHJvcF90eXBlc19fX2RlZmF1bHQuYS5zdHJpbmddKSxcXG4gICAgZG90czogX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX3Byb3BfdHlwZXNfX19kZWZhdWx0LmEuYm9vbCxcXG4gICAgZG90c0VhY2g6IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9wcm9wX3R5cGVzX19fZGVmYXVsdC5hLm9uZU9mVHlwZShbX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX3Byb3BfdHlwZXNfX19kZWZhdWx0LmEubnVtYmVyLCBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfcHJvcF90eXBlc19fX2RlZmF1bHQuYS5ib29sXSksXFxuICAgIGRvdERhdGE6IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9wcm9wX3R5cGVzX19fZGVmYXVsdC5hLmJvb2wsXFxuICAgIGxhenlMb2FkOiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfcHJvcF90eXBlc19fX2RlZmF1bHQuYS5ib29sLFxcbiAgICBsYXp5Q29udGVudDogX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX3Byb3BfdHlwZXNfX19kZWZhdWx0LmEuYm9vbCxcXG4gICAgYXV0b3BsYXk6IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9wcm9wX3R5cGVzX19fZGVmYXVsdC5hLmJvb2wsXFxuICAgIGF1dG9wbGF5VGltZW91dDogX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX3Byb3BfdHlwZXNfX19kZWZhdWx0LmEubnVtYmVyLFxcbiAgICBhdXRvcGxheUhvdmVyUGF1c2U6IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9wcm9wX3R5cGVzX19fZGVmYXVsdC5hLmJvb2wsXFxuICAgIHNtYXJ0U3BlZWQ6IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9wcm9wX3R5cGVzX19fZGVmYXVsdC5hLm51bWJlcixcXG4gICAgZmx1aWRTcGVlZDogX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX3Byb3BfdHlwZXNfX19kZWZhdWx0LmEuYm9vbCxcXG4gICAgYXV0b3BsYXlTcGVlZDogX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX3Byb3BfdHlwZXNfX19kZWZhdWx0LmEub25lT2ZUeXBlKFtfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfcHJvcF90eXBlc19fX2RlZmF1bHQuYS5udW1iZXIsIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9wcm9wX3R5cGVzX19fZGVmYXVsdC5hLmJvb2xdKSxcXG4gICAgbmF2U3BlZWQ6IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9wcm9wX3R5cGVzX19fZGVmYXVsdC5hLm9uZU9mVHlwZShbX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX3Byb3BfdHlwZXNfX19kZWZhdWx0LmEubnVtYmVyLCBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfcHJvcF90eXBlc19fX2RlZmF1bHQuYS5ib29sXSksXFxuICAgIGRvdHNTcGVlZDogX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX3Byb3BfdHlwZXNfX19kZWZhdWx0LmEub25lT2ZUeXBlKFtfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfcHJvcF90eXBlc19fX2RlZmF1bHQuYS5udW1iZXIsIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9wcm9wX3R5cGVzX19fZGVmYXVsdC5hLmJvb2xdKSxcXG4gICAgZHJhZ0VuZFNwZWVkOiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfcHJvcF90eXBlc19fX2RlZmF1bHQuYS5vbmVPZlR5cGUoW19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9wcm9wX3R5cGVzX19fZGVmYXVsdC5hLm51bWJlciwgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX3Byb3BfdHlwZXNfX19kZWZhdWx0LmEuYm9vbF0pLFxcbiAgICBjYWxsYmFja3M6IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9wcm9wX3R5cGVzX19fZGVmYXVsdC5hLmJvb2wsXFxuICAgIHJlc3BvbnNpdmU6IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9wcm9wX3R5cGVzX19fZGVmYXVsdC5hLm9iamVjdCxcXG4gICAgcmVzcG9uc2l2ZVJlZnJlc2hSYXRlOiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfcHJvcF90eXBlc19fX2RlZmF1bHQuYS5udW1iZXIsXFxuICAgIHJlc3BvbnNpdmVCYXNlRWxlbWVudDogX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX3Byb3BfdHlwZXNfX19kZWZhdWx0LmEuZWxlbWVudCxcXG4gICAgdmlkZW86IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9wcm9wX3R5cGVzX19fZGVmYXVsdC5hLmJvb2wsXFxuICAgIHZpZGVvSGVpZ2h0OiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfcHJvcF90eXBlc19fX2RlZmF1bHQuYS5vbmVPZlR5cGUoW19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9wcm9wX3R5cGVzX19fZGVmYXVsdC5hLm51bWJlciwgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX3Byb3BfdHlwZXNfX19kZWZhdWx0LmEuYm9vbF0pLFxcbiAgICB2aWRlb1dpZHRoOiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfcHJvcF90eXBlc19fX2RlZmF1bHQuYS5vbmVPZlR5cGUoW19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9wcm9wX3R5cGVzX19fZGVmYXVsdC5hLm51bWJlciwgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX3Byb3BfdHlwZXNfX19kZWZhdWx0LmEuYm9vbF0pLFxcbiAgICBhbmltYXRlT3V0OiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfcHJvcF90eXBlc19fX2RlZmF1bHQuYS5vbmVPZlR5cGUoW19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9wcm9wX3R5cGVzX19fZGVmYXVsdC5hLnN0cmluZywgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX3Byb3BfdHlwZXNfX19kZWZhdWx0LmEuYm9vbF0pLFxcbiAgICBhbmltYXRlSW46IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9wcm9wX3R5cGVzX19fZGVmYXVsdC5hLm9uZU9mVHlwZShbX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX3Byb3BfdHlwZXNfX19kZWZhdWx0LmEuc3RyaW5nLCBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfcHJvcF90eXBlc19fX2RlZmF1bHQuYS5ib29sXSksXFxuICAgIGZhbGxiYWNrRWFzaW5nOiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfcHJvcF90eXBlc19fX2RlZmF1bHQuYS5zdHJpbmcsXFxuICAgIGluZm86IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9wcm9wX3R5cGVzX19fZGVmYXVsdC5hLm9uZU9mVHlwZShbX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX3Byb3BfdHlwZXNfX19kZWZhdWx0LmEuZnVuYywgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX3Byb3BfdHlwZXNfX19kZWZhdWx0LmEuYm9vbF0pLFxcbiAgICBuZXN0ZWRJdGVtU2VsZWN0b3I6IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9wcm9wX3R5cGVzX19fZGVmYXVsdC5hLm9uZU9mVHlwZShbX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX3Byb3BfdHlwZXNfX19kZWZhdWx0LmEuc3RyaW5nLCBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfcHJvcF90eXBlc19fX2RlZmF1bHQuYS5ib29sXSksXFxuICAgIGl0ZW1FbGVtZW50OiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfcHJvcF90eXBlc19fX2RlZmF1bHQuYS5zdHJpbmcsXFxuICAgIHN0YWdlRWxlbWVudDogX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX3Byb3BfdHlwZXNfX19kZWZhdWx0LmEuc3RyaW5nLFxcbiAgICBuYXZDb250YWluZXI6IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9wcm9wX3R5cGVzX19fZGVmYXVsdC5hLm9uZU9mVHlwZShbX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX3Byb3BfdHlwZXNfX19kZWZhdWx0LmEuc3RyaW5nLCBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfcHJvcF90eXBlc19fX2RlZmF1bHQuYS5ib29sXSksXFxuICAgIGRvdHNDb250YWluZXI6IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9wcm9wX3R5cGVzX19fZGVmYXVsdC5hLm9uZU9mVHlwZShbX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX3Byb3BfdHlwZXNfX19kZWZhdWx0LmEuc3RyaW5nLCBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfcHJvcF90eXBlc19fX2RlZmF1bHQuYS5ib29sXSksXFxuXFxuICAgIC8vIGRvbSBjbGFzc1xcbiAgICByZWZyZXNoQ2xhc3M6IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9wcm9wX3R5cGVzX19fZGVmYXVsdC5hLnN0cmluZyxcXG4gICAgbG9hZGluZ0NsYXNzOiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfcHJvcF90eXBlc19fX2RlZmF1bHQuYS5zdHJpbmcsXFxuICAgIGxvYWRlZENsYXNzOiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfcHJvcF90eXBlc19fX2RlZmF1bHQuYS5zdHJpbmcsXFxuICAgIHJ0bENsYXNzOiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfcHJvcF90eXBlc19fX2RlZmF1bHQuYS5zdHJpbmcsXFxuICAgIGRyYWdDbGFzczogX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX3Byb3BfdHlwZXNfX19kZWZhdWx0LmEuc3RyaW5nLFxcbiAgICBncmFiQ2xhc3M6IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9wcm9wX3R5cGVzX19fZGVmYXVsdC5hLnN0cmluZyxcXG4gICAgc3RhZ2VDbGFzczogX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX3Byb3BfdHlwZXNfX19kZWZhdWx0LmEuc3RyaW5nLFxcbiAgICBzdGFnZU91dGVyQ2xhc3M6IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9wcm9wX3R5cGVzX19fZGVmYXVsdC5hLnN0cmluZyxcXG4gICAgbmF2Q29udGFpbmVyQ2xhc3M6IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9wcm9wX3R5cGVzX19fZGVmYXVsdC5hLnN0cmluZyxcXG4gICAgbmF2Q2xhc3M6IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9wcm9wX3R5cGVzX19fZGVmYXVsdC5hLmFycmF5T2YoX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX3Byb3BfdHlwZXNfX19kZWZhdWx0LmEuc3RyaW5nKSxcXG4gICAgY29udHJvbHNDbGFzczogX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX3Byb3BfdHlwZXNfX19kZWZhdWx0LmEuc3RyaW5nLFxcbiAgICBkb3RDbGFzczogX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX3Byb3BfdHlwZXNfX19kZWZhdWx0LmEuc3RyaW5nLFxcbiAgICBkb3RzQ2xhc3M6IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9wcm9wX3R5cGVzX19fZGVmYXVsdC5hLnN0cmluZyxcXG4gICAgYXV0b0hlaWdodENsYXNzOiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfcHJvcF90eXBlc19fX2RlZmF1bHQuYS5zdHJpbmcsXFxuICAgIHJlc3BvbnNpdmVDbGFzczogX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX3Byb3BfdHlwZXNfX19kZWZhdWx0LmEub25lT2ZUeXBlKFtfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfcHJvcF90eXBlc19fX2RlZmF1bHQuYS5zdHJpbmcsIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9wcm9wX3R5cGVzX19fZGVmYXVsdC5hLmJvb2xdKSxcXG5cXG4gICAgLy8gZXZlbnRcXG4gICAgb25Jbml0aWFsaXplOiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfcHJvcF90eXBlc19fX2RlZmF1bHQuYS5mdW5jLFxcbiAgICBvbkluaXRpYWxpemVkOiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfcHJvcF90eXBlc19fX2RlZmF1bHQuYS5mdW5jLFxcbiAgICBvblJlc2l6ZTogX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX3Byb3BfdHlwZXNfX19kZWZhdWx0LmEuZnVuYyxcXG4gICAgb25SZXNpemVkOiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfcHJvcF90eXBlc19fX2RlZmF1bHQuYS5mdW5jLFxcbiAgICBvblJlZnJlc2g6IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9wcm9wX3R5cGVzX19fZGVmYXVsdC5hLmZ1bmMsXFxuICAgIG9uUmVmcmVzaGVkOiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfcHJvcF90eXBlc19fX2RlZmF1bHQuYS5mdW5jLFxcbiAgICBvbkRyYWc6IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9wcm9wX3R5cGVzX19fZGVmYXVsdC5hLmZ1bmMsXFxuICAgIG9uRHJhZ2dlZDogX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX3Byb3BfdHlwZXNfX19kZWZhdWx0LmEuZnVuYyxcXG4gICAgb25UcmFuc2xhdGU6IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9wcm9wX3R5cGVzX19fZGVmYXVsdC5hLmZ1bmMsXFxuICAgIG9uVHJhbnNsYXRlZDogX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX3Byb3BfdHlwZXNfX19kZWZhdWx0LmEuZnVuYyxcXG4gICAgb25DaGFuZ2U6IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9wcm9wX3R5cGVzX19fZGVmYXVsdC5hLmZ1bmMsXFxuICAgIG9uQ2hhbmdlZDogX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX3Byb3BfdHlwZXNfX19kZWZhdWx0LmEuZnVuYyxcXG4gICAgb25Mb2FkTGF6eTogX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX3Byb3BfdHlwZXNfX19kZWZhdWx0LmEuZnVuYyxcXG4gICAgb25Mb2FkZWRMYXp5OiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfcHJvcF90eXBlc19fX2RlZmF1bHQuYS5mdW5jLFxcbiAgICBvblN0b3BWaWRlbzogX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX3Byb3BfdHlwZXNfX19kZWZhdWx0LmEuZnVuYyxcXG4gICAgb25QbGF5VmlkZW86IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9wcm9wX3R5cGVzX19fZGVmYXVsdC5hLmZ1bmNcXG59O1xcblxcbnZhciBPd2xDYXJvdXNlbCA9IGZ1bmN0aW9uIChfQ29tcG9uZW50KSB7XFxuICAgIF9pbmhlcml0cyhPd2xDYXJvdXNlbCwgX0NvbXBvbmVudCk7XFxuXFxuICAgIGZ1bmN0aW9uIE93bENhcm91c2VsKHByb3BzLCBjb250ZXh0KSB7XFxuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgT3dsQ2Fyb3VzZWwpO1xcblxcbiAgICAgICAgdmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKE93bENhcm91c2VsLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoT3dsQ2Fyb3VzZWwpKS5jYWxsKHRoaXMsIHByb3BzLCBjb250ZXh0KSk7XFxuXFxuICAgICAgICBfdGhpcy5uZXh0ID0gX3RoaXMubmV4dC5iaW5kKF90aGlzKTtcXG4gICAgICAgIF90aGlzLnByZXYgPSBfdGhpcy5wcmV2LmJpbmQoX3RoaXMpO1xcbiAgICAgICAgX3RoaXMudG8gPSBfdGhpcy50by5iaW5kKF90aGlzKTtcXG4gICAgICAgIF90aGlzLmNyZWF0ZSA9IF90aGlzLmNyZWF0ZS5iaW5kKF90aGlzKTtcXG4gICAgICAgIF90aGlzLmRlc3RvcnkgPSBfdGhpcy5kZXN0b3J5LmJpbmQoX3RoaXMpO1xcbiAgICAgICAgX3RoaXMucGxheSA9IF90aGlzLnBsYXkuYmluZChfdGhpcyk7XFxuICAgICAgICBfdGhpcy5zdG9wID0gX3RoaXMuc3RvcC5iaW5kKF90aGlzKTtcXG4gICAgICAgIHJldHVybiBfdGhpcztcXG4gICAgfVxcblxcbiAgICBfY3JlYXRlQ2xhc3MoT3dsQ2Fyb3VzZWwsIFt7XFxuICAgICAgICBrZXk6ICdjb21wb25lbnRXaWxsTW91bnQnLFxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxNb3VudCgpIHtcXG4gICAgICAgICAgICBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwKTtcXG4gICAgICAgICAgICBfX3dlYnBhY2tfcmVxdWlyZV9fKDExKTtcXG4gICAgICAgICAgICBfX3dlYnBhY2tfcmVxdWlyZV9fKDgpO1xcblxcbiAgICAgICAgICAgIHRoaXMuX2ZpbHRlclByb3BzKHRoaXMucHJvcHMpO1xcbiAgICAgICAgfVxcbiAgICB9LCB7XFxuICAgICAgICBrZXk6ICdjb21wb25lbnREaWRNb3VudCcsXFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY29tcG9uZW50RGlkTW91bnQoKSB7XFxuICAgICAgICAgICAgdGhpcy5vd2xDYXJvdXNlbCA9ICQodGhpcy5pbnN0KTtcXG4gICAgICAgICAgICB0aGlzLm93bENhcm91c2VsLm93bENhcm91c2VsKHRoaXMub3B0aW9ucyk7XFxuICAgICAgICB9XFxuICAgIH0sIHtcXG4gICAgICAgIGtleTogJ2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMnLFxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV4dFByb3BzKSB7XFxuICAgICAgICAgICAgdGhpcy5fZmlsdGVyUHJvcHMobmV4dFByb3BzKTtcXG4gICAgICAgICAgICB0aGlzLmRlc3RvcnkoKTtcXG4gICAgICAgIH1cXG4gICAgfSwge1xcbiAgICAgICAga2V5OiAnY29tcG9uZW50RGlkVXBkYXRlJyxcXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wb25lbnREaWRVcGRhdGUoKSB7XFxuICAgICAgICAgICAgdGhpcy5vd2xDYXJvdXNlbCA9ICQodGhpcy5pbnN0KTtcXG4gICAgICAgICAgICB0aGlzLm93bENhcm91c2VsLm93bENhcm91c2VsKHRoaXMub3B0aW9ucyk7XFxuICAgICAgICB9XFxuICAgIH0sIHtcXG4gICAgICAgIGtleTogJ2NvbXBvbmVudFdpbGxVbm1vdW50JyxcXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcXG4gICAgICAgICAgICB0aGlzLmRlc3RvcnkoKTtcXG4gICAgICAgIH1cXG4gICAgfSwge1xcbiAgICAgICAga2V5OiAnbmV4dCcsXFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gbmV4dChzcGVlZCkge1xcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc3BlZWQgPT0gJ251bWJlcicpIHtcXG4gICAgICAgICAgICAgICAgdGhpcy5vd2xDYXJvdXNlbC50cmlnZ2VyKCduZXh0Lm93bC5jYXJvdXNlbCcsIFtzcGVlZF0pO1xcbiAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgIHRoaXMub3dsQ2Fyb3VzZWwudHJpZ2dlcignbmV4dC5vd2wuY2Fyb3VzZWwnKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgIH0sIHtcXG4gICAgICAgIGtleTogJ3ByZXYnLFxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHByZXYoc3BlZWQpIHtcXG4gICAgICAgICAgICBpZiAodHlwZW9mIHNwZWVkID09ICdudW1iZXInKSB7XFxuICAgICAgICAgICAgICAgIHRoaXMub3dsQ2Fyb3VzZWwudHJpZ2dlcigncHJldi5vd2wuY2Fyb3VzZWwnLCBbc3BlZWRdKTtcXG4gICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICB0aGlzLm93bENhcm91c2VsLnRyaWdnZXIoJ3ByZXYub3dsLmNhcm91c2VsJyk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfVxcblxcbiAgICAgICAgLy8gcmVmcmVzaChldmVudCwgc3BlZWQpIHtcXG4gICAgICAgIC8vIH1cXG5cXG4gICAgfSwge1xcbiAgICAgICAga2V5OiAndG8nLFxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHRvKHBvc2l0aW9uLCBzcGVlZCkge1xcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcG9zaXRpb24gPT0gJ251bWJlcicgJiYgdHlwZW9mIHNwZWVkID09ICdudW1iZXInKSB7XFxuICAgICAgICAgICAgICAgIHRoaXMub3dsQ2Fyb3VzZWwudHJpZ2dlcigndG8ub3dsLmNhcm91c2VsJywgW3Bvc2l0aW9uLCBzcGVlZF0pO1xcbiAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgIHRoaXMub3dsQ2Fyb3VzZWwudHJpZ2dlcigndG8ub3dsLmNhcm91c2VsJyk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICB9LCB7XFxuICAgICAgICBrZXk6ICdjcmVhdGUnLFxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZSgpIHtcXG4gICAgICAgICAgICB0aGlzLm93bENhcm91c2VsLm93bENhcm91c2VsKHRoaXMub3B0aW9ucyk7XFxuICAgICAgICB9XFxuICAgIH0sIHtcXG4gICAgICAgIGtleTogJ2Rlc3RvcnknLFxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRlc3RvcnkoKSB7XFxuICAgICAgICAgICAgdGhpcy5vd2xDYXJvdXNlbC50cmlnZ2VyKCdkZXN0cm95Lm93bC5jYXJvdXNlbCcpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgLy8gcmVwbGFjZShkYXRhKSB7XFxuXFxuICAgICAgICAvLyB9XFxuXFxuICAgICAgICAvLyBhZGQoZGF0YSwgcG9zaXRpb24pIHtcXG5cXG4gICAgICAgIC8vIH1cXG5cXG4gICAgICAgIC8vIHJlbW92ZShwb3NpdGlvbikge1xcblxcbiAgICAgICAgLy8gfVxcblxcbiAgICB9LCB7XFxuICAgICAgICBrZXk6ICdwbGF5JyxcXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBwbGF5KHRpbWVvdXQsIHNwZWVkKSB7XFxuICAgICAgICAgICAgaWYgKHR5cGVvZiB0aW1lb3V0ID09ICdudW1iZXInICYmIHR5cGVvZiBzcGVlZCA9PSAnbnVtYmVyJykge1xcbiAgICAgICAgICAgICAgICB0aGlzLm93bENhcm91c2VsLnRyaWdnZXIoJ3BsYXkub3dsLmF1dG9wbGF5JywgW3RpbWVvdXQsIHNwZWVkXSk7XFxuICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgdGhpcy5vd2xDYXJvdXNlbC50cmlnZ2VyKCdwbGF5Lm93bC5hdXRvcGxheScpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgfSwge1xcbiAgICAgICAga2V5OiAnc3RvcCcsXFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gc3RvcCgpIHtcXG4gICAgICAgICAgICB0aGlzLm93bENhcm91c2VsLnRyaWdnZXIoJ3N0b3Aub3dsLmF1dG9wbGF5Jyk7XFxuICAgICAgICB9XFxuICAgIH0sIHtcXG4gICAgICAgIGtleTogJ19maWx0ZXJQcm9wcycsXFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2ZpbHRlclByb3BzKHByb3BzKSB7XFxuICAgICAgICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XFxuXFxuICAgICAgICAgICAgdGhpcy5vcHRpb25zID0ge307XFxuICAgICAgICAgICAgdGhpcy5wcm9wc1dpdGhvdXRPcHRpb25zID0ge307XFxuICAgICAgICAgICAgT2JqZWN0LmtleXMocHJvcHMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xcbiAgICAgICAgICAgICAgICBpZiAoT3dsX0Nhcm91c2VsX09wdGlvbnMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMyLm9wdGlvbnNba2V5XSA9IHByb3BzW2tleV07XFxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgICAgICBfdGhpczIucHJvcHNXaXRob3V0T3B0aW9uc1trZXldID0gcHJvcHNba2V5XTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH0pO1xcbiAgICAgICAgfVxcbiAgICB9LCB7XFxuICAgICAgICBrZXk6ICdyZW5kZXInLFxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcigpIHtcXG4gICAgICAgICAgICB2YXIgX3RoaXMzID0gdGhpcztcXG5cXG4gICAgICAgICAgICB2YXIgX3Byb3BzV2l0aG91dE9wdGlvbnMgPSB0aGlzLnByb3BzV2l0aG91dE9wdGlvbnMsXFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZSA9IF9wcm9wc1dpdGhvdXRPcHRpb25zLmNsYXNzTmFtZSxcXG4gICAgICAgICAgICAgICAgY2hpbGRyZW4gPSBfcHJvcHNXaXRob3V0T3B0aW9ucy5jaGlsZHJlbixcXG4gICAgICAgICAgICAgICAgcHJvcHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3Byb3BzV2l0aG91dE9wdGlvbnMsIFsnY2xhc3NOYW1lJywgJ2NoaWxkcmVuJ10pO1xcblxcbiAgICAgICAgICAgIHJldHVybiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfcmVhY3RfX19kZWZhdWx0LmEuY3JlYXRlRWxlbWVudChcXG4gICAgICAgICAgICAgICAgJ2RpdicsXFxuICAgICAgICAgICAgICAgIF9leHRlbmRzKHtcXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogJ293bC1jYXJvdXNlbCAnICsgY2xhc3NOYW1lLFxcbiAgICAgICAgICAgICAgICAgICAgcmVmOiBmdW5jdGlvbiByZWYoaW5zdCkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpczMuaW5zdCA9IGluc3Q7XFxuICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIH0sIHByb3BzKSxcXG4gICAgICAgICAgICAgICAgY2hpbGRyZW5cXG4gICAgICAgICAgICApO1xcbiAgICAgICAgfVxcbiAgICB9XSk7XFxuXFxuICAgIHJldHVybiBPd2xDYXJvdXNlbDtcXG59KF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9yZWFjdF9fW1xcXCJDb21wb25lbnRcXFwiXSk7XFxuXFxuT3dsQ2Fyb3VzZWwucHJvcFR5cGVzID0gT3dsX0Nhcm91c2VsX09wdGlvbnM7XFxuXFxuT3dsQ2Fyb3VzZWwuZGVmYXVsdFByb3BzID0ge1xcbiAgICBjbGFzc05hbWU6ICcnXFxufTtcXG5cXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXFxcImRlZmF1bHRcXFwiXSA9IChPd2xDYXJvdXNlbCk7XFxuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovfS5jYWxsKF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18oMSkpKVxcblxcbi8vLy8vLy8vLy8vLy8vLy8vL1xcbi8vIFdFQlBBQ0sgRk9PVEVSXFxuLy8gLi9jb21wb25lbnRzL093bENhcm91c2VsLmpzeFxcbi8vIG1vZHVsZSBpZCA9IDEzXFxuLy8gbW9kdWxlIGNodW5rcyA9IDBcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9jb21wb25lbnRzL093bENhcm91c2VsLmpzeD9cIik7XG5cbi8qKiovIH0pLFxuLyogMTQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuZXZhbChcInZhciBlc2NhcGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE2KTtcXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpKGZhbHNlKTtcXG4vLyBpbXBvcnRzXFxuXFxuXFxuLy8gbW9kdWxlXFxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaSwgXFxcIi8qKlxcXFxuICogT3dsIENhcm91c2VsIHYyLjIuMFxcXFxuICogQ29weXJpZ2h0IDIwMTMtMjAxNiBEYXZpZCBEZXV0c2NoXFxcXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS9Pd2xDYXJvdXNlbDIvT3dsQ2Fyb3VzZWwyL2Jsb2IvbWFzdGVyL0xJQ0VOU0UpXFxcXG4gKi9cXFxcbi5vd2wtY2Fyb3VzZWwsLm93bC1jYXJvdXNlbCAub3dsLWl0ZW17LXdlYmtpdC10YXAtaGlnaGxpZ2h0LWNvbG9yOnRyYW5zcGFyZW50O3Bvc2l0aW9uOnJlbGF0aXZlfS5vd2wtY2Fyb3VzZWx7ZGlzcGxheTpub25lO3dpZHRoOjEwMCU7ei1pbmRleDoxfS5vd2wtY2Fyb3VzZWwgLm93bC1zdGFnZXtwb3NpdGlvbjpyZWxhdGl2ZTstbXMtdG91Y2gtYWN0aW9uOnBhbi1ZfS5vd2wtY2Fyb3VzZWwgLm93bC1zdGFnZTphZnRlcntjb250ZW50OlxcXFxcXFwiLlxcXFxcXFwiO2Rpc3BsYXk6YmxvY2s7Y2xlYXI6Ym90aDt2aXNpYmlsaXR5OmhpZGRlbjtsaW5lLWhlaWdodDowO2hlaWdodDowfS5vd2wtY2Fyb3VzZWwgLm93bC1zdGFnZS1vdXRlcntwb3NpdGlvbjpyZWxhdGl2ZTtvdmVyZmxvdzpoaWRkZW47LXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlM2QoMCwwLDApfS5vd2wtY2Fyb3VzZWwgLm93bC1pdGVte21pbi1oZWlnaHQ6MXB4O2Zsb2F0OmxlZnQ7LXdlYmtpdC1iYWNrZmFjZS12aXNpYmlsaXR5OmhpZGRlbjstd2Via2l0LXRvdWNoLWNhbGxvdXQ6bm9uZX0ub3dsLWNhcm91c2VsIC5vd2wtaXRlbSBpbWd7ZGlzcGxheTpibG9jazt3aWR0aDoxMDAlOy13ZWJraXQtdHJhbnNmb3JtLXN0eWxlOnByZXNlcnZlLTNkfS5vd2wtY2Fyb3VzZWwgLm93bC1kb3RzLmRpc2FibGVkLC5vd2wtY2Fyb3VzZWwgLm93bC1uYXYuZGlzYWJsZWR7ZGlzcGxheTpub25lfS5uby1qcyAub3dsLWNhcm91c2VsLC5vd2wtY2Fyb3VzZWwub3dsLWxvYWRlZHtkaXNwbGF5OmJsb2NrfS5vd2wtY2Fyb3VzZWwgLm93bC1kb3QsLm93bC1jYXJvdXNlbCAub3dsLW5hdiAub3dsLW5leHQsLm93bC1jYXJvdXNlbCAub3dsLW5hdiAub3dsLXByZXZ7Y3Vyc29yOnBvaW50ZXI7Y3Vyc29yOmhhbmQ7LXdlYmtpdC11c2VyLXNlbGVjdDpub25lOy1raHRtbC11c2VyLXNlbGVjdDpub25lOy1tb3otdXNlci1zZWxlY3Q6bm9uZTstbXMtdXNlci1zZWxlY3Q6bm9uZTt1c2VyLXNlbGVjdDpub25lfS5vd2wtY2Fyb3VzZWwub3dsLWxvYWRpbmd7b3BhY2l0eTowO2Rpc3BsYXk6YmxvY2t9Lm93bC1jYXJvdXNlbC5vd2wtaGlkZGVue29wYWNpdHk6MH0ub3dsLWNhcm91c2VsLm93bC1yZWZyZXNoIC5vd2wtaXRlbXt2aXNpYmlsaXR5OmhpZGRlbn0ub3dsLWNhcm91c2VsLm93bC1kcmFnIC5vd2wtaXRlbXstd2Via2l0LXVzZXItc2VsZWN0Om5vbmU7LW1vei11c2VyLXNlbGVjdDpub25lOy1tcy11c2VyLXNlbGVjdDpub25lO3VzZXItc2VsZWN0Om5vbmV9Lm93bC1jYXJvdXNlbC5vd2wtZ3JhYntjdXJzb3I6bW92ZTtjdXJzb3I6Z3JhYn0ub3dsLWNhcm91c2VsLm93bC1ydGx7ZGlyZWN0aW9uOnJ0bH0ub3dsLWNhcm91c2VsLm93bC1ydGwgLm93bC1pdGVte2Zsb2F0OnJpZ2h0fS5vd2wtY2Fyb3VzZWwgLmFuaW1hdGVkey13ZWJraXQtYW5pbWF0aW9uLWR1cmF0aW9uOjFzO2FuaW1hdGlvbi1kdXJhdGlvbjoxczstd2Via2l0LWFuaW1hdGlvbi1maWxsLW1vZGU6Ym90aDthbmltYXRpb24tZmlsbC1tb2RlOmJvdGh9Lm93bC1jYXJvdXNlbCAub3dsLWFuaW1hdGVkLWlue3otaW5kZXg6MH0ub3dsLWNhcm91c2VsIC5vd2wtYW5pbWF0ZWQtb3V0e3otaW5kZXg6MX0ub3dsLWNhcm91c2VsIC5mYWRlT3V0ey13ZWJraXQtYW5pbWF0aW9uLW5hbWU6ZmFkZU91dDthbmltYXRpb24tbmFtZTpmYWRlT3V0fUAtd2Via2l0LWtleWZyYW1lcyBmYWRlT3V0ezAle29wYWNpdHk6MX0xMDAle29wYWNpdHk6MH19QGtleWZyYW1lcyBmYWRlT3V0ezAle29wYWNpdHk6MX0xMDAle29wYWNpdHk6MH19Lm93bC1oZWlnaHR7dHJhbnNpdGlvbjpoZWlnaHQgLjVzIGVhc2UtaW4tb3V0fS5vd2wtY2Fyb3VzZWwgLm93bC1pdGVtIC5vd2wtbGF6eXtvcGFjaXR5OjA7dHJhbnNpdGlvbjpvcGFjaXR5IC40cyBlYXNlfS5vd2wtY2Fyb3VzZWwgLm93bC1pdGVtIGltZy5vd2wtbGF6eXstd2Via2l0LXRyYW5zZm9ybS1zdHlsZTpwcmVzZXJ2ZS0zZDt0cmFuc2Zvcm0tc3R5bGU6cHJlc2VydmUtM2R9Lm93bC1jYXJvdXNlbCAub3dsLXZpZGVvLXdyYXBwZXJ7cG9zaXRpb246cmVsYXRpdmU7aGVpZ2h0OjEwMCU7YmFja2dyb3VuZDojMDAwfS5vd2wtY2Fyb3VzZWwgLm93bC12aWRlby1wbGF5LWljb257cG9zaXRpb246YWJzb2x1dGU7aGVpZ2h0OjgwcHg7d2lkdGg6ODBweDtsZWZ0OjUwJTt0b3A6NTAlO21hcmdpbi1sZWZ0Oi00MHB4O21hcmdpbi10b3A6LTQwcHg7YmFja2dyb3VuZDp1cmwoXFxcIiArIGVzY2FwZShfX3dlYnBhY2tfcmVxdWlyZV9fKDE3KSkgKyBcXFwiKSBuby1yZXBlYXQ7Y3Vyc29yOnBvaW50ZXI7ei1pbmRleDoxOy13ZWJraXQtYmFja2ZhY2UtdmlzaWJpbGl0eTpoaWRkZW47dHJhbnNpdGlvbjotd2Via2l0LXRyYW5zZm9ybSAuMXMgZWFzZTt0cmFuc2l0aW9uOnRyYW5zZm9ybSAuMXMgZWFzZX0ub3dsLWNhcm91c2VsIC5vd2wtdmlkZW8tcGxheS1pY29uOmhvdmVyey13ZWJraXQtdHJhbnNmb3JtOnNjYWxlKDEuMywxLjMpOy1tcy10cmFuc2Zvcm06c2NhbGUoMS4zLDEuMyk7dHJhbnNmb3JtOnNjYWxlKDEuMywxLjMpfS5vd2wtY2Fyb3VzZWwgLm93bC12aWRlby1wbGF5aW5nIC5vd2wtdmlkZW8tcGxheS1pY29uLC5vd2wtY2Fyb3VzZWwgLm93bC12aWRlby1wbGF5aW5nIC5vd2wtdmlkZW8tdG57ZGlzcGxheTpub25lfS5vd2wtY2Fyb3VzZWwgLm93bC12aWRlby10bntvcGFjaXR5OjA7aGVpZ2h0OjEwMCU7YmFja2dyb3VuZC1wb3NpdGlvbjpjZW50ZXIgY2VudGVyO2JhY2tncm91bmQtcmVwZWF0Om5vLXJlcGVhdDtiYWNrZ3JvdW5kLXNpemU6Y29udGFpbjt0cmFuc2l0aW9uOm9wYWNpdHkgLjRzIGVhc2V9Lm93bC1jYXJvdXNlbCAub3dsLXZpZGVvLWZyYW1le3Bvc2l0aW9uOnJlbGF0aXZlO3otaW5kZXg6MTtoZWlnaHQ6MTAwJTt3aWR0aDoxMDAlfVxcXCIsIFxcXCJcXFwiXSk7XFxuXFxuLy8gZXhwb3J0c1xcblxcblxcbi8vLy8vLy8vLy8vLy8vLy8vL1xcbi8vIFdFQlBBQ0sgRk9PVEVSXFxuLy8gLi9+L2Nzcy1sb2FkZXIhLi9+L293bC5jYXJvdXNlbC9kaXN0L2Fzc2V0cy9vd2wuY2Fyb3VzZWwubWluLmNzc1xcbi8vIG1vZHVsZSBpZCA9IDE0XFxuLy8gbW9kdWxlIGNodW5rcyA9IDBcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9+L293bC5jYXJvdXNlbC9kaXN0L2Fzc2V0cy9vd2wuY2Fyb3VzZWwubWluLmNzcz8uL34vY3NzLWxvYWRlclwiKTtcblxuLyoqKi8gfSksXG4vKiAxNSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5ldmFsKFwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KShmYWxzZSk7XFxuLy8gaW1wb3J0c1xcblxcblxcbi8vIG1vZHVsZVxcbmV4cG9ydHMucHVzaChbbW9kdWxlLmksIFxcXCIvKipcXFxcbiAqIE93bCBDYXJvdXNlbCB2Mi4yLjBcXFxcbiAqIENvcHlyaWdodCAyMDEzLTIwMTYgRGF2aWQgRGV1dHNjaFxcXFxuICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vT3dsQ2Fyb3VzZWwyL093bENhcm91c2VsMi9ibG9iL21hc3Rlci9MSUNFTlNFKVxcXFxuICovXFxcXG4ub3dsLXRoZW1lIC5vd2wtZG90cywub3dsLXRoZW1lIC5vd2wtbmF2e3RleHQtYWxpZ246Y2VudGVyOy13ZWJraXQtdGFwLWhpZ2hsaWdodC1jb2xvcjp0cmFuc3BhcmVudH0ub3dsLXRoZW1lIC5vd2wtbmF2e21hcmdpbi10b3A6MTBweH0ub3dsLXRoZW1lIC5vd2wtbmF2IFtjbGFzcyo9b3dsLV17Y29sb3I6I0ZGRjtmb250LXNpemU6MTRweDttYXJnaW46NXB4O3BhZGRpbmc6NHB4IDdweDtiYWNrZ3JvdW5kOiNENkQ2RDY7ZGlzcGxheTppbmxpbmUtYmxvY2s7Y3Vyc29yOnBvaW50ZXI7Ym9yZGVyLXJhZGl1czozcHh9Lm93bC10aGVtZSAub3dsLW5hdiBbY2xhc3MqPW93bC1dOmhvdmVye2JhY2tncm91bmQ6Izg2OTc5MTtjb2xvcjojRkZGO3RleHQtZGVjb3JhdGlvbjpub25lfS5vd2wtdGhlbWUgLm93bC1uYXYgLmRpc2FibGVke29wYWNpdHk6LjU7Y3Vyc29yOmRlZmF1bHR9Lm93bC10aGVtZSAub3dsLW5hdi5kaXNhYmxlZCsub3dsLWRvdHN7bWFyZ2luLXRvcDoxMHB4fS5vd2wtdGhlbWUgLm93bC1kb3RzIC5vd2wtZG90e2Rpc3BsYXk6aW5saW5lLWJsb2NrO3pvb206MX0ub3dsLXRoZW1lIC5vd2wtZG90cyAub3dsLWRvdCBzcGFue3dpZHRoOjEwcHg7aGVpZ2h0OjEwcHg7bWFyZ2luOjVweCA3cHg7YmFja2dyb3VuZDojRDZENkQ2O2Rpc3BsYXk6YmxvY2s7LXdlYmtpdC1iYWNrZmFjZS12aXNpYmlsaXR5OnZpc2libGU7dHJhbnNpdGlvbjpvcGFjaXR5IC4ycyBlYXNlO2JvcmRlci1yYWRpdXM6MzBweH0ub3dsLXRoZW1lIC5vd2wtZG90cyAub3dsLWRvdC5hY3RpdmUgc3Bhbiwub3dsLXRoZW1lIC5vd2wtZG90cyAub3dsLWRvdDpob3ZlciBzcGFue2JhY2tncm91bmQ6Izg2OTc5MX1cXFwiLCBcXFwiXFxcIl0pO1xcblxcbi8vIGV4cG9ydHNcXG5cXG5cXG4vLy8vLy8vLy8vLy8vLy8vLy9cXG4vLyBXRUJQQUNLIEZPT1RFUlxcbi8vIC4vfi9jc3MtbG9hZGVyIS4vfi9vd2wuY2Fyb3VzZWwvZGlzdC9hc3NldHMvb3dsLnRoZW1lLmRlZmF1bHQubWluLmNzc1xcbi8vIG1vZHVsZSBpZCA9IDE1XFxuLy8gbW9kdWxlIGNodW5rcyA9IDBcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9+L293bC5jYXJvdXNlbC9kaXN0L2Fzc2V0cy9vd2wudGhlbWUuZGVmYXVsdC5taW4uY3NzPy4vfi9jc3MtbG9hZGVyXCIpO1xuXG4vKioqLyB9KSxcbi8qIDE2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbmV2YWwoXCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGVzY2FwZSh1cmwpIHtcXG4gICAgaWYgKHR5cGVvZiB1cmwgIT09ICdzdHJpbmcnKSB7XFxuICAgICAgICByZXR1cm4gdXJsXFxuICAgIH1cXG4gICAgLy8gSWYgdXJsIGlzIGFscmVhZHkgd3JhcHBlZCBpbiBxdW90ZXMsIHJlbW92ZSB0aGVtXFxuICAgIGlmICgvXlsnXFxcIl0uKlsnXFxcIl0kLy50ZXN0KHVybCkpIHtcXG4gICAgICAgIHVybCA9IHVybC5zbGljZSgxLCAtMSk7XFxuICAgIH1cXG4gICAgLy8gU2hvdWxkIHVybCBiZSB3cmFwcGVkP1xcbiAgICAvLyBTZWUgaHR0cHM6Ly9kcmFmdHMuY3Nzd2cub3JnL2Nzcy12YWx1ZXMtMy8jdXJsc1xcbiAgICBpZiAoL1tcXFwiJygpIFxcXFx0XFxcXG5dLy50ZXN0KHVybCkpIHtcXG4gICAgICAgIHJldHVybiAnXFxcIicgKyB1cmwucmVwbGFjZSgvXFxcIi9nLCAnXFxcXFxcXFxcXFwiJykucmVwbGFjZSgvXFxcXG4vZywgJ1xcXFxcXFxcbicpICsgJ1xcXCInXFxuICAgIH1cXG5cXG4gICAgcmV0dXJuIHVybFxcbn1cXG5cXG5cXG4vLy8vLy8vLy8vLy8vLy8vLy9cXG4vLyBXRUJQQUNLIEZPT1RFUlxcbi8vIC4vfi9jc3MtbG9hZGVyL2xpYi91cmwvZXNjYXBlLmpzXFxuLy8gbW9kdWxlIGlkID0gMTZcXG4vLyBtb2R1bGUgY2h1bmtzID0gMFxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL34vY3NzLWxvYWRlci9saWIvdXJsL2VzY2FwZS5qcz9cIik7XG5cbi8qKiovIH0pLFxuLyogMTcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuZXZhbChcIm1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXy5wICsgXFxcIjRhMzdmODAwODk1OWM3NWY2MTliZjBhM2E0ZTJkN2EyLnBuZ1xcXCI7XFxuXFxuLy8vLy8vLy8vLy8vLy8vLy8vXFxuLy8gV0VCUEFDSyBGT09URVJcXG4vLyAuL34vb3dsLmNhcm91c2VsL2Rpc3QvYXNzZXRzL293bC52aWRlby5wbGF5LnBuZ1xcbi8vIG1vZHVsZSBpZCA9IDE3XFxuLy8gbW9kdWxlIGNodW5rcyA9IDBcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9+L293bC5jYXJvdXNlbC9kaXN0L2Fzc2V0cy9vd2wudmlkZW8ucGxheS5wbmc/XCIpO1xuXG4vKioqLyB9KSxcbi8qIDE4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuZXZhbChcIi8qXFxub2JqZWN0LWFzc2lnblxcbihjKSBTaW5kcmUgU29yaHVzXFxuQGxpY2Vuc2UgTUlUXFxuKi9cXG5cXG5cXG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xcbnZhciBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xcbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XFxudmFyIHByb3BJc0VudW1lcmFibGUgPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xcblxcbmZ1bmN0aW9uIHRvT2JqZWN0KHZhbCkge1xcblxcdGlmICh2YWwgPT09IG51bGwgfHwgdmFsID09PSB1bmRlZmluZWQpIHtcXG5cXHRcXHR0aHJvdyBuZXcgVHlwZUVycm9yKCdPYmplY3QuYXNzaWduIGNhbm5vdCBiZSBjYWxsZWQgd2l0aCBudWxsIG9yIHVuZGVmaW5lZCcpO1xcblxcdH1cXG5cXG5cXHRyZXR1cm4gT2JqZWN0KHZhbCk7XFxufVxcblxcbmZ1bmN0aW9uIHNob3VsZFVzZU5hdGl2ZSgpIHtcXG5cXHR0cnkge1xcblxcdFxcdGlmICghT2JqZWN0LmFzc2lnbikge1xcblxcdFxcdFxcdHJldHVybiBmYWxzZTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gRGV0ZWN0IGJ1Z2d5IHByb3BlcnR5IGVudW1lcmF0aW9uIG9yZGVyIGluIG9sZGVyIFY4IHZlcnNpb25zLlxcblxcblxcdFxcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTQxMThcXG5cXHRcXHR2YXIgdGVzdDEgPSBuZXcgU3RyaW5nKCdhYmMnKTsgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3LXdyYXBwZXJzXFxuXFx0XFx0dGVzdDFbNV0gPSAnZGUnO1xcblxcdFxcdGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0ZXN0MSlbMF0gPT09ICc1Jykge1xcblxcdFxcdFxcdHJldHVybiBmYWxzZTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzA1NlxcblxcdFxcdHZhciB0ZXN0MiA9IHt9O1xcblxcdFxcdGZvciAodmFyIGkgPSAwOyBpIDwgMTA7IGkrKykge1xcblxcdFxcdFxcdHRlc3QyWydfJyArIFN0cmluZy5mcm9tQ2hhckNvZGUoaSldID0gaTtcXG5cXHRcXHR9XFxuXFx0XFx0dmFyIG9yZGVyMiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRlc3QyKS5tYXAoZnVuY3Rpb24gKG4pIHtcXG5cXHRcXHRcXHRyZXR1cm4gdGVzdDJbbl07XFxuXFx0XFx0fSk7XFxuXFx0XFx0aWYgKG9yZGVyMi5qb2luKCcnKSAhPT0gJzAxMjM0NTY3ODknKSB7XFxuXFx0XFx0XFx0cmV0dXJuIGZhbHNlO1xcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zMDU2XFxuXFx0XFx0dmFyIHRlc3QzID0ge307XFxuXFx0XFx0J2FiY2RlZmdoaWprbG1ub3BxcnN0Jy5zcGxpdCgnJykuZm9yRWFjaChmdW5jdGlvbiAobGV0dGVyKSB7XFxuXFx0XFx0XFx0dGVzdDNbbGV0dGVyXSA9IGxldHRlcjtcXG5cXHRcXHR9KTtcXG5cXHRcXHRpZiAoT2JqZWN0LmtleXMoT2JqZWN0LmFzc2lnbih7fSwgdGVzdDMpKS5qb2luKCcnKSAhPT1cXG5cXHRcXHRcXHRcXHQnYWJjZGVmZ2hpamtsbW5vcHFyc3QnKSB7XFxuXFx0XFx0XFx0cmV0dXJuIGZhbHNlO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRyZXR1cm4gdHJ1ZTtcXG5cXHR9IGNhdGNoIChlcnIpIHtcXG5cXHRcXHQvLyBXZSBkb24ndCBleHBlY3QgYW55IG9mIHRoZSBhYm92ZSB0byB0aHJvdywgYnV0IGJldHRlciB0byBiZSBzYWZlLlxcblxcdFxcdHJldHVybiBmYWxzZTtcXG5cXHR9XFxufVxcblxcbm1vZHVsZS5leHBvcnRzID0gc2hvdWxkVXNlTmF0aXZlKCkgPyBPYmplY3QuYXNzaWduIDogZnVuY3Rpb24gKHRhcmdldCwgc291cmNlKSB7XFxuXFx0dmFyIGZyb207XFxuXFx0dmFyIHRvID0gdG9PYmplY3QodGFyZ2V0KTtcXG5cXHR2YXIgc3ltYm9scztcXG5cXG5cXHRmb3IgKHZhciBzID0gMTsgcyA8IGFyZ3VtZW50cy5sZW5ndGg7IHMrKykge1xcblxcdFxcdGZyb20gPSBPYmplY3QoYXJndW1lbnRzW3NdKTtcXG5cXG5cXHRcXHRmb3IgKHZhciBrZXkgaW4gZnJvbSkge1xcblxcdFxcdFxcdGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGZyb20sIGtleSkpIHtcXG5cXHRcXHRcXHRcXHR0b1trZXldID0gZnJvbVtrZXldO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFxuXFx0XFx0aWYgKGdldE93blByb3BlcnR5U3ltYm9scykge1xcblxcdFxcdFxcdHN5bWJvbHMgPSBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZnJvbSk7XFxuXFx0XFx0XFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzeW1ib2xzLmxlbmd0aDsgaSsrKSB7XFxuXFx0XFx0XFx0XFx0aWYgKHByb3BJc0VudW1lcmFibGUuY2FsbChmcm9tLCBzeW1ib2xzW2ldKSkge1xcblxcdFxcdFxcdFxcdFxcdHRvW3N5bWJvbHNbaV1dID0gZnJvbVtzeW1ib2xzW2ldXTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXHR9XFxuXFxuXFx0cmV0dXJuIHRvO1xcbn07XFxuXFxuXFxuLy8vLy8vLy8vLy8vLy8vLy8vXFxuLy8gV0VCUEFDSyBGT09URVJcXG4vLyAuL34vb2JqZWN0LWFzc2lnbi9pbmRleC5qc1xcbi8vIG1vZHVsZSBpZCA9IDE4XFxuLy8gbW9kdWxlIGNodW5rcyA9IDBcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9+L29iamVjdC1hc3NpZ24vaW5kZXguanM/XCIpO1xuXG4vKioqLyB9KSxcbi8qIDE5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuZXZhbChcIi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbihwcm9jZXNzKSB7LyoqXFxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXFxuICpcXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXFxuICovXFxuXFxuXFxuXFxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcXG4gIHZhciBpbnZhcmlhbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xcbiAgdmFyIHdhcm5pbmcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xcbiAgdmFyIFJlYWN0UHJvcFR5cGVzU2VjcmV0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcXG4gIHZhciBsb2dnZWRUeXBlRmFpbHVyZXMgPSB7fTtcXG59XFxuXFxuLyoqXFxuICogQXNzZXJ0IHRoYXQgdGhlIHZhbHVlcyBtYXRjaCB3aXRoIHRoZSB0eXBlIHNwZWNzLlxcbiAqIEVycm9yIG1lc3NhZ2VzIGFyZSBtZW1vcml6ZWQgYW5kIHdpbGwgb25seSBiZSBzaG93biBvbmNlLlxcbiAqXFxuICogQHBhcmFtIHtvYmplY3R9IHR5cGVTcGVjcyBNYXAgb2YgbmFtZSB0byBhIFJlYWN0UHJvcFR5cGVcXG4gKiBAcGFyYW0ge29iamVjdH0gdmFsdWVzIFJ1bnRpbWUgdmFsdWVzIHRoYXQgbmVlZCB0byBiZSB0eXBlLWNoZWNrZWRcXG4gKiBAcGFyYW0ge3N0cmluZ30gbG9jYXRpb24gZS5nLiBcXFwicHJvcFxcXCIsIFxcXCJjb250ZXh0XFxcIiwgXFxcImNoaWxkIGNvbnRleHRcXFwiXFxuICogQHBhcmFtIHtzdHJpbmd9IGNvbXBvbmVudE5hbWUgTmFtZSBvZiB0aGUgY29tcG9uZW50IGZvciBlcnJvciBtZXNzYWdlcy5cXG4gKiBAcGFyYW0gez9GdW5jdGlvbn0gZ2V0U3RhY2sgUmV0dXJucyB0aGUgY29tcG9uZW50IHN0YWNrLlxcbiAqIEBwcml2YXRlXFxuICovXFxuZnVuY3Rpb24gY2hlY2tQcm9wVHlwZXModHlwZVNwZWNzLCB2YWx1ZXMsIGxvY2F0aW9uLCBjb21wb25lbnROYW1lLCBnZXRTdGFjaykge1xcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcXG4gICAgZm9yICh2YXIgdHlwZVNwZWNOYW1lIGluIHR5cGVTcGVjcykge1xcbiAgICAgIGlmICh0eXBlU3BlY3MuaGFzT3duUHJvcGVydHkodHlwZVNwZWNOYW1lKSkge1xcbiAgICAgICAgdmFyIGVycm9yO1xcbiAgICAgICAgLy8gUHJvcCB0eXBlIHZhbGlkYXRpb24gbWF5IHRocm93LiBJbiBjYXNlIHRoZXkgZG8sIHdlIGRvbid0IHdhbnQgdG9cXG4gICAgICAgIC8vIGZhaWwgdGhlIHJlbmRlciBwaGFzZSB3aGVyZSBpdCBkaWRuJ3QgZmFpbCBiZWZvcmUuIFNvIHdlIGxvZyBpdC5cXG4gICAgICAgIC8vIEFmdGVyIHRoZXNlIGhhdmUgYmVlbiBjbGVhbmVkIHVwLCB3ZSdsbCBsZXQgdGhlbSB0aHJvdy5cXG4gICAgICAgIHRyeSB7XFxuICAgICAgICAgIC8vIFRoaXMgaXMgaW50ZW50aW9uYWxseSBhbiBpbnZhcmlhbnQgdGhhdCBnZXRzIGNhdWdodC4gSXQncyB0aGUgc2FtZVxcbiAgICAgICAgICAvLyBiZWhhdmlvciBhcyB3aXRob3V0IHRoaXMgc3RhdGVtZW50IGV4Y2VwdCB3aXRoIGEgYmV0dGVyIG1lc3NhZ2UuXFxuICAgICAgICAgIGludmFyaWFudCh0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gPT09ICdmdW5jdGlvbicsICclczogJXMgdHlwZSBgJXNgIGlzIGludmFsaWQ7IGl0IG11c3QgYmUgYSBmdW5jdGlvbiwgdXN1YWxseSBmcm9tICcgKyAndGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLCBidXQgcmVjZWl2ZWQgYCVzYC4nLCBjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycsIGxvY2F0aW9uLCB0eXBlU3BlY05hbWUsIHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSk7XFxuICAgICAgICAgIGVycm9yID0gdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0odmFsdWVzLCB0eXBlU3BlY05hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBudWxsLCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XFxuICAgICAgICB9IGNhdGNoIChleCkge1xcbiAgICAgICAgICBlcnJvciA9IGV4O1xcbiAgICAgICAgfVxcbiAgICAgICAgd2FybmluZyghZXJyb3IgfHwgZXJyb3IgaW5zdGFuY2VvZiBFcnJvciwgJyVzOiB0eXBlIHNwZWNpZmljYXRpb24gb2YgJXMgYCVzYCBpcyBpbnZhbGlkOyB0aGUgdHlwZSBjaGVja2VyICcgKyAnZnVuY3Rpb24gbXVzdCByZXR1cm4gYG51bGxgIG9yIGFuIGBFcnJvcmAgYnV0IHJldHVybmVkIGEgJXMuICcgKyAnWW91IG1heSBoYXZlIGZvcmdvdHRlbiB0byBwYXNzIGFuIGFyZ3VtZW50IHRvIHRoZSB0eXBlIGNoZWNrZXIgJyArICdjcmVhdG9yIChhcnJheU9mLCBpbnN0YW5jZU9mLCBvYmplY3RPZiwgb25lT2YsIG9uZU9mVHlwZSwgYW5kICcgKyAnc2hhcGUgYWxsIHJlcXVpcmUgYW4gYXJndW1lbnQpLicsIGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJywgbG9jYXRpb24sIHR5cGVTcGVjTmFtZSwgdHlwZW9mIGVycm9yKTtcXG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmICEoZXJyb3IubWVzc2FnZSBpbiBsb2dnZWRUeXBlRmFpbHVyZXMpKSB7XFxuICAgICAgICAgIC8vIE9ubHkgbW9uaXRvciB0aGlzIGZhaWx1cmUgb25jZSBiZWNhdXNlIHRoZXJlIHRlbmRzIHRvIGJlIGEgbG90IG9mIHRoZVxcbiAgICAgICAgICAvLyBzYW1lIGVycm9yLlxcbiAgICAgICAgICBsb2dnZWRUeXBlRmFpbHVyZXNbZXJyb3IubWVzc2FnZV0gPSB0cnVlO1xcblxcbiAgICAgICAgICB2YXIgc3RhY2sgPSBnZXRTdGFjayA/IGdldFN0YWNrKCkgOiAnJztcXG5cXG4gICAgICAgICAgd2FybmluZyhmYWxzZSwgJ0ZhaWxlZCAlcyB0eXBlOiAlcyVzJywgbG9jYXRpb24sIGVycm9yLm1lc3NhZ2UsIHN0YWNrICE9IG51bGwgPyBzdGFjayA6ICcnKTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIH1cXG4gIH1cXG59XFxuXFxubW9kdWxlLmV4cG9ydHMgPSBjaGVja1Byb3BUeXBlcztcXG5cXG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi99LmNhbGwoZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXygwKSkpXFxuXFxuLy8vLy8vLy8vLy8vLy8vLy8vXFxuLy8gV0VCUEFDSyBGT09URVJcXG4vLyAuL34vcHJvcC10eXBlcy9jaGVja1Byb3BUeXBlcy5qc1xcbi8vIG1vZHVsZSBpZCA9IDE5XFxuLy8gbW9kdWxlIGNodW5rcyA9IDBcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9+L3Byb3AtdHlwZXMvY2hlY2tQcm9wVHlwZXMuanM/XCIpO1xuXG4vKioqLyB9KSxcbi8qIDIwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuZXZhbChcIi8qKlxcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxcbiAqXFxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXFxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxcbiAqL1xcblxcblxcblxcbnZhciBlbXB0eUZ1bmN0aW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcXG52YXIgaW52YXJpYW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcXG52YXIgUmVhY3RQcm9wVHlwZXNTZWNyZXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xcblxcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XFxuICBmdW5jdGlvbiBzaGltKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSwgc2VjcmV0KSB7XFxuICAgIGlmIChzZWNyZXQgPT09IFJlYWN0UHJvcFR5cGVzU2VjcmV0KSB7XFxuICAgICAgLy8gSXQgaXMgc3RpbGwgc2FmZSB3aGVuIGNhbGxlZCBmcm9tIFJlYWN0LlxcbiAgICAgIHJldHVybjtcXG4gICAgfVxcbiAgICBpbnZhcmlhbnQoXFxuICAgICAgZmFsc2UsXFxuICAgICAgJ0NhbGxpbmcgUHJvcFR5cGVzIHZhbGlkYXRvcnMgZGlyZWN0bHkgaXMgbm90IHN1cHBvcnRlZCBieSB0aGUgYHByb3AtdHlwZXNgIHBhY2thZ2UuICcgK1xcbiAgICAgICdVc2UgUHJvcFR5cGVzLmNoZWNrUHJvcFR5cGVzKCkgdG8gY2FsbCB0aGVtLiAnICtcXG4gICAgICAnUmVhZCBtb3JlIGF0IGh0dHA6Ly9mYi5tZS91c2UtY2hlY2stcHJvcC10eXBlcydcXG4gICAgKTtcXG4gIH07XFxuICBzaGltLmlzUmVxdWlyZWQgPSBzaGltO1xcbiAgZnVuY3Rpb24gZ2V0U2hpbSgpIHtcXG4gICAgcmV0dXJuIHNoaW07XFxuICB9O1xcbiAgLy8gSW1wb3J0YW50IVxcbiAgLy8gS2VlcCB0aGlzIGxpc3QgaW4gc3luYyB3aXRoIHByb2R1Y3Rpb24gdmVyc2lvbiBpbiBgLi9mYWN0b3J5V2l0aFR5cGVDaGVja2Vycy5qc2AuXFxuICB2YXIgUmVhY3RQcm9wVHlwZXMgPSB7XFxuICAgIGFycmF5OiBzaGltLFxcbiAgICBib29sOiBzaGltLFxcbiAgICBmdW5jOiBzaGltLFxcbiAgICBudW1iZXI6IHNoaW0sXFxuICAgIG9iamVjdDogc2hpbSxcXG4gICAgc3RyaW5nOiBzaGltLFxcbiAgICBzeW1ib2w6IHNoaW0sXFxuXFxuICAgIGFueTogc2hpbSxcXG4gICAgYXJyYXlPZjogZ2V0U2hpbSxcXG4gICAgZWxlbWVudDogc2hpbSxcXG4gICAgaW5zdGFuY2VPZjogZ2V0U2hpbSxcXG4gICAgbm9kZTogc2hpbSxcXG4gICAgb2JqZWN0T2Y6IGdldFNoaW0sXFxuICAgIG9uZU9mOiBnZXRTaGltLFxcbiAgICBvbmVPZlR5cGU6IGdldFNoaW0sXFxuICAgIHNoYXBlOiBnZXRTaGltLFxcbiAgICBleGFjdDogZ2V0U2hpbVxcbiAgfTtcXG5cXG4gIFJlYWN0UHJvcFR5cGVzLmNoZWNrUHJvcFR5cGVzID0gZW1wdHlGdW5jdGlvbjtcXG4gIFJlYWN0UHJvcFR5cGVzLlByb3BUeXBlcyA9IFJlYWN0UHJvcFR5cGVzO1xcblxcbiAgcmV0dXJuIFJlYWN0UHJvcFR5cGVzO1xcbn07XFxuXFxuXFxuLy8vLy8vLy8vLy8vLy8vLy8vXFxuLy8gV0VCUEFDSyBGT09URVJcXG4vLyAuL34vcHJvcC10eXBlcy9mYWN0b3J5V2l0aFRocm93aW5nU2hpbXMuanNcXG4vLyBtb2R1bGUgaWQgPSAyMFxcbi8vIG1vZHVsZSBjaHVua3MgPSAwXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vfi9wcm9wLXR5cGVzL2ZhY3RvcnlXaXRoVGhyb3dpbmdTaGltcy5qcz9cIik7XG5cbi8qKiovIH0pLFxuLyogMjEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5ldmFsKFwiLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovKGZ1bmN0aW9uKHByb2Nlc3MpIHsvKipcXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cXG4gKlxcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cXG4gKi9cXG5cXG5cXG5cXG52YXIgZW1wdHlGdW5jdGlvbiA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XFxudmFyIGludmFyaWFudCA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XFxudmFyIHdhcm5pbmcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xcbnZhciBhc3NpZ24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE4KTtcXG5cXG52YXIgUmVhY3RQcm9wVHlwZXNTZWNyZXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xcbnZhciBjaGVja1Byb3BUeXBlcyA9IF9fd2VicGFja19yZXF1aXJlX18oMTkpO1xcblxcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXNWYWxpZEVsZW1lbnQsIHRocm93T25EaXJlY3RBY2Nlc3MpIHtcXG4gIC8qIGdsb2JhbCBTeW1ib2wgKi9cXG4gIHZhciBJVEVSQVRPUl9TWU1CT0wgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5pdGVyYXRvcjtcXG4gIHZhciBGQVVYX0lURVJBVE9SX1NZTUJPTCA9ICdAQGl0ZXJhdG9yJzsgLy8gQmVmb3JlIFN5bWJvbCBzcGVjLlxcblxcbiAgLyoqXFxuICAgKiBSZXR1cm5zIHRoZSBpdGVyYXRvciBtZXRob2QgZnVuY3Rpb24gY29udGFpbmVkIG9uIHRoZSBpdGVyYWJsZSBvYmplY3QuXFxuICAgKlxcbiAgICogQmUgc3VyZSB0byBpbnZva2UgdGhlIGZ1bmN0aW9uIHdpdGggdGhlIGl0ZXJhYmxlIGFzIGNvbnRleHQ6XFxuICAgKlxcbiAgICogICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihteUl0ZXJhYmxlKTtcXG4gICAqICAgICBpZiAoaXRlcmF0b3JGbikge1xcbiAgICogICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKG15SXRlcmFibGUpO1xcbiAgICogICAgICAgLi4uXFxuICAgKiAgICAgfVxcbiAgICpcXG4gICAqIEBwYXJhbSB7P29iamVjdH0gbWF5YmVJdGVyYWJsZVxcbiAgICogQHJldHVybiB7P2Z1bmN0aW9ufVxcbiAgICovXFxuICBmdW5jdGlvbiBnZXRJdGVyYXRvckZuKG1heWJlSXRlcmFibGUpIHtcXG4gICAgdmFyIGl0ZXJhdG9yRm4gPSBtYXliZUl0ZXJhYmxlICYmIChJVEVSQVRPUl9TWU1CT0wgJiYgbWF5YmVJdGVyYWJsZVtJVEVSQVRPUl9TWU1CT0xdIHx8IG1heWJlSXRlcmFibGVbRkFVWF9JVEVSQVRPUl9TWU1CT0xdKTtcXG4gICAgaWYgKHR5cGVvZiBpdGVyYXRvckZuID09PSAnZnVuY3Rpb24nKSB7XFxuICAgICAgcmV0dXJuIGl0ZXJhdG9yRm47XFxuICAgIH1cXG4gIH1cXG5cXG4gIC8qKlxcbiAgICogQ29sbGVjdGlvbiBvZiBtZXRob2RzIHRoYXQgYWxsb3cgZGVjbGFyYXRpb24gYW5kIHZhbGlkYXRpb24gb2YgcHJvcHMgdGhhdCBhcmVcXG4gICAqIHN1cHBsaWVkIHRvIFJlYWN0IGNvbXBvbmVudHMuIEV4YW1wbGUgdXNhZ2U6XFxuICAgKlxcbiAgICogICB2YXIgUHJvcHMgPSByZXF1aXJlKCdSZWFjdFByb3BUeXBlcycpO1xcbiAgICogICB2YXIgTXlBcnRpY2xlID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xcbiAgICogICAgIHByb3BUeXBlczoge1xcbiAgICogICAgICAgLy8gQW4gb3B0aW9uYWwgc3RyaW5nIHByb3AgbmFtZWQgXFxcImRlc2NyaXB0aW9uXFxcIi5cXG4gICAqICAgICAgIGRlc2NyaXB0aW9uOiBQcm9wcy5zdHJpbmcsXFxuICAgKlxcbiAgICogICAgICAgLy8gQSByZXF1aXJlZCBlbnVtIHByb3AgbmFtZWQgXFxcImNhdGVnb3J5XFxcIi5cXG4gICAqICAgICAgIGNhdGVnb3J5OiBQcm9wcy5vbmVPZihbJ05ld3MnLCdQaG90b3MnXSkuaXNSZXF1aXJlZCxcXG4gICAqXFxuICAgKiAgICAgICAvLyBBIHByb3AgbmFtZWQgXFxcImRpYWxvZ1xcXCIgdGhhdCByZXF1aXJlcyBhbiBpbnN0YW5jZSBvZiBEaWFsb2cuXFxuICAgKiAgICAgICBkaWFsb2c6IFByb3BzLmluc3RhbmNlT2YoRGlhbG9nKS5pc1JlcXVpcmVkXFxuICAgKiAgICAgfSxcXG4gICAqICAgICByZW5kZXI6IGZ1bmN0aW9uKCkgeyAuLi4gfVxcbiAgICogICB9KTtcXG4gICAqXFxuICAgKiBBIG1vcmUgZm9ybWFsIHNwZWNpZmljYXRpb24gb2YgaG93IHRoZXNlIG1ldGhvZHMgYXJlIHVzZWQ6XFxuICAgKlxcbiAgICogICB0eXBlIDo9IGFycmF5fGJvb2x8ZnVuY3xvYmplY3R8bnVtYmVyfHN0cmluZ3xvbmVPZihbLi4uXSl8aW5zdGFuY2VPZiguLi4pXFxuICAgKiAgIGRlY2wgOj0gUmVhY3RQcm9wVHlwZXMue3R5cGV9KC5pc1JlcXVpcmVkKT9cXG4gICAqXFxuICAgKiBFYWNoIGFuZCBldmVyeSBkZWNsYXJhdGlvbiBwcm9kdWNlcyBhIGZ1bmN0aW9uIHdpdGggdGhlIHNhbWUgc2lnbmF0dXJlLiBUaGlzXFxuICAgKiBhbGxvd3MgdGhlIGNyZWF0aW9uIG9mIGN1c3RvbSB2YWxpZGF0aW9uIGZ1bmN0aW9ucy4gRm9yIGV4YW1wbGU6XFxuICAgKlxcbiAgICogIHZhciBNeUxpbmsgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XFxuICAgKiAgICBwcm9wVHlwZXM6IHtcXG4gICAqICAgICAgLy8gQW4gb3B0aW9uYWwgc3RyaW5nIG9yIFVSSSBwcm9wIG5hbWVkIFxcXCJocmVmXFxcIi5cXG4gICAqICAgICAgaHJlZjogZnVuY3Rpb24ocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lKSB7XFxuICAgKiAgICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcXG4gICAqICAgICAgICBpZiAocHJvcFZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHByb3BWYWx1ZSAhPT0gJ3N0cmluZycgJiZcXG4gICAqICAgICAgICAgICAgIShwcm9wVmFsdWUgaW5zdGFuY2VvZiBVUkkpKSB7XFxuICAgKiAgICAgICAgICByZXR1cm4gbmV3IEVycm9yKFxcbiAgICogICAgICAgICAgICAnRXhwZWN0ZWQgYSBzdHJpbmcgb3IgYW4gVVJJIGZvciAnICsgcHJvcE5hbWUgKyAnIGluICcgK1xcbiAgICogICAgICAgICAgICBjb21wb25lbnROYW1lXFxuICAgKiAgICAgICAgICApO1xcbiAgICogICAgICAgIH1cXG4gICAqICAgICAgfVxcbiAgICogICAgfSxcXG4gICAqICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7Li4ufVxcbiAgICogIH0pO1xcbiAgICpcXG4gICAqIEBpbnRlcm5hbFxcbiAgICovXFxuXFxuICB2YXIgQU5PTllNT1VTID0gJzw8YW5vbnltb3VzPj4nO1xcblxcbiAgLy8gSW1wb3J0YW50IVxcbiAgLy8gS2VlcCB0aGlzIGxpc3QgaW4gc3luYyB3aXRoIHByb2R1Y3Rpb24gdmVyc2lvbiBpbiBgLi9mYWN0b3J5V2l0aFRocm93aW5nU2hpbXMuanNgLlxcbiAgdmFyIFJlYWN0UHJvcFR5cGVzID0ge1xcbiAgICBhcnJheTogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ2FycmF5JyksXFxuICAgIGJvb2w6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdib29sZWFuJyksXFxuICAgIGZ1bmM6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdmdW5jdGlvbicpLFxcbiAgICBudW1iZXI6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdudW1iZXInKSxcXG4gICAgb2JqZWN0OiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignb2JqZWN0JyksXFxuICAgIHN0cmluZzogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ3N0cmluZycpLFxcbiAgICBzeW1ib2w6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdzeW1ib2wnKSxcXG5cXG4gICAgYW55OiBjcmVhdGVBbnlUeXBlQ2hlY2tlcigpLFxcbiAgICBhcnJheU9mOiBjcmVhdGVBcnJheU9mVHlwZUNoZWNrZXIsXFxuICAgIGVsZW1lbnQ6IGNyZWF0ZUVsZW1lbnRUeXBlQ2hlY2tlcigpLFxcbiAgICBpbnN0YW5jZU9mOiBjcmVhdGVJbnN0YW5jZVR5cGVDaGVja2VyLFxcbiAgICBub2RlOiBjcmVhdGVOb2RlQ2hlY2tlcigpLFxcbiAgICBvYmplY3RPZjogY3JlYXRlT2JqZWN0T2ZUeXBlQ2hlY2tlcixcXG4gICAgb25lT2Y6IGNyZWF0ZUVudW1UeXBlQ2hlY2tlcixcXG4gICAgb25lT2ZUeXBlOiBjcmVhdGVVbmlvblR5cGVDaGVja2VyLFxcbiAgICBzaGFwZTogY3JlYXRlU2hhcGVUeXBlQ2hlY2tlcixcXG4gICAgZXhhY3Q6IGNyZWF0ZVN0cmljdFNoYXBlVHlwZUNoZWNrZXIsXFxuICB9O1xcblxcbiAgLyoqXFxuICAgKiBpbmxpbmVkIE9iamVjdC5pcyBwb2x5ZmlsbCB0byBhdm9pZCByZXF1aXJpbmcgY29uc3VtZXJzIHNoaXAgdGhlaXIgb3duXFxuICAgKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvaXNcXG4gICAqL1xcbiAgLyplc2xpbnQtZGlzYWJsZSBuby1zZWxmLWNvbXBhcmUqL1xcbiAgZnVuY3Rpb24gaXMoeCwgeSkge1xcbiAgICAvLyBTYW1lVmFsdWUgYWxnb3JpdGhtXFxuICAgIGlmICh4ID09PSB5KSB7XFxuICAgICAgLy8gU3RlcHMgMS01LCA3LTEwXFxuICAgICAgLy8gU3RlcHMgNi5iLTYuZTogKzAgIT0gLTBcXG4gICAgICByZXR1cm4geCAhPT0gMCB8fCAxIC8geCA9PT0gMSAvIHk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgLy8gU3RlcCA2LmE6IE5hTiA9PSBOYU5cXG4gICAgICByZXR1cm4geCAhPT0geCAmJiB5ICE9PSB5O1xcbiAgICB9XFxuICB9XFxuICAvKmVzbGludC1lbmFibGUgbm8tc2VsZi1jb21wYXJlKi9cXG5cXG4gIC8qKlxcbiAgICogV2UgdXNlIGFuIEVycm9yLWxpa2Ugb2JqZWN0IGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5IGFzIHBlb3BsZSBtYXkgY2FsbFxcbiAgICogUHJvcFR5cGVzIGRpcmVjdGx5IGFuZCBpbnNwZWN0IHRoZWlyIG91dHB1dC4gSG93ZXZlciwgd2UgZG9uJ3QgdXNlIHJlYWxcXG4gICAqIEVycm9ycyBhbnltb3JlLiBXZSBkb24ndCBpbnNwZWN0IHRoZWlyIHN0YWNrIGFueXdheSwgYW5kIGNyZWF0aW5nIHRoZW1cXG4gICAqIGlzIHByb2hpYml0aXZlbHkgZXhwZW5zaXZlIGlmIHRoZXkgYXJlIGNyZWF0ZWQgdG9vIG9mdGVuLCBzdWNoIGFzIHdoYXRcXG4gICAqIGhhcHBlbnMgaW4gb25lT2ZUeXBlKCkgZm9yIGFueSB0eXBlIGJlZm9yZSB0aGUgb25lIHRoYXQgbWF0Y2hlZC5cXG4gICAqL1xcbiAgZnVuY3Rpb24gUHJvcFR5cGVFcnJvcihtZXNzYWdlKSB7XFxuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XFxuICAgIHRoaXMuc3RhY2sgPSAnJztcXG4gIH1cXG4gIC8vIE1ha2UgYGluc3RhbmNlb2YgRXJyb3JgIHN0aWxsIHdvcmsgZm9yIHJldHVybmVkIGVycm9ycy5cXG4gIFByb3BUeXBlRXJyb3IucHJvdG90eXBlID0gRXJyb3IucHJvdG90eXBlO1xcblxcbiAgZnVuY3Rpb24gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpIHtcXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcXG4gICAgICB2YXIgbWFudWFsUHJvcFR5cGVDYWxsQ2FjaGUgPSB7fTtcXG4gICAgICB2YXIgbWFudWFsUHJvcFR5cGVXYXJuaW5nQ291bnQgPSAwO1xcbiAgICB9XFxuICAgIGZ1bmN0aW9uIGNoZWNrVHlwZShpc1JlcXVpcmVkLCBwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIHNlY3JldCkge1xcbiAgICAgIGNvbXBvbmVudE5hbWUgPSBjb21wb25lbnROYW1lIHx8IEFOT05ZTU9VUztcXG4gICAgICBwcm9wRnVsbE5hbWUgPSBwcm9wRnVsbE5hbWUgfHwgcHJvcE5hbWU7XFxuXFxuICAgICAgaWYgKHNlY3JldCAhPT0gUmVhY3RQcm9wVHlwZXNTZWNyZXQpIHtcXG4gICAgICAgIGlmICh0aHJvd09uRGlyZWN0QWNjZXNzKSB7XFxuICAgICAgICAgIC8vIE5ldyBiZWhhdmlvciBvbmx5IGZvciB1c2VycyBvZiBgcHJvcC10eXBlc2AgcGFja2FnZVxcbiAgICAgICAgICBpbnZhcmlhbnQoXFxuICAgICAgICAgICAgZmFsc2UsXFxuICAgICAgICAgICAgJ0NhbGxpbmcgUHJvcFR5cGVzIHZhbGlkYXRvcnMgZGlyZWN0bHkgaXMgbm90IHN1cHBvcnRlZCBieSB0aGUgYHByb3AtdHlwZXNgIHBhY2thZ2UuICcgK1xcbiAgICAgICAgICAgICdVc2UgYFByb3BUeXBlcy5jaGVja1Byb3BUeXBlcygpYCB0byBjYWxsIHRoZW0uICcgK1xcbiAgICAgICAgICAgICdSZWFkIG1vcmUgYXQgaHR0cDovL2ZiLm1lL3VzZS1jaGVjay1wcm9wLXR5cGVzJ1xcbiAgICAgICAgICApO1xcbiAgICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xcbiAgICAgICAgICAvLyBPbGQgYmVoYXZpb3IgZm9yIHBlb3BsZSB1c2luZyBSZWFjdC5Qcm9wVHlwZXNcXG4gICAgICAgICAgdmFyIGNhY2hlS2V5ID0gY29tcG9uZW50TmFtZSArICc6JyArIHByb3BOYW1lO1xcbiAgICAgICAgICBpZiAoXFxuICAgICAgICAgICAgIW1hbnVhbFByb3BUeXBlQ2FsbENhY2hlW2NhY2hlS2V5XSAmJlxcbiAgICAgICAgICAgIC8vIEF2b2lkIHNwYW1taW5nIHRoZSBjb25zb2xlIGJlY2F1c2UgdGhleSBhcmUgb2Z0ZW4gbm90IGFjdGlvbmFibGUgZXhjZXB0IGZvciBsaWIgYXV0aG9yc1xcbiAgICAgICAgICAgIG1hbnVhbFByb3BUeXBlV2FybmluZ0NvdW50IDwgM1xcbiAgICAgICAgICApIHtcXG4gICAgICAgICAgICB3YXJuaW5nKFxcbiAgICAgICAgICAgICAgZmFsc2UsXFxuICAgICAgICAgICAgICAnWW91IGFyZSBtYW51YWxseSBjYWxsaW5nIGEgUmVhY3QuUHJvcFR5cGVzIHZhbGlkYXRpb24gJyArXFxuICAgICAgICAgICAgICAnZnVuY3Rpb24gZm9yIHRoZSBgJXNgIHByb3Agb24gYCVzYC4gVGhpcyBpcyBkZXByZWNhdGVkICcgK1xcbiAgICAgICAgICAgICAgJ2FuZCB3aWxsIHRocm93IGluIHRoZSBzdGFuZGFsb25lIGBwcm9wLXR5cGVzYCBwYWNrYWdlLiAnICtcXG4gICAgICAgICAgICAgICdZb3UgbWF5IGJlIHNlZWluZyB0aGlzIHdhcm5pbmcgZHVlIHRvIGEgdGhpcmQtcGFydHkgUHJvcFR5cGVzICcgK1xcbiAgICAgICAgICAgICAgJ2xpYnJhcnkuIFNlZSBodHRwczovL2ZiLm1lL3JlYWN0LXdhcm5pbmctZG9udC1jYWxsLXByb3B0eXBlcyAnICsgJ2ZvciBkZXRhaWxzLicsXFxuICAgICAgICAgICAgICBwcm9wRnVsbE5hbWUsXFxuICAgICAgICAgICAgICBjb21wb25lbnROYW1lXFxuICAgICAgICAgICAgKTtcXG4gICAgICAgICAgICBtYW51YWxQcm9wVHlwZUNhbGxDYWNoZVtjYWNoZUtleV0gPSB0cnVlO1xcbiAgICAgICAgICAgIG1hbnVhbFByb3BUeXBlV2FybmluZ0NvdW50Kys7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PSBudWxsKSB7XFxuICAgICAgICBpZiAoaXNSZXF1aXJlZCkge1xcbiAgICAgICAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09PSBudWxsKSB7XFxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdUaGUgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIGlzIG1hcmtlZCBhcyByZXF1aXJlZCAnICsgKCdpbiBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgYnV0IGl0cyB2YWx1ZSBpcyBgbnVsbGAuJykpO1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignVGhlICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBpcyBtYXJrZWQgYXMgcmVxdWlyZWQgaW4gJyArICgnYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGJ1dCBpdHMgdmFsdWUgaXMgYHVuZGVmaW5lZGAuJykpO1xcbiAgICAgICAgfVxcbiAgICAgICAgcmV0dXJuIG51bGw7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHJldHVybiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpO1xcbiAgICAgIH1cXG4gICAgfVxcblxcbiAgICB2YXIgY2hhaW5lZENoZWNrVHlwZSA9IGNoZWNrVHlwZS5iaW5kKG51bGwsIGZhbHNlKTtcXG4gICAgY2hhaW5lZENoZWNrVHlwZS5pc1JlcXVpcmVkID0gY2hlY2tUeXBlLmJpbmQobnVsbCwgdHJ1ZSk7XFxuXFxuICAgIHJldHVybiBjaGFpbmVkQ2hlY2tUeXBlO1xcbiAgfVxcblxcbiAgZnVuY3Rpb24gY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoZXhwZWN0ZWRUeXBlKSB7XFxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSwgc2VjcmV0KSB7XFxuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcXG4gICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xcbiAgICAgIGlmIChwcm9wVHlwZSAhPT0gZXhwZWN0ZWRUeXBlKSB7XFxuICAgICAgICAvLyBgcHJvcFZhbHVlYCBiZWluZyBpbnN0YW5jZSBvZiwgc2F5LCBkYXRlL3JlZ2V4cCwgcGFzcyB0aGUgJ29iamVjdCdcXG4gICAgICAgIC8vIGNoZWNrLCBidXQgd2UgY2FuIG9mZmVyIGEgbW9yZSBwcmVjaXNlIGVycm9yIG1lc3NhZ2UgaGVyZSByYXRoZXIgdGhhblxcbiAgICAgICAgLy8gJ29mIHR5cGUgYG9iamVjdGAnLlxcbiAgICAgICAgdmFyIHByZWNpc2VUeXBlID0gZ2V0UHJlY2lzZVR5cGUocHJvcFZhbHVlKTtcXG5cXG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByZWNpc2VUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkICcpICsgKCdgJyArIGV4cGVjdGVkVHlwZSArICdgLicpKTtcXG4gICAgICB9XFxuICAgICAgcmV0dXJuIG51bGw7XFxuICAgIH1cXG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIGNyZWF0ZUFueVR5cGVDaGVja2VyKCkge1xcbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIoZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc051bGwpO1xcbiAgfVxcblxcbiAgZnVuY3Rpb24gY3JlYXRlQXJyYXlPZlR5cGVDaGVja2VyKHR5cGVDaGVja2VyKSB7XFxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xcbiAgICAgIGlmICh0eXBlb2YgdHlwZUNoZWNrZXIgIT09ICdmdW5jdGlvbicpIHtcXG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignUHJvcGVydHkgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiBjb21wb25lbnQgYCcgKyBjb21wb25lbnROYW1lICsgJ2AgaGFzIGludmFsaWQgUHJvcFR5cGUgbm90YXRpb24gaW5zaWRlIGFycmF5T2YuJyk7XFxuICAgICAgfVxcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XFxuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHByb3BWYWx1ZSkpIHtcXG4gICAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XFxuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcm9wVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhbiBhcnJheS4nKSk7XFxuICAgICAgfVxcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcFZhbHVlLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgICB2YXIgZXJyb3IgPSB0eXBlQ2hlY2tlcihwcm9wVmFsdWUsIGksIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUgKyAnWycgKyBpICsgJ10nLCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XFxuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xcbiAgICAgICAgICByZXR1cm4gZXJyb3I7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICAgIHJldHVybiBudWxsO1xcbiAgICB9XFxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XFxuICB9XFxuXFxuICBmdW5jdGlvbiBjcmVhdGVFbGVtZW50VHlwZUNoZWNrZXIoKSB7XFxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XFxuICAgICAgaWYgKCFpc1ZhbGlkRWxlbWVudChwcm9wVmFsdWUpKSB7XFxuICAgICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgcHJvcFR5cGUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYSBzaW5nbGUgUmVhY3RFbGVtZW50LicpKTtcXG4gICAgICB9XFxuICAgICAgcmV0dXJuIG51bGw7XFxuICAgIH1cXG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIGNyZWF0ZUluc3RhbmNlVHlwZUNoZWNrZXIoZXhwZWN0ZWRDbGFzcykge1xcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcXG4gICAgICBpZiAoIShwcm9wc1twcm9wTmFtZV0gaW5zdGFuY2VvZiBleHBlY3RlZENsYXNzKSkge1xcbiAgICAgICAgdmFyIGV4cGVjdGVkQ2xhc3NOYW1lID0gZXhwZWN0ZWRDbGFzcy5uYW1lIHx8IEFOT05ZTU9VUztcXG4gICAgICAgIHZhciBhY3R1YWxDbGFzc05hbWUgPSBnZXRDbGFzc05hbWUocHJvcHNbcHJvcE5hbWVdKTtcXG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIGFjdHVhbENsYXNzTmFtZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCAnKSArICgnaW5zdGFuY2Ugb2YgYCcgKyBleHBlY3RlZENsYXNzTmFtZSArICdgLicpKTtcXG4gICAgICB9XFxuICAgICAgcmV0dXJuIG51bGw7XFxuICAgIH1cXG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIGNyZWF0ZUVudW1UeXBlQ2hlY2tlcihleHBlY3RlZFZhbHVlcykge1xcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoZXhwZWN0ZWRWYWx1ZXMpKSB7XFxuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdJbnZhbGlkIGFyZ3VtZW50IHN1cHBsaWVkIHRvIG9uZU9mLCBleHBlY3RlZCBhbiBpbnN0YW5jZSBvZiBhcnJheS4nKSA6IHZvaWQgMDtcXG4gICAgICByZXR1cm4gZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc051bGw7XFxuICAgIH1cXG5cXG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XFxuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4cGVjdGVkVmFsdWVzLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgICBpZiAoaXMocHJvcFZhbHVlLCBleHBlY3RlZFZhbHVlc1tpXSkpIHtcXG4gICAgICAgICAgcmV0dXJuIG51bGw7XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIHZhciB2YWx1ZXNTdHJpbmcgPSBKU09OLnN0cmluZ2lmeShleHBlY3RlZFZhbHVlcyk7XFxuICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB2YWx1ZSBgJyArIHByb3BWYWx1ZSArICdgICcgKyAoJ3N1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBvbmUgb2YgJyArIHZhbHVlc1N0cmluZyArICcuJykpO1xcbiAgICB9XFxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XFxuICB9XFxuXFxuICBmdW5jdGlvbiBjcmVhdGVPYmplY3RPZlR5cGVDaGVja2VyKHR5cGVDaGVja2VyKSB7XFxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xcbiAgICAgIGlmICh0eXBlb2YgdHlwZUNoZWNrZXIgIT09ICdmdW5jdGlvbicpIHtcXG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignUHJvcGVydHkgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiBjb21wb25lbnQgYCcgKyBjb21wb25lbnROYW1lICsgJ2AgaGFzIGludmFsaWQgUHJvcFR5cGUgbm90YXRpb24gaW5zaWRlIG9iamVjdE9mLicpO1xcbiAgICAgIH1cXG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xcbiAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XFxuICAgICAgaWYgKHByb3BUeXBlICE9PSAnb2JqZWN0Jykge1xcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgcHJvcFR5cGUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYW4gb2JqZWN0LicpKTtcXG4gICAgICB9XFxuICAgICAgZm9yICh2YXIga2V5IGluIHByb3BWYWx1ZSkge1xcbiAgICAgICAgaWYgKHByb3BWYWx1ZS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XFxuICAgICAgICAgIHZhciBlcnJvciA9IHR5cGVDaGVja2VyKHByb3BWYWx1ZSwga2V5LCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lICsgJy4nICsga2V5LCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XFxuICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XFxuICAgICAgICAgICAgcmV0dXJuIGVycm9yO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICAgIHJldHVybiBudWxsO1xcbiAgICB9XFxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XFxuICB9XFxuXFxuICBmdW5jdGlvbiBjcmVhdGVVbmlvblR5cGVDaGVja2VyKGFycmF5T2ZUeXBlQ2hlY2tlcnMpIHtcXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGFycmF5T2ZUeXBlQ2hlY2tlcnMpKSB7XFxuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdJbnZhbGlkIGFyZ3VtZW50IHN1cHBsaWVkIHRvIG9uZU9mVHlwZSwgZXhwZWN0ZWQgYW4gaW5zdGFuY2Ugb2YgYXJyYXkuJykgOiB2b2lkIDA7XFxuICAgICAgcmV0dXJuIGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNOdWxsO1xcbiAgICB9XFxuXFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXlPZlR5cGVDaGVja2Vycy5sZW5ndGg7IGkrKykge1xcbiAgICAgIHZhciBjaGVja2VyID0gYXJyYXlPZlR5cGVDaGVja2Vyc1tpXTtcXG4gICAgICBpZiAodHlwZW9mIGNoZWNrZXIgIT09ICdmdW5jdGlvbicpIHtcXG4gICAgICAgIHdhcm5pbmcoXFxuICAgICAgICAgIGZhbHNlLFxcbiAgICAgICAgICAnSW52YWxpZCBhcmd1bWVudCBzdXBwbGllZCB0byBvbmVPZlR5cGUuIEV4cGVjdGVkIGFuIGFycmF5IG9mIGNoZWNrIGZ1bmN0aW9ucywgYnV0ICcgK1xcbiAgICAgICAgICAncmVjZWl2ZWQgJXMgYXQgaW5kZXggJXMuJyxcXG4gICAgICAgICAgZ2V0UG9zdGZpeEZvclR5cGVXYXJuaW5nKGNoZWNrZXIpLFxcbiAgICAgICAgICBpXFxuICAgICAgICApO1xcbiAgICAgICAgcmV0dXJuIGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNOdWxsO1xcbiAgICAgIH1cXG4gICAgfVxcblxcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5T2ZUeXBlQ2hlY2tlcnMubGVuZ3RoOyBpKyspIHtcXG4gICAgICAgIHZhciBjaGVja2VyID0gYXJyYXlPZlR5cGVDaGVja2Vyc1tpXTtcXG4gICAgICAgIGlmIChjaGVja2VyKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpID09IG51bGwpIHtcXG4gICAgICAgICAgcmV0dXJuIG51bGw7XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agc3VwcGxpZWQgdG8gJyArICgnYCcgKyBjb21wb25lbnROYW1lICsgJ2AuJykpO1xcbiAgICB9XFxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XFxuICB9XFxuXFxuICBmdW5jdGlvbiBjcmVhdGVOb2RlQ2hlY2tlcigpIHtcXG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XFxuICAgICAgaWYgKCFpc05vZGUocHJvcHNbcHJvcE5hbWVdKSkge1xcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBzdXBwbGllZCB0byAnICsgKCdgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYSBSZWFjdE5vZGUuJykpO1xcbiAgICAgIH1cXG4gICAgICByZXR1cm4gbnVsbDtcXG4gICAgfVxcbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xcbiAgfVxcblxcbiAgZnVuY3Rpb24gY3JlYXRlU2hhcGVUeXBlQ2hlY2tlcihzaGFwZVR5cGVzKSB7XFxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XFxuICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcXG4gICAgICBpZiAocHJvcFR5cGUgIT09ICdvYmplY3QnKSB7XFxuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgYCcgKyBwcm9wVHlwZSArICdgICcgKyAoJ3N1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBgb2JqZWN0YC4nKSk7XFxuICAgICAgfVxcbiAgICAgIGZvciAodmFyIGtleSBpbiBzaGFwZVR5cGVzKSB7XFxuICAgICAgICB2YXIgY2hlY2tlciA9IHNoYXBlVHlwZXNba2V5XTtcXG4gICAgICAgIGlmICghY2hlY2tlcikge1xcbiAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgIH1cXG4gICAgICAgIHZhciBlcnJvciA9IGNoZWNrZXIocHJvcFZhbHVlLCBrZXksIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUgKyAnLicgKyBrZXksIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcXG4gICAgICAgIGlmIChlcnJvcikge1xcbiAgICAgICAgICByZXR1cm4gZXJyb3I7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICAgIHJldHVybiBudWxsO1xcbiAgICB9XFxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XFxuICB9XFxuXFxuICBmdW5jdGlvbiBjcmVhdGVTdHJpY3RTaGFwZVR5cGVDaGVja2VyKHNoYXBlVHlwZXMpIHtcXG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XFxuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcXG4gICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xcbiAgICAgIGlmIChwcm9wVHlwZSAhPT0gJ29iamVjdCcpIHtcXG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSBgJyArIHByb3BUeXBlICsgJ2AgJyArICgnc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGBvYmplY3RgLicpKTtcXG4gICAgICB9XFxuICAgICAgLy8gV2UgbmVlZCB0byBjaGVjayBhbGwga2V5cyBpbiBjYXNlIHNvbWUgYXJlIHJlcXVpcmVkIGJ1dCBtaXNzaW5nIGZyb21cXG4gICAgICAvLyBwcm9wcy5cXG4gICAgICB2YXIgYWxsS2V5cyA9IGFzc2lnbih7fSwgcHJvcHNbcHJvcE5hbWVdLCBzaGFwZVR5cGVzKTtcXG4gICAgICBmb3IgKHZhciBrZXkgaW4gYWxsS2V5cykge1xcbiAgICAgICAgdmFyIGNoZWNrZXIgPSBzaGFwZVR5cGVzW2tleV07XFxuICAgICAgICBpZiAoIWNoZWNrZXIpIHtcXG4gICAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKFxcbiAgICAgICAgICAgICdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBrZXkgYCcgKyBrZXkgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYC4nICtcXG4gICAgICAgICAgICAnXFxcXG5CYWQgb2JqZWN0OiAnICsgSlNPTi5zdHJpbmdpZnkocHJvcHNbcHJvcE5hbWVdLCBudWxsLCAnICAnKSArXFxuICAgICAgICAgICAgJ1xcXFxuVmFsaWQga2V5czogJyArICBKU09OLnN0cmluZ2lmeShPYmplY3Qua2V5cyhzaGFwZVR5cGVzKSwgbnVsbCwgJyAgJylcXG4gICAgICAgICAgKTtcXG4gICAgICAgIH1cXG4gICAgICAgIHZhciBlcnJvciA9IGNoZWNrZXIocHJvcFZhbHVlLCBrZXksIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUgKyAnLicgKyBrZXksIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcXG4gICAgICAgIGlmIChlcnJvcikge1xcbiAgICAgICAgICByZXR1cm4gZXJyb3I7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICAgIHJldHVybiBudWxsO1xcbiAgICB9XFxuXFxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XFxuICB9XFxuXFxuICBmdW5jdGlvbiBpc05vZGUocHJvcFZhbHVlKSB7XFxuICAgIHN3aXRjaCAodHlwZW9mIHByb3BWYWx1ZSkge1xcbiAgICAgIGNhc2UgJ251bWJlcic6XFxuICAgICAgY2FzZSAnc3RyaW5nJzpcXG4gICAgICBjYXNlICd1bmRlZmluZWQnOlxcbiAgICAgICAgcmV0dXJuIHRydWU7XFxuICAgICAgY2FzZSAnYm9vbGVhbic6XFxuICAgICAgICByZXR1cm4gIXByb3BWYWx1ZTtcXG4gICAgICBjYXNlICdvYmplY3QnOlxcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocHJvcFZhbHVlKSkge1xcbiAgICAgICAgICByZXR1cm4gcHJvcFZhbHVlLmV2ZXJ5KGlzTm9kZSk7XFxuICAgICAgICB9XFxuICAgICAgICBpZiAocHJvcFZhbHVlID09PSBudWxsIHx8IGlzVmFsaWRFbGVtZW50KHByb3BWYWx1ZSkpIHtcXG4gICAgICAgICAgcmV0dXJuIHRydWU7XFxuICAgICAgICB9XFxuXFxuICAgICAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4ocHJvcFZhbHVlKTtcXG4gICAgICAgIGlmIChpdGVyYXRvckZuKSB7XFxuICAgICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChwcm9wVmFsdWUpO1xcbiAgICAgICAgICB2YXIgc3RlcDtcXG4gICAgICAgICAgaWYgKGl0ZXJhdG9yRm4gIT09IHByb3BWYWx1ZS5lbnRyaWVzKSB7XFxuICAgICAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xcbiAgICAgICAgICAgICAgaWYgKCFpc05vZGUoc3RlcC52YWx1ZSkpIHtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAvLyBJdGVyYXRvciB3aWxsIHByb3ZpZGUgZW50cnkgW2ssdl0gdHVwbGVzIHJhdGhlciB0aGFuIHZhbHVlcy5cXG4gICAgICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XFxuICAgICAgICAgICAgICB2YXIgZW50cnkgPSBzdGVwLnZhbHVlO1xcbiAgICAgICAgICAgICAgaWYgKGVudHJ5KSB7XFxuICAgICAgICAgICAgICAgIGlmICghaXNOb2RlKGVudHJ5WzFdKSkge1xcbiAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgcmV0dXJuIHRydWU7XFxuICAgICAgZGVmYXVsdDpcXG4gICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgfVxcbiAgfVxcblxcbiAgZnVuY3Rpb24gaXNTeW1ib2wocHJvcFR5cGUsIHByb3BWYWx1ZSkge1xcbiAgICAvLyBOYXRpdmUgU3ltYm9sLlxcbiAgICBpZiAocHJvcFR5cGUgPT09ICdzeW1ib2wnKSB7XFxuICAgICAgcmV0dXJuIHRydWU7XFxuICAgIH1cXG5cXG4gICAgLy8gMTkuNC4zLjUgU3ltYm9sLnByb3RvdHlwZVtAQHRvU3RyaW5nVGFnXSA9PT0gJ1N5bWJvbCdcXG4gICAgaWYgKHByb3BWYWx1ZVsnQEB0b1N0cmluZ1RhZyddID09PSAnU3ltYm9sJykge1xcbiAgICAgIHJldHVybiB0cnVlO1xcbiAgICB9XFxuXFxuICAgIC8vIEZhbGxiYWNrIGZvciBub24tc3BlYyBjb21wbGlhbnQgU3ltYm9scyB3aGljaCBhcmUgcG9seWZpbGxlZC5cXG4gICAgaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgcHJvcFZhbHVlIGluc3RhbmNlb2YgU3ltYm9sKSB7XFxuICAgICAgcmV0dXJuIHRydWU7XFxuICAgIH1cXG5cXG4gICAgcmV0dXJuIGZhbHNlO1xcbiAgfVxcblxcbiAgLy8gRXF1aXZhbGVudCBvZiBgdHlwZW9mYCBidXQgd2l0aCBzcGVjaWFsIGhhbmRsaW5nIGZvciBhcnJheSBhbmQgcmVnZXhwLlxcbiAgZnVuY3Rpb24gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKSB7XFxuICAgIHZhciBwcm9wVHlwZSA9IHR5cGVvZiBwcm9wVmFsdWU7XFxuICAgIGlmIChBcnJheS5pc0FycmF5KHByb3BWYWx1ZSkpIHtcXG4gICAgICByZXR1cm4gJ2FycmF5JztcXG4gICAgfVxcbiAgICBpZiAocHJvcFZhbHVlIGluc3RhbmNlb2YgUmVnRXhwKSB7XFxuICAgICAgLy8gT2xkIHdlYmtpdHMgKGF0IGxlYXN0IHVudGlsIEFuZHJvaWQgNC4wKSByZXR1cm4gJ2Z1bmN0aW9uJyByYXRoZXIgdGhhblxcbiAgICAgIC8vICdvYmplY3QnIGZvciB0eXBlb2YgYSBSZWdFeHAuIFdlJ2xsIG5vcm1hbGl6ZSB0aGlzIGhlcmUgc28gdGhhdCAvYmxhL1xcbiAgICAgIC8vIHBhc3NlcyBQcm9wVHlwZXMub2JqZWN0LlxcbiAgICAgIHJldHVybiAnb2JqZWN0JztcXG4gICAgfVxcbiAgICBpZiAoaXNTeW1ib2wocHJvcFR5cGUsIHByb3BWYWx1ZSkpIHtcXG4gICAgICByZXR1cm4gJ3N5bWJvbCc7XFxuICAgIH1cXG4gICAgcmV0dXJuIHByb3BUeXBlO1xcbiAgfVxcblxcbiAgLy8gVGhpcyBoYW5kbGVzIG1vcmUgdHlwZXMgdGhhbiBgZ2V0UHJvcFR5cGVgLiBPbmx5IHVzZWQgZm9yIGVycm9yIG1lc3NhZ2VzLlxcbiAgLy8gU2VlIGBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcmAuXFxuICBmdW5jdGlvbiBnZXRQcmVjaXNlVHlwZShwcm9wVmFsdWUpIHtcXG4gICAgaWYgKHR5cGVvZiBwcm9wVmFsdWUgPT09ICd1bmRlZmluZWQnIHx8IHByb3BWYWx1ZSA9PT0gbnVsbCkge1xcbiAgICAgIHJldHVybiAnJyArIHByb3BWYWx1ZTtcXG4gICAgfVxcbiAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xcbiAgICBpZiAocHJvcFR5cGUgPT09ICdvYmplY3QnKSB7XFxuICAgICAgaWYgKHByb3BWYWx1ZSBpbnN0YW5jZW9mIERhdGUpIHtcXG4gICAgICAgIHJldHVybiAnZGF0ZSc7XFxuICAgICAgfSBlbHNlIGlmIChwcm9wVmFsdWUgaW5zdGFuY2VvZiBSZWdFeHApIHtcXG4gICAgICAgIHJldHVybiAncmVnZXhwJztcXG4gICAgICB9XFxuICAgIH1cXG4gICAgcmV0dXJuIHByb3BUeXBlO1xcbiAgfVxcblxcbiAgLy8gUmV0dXJucyBhIHN0cmluZyB0aGF0IGlzIHBvc3RmaXhlZCB0byBhIHdhcm5pbmcgYWJvdXQgYW4gaW52YWxpZCB0eXBlLlxcbiAgLy8gRm9yIGV4YW1wbGUsIFxcXCJ1bmRlZmluZWRcXFwiIG9yIFxcXCJvZiB0eXBlIGFycmF5XFxcIlxcbiAgZnVuY3Rpb24gZ2V0UG9zdGZpeEZvclR5cGVXYXJuaW5nKHZhbHVlKSB7XFxuICAgIHZhciB0eXBlID0gZ2V0UHJlY2lzZVR5cGUodmFsdWUpO1xcbiAgICBzd2l0Y2ggKHR5cGUpIHtcXG4gICAgICBjYXNlICdhcnJheSc6XFxuICAgICAgY2FzZSAnb2JqZWN0JzpcXG4gICAgICAgIHJldHVybiAnYW4gJyArIHR5cGU7XFxuICAgICAgY2FzZSAnYm9vbGVhbic6XFxuICAgICAgY2FzZSAnZGF0ZSc6XFxuICAgICAgY2FzZSAncmVnZXhwJzpcXG4gICAgICAgIHJldHVybiAnYSAnICsgdHlwZTtcXG4gICAgICBkZWZhdWx0OlxcbiAgICAgICAgcmV0dXJuIHR5cGU7XFxuICAgIH1cXG4gIH1cXG5cXG4gIC8vIFJldHVybnMgY2xhc3MgbmFtZSBvZiB0aGUgb2JqZWN0LCBpZiBhbnkuXFxuICBmdW5jdGlvbiBnZXRDbGFzc05hbWUocHJvcFZhbHVlKSB7XFxuICAgIGlmICghcHJvcFZhbHVlLmNvbnN0cnVjdG9yIHx8ICFwcm9wVmFsdWUuY29uc3RydWN0b3IubmFtZSkge1xcbiAgICAgIHJldHVybiBBTk9OWU1PVVM7XFxuICAgIH1cXG4gICAgcmV0dXJuIHByb3BWYWx1ZS5jb25zdHJ1Y3Rvci5uYW1lO1xcbiAgfVxcblxcbiAgUmVhY3RQcm9wVHlwZXMuY2hlY2tQcm9wVHlwZXMgPSBjaGVja1Byb3BUeXBlcztcXG4gIFJlYWN0UHJvcFR5cGVzLlByb3BUeXBlcyA9IFJlYWN0UHJvcFR5cGVzO1xcblxcbiAgcmV0dXJuIFJlYWN0UHJvcFR5cGVzO1xcbn07XFxuXFxuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovfS5jYWxsKGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18oMCkpKVxcblxcbi8vLy8vLy8vLy8vLy8vLy8vL1xcbi8vIFdFQlBBQ0sgRk9PVEVSXFxuLy8gLi9+L3Byb3AtdHlwZXMvZmFjdG9yeVdpdGhUeXBlQ2hlY2tlcnMuanNcXG4vLyBtb2R1bGUgaWQgPSAyMVxcbi8vIG1vZHVsZSBjaHVua3MgPSAwXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vfi9wcm9wLXR5cGVzL2ZhY3RvcnlXaXRoVHlwZUNoZWNrZXJzLmpzP1wiKTtcblxuLyoqKi8gfSksXG4vKiAyMiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5ldmFsKFwiXFxuLyoqXFxuICogV2hlbiBzb3VyY2UgbWFwcyBhcmUgZW5hYmxlZCwgYHN0eWxlLWxvYWRlcmAgdXNlcyBhIGxpbmsgZWxlbWVudCB3aXRoIGEgZGF0YS11cmkgdG9cXG4gKiBlbWJlZCB0aGUgY3NzIG9uIHRoZSBwYWdlLiBUaGlzIGJyZWFrcyBhbGwgcmVsYXRpdmUgdXJscyBiZWNhdXNlIG5vdyB0aGV5IGFyZSByZWxhdGl2ZSB0byBhXFxuICogYnVuZGxlIGluc3RlYWQgb2YgdGhlIGN1cnJlbnQgcGFnZS5cXG4gKlxcbiAqIE9uZSBzb2x1dGlvbiBpcyB0byBvbmx5IHVzZSBmdWxsIHVybHMsIGJ1dCB0aGF0IG1heSBiZSBpbXBvc3NpYmxlLlxcbiAqXFxuICogSW5zdGVhZCwgdGhpcyBmdW5jdGlvbiBcXFwiZml4ZXNcXFwiIHRoZSByZWxhdGl2ZSB1cmxzIHRvIGJlIGFic29sdXRlIGFjY29yZGluZyB0byB0aGUgY3VycmVudCBwYWdlIGxvY2F0aW9uLlxcbiAqXFxuICogQSBydWRpbWVudGFyeSB0ZXN0IHN1aXRlIGlzIGxvY2F0ZWQgYXQgYHRlc3QvZml4VXJscy5qc2AgYW5kIGNhbiBiZSBydW4gdmlhIHRoZSBgbnBtIHRlc3RgIGNvbW1hbmQuXFxuICpcXG4gKi9cXG5cXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChjc3MpIHtcXG4gIC8vIGdldCBjdXJyZW50IGxvY2F0aW9uXFxuICB2YXIgbG9jYXRpb24gPSB0eXBlb2Ygd2luZG93ICE9PSBcXFwidW5kZWZpbmVkXFxcIiAmJiB3aW5kb3cubG9jYXRpb247XFxuXFxuICBpZiAoIWxvY2F0aW9uKSB7XFxuICAgIHRocm93IG5ldyBFcnJvcihcXFwiZml4VXJscyByZXF1aXJlcyB3aW5kb3cubG9jYXRpb25cXFwiKTtcXG4gIH1cXG5cXG5cXHQvLyBibGFuayBvciBudWxsP1xcblxcdGlmICghY3NzIHx8IHR5cGVvZiBjc3MgIT09IFxcXCJzdHJpbmdcXFwiKSB7XFxuXFx0ICByZXR1cm4gY3NzO1xcbiAgfVxcblxcbiAgdmFyIGJhc2VVcmwgPSBsb2NhdGlvbi5wcm90b2NvbCArIFxcXCIvL1xcXCIgKyBsb2NhdGlvbi5ob3N0O1xcbiAgdmFyIGN1cnJlbnREaXIgPSBiYXNlVXJsICsgbG9jYXRpb24ucGF0aG5hbWUucmVwbGFjZSgvXFxcXC9bXlxcXFwvXSokLywgXFxcIi9cXFwiKTtcXG5cXG5cXHQvLyBjb252ZXJ0IGVhY2ggdXJsKC4uLilcXG5cXHQvKlxcblxcdFRoaXMgcmVndWxhciBleHByZXNzaW9uIGlzIGp1c3QgYSB3YXkgdG8gcmVjdXJzaXZlbHkgbWF0Y2ggYnJhY2tldHMgd2l0aGluXFxuXFx0YSBzdHJpbmcuXFxuXFxuXFx0IC91cmxcXFxccypcXFxcKCAgPSBNYXRjaCBvbiB0aGUgd29yZCBcXFwidXJsXFxcIiB3aXRoIGFueSB3aGl0ZXNwYWNlIGFmdGVyIGl0IGFuZCB0aGVuIGEgcGFyZW5zXFxuXFx0ICAgKCAgPSBTdGFydCBhIGNhcHR1cmluZyBncm91cFxcblxcdCAgICAgKD86ICA9IFN0YXJ0IGEgbm9uLWNhcHR1cmluZyBncm91cFxcblxcdCAgICAgICAgIFteKShdICA9IE1hdGNoIGFueXRoaW5nIHRoYXQgaXNuJ3QgYSBwYXJlbnRoZXNlc1xcblxcdCAgICAgICAgIHwgID0gT1JcXG5cXHQgICAgICAgICBcXFxcKCAgPSBNYXRjaCBhIHN0YXJ0IHBhcmVudGhlc2VzXFxuXFx0ICAgICAgICAgICAgICg/OiAgPSBTdGFydCBhbm90aGVyIG5vbi1jYXB0dXJpbmcgZ3JvdXBzXFxuXFx0ICAgICAgICAgICAgICAgICBbXikoXSsgID0gTWF0Y2ggYW55dGhpbmcgdGhhdCBpc24ndCBhIHBhcmVudGhlc2VzXFxuXFx0ICAgICAgICAgICAgICAgICB8ICA9IE9SXFxuXFx0ICAgICAgICAgICAgICAgICBcXFxcKCAgPSBNYXRjaCBhIHN0YXJ0IHBhcmVudGhlc2VzXFxuXFx0ICAgICAgICAgICAgICAgICAgICAgW14pKF0qICA9IE1hdGNoIGFueXRoaW5nIHRoYXQgaXNuJ3QgYSBwYXJlbnRoZXNlc1xcblxcdCAgICAgICAgICAgICAgICAgXFxcXCkgID0gTWF0Y2ggYSBlbmQgcGFyZW50aGVzZXNcXG5cXHQgICAgICAgICAgICAgKSAgPSBFbmQgR3JvdXBcXG4gICAgICAgICAgICAgICpcXFxcKSA9IE1hdGNoIGFueXRoaW5nIGFuZCB0aGVuIGEgY2xvc2UgcGFyZW5zXFxuICAgICAgICAgICkgID0gQ2xvc2Ugbm9uLWNhcHR1cmluZyBncm91cFxcbiAgICAgICAgICAqICA9IE1hdGNoIGFueXRoaW5nXFxuICAgICAgICkgID0gQ2xvc2UgY2FwdHVyaW5nIGdyb3VwXFxuXFx0IFxcXFwpICA9IE1hdGNoIGEgY2xvc2UgcGFyZW5zXFxuXFxuXFx0IC9naSAgPSBHZXQgYWxsIG1hdGNoZXMsIG5vdCB0aGUgZmlyc3QuICBCZSBjYXNlIGluc2Vuc2l0aXZlLlxcblxcdCAqL1xcblxcdHZhciBmaXhlZENzcyA9IGNzcy5yZXBsYWNlKC91cmxcXFxccypcXFxcKCgoPzpbXikoXXxcXFxcKCg/OlteKShdK3xcXFxcKFteKShdKlxcXFwpKSpcXFxcKSkqKVxcXFwpL2dpLCBmdW5jdGlvbihmdWxsTWF0Y2gsIG9yaWdVcmwpIHtcXG5cXHRcXHQvLyBzdHJpcCBxdW90ZXMgKGlmIHRoZXkgZXhpc3QpXFxuXFx0XFx0dmFyIHVucXVvdGVkT3JpZ1VybCA9IG9yaWdVcmxcXG5cXHRcXHRcXHQudHJpbSgpXFxuXFx0XFx0XFx0LnJlcGxhY2UoL15cXFwiKC4qKVxcXCIkLywgZnVuY3Rpb24obywgJDEpeyByZXR1cm4gJDE7IH0pXFxuXFx0XFx0XFx0LnJlcGxhY2UoL14nKC4qKSckLywgZnVuY3Rpb24obywgJDEpeyByZXR1cm4gJDE7IH0pO1xcblxcblxcdFxcdC8vIGFscmVhZHkgYSBmdWxsIHVybD8gbm8gY2hhbmdlXFxuXFx0XFx0aWYgKC9eKCN8ZGF0YTp8aHR0cDpcXFxcL1xcXFwvfGh0dHBzOlxcXFwvXFxcXC98ZmlsZTpcXFxcL1xcXFwvXFxcXC8pL2kudGVzdCh1bnF1b3RlZE9yaWdVcmwpKSB7XFxuXFx0XFx0ICByZXR1cm4gZnVsbE1hdGNoO1xcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBjb252ZXJ0IHRoZSB1cmwgdG8gYSBmdWxsIHVybFxcblxcdFxcdHZhciBuZXdVcmw7XFxuXFxuXFx0XFx0aWYgKHVucXVvdGVkT3JpZ1VybC5pbmRleE9mKFxcXCIvL1xcXCIpID09PSAwKSB7XFxuXFx0XFx0ICBcXHQvL1RPRE86IHNob3VsZCB3ZSBhZGQgcHJvdG9jb2w/XFxuXFx0XFx0XFx0bmV3VXJsID0gdW5xdW90ZWRPcmlnVXJsO1xcblxcdFxcdH0gZWxzZSBpZiAodW5xdW90ZWRPcmlnVXJsLmluZGV4T2YoXFxcIi9cXFwiKSA9PT0gMCkge1xcblxcdFxcdFxcdC8vIHBhdGggc2hvdWxkIGJlIHJlbGF0aXZlIHRvIHRoZSBiYXNlIHVybFxcblxcdFxcdFxcdG5ld1VybCA9IGJhc2VVcmwgKyB1bnF1b3RlZE9yaWdVcmw7IC8vIGFscmVhZHkgc3RhcnRzIHdpdGggJy8nXFxuXFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHQvLyBwYXRoIHNob3VsZCBiZSByZWxhdGl2ZSB0byBjdXJyZW50IGRpcmVjdG9yeVxcblxcdFxcdFxcdG5ld1VybCA9IGN1cnJlbnREaXIgKyB1bnF1b3RlZE9yaWdVcmwucmVwbGFjZSgvXlxcXFwuXFxcXC8vLCBcXFwiXFxcIik7IC8vIFN0cmlwIGxlYWRpbmcgJy4vJ1xcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBzZW5kIGJhY2sgdGhlIGZpeGVkIHVybCguLi4pXFxuXFx0XFx0cmV0dXJuIFxcXCJ1cmwoXFxcIiArIEpTT04uc3RyaW5naWZ5KG5ld1VybCkgKyBcXFwiKVxcXCI7XFxuXFx0fSk7XFxuXFxuXFx0Ly8gc2VuZCBiYWNrIHRoZSBmaXhlZCBjc3NcXG5cXHRyZXR1cm4gZml4ZWRDc3M7XFxufTtcXG5cXG5cXG4vLy8vLy8vLy8vLy8vLy8vLy9cXG4vLyBXRUJQQUNLIEZPT1RFUlxcbi8vIC4vfi9zdHlsZS1sb2FkZXIvZml4VXJscy5qc1xcbi8vIG1vZHVsZSBpZCA9IDIyXFxuLy8gbW9kdWxlIGNodW5rcyA9IDBcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9+L3N0eWxlLWxvYWRlci9maXhVcmxzLmpzP1wiKTtcblxuLyoqKi8gfSlcbi8qKioqKiovIF0pO1xufSk7Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/react-owl-carousel3/lib/OwlCarousel.js\n");

/***/ })

}]);